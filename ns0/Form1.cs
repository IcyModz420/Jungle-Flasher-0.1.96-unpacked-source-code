using System;
using System.ComponentModel;
using System.Diagnostics;
using System.Drawing;
using System.IO;
using System.Reflection;
using System.Resources;
using System.Runtime.InteropServices;
using System.Security.Permissions;
using System.Threading;
using System.Windows.Forms;
using AxSHDocVw;
using Microsoft.Win32;

namespace ns0
{
	// Token: 0x020000A9 RID: 169
	public partial class Form1 : Form
	{
		// Token: 0x060001B2 RID: 434 RVA: 0x000F70E4 File Offset: 0x000F70E4
		public Form1()
		{
			this.Cursor = Cursors.AppStarting;
			AppDomain.CurrentDomain.AssemblyResolve += this.method_0;
			this.InitializeComponent();
		}

		// Token: 0x060001B4 RID: 436 RVA: 0x003BE554 File Offset: 0x00306554
		[PermissionSet(SecurityAction.Demand, XML = "<PermissionSet class=\"System.Security.PermissionSet\"\r\n               version=\"1\"\r\n               Unrestricted=\"true\"/>\r\n")]
		protected override void WndProc(ref Message message_0)
		{
			if (message_0.Msg == 537)
			{
				if (this.bool_5)
				{
					this.bool_6 = true;
				}
				else
				{
					this.bool_6 = false;
				}
				this.method_410();
				if (this.bool_6 != this.bool_5)
				{
					if (this.bool_5)
					{
						this.textBox6.AppendText("XECUTER X360USB PRO attached." + "\r\n\r\n");
						this.method_170();
					}
					else
					{
						this.textBox6.AppendText("XECUTER X360USB PRO removed." + "\r\n\r\n");
						this.method_422();
						this.method_170();
					}
				}
				if (this.bool_7)
				{
					this.bool_8 = true;
				}
				else
				{
					this.bool_8 = false;
				}
				this.method_411();
				if (this.bool_8 != this.bool_7)
				{
					if (this.bool_7)
					{
						this.textBox6.AppendText("XECUTER X360USB BAD ASS attached." + "\r\n\r\n");
						this.method_170();
					}
					else
					{
						this.textBox6.AppendText("XECUTER X360USB BAD ASS removed." + "\r\n\r\n");
						this.method_423();
						this.method_170();
					}
				}
				IntPtr value = 0;
				value = new IntPtr(32768);
				IntPtr wparam = message_0.WParam;
				IntPtr value2 = wparam;
				if (value2 == value)
				{
					IntPtr lparam = message_0.LParam;
					IntPtr ptr = lparam;
					int num = Marshal.ReadInt32(ptr, 4);
					if (num == 2)
					{
						this.int_11 = this.int_10;
						this.method_360();
						if (this.int_11 < this.int_10)
						{
							this.textBox6.AppendText("New CD/DVD detected." + "\r\n");
							this.method_361();
						}
					}
				}
				IntPtr value3 = 0;
				value3 = new IntPtr(32772);
				IntPtr wparam2 = message_0.WParam;
				IntPtr value4 = wparam2;
				if (value4 == value3)
				{
					IntPtr lparam2 = message_0.LParam;
					IntPtr ptr2 = lparam2;
					int num = Marshal.ReadInt32(ptr2, 4);
					if (num == 2)
					{
						this.method_360();
						this.int_11 = this.int_10;
					}
				}
			}
			base.WndProc(ref message_0);
		}

		// Token: 0x060001B6 RID: 438 RVA: 0x00106518 File Offset: 0x00106518
		private unsafe Assembly method_0(object object_0, ResolveEventArgs resolveEventArgs_0)
		{
			string name = resolveEventArgs_0.Name;
			Assembly result;
			if (string.Compare(resolveEventArgs_0.Name.Substring(0, resolveEventArgs_0.Name.IndexOf(new string((sbyte*)(&<Module>.struct6_4)))), "AxInterop.SHDocVw") == 0)
			{
				Stream manifestResourceStream = Assembly.GetExecutingAssembly().GetManifestResourceStream("AxInterop.SHDocVw.dll");
				byte[] array = new byte[(int)manifestResourceStream.Length];
				array.Initialize();
				byte[] array2 = array;
				manifestResourceStream.Read(array2, 0, array2.Length);
				result = Assembly.Load(array2);
			}
			else if (string.Compare(resolveEventArgs_0.Name.Substring(0, resolveEventArgs_0.Name.IndexOf(new string((sbyte*)(&<Module>.struct6_4)))), "Interop.SHDocVw") == 0)
			{
				Stream manifestResourceStream = Assembly.GetExecutingAssembly().GetManifestResourceStream("Interop.SHDocVw.dll");
				byte[] array3 = new byte[(int)manifestResourceStream.Length];
				array3.Initialize();
				byte[] array4 = array3;
				manifestResourceStream.Read(array4, 0, array4.Length);
				result = Assembly.Load(array4);
			}
			else
			{
				result = null;
			}
			return result;
		}

		// Token: 0x060001B7 RID: 439 RVA: 0x0010660C File Offset: 0x0010660C
		private void method_1(object sender, EventArgs e)
		{
			<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
			if (MessageBox.Show("Do you want to exit?", "Jungle Flasher", MessageBoxButtons.YesNo, MessageBoxIcon.Question) == DialogResult.Yes)
			{
				this.method_4();
				Application.Exit();
			}
			<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
		}

		// Token: 0x060001B8 RID: 440 RVA: 0x00106668 File Offset: 0x00106668
		private void Form1_Closed(object sender, EventArgs e)
		{
			this.bool_1 = false;
			this.method_4();
		}

		// Token: 0x060001B9 RID: 441 RVA: 0x00106684 File Offset: 0x00106684
		private unsafe void Form1_Closing(object sender, CancelEventArgs e)
		{
			while (this.pVoid_0 != null)
			{
				<Module>.Sleep(100);
				<Module>.SetCommMask(this.pVoid_0, 64);
			}
			<Module>.smethod_150(*(ref <Module>.gstruct101_0 + 4));
			<Module>.smethod_148((sbyte*)(&<Module>.struct24_5));
			if (*(ref <Module>.gstruct10_0 + 12) == 1 && this.method_424(1) == 1)
			{
				<Module>.Sleep(250);
				this.method_422();
			}
		}

		// Token: 0x060001BA RID: 442 RVA: 0x003BE754 File Offset: 0x00306754
		private unsafe void Form1_Load(object sender, EventArgs e)
		{
			string strA = null;
			string strA2 = null;
			string strA3 = null;
			string strA4 = null;
			string strA5 = null;
			this.Cursor = Cursors.AppStarting;
			this.bool_1 = false;
			this.pGstruct11_0 = <Module>.FindWindowA(null, (sbyte*)(&<Module>.struct12_5));
			RegistryKey registryKey = Registry.CurrentUser.CreateSubKey("JungleFlasher");
			this.int_7 = 0;
			this.int_8 = 0;
			string text;
			if (registryKey.GetValue("Left") != null)
			{
				text = registryKey.GetValue("Left").ToString();
			}
			else
			{
				text = new string((sbyte*)(&<Module>.struct18_6));
				registryKey.SetValue("Left", "0");
			}
			string text2;
			if (registryKey.GetValue("Top") != null)
			{
				text2 = registryKey.GetValue("Top").ToString();
			}
			else
			{
				text2 = new string((sbyte*)(&<Module>.struct18_6));
				registryKey.SetValue("Top", "0");
			}
			string value;
			if (registryKey.GetValue("IOPort") != null)
			{
				value = registryKey.GetValue("IOPort").ToString();
			}
			else
			{
				value = new string((sbyte*)(&<Module>.struct6_6));
				registryKey.SetValue("IOPort", "0");
			}
			if (registryKey.GetValue("COMPort") != null)
			{
				this.string_12 = registryKey.GetValue("COMPort").ToString();
			}
			else
			{
				this.string_12 = new string((sbyte*)(&<Module>.struct18_6));
				registryKey.SetValue("COMPort", "-1");
			}
			string strA6;
			if (registryKey.GetValue("AdvView") != null)
			{
				strA6 = registryKey.GetValue("AdvView").ToString();
			}
			else
			{
				strA6 = new string((sbyte*)(&<Module>.struct6_6));
				registryKey.SetValue("AdvView", "0");
			}
			string strA7;
			if (registryKey.GetValue("ScsiPorts") != null)
			{
				strA7 = registryKey.GetValue("ScsiPorts").ToString();
			}
			else
			{
				strA7 = new string((sbyte*)(&<Module>.struct6_6));
				registryKey.SetValue("ScsiPorts", "0");
			}
			string strA8;
			if (registryKey.GetValue("ViaPortsOnly") != null)
			{
				strA8 = registryKey.GetValue("ViaPortsOnly").ToString();
			}
			else
			{
				strA8 = new string((sbyte*)(&<Module>.struct6_8));
				registryKey.SetValue("ViaPortsOnly", "0");
			}
			string strA9;
			if (registryKey.GetValue("OnlyDummy") != null)
			{
				strA9 = registryKey.GetValue("OnlyDummy").ToString();
			}
			else
			{
				strA9 = new string((sbyte*)(&<Module>.struct6_6));
				registryKey.SetValue("OnlyDummy", "0");
			}
			string strA10;
			if (registryKey.GetValue("Xswitch") != null)
			{
				strA10 = registryKey.GetValue("Xswitch").ToString();
			}
			else
			{
				strA10 = new string((sbyte*)(&<Module>.struct6_6));
				registryKey.SetValue("Xswitch", "0");
			}
			string strA11;
			if (registryKey.GetValue("HitRev") != null)
			{
				strA11 = registryKey.GetValue("HitRev").ToString();
			}
			else
			{
				strA11 = new string((sbyte*)(&<Module>.struct18_7));
				registryKey.SetValue("HitRev", "47");
			}
			string strA12;
			if (registryKey.GetValue("HitAPi") != null)
			{
				strA12 = registryKey.GetValue("HitAPi").ToString();
			}
			else
			{
				strA12 = new string((sbyte*)(&<Module>.struct6_8));
				registryKey.SetValue("HitAPi", "1");
			}
			if (registryKey.GetValue("PermPortIO") != null)
			{
				strA = registryKey.GetValue("PermPortIO").ToString();
			}
			if (registryKey.GetValue("HackerMode") != null)
			{
				strA2 = registryKey.GetValue("HackerMode").ToString();
			}
			if (registryKey.GetValue("NoKeepDB") != null)
			{
				strA3 = registryKey.GetValue("NoKeepDB").ToString();
			}
			if (registryKey.GetValue("Sponsor") != null)
			{
				strA4 = registryKey.GetValue("Sponsor").ToString();
			}
			string strA13;
			if (registryKey.GetValue("HitTran") != null)
			{
				strA13 = registryKey.GetValue("HitTran").ToString();
			}
			else
			{
				strA13 = new string((sbyte*)(&<Module>.struct6_8));
				registryKey.SetValue("HitTran", "1");
			}
			if (registryKey.GetValue("BackupFolder") != null)
			{
				this.string_8 = registryKey.GetValue("BackupFolder").ToString();
				this.bool_2 = true;
			}
			else
			{
				this.bool_2 = false;
			}
			string strA14;
			if (registryKey.GetValue("DoCom") != null)
			{
				strA14 = registryKey.GetValue("DoCom").ToString();
			}
			else
			{
				strA14 = "1";
				registryKey.SetValue("DoCom", "1");
			}
			string strA15;
			if (registryKey.GetValue("DoIO") != null)
			{
				strA15 = registryKey.GetValue("DoIO").ToString();
			}
			else
			{
				strA15 = "1";
				registryKey.SetValue("DoIO", "1");
			}
			string strA16;
			if (registryKey.GetValue("DoDrives") != null)
			{
				strA16 = registryKey.GetValue("DoDrives").ToString();
			}
			else
			{
				strA16 = "1";
				registryKey.SetValue("DoDrives", "1");
			}
			string strA17;
			if (registryKey.GetValue("DoDevID") != null)
			{
				strA17 = registryKey.GetValue("DoDevID").ToString();
			}
			else
			{
				strA17 = "0";
				registryKey.SetValue("DoDevID", "0");
			}
			if (registryKey.GetValue("DoUSBOnly") != null)
			{
				this.string_18 = registryKey.GetValue("DoUSBOnly").ToString();
			}
			else
			{
				this.string_18 = "0";
				registryKey.SetValue("DoUSBOnly", "0");
			}
			if (registryKey.GetValue("Delay32") != null)
			{
				strA5 = registryKey.GetValue("Delay32").ToString();
			}
			if (registryKey.GetValue("Mods") != null)
			{
				this.string_11 = registryKey.GetValue("Mods").ToString();
			}
			else
			{
				this.string_11 = "0";
				registryKey.SetValue("Mods", "0");
			}
			if (registryKey.GetValue("NetBook") != null)
			{
			}
			if (registryKey.GetValue("WriteKey") != null)
			{
				this.menuItem_32.Visible = true;
			}
			registryKey.Close();
			int systemMetrics = <Module>.GetSystemMetrics(0);
			int systemMetrics2 = <Module>.GetSystemMetrics(1);
			GStruct92* pGstruct92_ = <Module>.CreateDCA((sbyte*)(&<Module>.struct22_2), null, null, null);
			int deviceCaps = <Module>.GetDeviceCaps(pGstruct92_, 88);
			int deviceCaps2 = <Module>.GetDeviceCaps(pGstruct92_, 10);
			if (((IConvertible)text).ToInt32(null) + base.Width > systemMetrics)
			{
				base.Left = (systemMetrics - base.Width) / 2;
			}
			else if (((IConvertible)text).ToInt32(null) < 0)
			{
				base.Left = (systemMetrics - base.Width) / 2;
			}
			else
			{
				base.Left = ((IConvertible)text).ToInt32(null);
			}
			if (((IConvertible)text2).ToInt32(null) + base.Height > systemMetrics2)
			{
				base.Top = (systemMetrics2 - base.Height) / 2;
			}
			else if (((IConvertible)text2).ToInt32(null) < 0)
			{
				base.Top = (systemMetrics2 - base.Height) / 2;
			}
			else
			{
				base.Top = ((IConvertible)text2).ToInt32(null);
			}
			if (string.Compare(strA6, "1") == 0)
			{
				this.checkBox3.CheckState = CheckState.Checked;
			}
			else
			{
				this.checkBox3.CheckState = CheckState.Unchecked;
			}
			if (string.Compare(strA7, "1") == 0)
			{
				this.checkBox2.CheckState = CheckState.Checked;
				this.checkBox11.CheckState = CheckState.Checked;
			}
			else
			{
				this.checkBox2.CheckState = CheckState.Unchecked;
				this.checkBox11.CheckState = CheckState.Unchecked;
			}
			if (string.Compare(strA8, "0") == 0)
			{
				this.checkBox4.CheckState = CheckState.Unchecked;
				this.checkBox10.CheckState = CheckState.Unchecked;
				this.checkBox2.Enabled = true;
				this.checkBox11.Enabled = true;
				this.radioButton18.Enabled = false;
				this.radioButton17.Checked = true;
			}
			else
			{
				this.checkBox4.CheckState = CheckState.Checked;
				this.checkBox10.CheckState = CheckState.Checked;
				this.checkBox2.Enabled = false;
				this.checkBox11.Enabled = false;
				this.radioButton18.Enabled = true;
			}
			if (string.Compare(strA9, "0") == 0)
			{
				this.checkBox8.CheckState = CheckState.Unchecked;
			}
			else
			{
				this.checkBox8.CheckState = CheckState.Checked;
			}
			if (string.Compare(strA10, "0") == 0)
			{
				this.checkBox9.CheckState = CheckState.Unchecked;
			}
			else
			{
				this.checkBox9.CheckState = CheckState.Checked;
			}
			if (string.Compare(strA17, "1") == 0)
			{
				this.checkBox5.CheckState = CheckState.Checked;
			}
			else
			{
				this.checkBox5.CheckState = CheckState.Unchecked;
			}
			if (string.Compare(this.string_18, "1") == 0)
			{
				this.checkBox15.CheckState = CheckState.Checked;
				this.checkBox16.CheckState = CheckState.Checked;
				this.checkBox2.Enabled = false;
				this.checkBox11.Enabled = false;
				this.checkBox4.Enabled = false;
				this.checkBox10.Enabled = false;
				this.radioButton18.Enabled = true;
				this.radioButton17.Checked = true;
			}
			else
			{
				this.checkBox15.CheckState = CheckState.Unchecked;
				this.checkBox16.CheckState = CheckState.Unchecked;
				this.checkBox2.Enabled = true;
				this.checkBox11.Enabled = true;
				this.checkBox4.Enabled = true;
				this.checkBox10.Enabled = true;
				this.radioButton18.Enabled = false;
				this.radioButton17.Checked = true;
			}
			this.int_14 = 0;
			this.string_21 = "Dump";
			this.radioButton11.Checked = true;
			if (string.Compare(strA11, "32") == 0)
			{
				this.radioButton1.Checked = true;
				this.int_12 = 32;
				this.string_19 = "0032/0040";
			}
			else if (string.Compare(strA11, "36") == 0)
			{
				this.radioButton2.Checked = true;
				this.int_12 = 36;
				this.string_19 = "0036";
			}
			else if (string.Compare(strA11, "47") == 0)
			{
				this.radioButton3.Checked = true;
				this.int_12 = 47;
				this.string_19 = "0046/0047";
			}
			else if (string.Compare(strA11, "59") == 0)
			{
				this.radioButton4.Checked = true;
				this.int_12 = 59;
				this.string_19 = "0058/0059";
			}
			else if (string.Compare(strA11, "79") == 0)
			{
				this.radioButton5.Checked = true;
				this.int_12 = 79;
				this.string_19 = "0078/0079";
			}
			if (string.Compare(strA12, "1") == 0)
			{
				this.radioButton17.Checked = true;
			}
			else
			{
				this.radioButton18.Checked = true;
			}
			if (string.Compare(strA13, "0") == 0)
			{
				this.radioButton15.Checked = true;
				this.int_13 = 0;
				this.string_20 = "Classic Ram Peek";
			}
			else if (string.Compare(strA13, "1") == 0)
			{
				this.radioButton14.Checked = true;
				this.int_13 = 1;
				this.string_20 = "Ram Upload";
			}
			else if (string.Compare(strA13, "2") == 0)
			{
				this.radioButton13.Checked = true;
				this.int_13 = 2;
				this.string_20 = "Mode Select";
			}
			else if (string.Compare(strA13, "3") == 0)
			{
				this.radioButton12.Checked = true;
				this.int_13 = 3;
				this.string_20 = "Ram Poke";
			}
			this.method_378();
			this.textBox6.AppendText("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~" + "\r\n" + "JungleFlasher 0.1.96 Beta (323)" + "\r\n");
			int num;
			<Module>.time((int*)(&num));
			GStruct85* pGstruct85_ = <Module>.localtime((int*)(&num));
			this.textBox6.AppendText("Session Started " + Convert.ToString(new string(<Module>.asctime((GStruct85*)pGstruct85_))).Substring(0, 24) + "\r\n\r\n");
			int num2 = 0;
			method procAddress = <Module>.GetProcAddress(<Module>.GetModuleHandleA((sbyte*)(&<Module>.struct24_6)), (sbyte*)(&<Module>.struct65_0));
			if (0 != procAddress)
			{
				object obj = calli(System.Int32 modopt(System.Runtime.CompilerServices.CallConvStdcall)(System.Void*,System.Int32*), <Module>.GetCurrentProcess(), ref num2, procAddress);
			}
			if (num2 != 0)
			{
				this.textBox6.AppendText("This is a Wow 64 process ");
			}
			else
			{
				this.textBox6.AppendText("This is a 32 bit process ");
			}
			GStruct81* moduleHandleA = <Module>.GetModuleHandleA((sbyte*)(&<Module>.struct15_1));
			method procAddress2 = <Module>.GetProcAddress(moduleHandleA, (sbyte*)(&<Module>.struct66_0));
			GStruct91 gstruct;
			if (procAddress2 != null)
			{
				calli(System.Void modopt(System.Runtime.CompilerServices.CallConvStdcall)(ns0.GStruct91*), ref gstruct, procAddress2);
			}
			else
			{
				<Module>.GetSystemInfo(&gstruct);
			}
			int num3 = *(ref gstruct + 20);
			if (gstruct == null)
			{
				if (num3 != 1)
				{
					this.textBox6.AppendText("running on " + Convert.ToString(num3) + " x 32 bit CPUs " + "\r\n");
				}
				else
				{
					this.textBox6.AppendText("running on " + "a 32 bit CPU " + "\r\n");
				}
			}
			else if (gstruct == 9)
			{
				if (num3 != 1)
				{
					this.textBox6.AppendText("running on " + Convert.ToString(num3) + " x 64 bit CPUs " + "\r\n");
				}
				else
				{
					this.textBox6.AppendText("running on " + "a 64 bit CPU " + "\r\n");
				}
			}
			else
			{
				this.textBox6.AppendText(Convert.ToString(num3) + " x unknown CPU " + "\r\n");
			}
			if (this.method_410() == 1)
			{
				this.textBox6.AppendText("X360USB PRO detected, ");
				*(ref <Module>.gstruct10_0 + 14) = 0;
				this.method_420();
				this.method_412();
				this.method_422();
				this.textBox6.AppendText("\r\n");
			}
			if (this.method_411() == 1)
			{
				this.textBox6.AppendText("X360USB BAD ASS detected, ");
				if (*(ref <Module>.gstruct10_0 + 12) == 1)
				{
					*(ref <Module>.gstruct10_0 + 14) = 0;
				}
				else
				{
					*(ref <Module>.gstruct10_0 + 14) = 1;
				}
				this.method_421();
				this.method_413();
				this.method_423();
				this.textBox6.AppendText("\r\n");
			}
			if (string.Compare(this.string_18, "1") != 0 || *(ref <Module>.gstruct10_0 + 13) != 1)
			{
				if (string.Compare(this.string_18, "1") != 0 || *(ref <Module>.gstruct10_0 + 12) != 1)
				{
					this.method_2();
				}
			}
			if (string.Compare(strA15, "1") == 0)
			{
				if (this.method_170() != 0)
				{
					this.textBox6.AppendText("Found " + Convert.ToString(this.comboBox1.Items.Count) + " I/O Ports." + "\r\n");
					if ((int)Convert.ToInt16(value) > this.comboBox1.Items.Count - 1)
					{
						this.comboBox1.SelectedIndex = this.comboBox1.Items.Count - 1;
					}
					else
					{
						this.comboBox1.SelectedIndex = 0;
						<Module>.Sleep(200);
						this.comboBox1.SelectedIndex = (int)Convert.ToInt16(value);
					}
					this.method_177();
					if (string.Compare(this.string_18, "1") != 0)
					{
						this.method_169();
					}
				}
				else
				{
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					MessageBox.Show("No I/O ports were found during Enumeration!", "JungleFlasher", MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
					this.textBox6.AppendText("Found 0 I/O Ports." + "\r\n");
				}
			}
			if (string.Compare(strA14, "1") == 0)
			{
				if (this.method_145() != 0)
				{
					this.textBox6.AppendText("Found " + Convert.ToString(this.comboBox10.Items.Count) + " Com Ports.");
					if (Convert.ToInt16(this.string_12) == -1 && this.comboBox10.Items.Count > 0)
					{
						this.comboBox10.SelectedIndex = 0;
						this.method_148();
					}
					else if ((int)Convert.ToInt16(this.string_12) > this.comboBox10.Items.Count - 1)
					{
						this.comboBox10.SelectedIndex = 0;
						this.method_148();
					}
					else
					{
						this.comboBox10.SelectedIndex = 0;
						this.comboBox10.SelectedIndex = (int)Convert.ToInt16(this.string_12);
					}
					for (int i = 0; i < this.comboBox10.Items.Count; i++)
					{
						if (*(ref <Module>.struct122_0 + i * 324 + 8) == 7)
						{
							this.int_0 = 1;
							this.string_1 = Convert.ToString(new string(ref <Module>.struct122_0 + i * 324));
							this.textBox6.AppendText("\r\n" + "CK3-CP Found on " + Convert.ToString(new string(ref <Module>.struct122_0 + i * 324)) + ": Connecting...");
							this.method_151();
						}
					}
					this.textBox6.AppendText("\r\n");
					if (*(ref <Module>.struct122_0 + this.comboBox10.SelectedIndex * 324 + 8) == 6 && this.checkBox9.CheckState == CheckState.Checked)
					{
						this.method_166(17U);
					}
					if (*(ref <Module>.struct122_0 + this.comboBox10.SelectedIndex * 324 + 8) == 8 && this.checkBox9.CheckState == CheckState.Checked)
					{
						this.label135.Text = "xt2: Enabled";
					}
					if (this.checkBox9.Enabled && this.checkBox9.CheckState == CheckState.Checked)
					{
						this.method_150();
					}
				}
				else
				{
					this.textBox6.AppendText("Found 0 Com Ports." + "\r\n");
				}
			}
			if (string.Compare(strA16, "1") == 0)
			{
				this.method_359();
				this.int_11 = this.int_10;
			}
			string[] commandLineArgs = Environment.GetCommandLineArgs();
			this.method_29();
			if (commandLineArgs.Length == 3)
			{
				if (string.Compare(commandLineArgs[2], "Target") == 0)
				{
					this.method_36(commandLineArgs[1], 1);
				}
				else if (string.Compare(commandLineArgs[2], "Source") == 0)
				{
					this.method_36(commandLineArgs[1], 0);
				}
			}
			else if (commandLineArgs.Length == 2)
			{
				this.method_36(commandLineArgs[1], 0);
			}
			else
			{
				Welcome welcome = new Welcome();
				welcome.ShowDialog(this);
			}
			if (this.bool_2)
			{
				this.string_9 = "";
				this.string_10 = this.string_8;
				ProjectName projectName = new ProjectName();
				if (projectName.ShowDialog(this) == DialogResult.OK)
				{
					this.string_9 = projectName.textBox1.Text;
					this.string_10 = this.string_8 + this.string_9;
					if (projectName.textBox1.Text != "")
					{
						if (Directory.Exists(this.string_10))
						{
							<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
							MessageBox.Show("The folder " + this.string_10 + " already exists!", "Enter Job Name", MessageBoxButtons.OK);
							<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
							this.textBox6.AppendText("Working folder '" + this.string_10 + "' re-opened." + "\r\n");
						}
						else
						{
							Directory.CreateDirectory(this.string_10);
							this.textBox6.AppendText("Working folder '" + this.string_10 + "' created." + "\r\n");
						}
					}
					Directory.SetCurrentDirectory(this.string_10);
				}
			}
			if (string.Compare(strA12, "1") == 0)
			{
				this.radioButton17.Checked = true;
			}
			else
			{
				this.radioButton18.Checked = true;
			}
			if (!this.radioButton18.Enabled)
			{
				this.radioButton17.Checked = true;
			}
			if (string.Compare(strA, "1") == 0)
			{
				this.radioButton18.Checked = true;
				this.radioButton18.Enabled = true;
			}
			if (string.Compare(this.string_18, "1") == 0)
			{
				this.radioButton18.Enabled = true;
				this.radioButton17.Checked = true;
			}
			if (string.Compare(strA2, "1") == 0)
			{
				this.bool_3 = true;
			}
			else
			{
				this.bool_3 = false;
			}
			if (string.Compare(strA3, "1") == 0)
			{
				this.bool_4 = true;
				this.menuItem_7.Visible = false;
				this.menuItem_12.Visible = false;
			}
			if (string.Compare(strA4, "1") != 0)
			{
				this.axWebBrowser_0.Width = deviceCaps * 160 / 96 + 4;
				this.axWebBrowser_0.Height = deviceCaps * 560 / 96 + 4;
				this.pictureBox3.Width = deviceCaps * 160 / 96;
				this.pictureBox3.Height = deviceCaps * 560 / 96;
				if (deviceCaps2 == 600)
				{
					Size maximumSize = default(Size);
					maximumSize = new Size(856, 565);
					base.MaximumSize = maximumSize;
					Size minimumSize = default(Size);
					minimumSize = new Size(856, 565);
					base.MinimumSize = minimumSize;
					this.textBox6.Height = 109;
				}
				Thread thread = new Thread(new ThreadStart(this.method_11));
				thread.Start();
			}
			else
			{
				Size maximumSize2 = default(Size);
				maximumSize2 = new Size(688, 608);
				base.MaximumSize = maximumSize2;
				Size minimumSize2 = default(Size);
				minimumSize2 = new Size(688, 608);
				base.MinimumSize = minimumSize2;
			}
			this.bool_1 = true;
			Thread thread2 = new Thread(new ThreadStart(this.method_20));
			thread2.Start();
			if (string.Compare(strA5, "0") == 0)
			{
				this.menuItem_14.Enabled = false;
			}
			else if (string.Compare(strA5, "5") == 0)
			{
				this.menuItem_15.Enabled = false;
			}
			else if (string.Compare(strA5, "10") == 0)
			{
				this.menuItem_16.Enabled = false;
			}
			else if (string.Compare(strA5, "15") == 0)
			{
				this.menuItem_17.Enabled = false;
			}
			else if (string.Compare(strA5, "20") == 0)
			{
				this.menuItem_18.Enabled = false;
			}
			this.radioButton21.Visible = true;
			this.Cursor = Cursors.Arrow;
		}

		// Token: 0x060001BB RID: 443 RVA: 0x00107CB4 File Offset: 0x00107CB4
		private unsafe void method_2()
		{
			string text = null;
			Struct68 @struct;
			<Module>.memset((void*)(&@struct), 0, 260U);
			<Module>.smethod_146((sbyte*)(&@struct));
			GStruct81* moduleHandleA = <Module>.GetModuleHandleA((sbyte*)(&<Module>.struct15_1));
			method procAddress = <Module>.GetProcAddress(moduleHandleA, (sbyte*)(&<Module>.struct66_0));
			GStruct91 gstruct;
			if (procAddress != null)
			{
				calli(System.Void modopt(System.Runtime.CompilerServices.CallConvStdcall)(ns0.GStruct91*), ref gstruct, procAddress);
			}
			else
			{
				<Module>.GetSystemInfo(&gstruct);
			}
			Struct68 struct3;
			if (gstruct == null)
			{
				<Module>.strcat((sbyte*)(&@struct), (sbyte*)(&<Module>.struct67_0));
				text = "portio32.sys";
				if (!File.Exists(Convert.ToString(new string((sbyte*)(&@struct)))))
				{
					Struct68 struct2;
					int tempPathA = <Module>.GetTempPathA(260, (sbyte*)(&struct2));
					if (tempPathA > 260 || tempPathA == 0)
					{
						return;
					}
					int tempFileNameA = <Module>.GetTempFileNameA((sbyte*)(&struct2), (sbyte*)(&<Module>.struct25_8), 0U, (sbyte*)(&struct3));
					if (tempFileNameA == 0)
					{
						return;
					}
					GStruct5* ptr = <Module>.fopen((sbyte*)(&struct3), (sbyte*)(&<Module>.struct18_5));
					if (ptr == null)
					{
						<Module>.DeleteFileA((sbyte*)(&struct3));
						return;
					}
					<Module>.fwrite((void*)(&<Module>.struct50_0), 2560U, 1U, ptr);
					<Module>.strcpy((sbyte*)(&@struct), (sbyte*)(&struct3));
					<Module>.fclose(ptr);
				}
			}
			else if (gstruct == 9)
			{
				<Module>.strcat((sbyte*)(&@struct), (sbyte*)(&<Module>.struct67_1));
				text = "portio64.sys";
				if (!File.Exists(Convert.ToString(new string((sbyte*)(&@struct)))))
				{
					Struct68 struct2;
					int tempPathA = <Module>.GetTempPathA(260, (sbyte*)(&struct2));
					if (tempPathA > 260 || tempPathA == 0)
					{
						return;
					}
					int tempFileNameA = <Module>.GetTempFileNameA((sbyte*)(&struct2), (sbyte*)(&<Module>.struct25_8), 0U, (sbyte*)(&struct3));
					if (tempFileNameA == 0)
					{
						return;
					}
					GStruct5* ptr = <Module>.fopen((sbyte*)(&struct3), (sbyte*)(&<Module>.struct18_5));
					if (ptr == null)
					{
						<Module>.DeleteFileA((sbyte*)(&struct3));
						return;
					}
					<Module>.fwrite((void*)(&<Module>.struct53_0), 4608U, 1U, ptr);
					<Module>.strcpy((sbyte*)(&@struct), (sbyte*)(&struct3));
					<Module>.fclose(ptr);
				}
			}
			else
			{
				MessageBox.Show("Processor architecture is not supported!", "Error", MessageBoxButtons.OK, MessageBoxIcon.Hand);
			}
			<Module>.smethod_148((sbyte*)(&<Module>.struct24_5));
			<Module>.smethod_148((sbyte*)(&<Module>.struct10_18));
			if (<Module>.smethod_147((sbyte*)(&@struct), (sbyte*)(&<Module>.struct24_5)) != null)
			{
				if (string.Compare(text, "portio64.sys") == 0)
				{
					MessageBox.Show("Can't install " + text + " driver!" + "\r\n" + "Press F8 at boot to 'Disable Driver Signature Enforcement'" + "\r\n" + "OR Test sign the driver an run in 'Test Mode'" + "\r\n\r\n" + "And Be Sure to 'Run as Administrator' !", "PortIO Error", MessageBoxButtons.OK, MessageBoxIcon.Hand);
					this.textBox6.AppendText(text + " Driver not Installed " + "\r\n");
					<Module>.DeleteFileA((sbyte*)(&struct3));
					return;
				}
				if (string.Compare(text, "portio32.sys") == 0)
				{
					MessageBox.Show("Can't install " + text + " driver!" + "\r\n" + "Be Sure to 'Run as Administrator' !", "PortIO Error", MessageBoxButtons.OK, MessageBoxIcon.Hand);
					this.textBox6.AppendText(text + " Driver not Installed " + "\r\n");
					<Module>.DeleteFileA((sbyte*)(&struct3));
					return;
				}
			}
			else
			{
				this.textBox6.AppendText(text + " Driver Installed " + "\r\n");
			}
			if (<Module>.smethod_149(ref <Module>.gstruct101_0 + 4) != null)
			{
				MessageBox.Show("Can't start " + text + " driver!" + "\r\n" + "Be Sure to 'Run as Administrator' !", "PortIO Error", MessageBoxButtons.OK, MessageBoxIcon.Hand);
			}
			else
			{
				this.textBox6.AppendText(text + " Driver Started, thanks Schtrom ! " + "\r\n");
			}
			<Module>.DeleteFileA((sbyte*)(&struct3));
		}

		// Token: 0x060001BC RID: 444 RVA: 0x00107FDC File Offset: 0x00107FDC
		private void method_3()
		{
			Welcome welcome = new Welcome();
			welcome.ShowDialog(this);
		}

		// Token: 0x060001BD RID: 445 RVA: 0x00107FFC File Offset: 0x00107FFC
		private void checkBox3_CheckedChanged(object sender, EventArgs e)
		{
			if (this.checkBox3.CheckState == CheckState.Unchecked)
			{
				this.tabControl1.Visible = true;
				this.tabControl2.Visible = true;
				this.tabControl3.Visible = false;
				this.tabControl4.Visible = false;
			}
			else
			{
				this.tabControl1.Visible = false;
				this.tabControl2.Visible = false;
				this.tabControl3.Visible = true;
				this.tabControl4.Visible = true;
			}
		}

		// Token: 0x060001BE RID: 446 RVA: 0x00108078 File Offset: 0x00108078
		private unsafe void method_4()
		{
			RegistryKey registryKey = Registry.CurrentUser.CreateSubKey("JungleFlasher");
			registryKey.SetValue("Left", Convert.ToString(base.Left));
			registryKey.SetValue("Top", Convert.ToString(base.Top));
			if (this.checkBox3.CheckState == CheckState.Checked)
			{
				registryKey.SetValue("AdvView", "1");
			}
			else
			{
				registryKey.SetValue("AdvView", "0");
			}
			if (this.checkBox2.CheckState == CheckState.Checked)
			{
				registryKey.SetValue("ScsiPorts", "1");
			}
			else
			{
				registryKey.SetValue("ScsiPorts", "0");
			}
			if (this.checkBox4.CheckState == CheckState.Checked)
			{
				registryKey.SetValue("ViaPortsOnly", "1");
			}
			else
			{
				registryKey.SetValue("ViaPortsOnly", "0");
			}
			if (this.checkBox8.CheckState == CheckState.Checked)
			{
				registryKey.SetValue("OnlyDummy", "1");
			}
			else
			{
				registryKey.SetValue("OnlyDummy", "0");
			}
			if (this.checkBox9.CheckState == CheckState.Checked)
			{
				registryKey.SetValue("Xswitch", "1");
			}
			else
			{
				registryKey.SetValue("Xswitch", "0");
			}
			if (this.checkBox15.CheckState == CheckState.Checked)
			{
				registryKey.SetValue("DoUSBOnly", "1");
			}
			else
			{
				registryKey.SetValue("DoUSBOnly", "0");
			}
			if (this.radioButton1.Checked)
			{
				registryKey.SetValue("HitRev", "32");
			}
			else if (this.radioButton2.Checked)
			{
				registryKey.SetValue("HitRev", "36");
			}
			else if (this.radioButton3.Checked)
			{
				registryKey.SetValue("HitRev", "47");
			}
			else if (this.radioButton4.Checked)
			{
				registryKey.SetValue("HitRev", "59");
			}
			else if (this.radioButton5.Checked)
			{
				registryKey.SetValue("HitRev", "79");
			}
			if (this.radioButton17.Checked)
			{
				registryKey.SetValue("HitAPi", "1");
			}
			else
			{
				registryKey.SetValue("HitAPi", "0");
			}
			if (this.radioButton15.Checked)
			{
				registryKey.SetValue("HitTran", "0");
			}
			else if (this.radioButton13.Checked)
			{
				registryKey.SetValue("HitTran", "2");
			}
			else if (this.radioButton14.Checked)
			{
				registryKey.SetValue("HitTran", "1");
			}
			else if (this.radioButton12.Checked)
			{
				registryKey.SetValue("HitTran", "3");
			}
			registryKey.SetValue("ioport", Convert.ToString(this.comboBox1.SelectedIndex));
			registryKey.SetValue("COMPort", Convert.ToString(this.comboBox10.SelectedIndex));
			registryKey.Close();
			if (this.int_7 == 1 || this.int_8 != 0)
			{
				this.method_152();
			}
			int selectedIndex = this.comboBox10.SelectedIndex;
			if (*(ref <Module>.struct122_0 + selectedIndex * 324 + 8) == 9 && this.checkBox9.CheckState == CheckState.Checked)
			{
				this.method_135();
				this.method_137();
				this.method_138();
			}
			if (this.bool_2)
			{
				string text = this.string_10 + "\\jf.log";
				IntPtr intPtr = Marshal.StringToHGlobalAnsi(text);
				IntPtr value = intPtr;
				sbyte* pSbyte_ = (sbyte*)((void*)value);
				GStruct5* ptr = <Module>.fopen((sbyte*)pSbyte_, (sbyte*)(&<Module>.struct18_8));
				if (ptr == null)
				{
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					MessageBox.Show(text, "Can't open log file", MessageBoxButtons.OK);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
				}
				else
				{
					IntPtr intPtr2 = Marshal.StringToHGlobalAnsi(this.textBox6.Text);
					IntPtr value2 = intPtr2;
					sbyte* pSbyte_2 = (sbyte*)((void*)value2);
					<Module>.fputs((sbyte*)(&<Module>.struct35_122), ptr);
					<Module>.fputs((sbyte*)pSbyte_2, ptr);
					<Module>.fclose(ptr);
				}
			}
			else
			{
				SaveFileDialog saveFileDialog = new SaveFileDialog();
				saveFileDialog.Filter = "Session Log file (*.log)|*.log|All Files (*.*)|*.*";
				saveFileDialog.DefaultExt = ".log";
				saveFileDialog.FileName = "jf.log";
				saveFileDialog.OverwritePrompt = false;
				if (saveFileDialog.ShowDialog() == DialogResult.OK)
				{
					string fullPath = Path.GetFullPath(saveFileDialog.FileName);
					IntPtr intPtr3 = Marshal.StringToHGlobalAnsi(fullPath);
					IntPtr value3 = intPtr3;
					sbyte* pSbyte_3 = (sbyte*)((void*)value3);
					string fileName = saveFileDialog.FileName;
					GStruct5* ptr = <Module>.fopen((sbyte*)pSbyte_3, (sbyte*)(&<Module>.struct18_8));
					if (ptr == null)
					{
						<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
						MessageBox.Show(saveFileDialog.FileName.ToString(), "Can't open log file", MessageBoxButtons.OK);
						<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
					}
					else
					{
						IntPtr intPtr4 = Marshal.StringToHGlobalAnsi(this.textBox6.Text);
						IntPtr value4 = intPtr4;
						sbyte* pSbyte_4 = (sbyte*)((void*)value4);
						<Module>.fputs((sbyte*)(&<Module>.struct35_122), ptr);
						<Module>.fputs((sbyte*)pSbyte_4, ptr);
						<Module>.fclose(ptr);
					}
				}
			}
		}

		// Token: 0x060001BF RID: 447 RVA: 0x00108588 File Offset: 0x00108588
		private unsafe void method_5(byte* pByte_0, uint uint_0, uint uint_1)
		{
			string str = null;
			string str2 = null;
			Struct20 @struct;
			<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct18_0), 13);
			str += new string((sbyte*)(&@struct));
			uint num2;
			Struct71 struct2;
			for (uint num = 0U; num < uint_0; num += 1U)
			{
				num2 = num % 16U;
				string text;
				if (num2 == 0U)
				{
					if (num != 0U)
					{
						for (uint num3 = 0U; num3 < 16U; num3 += 1U)
						{
							if (*(ref struct2 + num3) >= 32 && *(ref struct2 + num3) <= 126)
							{
								<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct18_0), *(ref struct2 + num3));
								text = new string((sbyte*)(&<Module>.struct19_0));
								text += new string((sbyte*)(&@struct));
								str2 += text;
							}
							else
							{
								str2 += ".";
							}
						}
						str2 += "\r\n";
					}
					Struct69 struct3;
					<Module>.sprintf((sbyte*)(&struct3), (sbyte*)(&<Module>.struct10_19), uint_1 + num);
					text = new string((sbyte*)(&<Module>.struct19_0));
					text += new string((sbyte*)(&struct3));
					str2 += text;
				}
				else if (num != 0U && num % 8U == 0U)
				{
					str2 += "- ";
				}
				*(ref struct2 + num2) = (byte)((sbyte)pByte_0[num]);
				Struct70 struct4;
				<Module>.sprintf((sbyte*)(&struct4), (sbyte*)(&<Module>.struct23_39), pByte_0[num]);
				text = new string((sbyte*)(&<Module>.struct19_0));
				text += new string((sbyte*)(&struct4));
				str2 += text;
			}
			if (uint_0 == 0U)
			{
				str2 += "\r\n";
			}
			else
			{
				uint_0 = 16U - uint_0 % 16U;
				if (uint_0 != 16U)
				{
					if (uint_0 >= 8U)
					{
						str2 += "  ";
					}
					num2 += 1U;
					for (uint num = 0U; num < uint_0; num += 1U)
					{
						*(ref struct2 + (num2 + num)) = 32;
						str2 += "   ";
					}
				}
				for (uint num3 = 0U; num3 < 16U; num3 += 1U)
				{
					if (*(ref struct2 + num3) >= 32 && *(ref struct2 + num3) <= 126)
					{
						<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct18_0), *(ref struct2 + num3));
						string text = new string((sbyte*)(&<Module>.struct19_0));
						text += new string((sbyte*)(&@struct));
						str2 += text;
					}
					else
					{
						str2 += ".";
					}
				}
				str2 += "\r\n";
			}
			this.string_0 = str2;
		}

		// Token: 0x060001C0 RID: 448 RVA: 0x001087A4 File Offset: 0x001087A4
		private unsafe void method_6(byte* pByte_0, uint uint_0, uint uint_1)
		{
			string str = null;
			for (uint num = 0U; num < uint_0; num += 1U)
			{
				Struct62 @struct;
				<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct35_121), pByte_0[num]);
				string text = new string((sbyte*)(&<Module>.struct19_0));
				text += new string((sbyte*)(&@struct));
				str += text;
			}
			this.string_0 = str;
		}

		// Token: 0x060001C1 RID: 449 RVA: 0x001087FC File Offset: 0x001087FC
		private unsafe void method_7(byte* pByte_0)
		{
			string str = null;
			for (uint num = 0U; num < 32U; num += 1U)
			{
				if (pByte_0[num] >= 32 && pByte_0[num] <= 126)
				{
					Struct20 @struct;
					<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct18_0), pByte_0[num]);
					string text = new string((sbyte*)(&<Module>.struct19_0));
					text += new string((sbyte*)(&@struct));
					str += text;
				}
				else
				{
					str += " ";
				}
			}
			this.string_0 = str;
		}

		// Token: 0x060001C2 RID: 450 RVA: 0x00108874 File Offset: 0x00108874
		private unsafe void method_8(byte* pByte_0)
		{
			string str = null;
			for (uint num = 0U; num < 28U; num += 1U)
			{
				if (pByte_0[num] >= 32 && pByte_0[num] <= 126)
				{
					Struct20 @struct;
					<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct18_0), pByte_0[num]);
					string text = new string((sbyte*)(&<Module>.struct19_0));
					text += new string((sbyte*)(&@struct));
					str += text;
				}
				else
				{
					str += new string((sbyte*)(&<Module>.struct6_5));
				}
			}
			this.string_0 = str;
		}

		// Token: 0x060001C3 RID: 451 RVA: 0x001088F0 File Offset: 0x001088F0
		private unsafe void method_9(byte* pByte_0, uint uint_0)
		{
			string str = null;
			for (uint num = 0U; num < uint_0; num += 1U)
			{
				if (pByte_0[num] >= 32 && pByte_0[num] <= 126)
				{
					Struct20 @struct;
					<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct18_0), pByte_0[num]);
					string text = new string((sbyte*)(&<Module>.struct19_0));
					text += new string((sbyte*)(&@struct));
					str += text;
				}
				else
				{
					str += " ";
				}
			}
			this.string_0 = str;
		}

		// Token: 0x060001C4 RID: 452 RVA: 0x00108968 File Offset: 0x00108968
		private unsafe int method_10(void* pVoid_3, sbyte* pSbyte_0, int int_16)
		{
			<Module>.memset(pVoid_3, 0, (uint)int_16);
			int num = <Module>.strlen((sbyte*)pSbyte_0) - 1;
			for (int i = num; i >= 0; i--)
			{
				byte b;
				if (*(sbyte*)(pSbyte_0 + i / sizeof(sbyte)) >= 48 && *(sbyte*)(pSbyte_0 + i / sizeof(sbyte)) <= 57)
				{
					b = (byte)(*(sbyte*)(pSbyte_0 + i / sizeof(sbyte)) - 48);
				}
				else if (*(sbyte*)(pSbyte_0 + i / sizeof(sbyte)) >= 97 && *(sbyte*)(pSbyte_0 + i / sizeof(sbyte)) <= 102)
				{
					b = (byte)(*(sbyte*)(pSbyte_0 + i / sizeof(sbyte)) - 96 + 9);
				}
				else
				{
					if (*(sbyte*)(pSbyte_0 + i / sizeof(sbyte)) < 65 || *(sbyte*)(pSbyte_0 + i / sizeof(sbyte)) > 70)
					{
						return 1;
					}
					b = (byte)(*(sbyte*)(pSbyte_0 + i / sizeof(sbyte)) - 64 + 9);
				}
				int num2 = num - i;
				if ((num2 & 1) != 0)
				{
					b = (byte)(b << 4);
				}
				num2 >>= 1;
				if (num2 >= int_16 || num2 < 0)
				{
					break;
				}
				((byte*)pVoid_3)[num2] = (((byte*)pVoid_3)[num2] | b);
			}
			return 0;
		}

		// Token: 0x060001C5 RID: 453 RVA: 0x00108A1C File Offset: 0x00108A1C
		private void linkLabel1_LinkClicked(object sender, LinkLabelLinkClickedEventArgs e)
		{
			this.linkLabel1.LinkVisited = true;
			try
			{
				Process.Start("http://www.jungleflasher.net/files/JungleFlasher.pdf");
			}
			catch (Exception ex)
			{
				<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
				MessageBox.Show(ex.Message, this.Text, MessageBoxButtons.OK, MessageBoxIcon.Hand);
				<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
			}
		}

		// Token: 0x060001C6 RID: 454 RVA: 0x00108AA8 File Offset: 0x00108AA8
		private void linkLabel2_LinkClicked(object sender, LinkLabelLinkClickedEventArgs e)
		{
			this.linkLabel2.LinkVisited = true;
			try
			{
				Process.Start("http://www.jungleflasher.net/files/activate.rar");
			}
			catch (Exception ex)
			{
				<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
				MessageBox.Show(ex.Message, this.Text, MessageBoxButtons.OK, MessageBoxIcon.Hand);
				<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
			}
		}

		// Token: 0x060001C7 RID: 455 RVA: 0x00108B34 File Offset: 0x00108B34
		private void linkLabel3_LinkClicked(object sender, LinkLabelLinkClickedEventArgs e)
		{
			this.linkLabel3.LinkVisited = true;
			try
			{
				Process.Start("http://www.jungleflasher.net/files/79_Unlock.rar");
			}
			catch (Exception ex)
			{
				<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
				MessageBox.Show(ex.Message, this.Text, MessageBoxButtons.OK, MessageBoxIcon.Hand);
				<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
			}
		}

		// Token: 0x060001C8 RID: 456 RVA: 0x00108BC0 File Offset: 0x00108BC0
		private void linkLabel4_LinkClicked(object sender, LinkLabelLinkClickedEventArgs e)
		{
			this.linkLabel4.LinkVisited = true;
			try
			{
				Process.Start("http://JungleFlasher.net/donate.html");
			}
			catch (Exception ex)
			{
				<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
				MessageBox.Show(ex.Message, this.Text, MessageBoxButtons.OK, MessageBoxIcon.Hand);
				<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
			}
		}

		// Token: 0x060001C9 RID: 457 RVA: 0x00108C4C File Offset: 0x00108C4C
		private void pictureBox4_Click(object sender, EventArgs e)
		{
			try
			{
				Process.Start("http://JungleFlasher.net/donate.html");
			}
			catch (Exception ex)
			{
				<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
				MessageBox.Show(ex.Message, this.Text, MessageBoxButtons.OK, MessageBoxIcon.Hand);
				<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
			}
		}

		// Token: 0x060001CA RID: 458 RVA: 0x00108CCC File Offset: 0x00108CCC
		private void pictureBox3_MouseEnter(object sender, EventArgs e)
		{
			this.Cursor = Cursors.Hand;
		}

		// Token: 0x060001CB RID: 459 RVA: 0x00108CE4 File Offset: 0x00108CE4
		private void pictureBox3_MouseLeave(object sender, EventArgs e)
		{
			this.Cursor = Cursors.Arrow;
		}

		// Token: 0x060001CC RID: 460 RVA: 0x00108CFC File Offset: 0x00108CFC
		private unsafe void Form1_KeyDown(object sender, KeyEventArgs e)
		{
			int selectedIndex = this.comboBox10.SelectedIndex;
			Struct28 @struct = 0;
			initblk(ref @struct + 1, 0, 15);
			Struct28 struct2 = 195;
			*(ref struct2 + 1) = 177;
			*(ref struct2 + 2) = 42;
			*(ref struct2 + 3) = 66;
			*(ref struct2 + 4) = 160;
			*(ref struct2 + 5) = 142;
			*(ref struct2 + 6) = 124;
			*(ref struct2 + 7) = 228;
			*(ref struct2 + 8) = 118;
			*(ref struct2 + 9) = 126;
			*(ref struct2 + 10) = 84;
			*(ref struct2 + 11) = 87;
			*(ref struct2 + 12) = 240;
			*(ref struct2 + 13) = 40;
			*(ref struct2 + 14) = 182;
			*(ref struct2 + 15) = 222;
			Struct28 struct3 = 90;
			*(ref struct3 + 1) = 90;
			*(ref struct3 + 2) = 90;
			*(ref struct3 + 3) = 90;
			*(ref struct3 + 4) = 90;
			*(ref struct3 + 5) = 90;
			*(ref struct3 + 6) = 90;
			*(ref struct3 + 7) = 90;
			*(ref struct3 + 8) = 90;
			*(ref struct3 + 9) = 90;
			*(ref struct3 + 10) = 90;
			*(ref struct3 + 11) = 90;
			*(ref struct3 + 12) = 90;
			*(ref struct3 + 13) = 90;
			*(ref struct3 + 14) = 90;
			*(ref struct3 + 15) = 90;
			Struct28 struct4 = 155;
			*(ref struct4 + 1) = 106;
			*(ref struct4 + 2) = 72;
			*(ref struct4 + 3) = 189;
			*(ref struct4 + 4) = 225;
			*(ref struct4 + 5) = 101;
			*(ref struct4 + 6) = 95;
			*(ref struct4 + 7) = 184;
			*(ref struct4 + 8) = 152;
			*(ref struct4 + 9) = 240;
			*(ref struct4 + 10) = 183;
			*(ref struct4 + 11) = 187;
			*(ref struct4 + 12) = 237;
			*(ref struct4 + 13) = 60;
			*(ref struct4 + 14) = 194;
			*(ref struct4 + 15) = 66;
			Struct28 struct5 = 90;
			*(ref struct5 + 1) = 90;
			*(ref struct5 + 2) = 90;
			*(ref struct5 + 3) = 90;
			*(ref struct5 + 4) = 90;
			*(ref struct5 + 5) = 90;
			*(ref struct5 + 6) = 90;
			*(ref struct5 + 7) = 90;
			*(ref struct5 + 8) = 90;
			*(ref struct5 + 9) = 90;
			*(ref struct5 + 10) = 90;
			*(ref struct5 + 11) = 90;
			*(ref struct5 + 12) = 90;
			*(ref struct5 + 13) = 90;
			*(ref struct5 + 14) = 90;
			*(ref struct5 + 15) = 90;
			if (e.Modifiers == Keys.Control && e.KeyCode == Keys.F1)
			{
				this.method_12();
			}
			if (e.Modifiers == Keys.Control && e.KeyCode == Keys.F2)
			{
				this.method_13();
			}
			if (e.Modifiers == Keys.Control && e.KeyCode == Keys.F3)
			{
				this.tabControl5.SelectedTab = this.Benq;
				this.method_202();
			}
			if (e.Modifiers == Keys.Control && e.KeyCode == Keys.F4)
			{
				this.method_56();
			}
			if (e.Modifiers == Keys.Control && e.KeyCode == Keys.F5)
			{
				WorkingFolder workingFolder = new WorkingFolder();
				if (this.bool_2)
				{
					workingFolder.textBox8.Text = this.string_8;
				}
				if (workingFolder.ShowDialog(this) == DialogResult.OK)
				{
					this.string_8 = workingFolder.textBox8.Text;
					if (workingFolder.textBox8.Text != "")
					{
						this.textBox6.AppendText("Backup Dir set as '" + this.string_8 + "\r\n");
						RegistryKey registryKey = Registry.CurrentUser.CreateSubKey("JungleFlasher");
						registryKey.SetValue("BackupFolder", this.string_8);
						this.bool_2 = true;
						registryKey.Close();
						ProjectName projectName = new ProjectName();
						if (projectName.ShowDialog(this) == DialogResult.OK)
						{
							this.string_10 = this.string_8 + projectName.textBox1.Text;
							this.string_9 = projectName.textBox1.Text;
							if (projectName.textBox1.Text == "")
							{
								return;
							}
							if (Directory.Exists(this.string_10))
							{
								<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
								MessageBox.Show("The folder " + this.string_10 + " already exists!", "Enter Job Name", MessageBoxButtons.OK);
								<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
								this.textBox6.AppendText("Working folder '" + this.string_10 + "' re-opened." + "\r\n");
							}
							else
							{
								Directory.CreateDirectory(this.string_10);
								this.textBox6.AppendText("Working folder '" + this.string_10 + "' created." + "\r\n");
							}
							Directory.SetCurrentDirectory(this.string_10);
						}
					}
					else
					{
						this.textBox6.AppendText("Removing Backup Dir from Registry" + "\r\n");
						RegistryKey registryKey2 = Registry.CurrentUser.CreateSubKey("JungleFlasher");
						registryKey2.DeleteValue("BackupFolder");
						this.bool_2 = false;
						registryKey2.Close();
					}
				}
			}
			if (e.Modifiers == Keys.Control && e.KeyCode == Keys.F6)
			{
				if (this.checkBox7.CheckState == CheckState.Unchecked)
				{
					this.checkBox7.CheckState = CheckState.Checked;
				}
				else
				{
					this.checkBox7.CheckState = CheckState.Unchecked;
				}
			}
			if (e.Modifiers == Keys.Control && e.KeyCode == Keys.F7)
			{
				<Module>.memset(<Module>.struct123_0, 0, 2392U);
				<Module>.memset(*(ref <Module>.struct123_0 + 4), 0, 2392U);
				this.method_40();
				this.method_43();
				this.method_177();
				this.label87.Text = "";
				this.label88.Text = "";
				if (this.bool_2)
				{
					int num = Convert.ToInt32(this.string_11);
					num++;
					this.string_11 = Convert.ToString(num);
					RegistryKey registryKey3 = Registry.CurrentUser.CreateSubKey("JungleFlasher");
					registryKey3.SetValue("Mods", Convert.ToString(num));
					registryKey3.Close();
					if (num % 10 == 0)
					{
						Donate donate = new Donate();
						if (donate.ShowDialog(this) == DialogResult.OK)
						{
							try
							{
								Process.Start("http://JungleFlasher.net/donate.html");
							}
							catch (Exception ex)
							{
								<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
								MessageBox.Show(ex.Message, this.Text, MessageBoxButtons.OK, MessageBoxIcon.Hand);
								<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
							}
						}
					}
					string text = this.string_10 + "\\jf.log";
					IntPtr intPtr = Marshal.StringToHGlobalAnsi(text);
					IntPtr value = intPtr;
					sbyte* pSbyte_ = (sbyte*)((void*)value);
					GStruct5* ptr = <Module>.fopen((sbyte*)pSbyte_, (sbyte*)(&<Module>.struct18_8));
					if (ptr == null)
					{
						<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
						MessageBox.Show(text, "Can't open log file", MessageBoxButtons.OK);
						<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
						return;
					}
					IntPtr intPtr2 = Marshal.StringToHGlobalAnsi(this.textBox6.Text);
					IntPtr value2 = intPtr2;
					sbyte* pSbyte_2 = (sbyte*)((void*)value2);
					<Module>.fputs((sbyte*)(&<Module>.struct35_122), ptr);
					<Module>.fputs((sbyte*)pSbyte_2, ptr);
					<Module>.fclose(ptr);
					this.textBox6.Clear();
					this.textBox6.AppendText("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~" + "\r\n" + "JungleFlasher 0.1.96 Beta" + "\r\n");
					int num2;
					<Module>.time((int*)(&num2));
					GStruct85* pGstruct85_ = <Module>.localtime((int*)(&num2));
					this.textBox6.AppendText("Session Started " + Convert.ToString(new string(<Module>.asctime((GStruct85*)pGstruct85_))).Substring(0, 24) + "\r\n\r\n");
					ProjectName projectName2 = new ProjectName();
					if (projectName2.ShowDialog(this) == DialogResult.OK)
					{
						this.string_10 = this.string_8 + projectName2.textBox1.Text;
						this.string_9 = projectName2.textBox1.Text;
						if (projectName2.textBox1.Text == "")
						{
							return;
						}
						if (Directory.Exists(this.string_10))
						{
							<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
							MessageBox.Show("The folder " + this.string_10 + " already exists!", "Enter Job Name", MessageBoxButtons.OK);
							<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
							this.textBox6.AppendText("Working folder '" + this.string_10 + "' re-opened." + "\r\n");
						}
						else
						{
							Directory.CreateDirectory(this.string_10);
							this.textBox6.AppendText("Working folder '" + this.string_10 + "' created." + "\r\n");
						}
						Directory.SetCurrentDirectory(this.string_10);
					}
				}
			}
			if (e.Modifiers == Keys.Control && e.KeyCode == Keys.F8)
			{
				this.radioButton16.Enabled = true;
				if (this.radioButton13.Enabled)
				{
					this.radioButton12.Enabled = true;
				}
				else
				{
					this.radioButton12.Enabled = false;
				}
			}
			if (e.Modifiers == Keys.Control && e.KeyCode == Keys.F9)
			{
				<Module>.smethod_157();
			}
			if (e.Modifiers == Keys.Control && e.KeyCode == Keys.F10 && !this.bool_4)
			{
				this.method_27();
			}
			if (e.Modifiers == Keys.Control && e.KeyCode == Keys.F12)
			{
				this.method_24();
			}
			if (e.Shift && e.Control && e.KeyCode == Keys.F1)
			{
				this.method_192();
			}
			if (e.Shift && e.Control && e.KeyCode == Keys.F9)
			{
				this.method_215();
			}
			if (e.Shift && e.Control && e.KeyCode == Keys.F10)
			{
				if (*<Module>.struct123_0 != 1)
				{
					return;
				}
				if (<Module>.memcmp(<Module>.struct123_0 + 280, (void*)(&@struct), 16U) == null)
				{
					this.method_53();
					this.method_54();
				}
				else if (string.Compare(this.textBox9.Text, "") == 0)
				{
					this.method_53();
					this.method_54();
				}
				else
				{
					this.method_53();
				}
			}
			if (e.Shift && e.Control && e.KeyCode == Keys.F12)
			{
				this.radioButton18.Enabled = true;
			}
			if (e.Shift && e.Control && e.KeyCode == Keys.F11)
			{
				this.method_322();
			}
		}

		// Token: 0x060001CD RID: 461 RVA: 0x003BFD58 File Offset: 0x00307D58
		private unsafe void method_11()
		{
			GStruct92* pGstruct92_ = <Module>.CreateDCA((sbyte*)(&<Module>.struct22_2), null, null, null);
			int deviceCaps = <Module>.GetDeviceCaps(pGstruct92_, 88);
			this.pictureBox3.Visible = false;
			this.axWebBrowser_0.Visible = true;
			if (deviceCaps == 120)
			{
				this.axWebBrowser_0.Navigate("http://jungleflasher.net/flash/loader1.html");
			}
			else
			{
				this.axWebBrowser_0.Navigate("http://jungleflasher.net/flash/loader.html");
			}
			while (this.axWebBrowser_0.Busy)
			{
				Application.DoEvents();
			}
		}

		// Token: 0x060001CE RID: 462 RVA: 0x001097E0 File Offset: 0x001097E0
		private void axWebBrowser_0_NavigateError(object object_0, DWebBrowserEvents2_NavigateErrorEvent dwebBrowserEvents2_NavigateErrorEvent_0)
		{
			this.pictureBox3.Visible = true;
			this.axWebBrowser_0.Visible = false;
			this.axWebBrowser_0.Stop();
		}

		// Token: 0x060001CF RID: 463 RVA: 0x00109810 File Offset: 0x00109810
		private void axWebBrowser_0_NavigateComplete2(object object_0, DWebBrowserEvents2_NavigateComplete2Event dwebBrowserEvents2_NavigateComplete2Event_0)
		{
		}

		// Token: 0x060001D0 RID: 464 RVA: 0x00109820 File Offset: 0x00109820
		private void axWebBrowser_0_NewWindow3(object object_0, DWebBrowserEvents2_NewWindow3Event dwebBrowserEvents2_NewWindow3Event_0)
		{
			string text = Convert.ToString(dwebBrowserEvents2_NewWindow3Event_0.bstrUrl);
			if (string.Compare(text, "http://jungleflasher.net/flash/loader.html") != 0 && string.Compare(text, "http://jungleflasher.net/flash/loader1.html") != 0)
			{
				dwebBrowserEvents2_NewWindow3Event_0.cancel = true;
				Process.Start(text);
			}
		}

		// Token: 0x060001D1 RID: 465 RVA: 0x00109864 File Offset: 0x00109864
		private void pictureBox3_Click(object sender, EventArgs e)
		{
			try
			{
				Process.Start("http://www.modtraders.co.uk");
			}
			catch (Exception ex)
			{
				<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
				MessageBox.Show(ex.Message, this.Text, MessageBoxButtons.OK, MessageBoxIcon.Hand);
				<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
			}
		}

		// Token: 0x060001D2 RID: 466 RVA: 0x001098E4 File Offset: 0x001098E4
		private unsafe void textBox6_DoubleClick(object sender, EventArgs e)
		{
			Process process = new Process();
			process.StartInfo.FileName = new string((sbyte*)(&<Module>.struct72_0));
			process.Start();
			process.WaitForInputIdle();
			GStruct11* ptr = <Module>.FindWindowA((sbyte*)(&<Module>.struct22_3), null);
			string s = new string((sbyte*)(&<Module>.struct13_1)) + this.string_9;
			IntPtr intPtr = Marshal.StringToHGlobalAnsi(s);
			IntPtr value = intPtr;
			sbyte* int_ = (sbyte*)((void*)value);
			if (ptr != -1)
			{
				<Module>.SendMessageA(ptr, 12U, 0U, int_);
				GStruct11* ptr2 = <Module>.FindWindowExA(ptr, null, (sbyte*)(&<Module>.struct35_123), null);
				string text = this.textBox6.Text;
				IntPtr intPtr2 = Marshal.StringToHGlobalAnsi(text);
				IntPtr value2 = intPtr2;
				int int_2 = (void*)value2;
				<Module>.SendMessageA(ptr2, 12U, 0U, int_2);
			}
		}

		// Token: 0x060001D3 RID: 467 RVA: 0x001099AC File Offset: 0x001099AC
		private unsafe void method_12()
		{
			string[] commandLineArgs = Environment.GetCommandLineArgs();
			string value = commandLineArgs[0] + " \"%1\" Source";
			string value2 = commandLineArgs[0] + " \"%1\" Target";
			string value3 = commandLineArgs[0] + " \"%1\" DBupdate";
			string value4 = commandLineArgs[0] + " \"%1\"";
			RegistryKey registryKey = Registry.ClassesRoot.CreateSubKey(".bin\\Shell\\JF Source\\Command");
			registryKey.SetValue(new string((sbyte*)(&<Module>.struct19_0)), value);
			registryKey.Close();
			registryKey = Registry.ClassesRoot.CreateSubKey(".bin\\Shell\\JF Target\\Command");
			registryKey.SetValue(new string((sbyte*)(&<Module>.struct19_0)), value2);
			registryKey.Close();
			if (!this.bool_4)
			{
				registryKey = Registry.ClassesRoot.CreateSubKey(".bin\\Shell\\JF Update DB\\Command");
				registryKey.SetValue(new string((sbyte*)(&<Module>.struct19_0)), value3);
				registryKey.Close();
			}
			registryKey = Registry.ClassesRoot.CreateSubKey(".bin\\Shell\\Open\\Command");
			registryKey.SetValue(new string((sbyte*)(&<Module>.struct19_0)), value4);
			registryKey.Close();
			registryKey = Registry.ClassesRoot.CreateSubKey(".bin");
			if (registryKey.GetValue("NoOpen") != null)
			{
				registryKey.DeleteValue("NoOpen");
			}
			registryKey.SetValue(new string((sbyte*)(&<Module>.struct19_0)), "Open");
			registryKey.Close();
		}

		// Token: 0x060001D4 RID: 468 RVA: 0x00109AF4 File Offset: 0x00109AF4
		private void method_13()
		{
			Registry.ClassesRoot.DeleteSubKey(".bin\\Shell\\JF Target\\Command", false);
			Registry.ClassesRoot.DeleteSubKey(".bin\\Shell\\JF Target", false);
			Registry.ClassesRoot.DeleteSubKey(".bin\\Shell\\JF Source\\Command", false);
			Registry.ClassesRoot.DeleteSubKey(".bin\\Shell\\JF Source", false);
			Registry.ClassesRoot.DeleteSubKey(".bin\\Shell\\JF Update DB\\Command", false);
			Registry.ClassesRoot.DeleteSubKey(".bin\\Shell\\JF Update DB", false);
			Registry.ClassesRoot.DeleteSubKey(".bin\\Shell\\Open\\Command", false);
			Registry.ClassesRoot.DeleteSubKey(".bin\\Shell\\Open", false);
		}

		// Token: 0x060001D5 RID: 469 RVA: 0x00109B84 File Offset: 0x00109B84
		private unsafe void method_14()
		{
			uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
			if (*(ref <Module>.struct38_0 + selectedIndex * 72U) == 0 && *(ref <Module>.struct38_0 + selectedIndex * 72U + 3) == 0)
			{
				this.method_424(2);
			}
			this.button7.Enabled = false;
			this.button13.Enabled = false;
			this.button14.Enabled = false;
			this.button15.Enabled = false;
			this.button16.Enabled = false;
			this.button17.Enabled = false;
			this.button18.Enabled = false;
			this.button21.Enabled = false;
			this.button40.Enabled = false;
			this.button42.Enabled = false;
		}

		// Token: 0x060001D6 RID: 470 RVA: 0x00109C3C File Offset: 0x00109C3C
		private void method_15()
		{
			this.button7.Enabled = true;
			this.button16.Enabled = true;
			this.button17.Enabled = true;
			this.button18.Enabled = true;
			this.button21.Enabled = true;
			this.button40.Enabled = true;
			this.button14.Enabled = true;
			this.button13.Enabled = true;
			this.button15.Enabled = true;
			if (string.Compare(this.button42.Text, "") != 0)
			{
				this.button42.Enabled = true;
			}
		}

		// Token: 0x060001D7 RID: 471 RVA: 0x00109CD8 File Offset: 0x00109CD8
		private void method_16()
		{
			this.groupBox11.Enabled = true;
			this.groupBox13.Enabled = true;
			this.groupBox14.Enabled = true;
		}

		// Token: 0x060001D8 RID: 472 RVA: 0x00109D0C File Offset: 0x00109D0C
		private void method_17()
		{
			this.groupBox11.Enabled = false;
			this.groupBox13.Enabled = false;
			this.groupBox14.Enabled = false;
		}

		// Token: 0x060001D9 RID: 473 RVA: 0x00109D40 File Offset: 0x00109D40
		private void radioButton19_CheckedChanged(object sender, EventArgs e)
		{
			if (string.Compare(this.button42.Text, "") != 0)
			{
				this.button42.Enabled = true;
			}
		}

		// Token: 0x060001DA RID: 474 RVA: 0x00109D70 File Offset: 0x00109D70
		private unsafe void method_18()
		{
			uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
			if (*(ref <Module>.struct38_0 + selectedIndex * 72U) == 0 && *(ref <Module>.struct38_0 + selectedIndex * 72U + 3) == 0)
			{
				this.method_424(2);
			}
			this.button1.Enabled = false;
			this.button2.Enabled = false;
			this.button4.Enabled = false;
			this.button5.Enabled = false;
			this.button28.Enabled = false;
			this.button32.Enabled = false;
			this.button38.Enabled = false;
			this.button39.Enabled = false;
			Application.DoEvents();
		}

		// Token: 0x060001DB RID: 475 RVA: 0x00109E14 File Offset: 0x00109E14
		private void method_19()
		{
			this.button1.Enabled = true;
			this.button2.Enabled = true;
			this.button4.Enabled = true;
			this.button5.Enabled = true;
			this.button28.Enabled = true;
			this.button32.Enabled = true;
			this.button38.Enabled = true;
			this.button39.Enabled = true;
		}

		// Token: 0x060001DC RID: 476 RVA: 0x00109E84 File Offset: 0x00109E84
		private void button30_Click(object sender, EventArgs e)
		{
			this.axWebBrowser_1.Navigate("http://jungleflasher.net/chat/support.html");
		}

		// Token: 0x060001DD RID: 477 RVA: 0x00109EA4 File Offset: 0x00109EA4
		private void button31_Click(object sender, EventArgs e)
		{
			this.axWebBrowser_1.Navigate("http://jungleflasher.net/chat/leave.html");
		}

		// Token: 0x060001DE RID: 478 RVA: 0x00109EC4 File Offset: 0x00109EC4
		private unsafe void method_20()
		{
			if (*(ref <Module>.gstruct10_0 + 12) == 1)
			{
				this.axWebBrowser_1.Navigate("http://jungleflasher.net/chat/jf196u.html");
			}
			else
			{
				this.axWebBrowser_1.Navigate("http://jungleflasher.net/chat/jf196.html");
			}
		}

		// Token: 0x060001DF RID: 479 RVA: 0x00109F00 File Offset: 0x00109F00
		private unsafe void axWebBrowser_1_NavigateError(object object_0, DWebBrowserEvents2_NavigateErrorEvent dwebBrowserEvents2_NavigateErrorEvent_0)
		{
			string text = null;
			string[] commandLineArgs = Environment.GetCommandLineArgs();
			string directoryName = Path.GetDirectoryName(commandLineArgs[0]);
			string text2 = directoryName + "\\Blank.html";
			IntPtr intPtr = Marshal.StringToHGlobalAnsi(text2);
			IntPtr value = intPtr;
			sbyte* pSbyte_ = (sbyte*)((void*)value);
			GStruct5* ptr = <Module>.fopen((sbyte*)pSbyte_, (sbyte*)(&<Module>.struct18_2));
			if (ptr != null)
			{
				text = text + "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">" + "\r\n";
				text = text + "<html xmlns=\"www.Jungleflasher.net\" xml:lang=\"en\">" + "\r\n";
				text = text + "   <body>" + "\r\n" + "      <div id=\"main\">" + "\r\n" + "      </div>" + "\r\n" + "   </body>" + "\r\n" + "</html>" + "\r\n";
				IntPtr intPtr2 = Marshal.StringToHGlobalAnsi(text);
				IntPtr value2 = intPtr2;
				sbyte* pSbyte_2 = (sbyte*)((void*)value2);
				<Module>.fputs((sbyte*)pSbyte_2, ptr);
				<Module>.fclose(ptr);
			}
			this.axWebBrowser_1.Navigate(text2);
		}

		// Token: 0x060001E0 RID: 480 RVA: 0x00109FE8 File Offset: 0x00109FE8
		private void axWebBrowser_1_NewWindow3(object object_0, DWebBrowserEvents2_NewWindow3Event dwebBrowserEvents2_NewWindow3Event_0)
		{
			string text = Convert.ToString(dwebBrowserEvents2_NewWindow3Event_0.bstrUrl);
			if (string.Compare(text, "http://jungleflasher.net/chat/jf196.html") != 0)
			{
				dwebBrowserEvents2_NewWindow3Event_0.cancel = true;
				Process.Start(text);
			}
		}

		// Token: 0x060001E1 RID: 481 RVA: 0x0010A020 File Offset: 0x0010A020
		private int method_21()
		{
			RegistryKey registryKey = Registry.CurrentUser.CreateSubKey("JF_KeyDB");
			int num;
			if (registryKey.GetValue("Index") != null)
			{
				string value = registryKey.GetValue("Index").ToString();
				num = Convert.ToInt32(value) + 1;
				value = Convert.ToString(num);
				registryKey.SetValue("Index", value);
			}
			else
			{
				num = 1;
				registryKey.SetValue("Index", "1");
			}
			registryKey.Close();
			return num;
		}

		// Token: 0x060001E2 RID: 482 RVA: 0x0010A098 File Offset: 0x0010A098
		private unsafe int method_22(string string_25)
		{
			Struct68 @struct = 0;
			initblk(ref @struct + 1, 0, 259);
			RegistryKey registryKey = Registry.CurrentUser.CreateSubKey("JF_KeyDB\\KeyList");
			string value;
			int num;
			if (registryKey.GetValue(string_25) != null)
			{
				value = registryKey.GetValue(string_25).ToString();
				num = Convert.ToInt32(value);
			}
			else
			{
				num = this.method_21();
				value = Convert.ToString(num);
				registryKey.SetValue(string_25, value);
			}
			registryKey = Registry.CurrentUser.CreateSubKey("JF_KeyDB\\SerList");
			if (*<Module>.struct123_0 == 4 && *(<Module>.struct123_0 + 2028) != 0 && *(<Module>.struct123_0 + 2028) != 255)
			{
				string text = "";
				<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct19_0));
				<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct18_9), <Module>.struct123_0 + 2028);
				text += new string((sbyte*)(&@struct));
				registryKey.SetValue(text.Substring(0, 17), value);
				if (string.Compare(text, "D608CG73880800348") == 0 && this.bool_1)
				{
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					int num2 = (int)MessageBox.Show("Barcode is common to all Lite-On DG-16D2S following the 13146 System update" + "\n" + "Do you wish to enter the actual barcode as a second Key DB Barcode entry" + "\n" + "Click YES to manually enter and include the Case Barcode.", "PhatKey", MessageBoxButtons.YesNo, MessageBoxIcon.Question, MessageBoxDefaultButton.Button1);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
					if (num2 == 6)
					{
						Common_Barcode common_Barcode = new Common_Barcode();
						if (common_Barcode.ShowDialog(this) == DialogResult.OK)
						{
							text = common_Barcode.textBox3.Text;
							text = text.Substring(0, 17);
							registryKey.SetValue(text.Substring(0, 17), value);
						}
					}
				}
			}
			if (*<Module>.struct123_0 != 4 && *(<Module>.struct123_0 + 2382) == 4 && *(<Module>.struct123_0 + 2028) != 0 && *(<Module>.struct123_0 + 2028) != 255)
			{
				Struct73 struct2;
				<Module>.memcpy((void*)(&struct2), <Module>.struct123_0 + 610, 20U);
				string text = "";
				<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct19_0));
				<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct18_9), ref struct2);
				text += new string((sbyte*)(&@struct));
				registryKey.SetValue(text.Substring(0, 17), value);
			}
			if (*<Module>.struct123_0 == 5 && *(<Module>.struct123_0 + 2028) != 0 && *(<Module>.struct123_0 + 2028) != 255)
			{
				string text = "";
				<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct19_0));
				<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct18_9), <Module>.struct123_0 + 2028);
				text += new string((sbyte*)(&@struct));
				registryKey.SetValue(text.Substring(0, 17), value);
			}
			if (*<Module>.struct123_0 == 6 && *(<Module>.struct123_0 + 2028) != 0 && *(<Module>.struct123_0 + 2028) != 255)
			{
				string text = "";
				<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct19_0));
				<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct18_9), <Module>.struct123_0 + 2028);
				text += new string((sbyte*)(&@struct));
				registryKey.SetValue(text.Substring(0, 17), value);
			}
			registryKey.Close();
			return num;
		}

		// Token: 0x060001E3 RID: 483 RVA: 0x0010A3DC File Offset: 0x0010A3DC
		private unsafe void method_23(int int_16)
		{
			Struct68 @struct = 0;
			initblk(ref @struct + 1, 0, 259);
			string text = this.textBox9.Text;
			string text2 = this.label37.Text;
			string text3 = this.label6.Text;
			string text4 = this.label7.Text;
			string text5 = this.label8.Text;
			string text6 = this.label16.Text;
			string text7 = this.label44.Text;
			string text8 = this.label40.Text;
			string text9 = this.textBox15.Text;
			int num = 0;
			string text10 = Convert.ToString(int_16);
			RegistryKey registryKey = Registry.CurrentUser.CreateSubKey("JF_KeyDB\\" + text10);
			if (registryKey.GetValue("Key") != null)
			{
				if (registryKey.GetValue("Date1") == null && registryKey.GetValue("Updated") != null)
				{
					registryKey.SetValue("Date1", registryKey.GetValue("Updated"));
				}
				int num2;
				<Module>.time((int*)(&num2));
				GStruct85* pGstruct85_ = <Module>.localtime((int*)(&num2));
				registryKey.SetValue("Updated", Convert.ToString(new string(<Module>.asctime((GStruct85*)pGstruct85_))).Substring(0, 24));
				this.textBox6.AppendText("Key database updated" + "\r\n\r\n");
				this.label21.Text = "DVD Key @";
				do
				{
					num++;
				}
				while (registryKey.GetValue("Date" + Convert.ToString(num)) != null);
				registryKey.SetValue("Date" + Convert.ToString(num), Convert.ToString(new string(<Module>.asctime((GStruct85*)pGstruct85_))).Substring(0, 24));
				registryKey.SetValue("LastFile", text9);
			}
			else
			{
				registryKey.SetValue("Index", text10);
				registryKey.SetValue("Key", text);
				registryKey.SetValue("KeyLoc", text2);
				registryKey.SetValue("Vendor", text3);
				registryKey.SetValue(new string((sbyte*)(&<Module>.struct23_0)), text4);
				registryKey.SetValue("Rev", text5);
				registryKey.SetValue("Type", text6);
				registryKey.SetValue("Osig", text7);
				registryKey.SetValue("LastFile", text9);
				if (string.Compare(text7, text8) != 0)
				{
					registryKey.SetValue("Spoof", text8);
				}
				int num3;
				<Module>.time((int*)(&num3));
				GStruct85* pGstruct85_2 = <Module>.localtime((int*)(&num3));
				registryKey.SetValue(new string((sbyte*)(&<Module>.struct22_0)), Convert.ToString(new string(<Module>.asctime((GStruct85*)pGstruct85_2))).Substring(0, 24));
				this.textBox6.AppendText("Key added to database" + "\r\n\r\n");
				this.label21.Text = "DVD Key *";
			}
			string value;
			string text11;
			if (this.bool_2)
			{
				if (this.string_9 == "")
				{
					value = "N/A";
					text11 = "N/A";
					if (this.textBox15.TextLength != 0)
					{
						text11 = Path.GetDirectoryName(this.textBox15.Text);
						value = Path.GetFileName(text11);
					}
				}
				else
				{
					value = this.string_9;
					text11 = this.string_10;
				}
			}
			else if (this.textBox15.TextLength != 0)
			{
				text11 = Path.GetDirectoryName(this.textBox15.Text);
				value = Path.GetFileName(text11);
			}
			else
			{
				text11 = "N/A";
				value = "N/A";
			}
			registryKey.SetValue("JobName", value);
			registryKey.SetValue("WorkingDir", text11);
			registryKey.Close();
		}

		// Token: 0x060001E4 RID: 484 RVA: 0x0010A758 File Offset: 0x0010A758
		private unsafe void method_24()
		{
			string text = null;
			RegistryKey registryKey = Registry.CurrentUser.CreateSubKey("JF_KeyDB");
			int num;
			if (registryKey.GetValue("Index") != null)
			{
				text = registryKey.GetValue("Index").ToString();
				num = Convert.ToInt32(text) + 1;
			}
			registryKey.Close();
			string text2 = "JungleFlasher Key Database - dumped at ";
			int num2;
			<Module>.time((int*)(&num2));
			GStruct85* pGstruct85_ = <Module>.localtime((int*)(&num2));
			text2 = text2 + Convert.ToString(new string(<Module>.asctime((GStruct85*)pGstruct85_))).Substring(0, 24) + "\r\n";
			text2 = text2 + text + " keys present!" + "\r\n";
			for (int i = 1; i < num; i++)
			{
				RegistryKey registryKey2 = Registry.CurrentUser.CreateSubKey("JF_KeyDB\\" + Convert.ToString(i));
				if (registryKey2.GetValue("Key") != null)
				{
					string arg = registryKey2.GetValue("Key").ToString();
					string text3 = registryKey2.GetValue("KeyLoc").ToString();
					string value = registryKey2.GetValue("Vendor").ToString();
					string value2 = registryKey2.GetValue(new string((sbyte*)(&<Module>.struct23_0))).ToString();
					string value3 = registryKey2.GetValue("Rev").ToString();
					string value4 = registryKey2.GetValue("Type").ToString();
					string text4 = registryKey2.GetValue("JobName").ToString();
					string text5 = registryKey2.GetValue(new string((sbyte*)(&<Module>.struct22_0))).ToString();
					string text6;
					if (registryKey2.GetValue("Spoof") != null)
					{
						text6 = registryKey2.GetValue("Spoof").ToString();
					}
					else
					{
						text6 = "";
					}
					string text7;
					if (registryKey2.GetValue("Updated") != null)
					{
						text7 = registryKey2.GetValue("Updated").ToString();
					}
					else
					{
						text7 = "";
					}
					string arg2 = registryKey2.GetValue("Osig").ToString();
					string str = registryKey2.GetValue("WorkingDir").ToString();
					registryKey2.Close();
					text2 = text2 + "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~" + "\r\n\r\n";
					text2 = text2 + "  " + Convert.ToString(i) + "\t" + "Job: " + text4 + "\t" + " Created: " + text5 + "\r\n\r\n";
					text2 = text2 + "  " + str + "\r\n\r\n";
					text2 = text2 + "  Osig:  [" + arg2 + "]" + "\r\n";
					if (string.Compare(text6, "") != 0)
					{
						text2 = text2 + "  Spoof: [" + text6 + "]" + "\r\n";
					}
					text2 += "\r\n";
					string text8 = "                                                          ";
					text8 = text8.Insert(0, value);
					text8 = text8.Insert(9, value2);
					text8 = text8.Insert(19, value3);
					text8 = text8.Insert(27, value4);
					text2 = text2 + "  " + text8 + "\r\n\r\n";
					text2 = text2 + "  Key: " + arg + " @ " + text3 + "\r\n\r\n";
					if (string.Compare(text7, "") != 0)
					{
						text2 = text2 + "  Last Updated: " + text7 + "\r\n\r\n";
					}
				}
			}
			text2 = text2 + "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~" + "\r\n";
			Process process = new Process();
			process.StartInfo.FileName = new string((sbyte*)(&<Module>.struct72_0));
			process.Start();
			process.WaitForInputIdle();
			GStruct11* ptr = <Module>.FindWindowA((sbyte*)(&<Module>.struct22_3), null);
			string s = "JungleFlasher Key Database";
			IntPtr intPtr = Marshal.StringToHGlobalAnsi(s);
			IntPtr value5 = intPtr;
			sbyte* int_ = (sbyte*)((void*)value5);
			if (ptr != -1)
			{
				<Module>.SendMessageA(ptr, 12U, 0U, int_);
				GStruct11* ptr2 = <Module>.FindWindowExA(ptr, null, (sbyte*)(&<Module>.struct35_123), null);
				string s2 = text2;
				IntPtr intPtr2 = Marshal.StringToHGlobalAnsi(s2);
				IntPtr value6 = intPtr2;
				int int_2 = (void*)value6;
				<Module>.SendMessageA(ptr2, 12U, 0U, int_2);
			}
		}

		// Token: 0x060001E5 RID: 485 RVA: 0x0010AB58 File Offset: 0x0010AB58
		private unsafe void method_25()
		{
			string text = null;
			RegistryKey registryKey = Registry.CurrentUser.CreateSubKey("JF_KeyDB");
			int num;
			if (registryKey.GetValue("Index") != null)
			{
				text = registryKey.GetValue("Index").ToString();
				num = Convert.ToInt32(text) + 1;
			}
			registryKey.Close();
			RegistryKey registryKey2 = Registry.CurrentUser.CreateSubKey("JF_KeyDB\\SerList");
			string value = registryKey2.ValueCount.ToString();
			string[] valueNames = registryKey2.GetValueNames();
			string text2 = ",,JungleFlasher Key Database,";
			int num2;
			<Module>.time((int*)(&num2));
			GStruct85* pGstruct85_ = <Module>.localtime((int*)(&num2));
			text2 += Convert.ToString(new string(<Module>.asctime((GStruct85*)pGstruct85_))).Substring(0, 24);
			text2 = text2 + "," + text + " keys present!" + "\n";
			for (int i = 1; i < num; i++)
			{
				RegistryKey registryKey3 = Registry.CurrentUser.CreateSubKey("JF_KeyDB\\" + Convert.ToString(i));
				if (registryKey3.GetValue("Key") != null)
				{
					string str = registryKey3.GetValue("Key").ToString();
					string str2 = registryKey3.GetValue("KeyLoc").ToString();
					string str3 = registryKey3.GetValue("Vendor").ToString();
					string str4 = registryKey3.GetValue(new string((sbyte*)(&<Module>.struct23_0))).ToString();
					string str5 = registryKey3.GetValue("Rev").ToString();
					string str6 = registryKey3.GetValue("Type").ToString();
					string str7 = registryKey3.GetValue("JobName").ToString();
					string str8 = registryKey3.GetValue(new string((sbyte*)(&<Module>.struct22_0))).ToString();
					string text3;
					if (registryKey3.GetValue("Spoof") != null)
					{
						text3 = registryKey3.GetValue("Spoof").ToString();
					}
					else
					{
						text3 = "";
					}
					string text4;
					if (registryKey3.GetValue("Updated") != null)
					{
						text4 = registryKey3.GetValue("Updated").ToString();
					}
					else
					{
						text4 = "";
					}
					string str9 = registryKey3.GetValue("Osig").ToString();
					string str10 = registryKey3.GetValue("WorkingDir").ToString();
					string text5;
					if (registryKey3.GetValue("LastFile") != null)
					{
						text5 = registryKey3.GetValue("LastFile").ToString();
					}
					else
					{
						text5 = "";
					}
					registryKey3.Close();
					string text6 = "";
					for (int j = 0; j < Convert.ToInt32(value); j++)
					{
						if (string.Compare(registryKey2.GetValue(valueNames[j]).ToString(), Convert.ToString(i)) == 0)
						{
							text6 = valueNames[j];
							break;
						}
					}
					text2 = text2 + Convert.ToString(i) + ",";
					text2 = text2 + str7 + ",";
					text2 = text2 + str8 + ",";
					text2 = text2 + str10 + ",";
					text2 = text2 + str9 + ",";
					if (string.Compare(text3, "") != 0)
					{
						text2 = text2 + text3 + ",";
					}
					else
					{
						text2 += ",";
					}
					text2 = text2 + str3 + ",";
					text2 = text2 + str4 + ",";
					text2 = text2 + str5 + ",";
					text2 = text2 + str6 + ",";
					text2 = text2 + str + ",";
					text2 = text2 + str2 + ",";
					if (string.Compare(text4, "") != 0)
					{
						text2 = text2 + text4 + ",";
					}
					else
					{
						text2 += "n/a,";
					}
					if (string.Compare(text5, "") != 0)
					{
						text2 = text2 + text5 + ",";
					}
					else
					{
						text2 += "n/a,";
					}
					if (string.Compare(text6, "") != 0)
					{
						text2 = text2 + text6 + "\n";
					}
					else
					{
						text2 += "n/a\n";
					}
				}
			}
			registryKey2.Close();
			SaveFileDialog saveFileDialog = new SaveFileDialog();
			saveFileDialog.Filter = "KeyDb CSV file (*.csv)|*.csv|All Files (*.*)|*.*";
			saveFileDialog.DefaultExt = ".csv";
			saveFileDialog.FileName = "JF_Key_db.csv";
			saveFileDialog.OverwritePrompt = false;
			if (saveFileDialog.ShowDialog() == DialogResult.OK)
			{
				string fullPath = Path.GetFullPath(saveFileDialog.FileName);
				IntPtr intPtr = Marshal.StringToHGlobalAnsi(fullPath);
				IntPtr value2 = intPtr;
				sbyte* pSbyte_ = (sbyte*)((void*)value2);
				this.string_13 = saveFileDialog.FileName;
				GStruct5* ptr = <Module>.fopen((sbyte*)pSbyte_, (sbyte*)(&<Module>.struct18_2));
				if (ptr == null)
				{
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					MessageBox.Show(saveFileDialog.FileName.ToString(), "Can't open log file", MessageBoxButtons.OK);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
				}
				else
				{
					IntPtr intPtr2 = Marshal.StringToHGlobalAnsi(text2);
					IntPtr value3 = intPtr2;
					sbyte* pSbyte_2 = (sbyte*)((void*)value3);
					<Module>.fputs((sbyte*)pSbyte_2, ptr);
					<Module>.fclose(ptr);
				}
			}
		}

		// Token: 0x060001E6 RID: 486 RVA: 0x0010B060 File Offset: 0x0010B060
		private unsafe void method_26()
		{
			string value = null;
			string[,] array = null;
			OpenFileDialog openFileDialog = new OpenFileDialog();
			openFileDialog.Filter = "KeyDB Backup file (*.csv)|*.csv|All Files (*.*)|*.*";
			openFileDialog.FileName = "KeyDB.csv";
			openFileDialog.DefaultExt = ".csv";
			openFileDialog.CheckFileExists = true;
			openFileDialog.CheckPathExists = true;
			openFileDialog.RestoreDirectory = false;
			if (openFileDialog.ShowDialog() == DialogResult.OK)
			{
				string fullPath = Path.GetFullPath(openFileDialog.FileName);
				IntPtr intPtr = Marshal.StringToHGlobalAnsi(fullPath);
				IntPtr value2 = intPtr;
				sbyte* pSbyte_ = (sbyte*)((void*)value2);
				GStruct5* ptr = <Module>.fopen((sbyte*)pSbyte_, (sbyte*)(&<Module>.struct6_3));
				if (ptr == null)
				{
					<Module>.pGstruct14_9 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, null, <Module>.GetCurrentThreadId());
					MessageBox.Show(openFileDialog.FileName.ToString(), "Can't open file", MessageBoxButtons.OK);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_9);
					return;
				}
				Struct27 @struct;
				<Module>.fgets((sbyte*)(&@struct), 1024, ptr);
				sbyte* ptr2 = <Module>.strtok((sbyte*)(&@struct), (sbyte*)(&<Module>.struct6_4));
				ptr2 = <Module>.strtok(null, (sbyte*)(&<Module>.struct6_4));
				ptr2 = <Module>.strtok(null, (sbyte*)(&<Module>.struct6_4));
				sbyte* value3 = <Module>.strtok(ptr2, (sbyte*)(&<Module>.struct6_5));
				value = "" + new string((sbyte*)value3);
				array = new string[Convert.ToInt32(value), 15];
				for (int i = 0; i < Convert.ToInt32(value); i++)
				{
					<Module>.fgets((sbyte*)(&@struct), 1024, ptr);
					ptr2 = <Module>.strtok((sbyte*)(&@struct), (sbyte*)(&<Module>.struct6_4));
					string text = "" + new string((sbyte*)ptr2);
					array[i, 0] = text;
					for (int j = 1; j < 15; j++)
					{
						ptr2 = <Module>.strtok(null, (sbyte*)(&<Module>.struct18_3));
						text = "" + new string((sbyte*)ptr2);
						array[i, j] = text;
					}
				}
			}
			RegistryKey registryKey = Registry.CurrentUser.CreateSubKey("JF_KeyDB_Import");
			registryKey.SetValue("Index", Convert.ToString(value));
			registryKey.Close();
			for (int i = 0; i < Convert.ToInt32(value); i++)
			{
				registryKey = Registry.CurrentUser.CreateSubKey(new string((sbyte*)(&<Module>.struct16_4)) + Convert.ToString(i + 1));
				registryKey.SetValue("Index", Convert.ToString(i + 1));
				registryKey.SetValue("JobName", array[i, 1]);
				registryKey.SetValue("Created", array[i, 2]);
				registryKey.SetValue("Working", array[i, 3]);
				registryKey.SetValue("Osig", array[i, 4]);
				registryKey.SetValue("Spoof", array[i, 5]);
				registryKey.SetValue("Vendor", array[i, 6]);
				registryKey.SetValue("Model", array[i, 7]);
				registryKey.SetValue("Rev", array[i, 8]);
				registryKey.SetValue("Type", array[i, 9]);
				registryKey.SetValue("Key", array[i, 10]);
				registryKey.SetValue("KeyLoc", array[i, 11]);
				registryKey.SetValue("Updated", array[i, 12]);
				registryKey.SetValue("Lastfile", array[i, 13]);
				registryKey.Close();
			}
			for (int i = 0; i < Convert.ToInt32(value); i++)
			{
				registryKey = Registry.CurrentUser.CreateSubKey(new string((sbyte*)(&<Module>.struct1_2)));
				registryKey.SetValue(array[i, 10], Convert.ToString(i + 1));
				registryKey.Close();
			}
			for (int i = 0; i < Convert.ToInt32(value); i++)
			{
				registryKey = Registry.CurrentUser.CreateSubKey(new string((sbyte*)(&<Module>.struct1_3)));
				registryKey.SetValue(array[i, 14], Convert.ToString(i + 1));
				registryKey.Close();
			}
		}

		// Token: 0x060001E7 RID: 487 RVA: 0x0010B434 File Offset: 0x0010B434
		private void method_27()
		{
			if (string.Compare(this.textBox9.Text, "4DCB62B1031A08033818E62E95EE11EF") == 0)
			{
				new Donate();
				try
				{
					Process.Start("http://JungleFlasher.net/donate.html");
				}
				catch (Exception ex)
				{
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					MessageBox.Show(ex.Message, this.Text, MessageBoxButtons.OK, MessageBoxIcon.Hand);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
				}
				Application.Exit();
			}
			if (!this.bool_4)
			{
				if (this.textBox9.TextLength != 0)
				{
					int int_ = this.method_22(this.textBox9.Text);
					this.method_23(int_);
				}
			}
		}

		// Token: 0x060001E8 RID: 488 RVA: 0x0010B508 File Offset: 0x0010B508
		private void method_28()
		{
			if (string.Compare(this.textBox9.Text, "") != 0)
			{
				int num = this.method_22(this.textBox9.Text);
				new Job_history
				{
					int_0 = num
				}.ShowDialog(this);
			}
		}

		// Token: 0x060001E9 RID: 489 RVA: 0x0010B558 File Offset: 0x0010B558
		private unsafe void method_29()
		{
			for (int i = 0; i < 4; i++)
			{
				*(ref <Module>.struct123_0 + i * 4) = <Module>.malloc(2392U);
				if (*(ref <Module>.struct123_0 + i * 4) == 0)
				{
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					MessageBox.Show("Malloc Failed Struct:" + Convert.ToString(i), "SetupFI", MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
				}
				<Module>.memset(*(ref <Module>.struct123_0 + i * 4), 0, 2392U);
				if (*(ref <Module>.struct121_0 + i * 2392 + 2388) != 0)
				{
					<Module>.free(*(ref <Module>.struct121_0 + i * 2392 + 2388));
				}
				*(ref <Module>.struct121_0 + i * 2392 + 2388) = <Module>.malloc(262144U);
				if (*(ref <Module>.struct121_0 + i * 2392 + 2388) == 0)
				{
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					MessageBox.Show("Malloc Failed Buffer:" + Convert.ToString(i), "SetupFI", MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
				}
			}
		}

		// Token: 0x060001EA RID: 490 RVA: 0x0010B6A8 File Offset: 0x0010B6A8
		private unsafe int method_30(int int_16)
		{
			byte* ptr = *(ref <Module>.struct121_0 + int_16 * 2392 + 2388);
			uint num = 0U;
			uint num2 = 0U;
			for (uint num3 = 45056U; num3 < 110592U; num3 += 4U)
			{
				num2 += num;
				num = (uint)((int)ptr[num3 + 3U] << 24 | (int)ptr[num3 + 2U] << 16 | (int)ptr[num3 + 1U] << 8 | (int)ptr[num3]);
			}
			num2 = 0U - num2;
			uint result;
			if (num2 == 789421430U)
			{
				result = 1U;
			}
			else if (num2 == 529584510U)
			{
				result = 2U;
			}
			else if (num2 == 1731285449U)
			{
				result = 3U;
			}
			else if (num2 == 4236510092U)
			{
				result = 4U;
			}
			else if (num2 == 17588177U)
			{
				result = 5U;
			}
			else if (num2 == 2999884414U)
			{
				result = 6U;
			}
			else if (num2 == 253026502U)
			{
				result = 7U;
			}
			else if (num2 == 771127765U)
			{
				result = 8U;
			}
			else if (num2 == 2680630850U)
			{
				result = 9U;
			}
			else if (num2 == 3231213612U)
			{
				result = 10U;
			}
			else if (num2 == 1482142839U)
			{
				result = 11U;
			}
			else if (num2 == 2691219462U)
			{
				result = 12U;
			}
			else if (num2 == 811045522U)
			{
				result = 13U;
			}
			else if (num2 == 1009034336U)
			{
				result = 14U;
			}
			else
			{
				if (num2 != 3402234535U)
				{
					return 0;
				}
				result = 15U;
			}
			return (int)result;
		}

		// Token: 0x060001EB RID: 491 RVA: 0x0010B7E4 File Offset: 0x0010B7E4
		private unsafe int method_31(int int_16)
		{
			Struct76 @struct = 0;
			initblk(ref @struct + 1, 0, 259);
			Struct76 struct2 = 0;
			initblk(ref struct2 + 1, 0, 259);
			Struct28 struct3 = 255;
			*(ref struct3 + 1) = byte.MaxValue;
			*(ref struct3 + 2) = byte.MaxValue;
			*(ref struct3 + 3) = byte.MaxValue;
			*(ref struct3 + 4) = byte.MaxValue;
			*(ref struct3 + 5) = byte.MaxValue;
			*(ref struct3 + 6) = byte.MaxValue;
			*(ref struct3 + 7) = byte.MaxValue;
			*(ref struct3 + 8) = byte.MaxValue;
			*(ref struct3 + 9) = byte.MaxValue;
			*(ref struct3 + 10) = byte.MaxValue;
			*(ref struct3 + 11) = byte.MaxValue;
			*(ref struct3 + 12) = byte.MaxValue;
			*(ref struct3 + 13) = byte.MaxValue;
			*(ref struct3 + 14) = byte.MaxValue;
			*(ref struct3 + 15) = byte.MaxValue;
			Struct42 struct4 = 255;
			*(ref struct4 + 1) = byte.MaxValue;
			*(ref struct4 + 2) = byte.MaxValue;
			*(ref struct4 + 3) = byte.MaxValue;
			*(ref struct4 + 4) = byte.MaxValue;
			*(ref struct4 + 5) = byte.MaxValue;
			*(ref struct4 + 6) = byte.MaxValue;
			*(ref struct4 + 7) = byte.MaxValue;
			*(ref struct4 + 8) = byte.MaxValue;
			*(ref struct4 + 9) = byte.MaxValue;
			*(ref struct4 + 10) = byte.MaxValue;
			*(ref struct4 + 11) = byte.MaxValue;
			*(ref struct4 + 12) = byte.MaxValue;
			*(ref struct4 + 13) = byte.MaxValue;
			*(ref struct4 + 14) = byte.MaxValue;
			*(ref struct4 + 15) = byte.MaxValue;
			*(ref struct4 + 16) = byte.MaxValue;
			*(ref struct4 + 17) = byte.MaxValue;
			*(ref struct4 + 18) = byte.MaxValue;
			*(ref struct4 + 19) = byte.MaxValue;
			Struct28 struct5 = 248;
			*(ref struct5 + 1) = 121;
			*(ref struct5 + 2) = 55;
			*(ref struct5 + 3) = 225;
			*(ref struct5 + 4) = 18;
			*(ref struct5 + 5) = 144;
			*(ref struct5 + 6) = 161;
			*(ref struct5 + 7) = 82;
			*(ref struct5 + 8) = 4;
			*(ref struct5 + 9) = 46;
			*(ref struct5 + 10) = 3;
			*(ref struct5 + 11) = 9;
			*(ref struct5 + 12) = 145;
			*(ref struct5 + 13) = 109;
			*(ref struct5 + 14) = 2;
			*(ref struct5 + 15) = 81;
			Struct28 struct6 = 118;
			*(ref struct6 + 1) = 36;
			*(ref struct6 + 2) = 207;
			*(ref struct6 + 3) = 26;
			*(ref struct6 + 4) = 128;
			*(ref struct6 + 5) = 64;
			*(ref struct6 + 6) = 59;
			*(ref struct6 + 7) = 187;
			*(ref struct6 + 8) = 120;
			*(ref struct6 + 9) = 42;
			*(ref struct6 + 10) = 105;
			*(ref struct6 + 11) = 8;
			*(ref struct6 + 12) = 1;
			*(ref struct6 + 13) = 102;
			*(ref struct6 + 14) = 240;
			*(ref struct6 + 15) = 24;
			Struct41 struct7 = 27;
			*(ref struct7 + 1) = 41;
			*(ref struct7 + 2) = 209;
			*(ref struct7 + 3) = 161;
			*(ref struct7 + 4) = 157;
			*(ref struct7 + 5) = 12;
			*(ref struct7 + 6) = 156;
			*(ref struct7 + 7) = 232;
			*(ref struct7 + 8) = 132;
			*(ref struct7 + 9) = 220;
			*(ref struct7 + 10) = 21;
			*(ref struct7 + 11) = 229;
			*(ref struct7 + 12) = 153;
			*(ref struct7 + 13) = 8;
			*(ref struct7 + 14) = 253;
			*(ref struct7 + 15) = 229;
			*(ref struct7 + 16) = 17;
			*(ref struct7 + 17) = 126;
			Struct41 struct8 = 27;
			*(ref struct8 + 1) = 41;
			*(ref struct8 + 2) = 209;
			*(ref struct8 + 3) = 161;
			*(ref struct8 + 4) = 157;
			*(ref struct8 + 5) = 12;
			*(ref struct8 + 6) = 156;
			*(ref struct8 + 7) = 232;
			*(ref struct8 + 8) = 132;
			*(ref struct8 + 9) = 220;
			*(ref struct8 + 10) = 21;
			*(ref struct8 + 11) = 229;
			*(ref struct8 + 12) = 157;
			*(ref struct8 + 13) = 8;
			*(ref struct8 + 14) = 253;
			*(ref struct8 + 15) = 229;
			*(ref struct8 + 16) = 17;
			*(ref struct8 + 17) = 126;
			Struct41 struct9 = 27;
			*(ref struct9 + 1) = 41;
			*(ref struct9 + 2) = 209;
			*(ref struct9 + 3) = 161;
			*(ref struct9 + 4) = 157;
			*(ref struct9 + 5) = 12;
			*(ref struct9 + 6) = 156;
			*(ref struct9 + 7) = 232;
			*(ref struct9 + 8) = 132;
			*(ref struct9 + 9) = 220;
			*(ref struct9 + 10) = 21;
			*(ref struct9 + 11) = 233;
			*(ref struct9 + 12) = 157;
			*(ref struct9 + 13) = 8;
			*(ref struct9 + 14) = 253;
			*(ref struct9 + 15) = 229;
			*(ref struct9 + 16) = 17;
			*(ref struct9 + 17) = 126;
			Struct41 struct10 = 27;
			*(ref struct10 + 1) = 41;
			*(ref struct10 + 2) = 209;
			*(ref struct10 + 3) = 161;
			*(ref struct10 + 4) = 157;
			*(ref struct10 + 5) = 12;
			*(ref struct10 + 6) = 156;
			*(ref struct10 + 7) = 232;
			*(ref struct10 + 8) = 132;
			*(ref struct10 + 9) = 220;
			*(ref struct10 + 10) = 21;
			*(ref struct10 + 11) = 233;
			*(ref struct10 + 12) = 153;
			*(ref struct10 + 13) = 8;
			*(ref struct10 + 14) = 253;
			*(ref struct10 + 15) = 229;
			*(ref struct10 + 16) = 17;
			*(ref struct10 + 17) = 126;
			Struct41 struct11 = 93;
			*(ref struct11 + 1) = 44;
			*(ref struct11 + 2) = 211;
			*(ref struct11 + 3) = 238;
			*(ref struct11 + 4) = 23;
			*(ref struct11 + 5) = 2;
			*(ref struct11 + 6) = 12;
			*(ref struct11 + 7) = 254;
			*(ref struct11 + 8) = 206;
			*(ref struct11 + 9) = 208;
			*(ref struct11 + 10) = 152;
			*(ref struct11 + 11) = 251;
			*(ref struct11 + 12) = 145;
			*(ref struct11 + 13) = 4;
			*(ref struct11 + 14) = 249;
			*(ref struct11 + 15) = 236;
			*(ref struct11 + 16) = 128;
			*(ref struct11 + 17) = 186;
			Struct41 struct12 = 72;
			*(ref struct12 + 1) = 70;
			*(ref struct12 + 2) = 191;
			*(ref struct12 + 3) = 169;
			*(ref struct12 + 4) = 192;
			*(ref struct12 + 5) = 220;
			*(ref struct12 + 6) = 10;
			*(ref struct12 + 7) = 133;
			*(ref struct12 + 8) = 16;
			*(ref struct12 + 9) = 23;
			*(ref struct12 + 10) = 237;
			*(ref struct12 + 11) = 17;
			*(ref struct12 + 12) = 245;
			*(ref struct12 + 13) = 224;
			*(ref struct12 + 14) = 100;
			*(ref struct12 + 15) = 23;
			*(ref struct12 + 16) = 245;
			*(ref struct12 + 17) = 145;
			Struct41 struct13 = 203;
			*(ref struct13 + 1) = 241;
			*(ref struct13 + 2) = 181;
			*(ref struct13 + 3) = 55;
			*(ref struct13 + 4) = 18;
			*(ref struct13 + 5) = 0;
			*(ref struct13 + 6) = 3;
			*(ref struct13 + 7) = 7;
			*(ref struct13 + 8) = 213;
			*(ref struct13 + 9) = 55;
			*(ref struct13 + 10) = 140;
			*(ref struct13 + 11) = 215;
			*(ref struct13 + 12) = 85;
			*(ref struct13 + 13) = 39;
			*(ref struct13 + 14) = 93;
			*(ref struct13 + 15) = 172;
			*(ref struct13 + 16) = 52;
			*(ref struct13 + 17) = 177;
			Struct41 struct14 = 124;
			*(ref struct14 + 1) = 8;
			*(ref struct14 + 2) = 22;
			*(ref struct14 + 3) = 102;
			*(ref struct14 + 4) = 227;
			*(ref struct14 + 5) = 9;
			*(ref struct14 + 6) = 24;
			*(ref struct14 + 7) = 222;
			*(ref struct14 + 8) = 233;
			*(ref struct14 + 9) = 80;
			*(ref struct14 + 10) = 24;
			*(ref struct14 + 11) = 168;
			*(ref struct14 + 12) = 190;
			*(ref struct14 + 13) = 82;
			*(ref struct14 + 14) = 218;
			*(ref struct14 + 15) = 241;
			*(ref struct14 + 16) = 126;
			*(ref struct14 + 17) = 80;
			Struct41 struct15 = 87;
			*(ref struct15 + 1) = 238;
			*(ref struct15 + 2) = 39;
			*(ref struct15 + 3) = 8;
			*(ref struct15 + 4) = 64;
			*(ref struct15 + 5) = 200;
			*(ref struct15 + 6) = byte.MaxValue;
			*(ref struct15 + 7) = 61;
			*(ref struct15 + 8) = 141;
			*(ref struct15 + 9) = 173;
			*(ref struct15 + 10) = 117;
			*(ref struct15 + 11) = 2;
			*(ref struct15 + 12) = 33;
			*(ref struct15 + 13) = 249;
			*(ref struct15 + 14) = 205;
			*(ref struct15 + 15) = 155;
			*(ref struct15 + 16) = 138;
			*(ref struct15 + 17) = 209;
			Struct41 struct16 = 64;
			*(ref struct16 + 1) = 246;
			*(ref struct16 + 2) = 147;
			*(ref struct16 + 3) = 70;
			*(ref struct16 + 4) = 118;
			*(ref struct16 + 5) = 192;
			*(ref struct16 + 6) = 60;
			*(ref struct16 + 7) = 223;
			*(ref struct16 + 8) = 178;
			*(ref struct16 + 9) = 49;
			*(ref struct16 + 10) = 3;
			*(ref struct16 + 11) = 133;
			*(ref struct16 + 12) = 64;
			*(ref struct16 + 13) = 133;
			*(ref struct16 + 14) = 213;
			*(ref struct16 + 15) = 13;
			*(ref struct16 + 16) = 101;
			*(ref struct16 + 17) = 226;
			Struct41 struct17 = 187;
			*(ref struct17 + 1) = 17;
			*(ref struct17 + 2) = 180;
			*(ref struct17 + 3) = 20;
			*(ref struct17 + 4) = 49;
			*(ref struct17 + 5) = 209;
			*(ref struct17 + 6) = 145;
			*(ref struct17 + 7) = 190;
			*(ref struct17 + 8) = 90;
			*(ref struct17 + 9) = 232;
			*(ref struct17 + 10) = 25;
			*(ref struct17 + 11) = 133;
			*(ref struct17 + 12) = 21;
			*(ref struct17 + 13) = 113;
			*(ref struct17 + 14) = 45;
			*(ref struct17 + 15) = 137;
			*(ref struct17 + 16) = 220;
			*(ref struct17 + 17) = 19;
			Struct41 struct18 = 220;
			*(ref struct18 + 1) = 41;
			*(ref struct18 + 2) = 114;
			*(ref struct18 + 3) = 172;
			*(ref struct18 + 4) = 224;
			*(ref struct18 + 5) = 244;
			*(ref struct18 + 6) = 33;
			*(ref struct18 + 7) = 210;
			*(ref struct18 + 8) = 22;
			*(ref struct18 + 9) = 185;
			*(ref struct18 + 10) = 161;
			*(ref struct18 + 11) = 147;
			*(ref struct18 + 12) = 14;
			*(ref struct18 + 13) = 20;
			*(ref struct18 + 14) = 57;
			*(ref struct18 + 15) = 157;
			*(ref struct18 + 16) = 41;
			*(ref struct18 + 17) = 78;
			Struct28 struct19 = 192;
			*(ref struct19 + 1) = 224;
			*(ref struct19 + 2) = 126;
			*(ref struct19 + 3) = 9;
			*(ref struct19 + 4) = 127;
			*(ref struct19 + 5) = 234;
			*(ref struct19 + 6) = 18;
			*(ref struct19 + 7) = 70;
			*(ref struct19 + 8) = 17;
			*(ref struct19 + 9) = 239;
			*(ref struct19 + 10) = 84;
			*(ref struct19 + 11) = 1;
			*(ref struct19 + 12) = byte.MaxValue;
			*(ref struct19 + 13) = 208;
			*(ref struct19 + 14) = 224;
			*(ref struct19 + 15) = 34;
			Struct28 struct20 = 2;
			*(ref struct20 + 1) = 208;
			*(ref struct20 + 2) = 128;
			*(ref struct20 + 3) = 228;
			*(ref struct20 + 4) = 245;
			*(ref struct20 + 5) = 58;
			*(ref struct20 + 6) = 245;
			*(ref struct20 + 7) = 59;
			*(ref struct20 + 8) = 5;
			*(ref struct20 + 9) = 59;
			*(ref struct20 + 10) = 229;
			*(ref struct20 + 11) = 59;
			*(ref struct20 + 12) = 174;
			*(ref struct20 + 13) = 58;
			*(ref struct20 + 14) = 112;
			*(ref struct20 + 15) = 2;
			Struct28 struct21 = 2;
			*(ref struct21 + 1) = 213;
			*(ref struct21 + 2) = 0;
			*(ref struct21 + 3) = 228;
			*(ref struct21 + 4) = 245;
			*(ref struct21 + 5) = 58;
			*(ref struct21 + 6) = 245;
			*(ref struct21 + 7) = 59;
			*(ref struct21 + 8) = 5;
			*(ref struct21 + 9) = 59;
			*(ref struct21 + 10) = 229;
			*(ref struct21 + 11) = 59;
			*(ref struct21 + 12) = 174;
			*(ref struct21 + 13) = 58;
			*(ref struct21 + 14) = 112;
			*(ref struct21 + 15) = 2;
			Struct28 struct22 = 2;
			*(ref struct22 + 1) = 208;
			*(ref struct22 + 2) = 128;
			*(ref struct22 + 3) = 228;
			*(ref struct22 + 4) = 245;
			*(ref struct22 + 5) = 58;
			*(ref struct22 + 6) = 245;
			*(ref struct22 + 7) = 59;
			*(ref struct22 + 8) = 5;
			*(ref struct22 + 9) = 59;
			*(ref struct22 + 10) = 229;
			*(ref struct22 + 11) = 59;
			*(ref struct22 + 12) = 174;
			*(ref struct22 + 13) = 58;
			*(ref struct22 + 14) = 112;
			*(ref struct22 + 15) = 2;
			Struct28 struct23 = 2;
			*(ref struct23 + 1) = 213;
			*(ref struct23 + 2) = 128;
			*(ref struct23 + 3) = 228;
			*(ref struct23 + 4) = 245;
			*(ref struct23 + 5) = 58;
			*(ref struct23 + 6) = 245;
			*(ref struct23 + 7) = 59;
			*(ref struct23 + 8) = 5;
			*(ref struct23 + 9) = 59;
			*(ref struct23 + 10) = 229;
			*(ref struct23 + 11) = 59;
			*(ref struct23 + 12) = 174;
			*(ref struct23 + 13) = 58;
			*(ref struct23 + 14) = 112;
			*(ref struct23 + 15) = 2;
			Struct28 struct24 = 239;
			*(ref struct24 + 1) = 192;
			*(ref struct24 + 2) = 224;
			*(ref struct24 + 3) = 126;
			*(ref struct24 + 4) = 9;
			*(ref struct24 + 5) = 127;
			*(ref struct24 + 6) = 234;
			*(ref struct24 + 7) = 18;
			*(ref struct24 + 8) = 64;
			*(ref struct24 + 9) = 2;
			*(ref struct24 + 10) = 239;
			*(ref struct24 + 11) = 84;
			*(ref struct24 + 12) = 1;
			*(ref struct24 + 13) = byte.MaxValue;
			*(ref struct24 + 14) = 208;
			*(ref struct24 + 15) = 224;
			Struct28 struct25 = 123;
			*(ref struct25 + 1) = 12;
			*(ref struct25 + 2) = 228;
			*(ref struct25 + 3) = 253;
			*(ref struct25 + 4) = byte.MaxValue;
			*(ref struct25 + 5) = 254;
			*(ref struct25 + 6) = 18;
			*(ref struct25 + 7) = 62;
			*(ref struct25 + 8) = 47;
			*(ref struct25 + 9) = 143;
			*(ref struct25 + 10) = 53;
			*(ref struct25 + 11) = 142;
			*(ref struct25 + 12) = 52;
			*(ref struct25 + 13) = 141;
			*(ref struct25 + 14) = 51;
			*(ref struct25 + 15) = 140;
			Struct28 struct26 = 2;
			*(ref struct26 + 1) = 87;
			*(ref struct26 + 2) = 0;
			*(ref struct26 + 3) = 126;
			*(ref struct26 + 4) = 33;
			*(ref struct26 + 5) = 127;
			*(ref struct26 + 6) = 67;
			*(ref struct26 + 7) = 18;
			*(ref struct26 + 8) = 64;
			*(ref struct26 + 9) = 2;
			*(ref struct26 + 10) = 239;
			*(ref struct26 + 11) = 100;
			*(ref struct26 + 12) = 32;
			*(ref struct26 + 13) = 96;
			*(ref struct26 + 14) = 1;
			*(ref struct26 + 15) = 34;
			Struct28 struct27 = 128;
			*(ref struct27 + 1) = 227;
			*(ref struct27 + 2) = 129;
			*(ref struct27 + 3) = 196;
			*(ref struct27 + 4) = 7;
			*(ref struct27 + 5) = 12;
			*(ref struct27 + 6) = 78;
			*(ref struct27 + 7) = 116;
			*(ref struct27 + 8) = 78;
			*(ref struct27 + 9) = 138;
			*(ref struct27 + 10) = 121;
			*(ref struct27 + 11) = 171;
			*(ref struct27 + 12) = 98;
			*(ref struct27 + 13) = 5;
			*(ref struct27 + 14) = 31;
			*(ref struct27 + 15) = 116;
			Struct28 struct28 = 116;
			*(ref struct28 + 1) = 55;
			*(ref struct28 + 2) = 240;
			*(ref struct28 + 3) = 116;
			*(ref struct28 + 4) = 243;
			*(ref struct28 + 5) = 240;
			*(ref struct28 + 6) = 210;
			*(ref struct28 + 7) = 81;
			*(ref struct28 + 8) = 228;
			*(ref struct28 + 9) = 245;
			*(ref struct28 + 10) = 30;
			*(ref struct28 + 11) = 120;
			*(ref struct28 + 12) = 127;
			*(ref struct28 + 13) = 246;
			*(ref struct28 + 14) = 120;
			*(ref struct28 + 15) = 137;
			Struct28 struct29 = 116;
			*(ref struct29 + 1) = 164;
			*(ref struct29 + 2) = 240;
			*(ref struct29 + 3) = 116;
			*(ref struct29 + 4) = 64;
			*(ref struct29 + 5) = 240;
			*(ref struct29 + 6) = 210;
			*(ref struct29 + 7) = 81;
			*(ref struct29 + 8) = 228;
			*(ref struct29 + 9) = 245;
			*(ref struct29 + 10) = 30;
			*(ref struct29 + 11) = 120;
			*(ref struct29 + 12) = 127;
			*(ref struct29 + 13) = 246;
			*(ref struct29 + 14) = 120;
			*(ref struct29 + 15) = 137;
			Struct28 struct30 = 209;
			*(ref struct30 + 1) = 62;
			*(ref struct30 + 2) = 182;
			*(ref struct30 + 3) = 196;
			*(ref struct30 + 4) = 140;
			*(ref struct30 + 5) = 172;
			*(ref struct30 + 6) = 26;
			*(ref struct30 + 7) = 204;
			*(ref struct30 + 8) = 196;
			*(ref struct30 + 9) = 176;
			*(ref struct30 + 10) = 82;
			*(ref struct30 + 11) = 243;
			*(ref struct30 + 12) = 207;
			*(ref struct30 + 13) = 10;
			*(ref struct30 + 14) = 44;
			*(ref struct30 + 15) = 249;
			Struct28 struct31 = 210;
			*(ref struct31 + 1) = 225;
			*(ref struct31 + 2) = 241;
			*(ref struct31 + 3) = 225;
			*(ref struct31 + 4) = 2;
			*(ref struct31 + 5) = 103;
			*(ref struct31 + 6) = 0;
			*(ref struct31 + 7) = 29;
			*(ref struct31 + 8) = 82;
			*(ref struct31 + 9) = 230;
			*(ref struct31 + 10) = 36;
			*(ref struct31 + 11) = 220;
			*(ref struct31 + 12) = 161;
			*(ref struct31 + 13) = 161;
			*(ref struct31 + 14) = 143;
			*(ref struct31 + 15) = 64;
			Struct28 struct32 = 13;
			*(ref struct32 + 1) = 225;
			*(ref struct32 + 2) = 183;
			*(ref struct32 + 3) = 224;
			*(ref struct32 + 4) = 2;
			*(ref struct32 + 5) = 253;
			*(ref struct32 + 6) = 241;
			*(ref struct32 + 7) = 42;
			*(ref struct32 + 8) = 5;
			*(ref struct32 + 9) = 42;
			*(ref struct32 + 10) = 234;
			*(ref struct32 + 11) = 247;
			*(ref struct32 + 12) = 235;
			*(ref struct32 + 13) = 250;
			*(ref struct32 + 14) = 34;
			*(ref struct32 + 15) = 96;
			Struct28 struct33 = 15;
			*(ref struct33 + 1) = 62;
			*(ref struct33 + 2) = byte.MaxValue;
			*(ref struct33 + 3) = 233;
			*(ref struct33 + 4) = 10;
			*(ref struct33 + 5) = 218;
			*(ref struct33 + 6) = 15;
			*(ref struct33 + 7) = 120;
			*(ref struct33 + 8) = 10;
			*(ref struct33 + 9) = 56;
			*(ref struct33 + 10) = 230;
			*(ref struct33 + 11) = byte.MaxValue;
			*(ref struct33 + 12) = 218;
			*(ref struct33 + 13) = 218;
			*(ref struct33 + 14) = 249;
			*(ref struct33 + 15) = 98;
			Struct28 struct34 = 76;
			*(ref struct34 + 1) = 48;
			*(ref struct34 + 2) = 83;
			*(ref struct34 + 3) = 32;
			*(ref struct34 + 4) = 191;
			*(ref struct34 + 5) = 215;
			*(ref struct34 + 6) = 103;
			*(ref struct34 + 7) = 44;
			*(ref struct34 + 8) = 102;
			*(ref struct34 + 9) = 1;
			*(ref struct34 + 10) = 106;
			*(ref struct34 + 11) = 228;
			*(ref struct34 + 12) = 110;
			*(ref struct34 + 13) = 201;
			*(ref struct34 + 14) = 129;
			*(ref struct34 + 15) = 248;
			Struct28 struct35 = 76;
			*(ref struct35 + 1) = 48;
			*(ref struct35 + 2) = 83;
			*(ref struct35 + 3) = 33;
			*(ref struct35 + 4) = 4;
			*(ref struct35 + 5) = 194;
			*(ref struct35 + 6) = 103;
			*(ref struct35 + 7) = 44;
			*(ref struct35 + 8) = 102;
			*(ref struct35 + 9) = 1;
			*(ref struct35 + 10) = 106;
			*(ref struct35 + 11) = 228;
			*(ref struct35 + 12) = 110;
			*(ref struct35 + 13) = 201;
			*(ref struct35 + 14) = 129;
			*(ref struct35 + 15) = 248;
			Struct77 struct36 = 217;
			*(ref struct36 + 1) = 108;
			*(ref struct36 + 2) = 10;
			*(ref struct36 + 3) = 39;
			*(ref struct36 + 4) = 95;
			*(ref struct36 + 5) = 82;
			Struct77 struct37 = 214;
			*(ref struct37 + 1) = 4;
			*(ref struct37 + 2) = 104;
			*(ref struct37 + 3) = 56;
			*(ref struct37 + 4) = 208;
			*(ref struct37 + 5) = 99;
			Struct77 struct38 = 241;
			*(ref struct38 + 1) = 76;
			*(ref struct38 + 2) = 182;
			*(ref struct38 + 3) = 121;
			*(ref struct38 + 4) = 75;
			*(ref struct38 + 5) = 171;
			Struct77 struct39 = 156;
			*(ref struct39 + 1) = 77;
			*(ref struct39 + 2) = 201;
			*(ref struct39 + 3) = 90;
			*(ref struct39 + 4) = 35;
			*(ref struct39 + 5) = 208;
			Struct28 struct40 = 0;
			initblk(ref struct40 + 1, 0, 15);
			Struct71 struct41 = 0;
			initblk(ref struct41 + 1, 0, 15);
			Struct55 struct42 = 213;
			*(ref struct42 + 1) = 110;
			*(ref struct42 + 2) = 185;
			*(ref struct42 + 3) = 18;
			*(ref struct42 + 4) = 21;
			*(ref struct42 + 5) = 210;
			*(ref struct42 + 6) = 40;
			*(ref struct42 + 7) = 34;
			*(ref struct42 + 8) = 28;
			*(ref struct42 + 9) = 145;
			*(ref struct42 + 10) = 238;
			*(ref struct42 + 11) = 120;
			*(ref struct42 + 12) = 247;
			*(ref struct42 + 13) = 9;
			*(ref struct42 + 14) = 249;
			*(ref struct42 + 15) = 0;
			*(ref struct42 + 16) = 80;
			*(ref struct42 + 17) = 248;
			*(ref struct42 + 18) = 163;
			*(ref struct42 + 19) = 254;
			*(ref struct42 + 20) = 148;
			*(ref struct42 + 21) = 106;
			*(ref struct42 + 22) = 172;
			*(ref struct42 + 23) = 54;
			*(ref struct42 + 24) = 180;
			*(ref struct42 + 25) = 155;
			*(ref struct42 + 26) = 36;
			*(ref struct42 + 27) = 62;
			*(ref struct42 + 28) = 63;
			*(ref struct42 + 29) = 174;
			*(ref struct42 + 30) = 161;
			*(ref struct42 + 31) = 65;
			byte* ptr = *(ref <Module>.struct121_0 + int_16 * 2392 + 2388);
			byte* pByte_ = *(ref <Module>.struct121_0 + 7172);
			int num = 8192;
			while (num < 12288 && (ptr[num] != 5 || ptr[num + 1] != 128 || ptr[num + 2] != 0 || ptr[num + 3] != 50 || ptr[num + 5] != 0 || ptr[num + 7] != 0))
			{
				num++;
			}
			if (num != 12288)
			{
				<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 568, (void*)(ptr + num), 96U);
				<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2316, (void*)(ptr + (num + 8)), 28U);
				*(*(ref <Module>.struct123_0 + int_16 * 4) + 560) = num;
				this.textBox6.AppendText("Inquiry string found" + "\r\n");
			}
			int i = 8192;
			while (i < 12288 && (ptr[i] != 192 || ptr[i + 1] != 133 || ptr[i + 2] != 0 || ptr[i + 3] != 0 || ptr[i + 4] != 0 || ptr[i + 5] != 0))
			{
				i++;
			}
			if (i != 12288)
			{
				<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 780, (void*)(ptr + i), 180U);
				*(*(ref <Module>.struct123_0 + int_16 * 4) + 564) = i;
				this.textBox6.AppendText("Identify string found" + "\r\n");
			}
			if (num == 8372)
			{
				*(*(ref <Module>.struct123_0 + int_16 * 4)) = 1;
				if (ptr[2152] == 230 && ptr[2153] == 160 && ptr[2158] == 189)
				{
					*(*(ref <Module>.struct123_0 + int_16 * 4) + 2) = 1;
					<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2284, (void*)(&<Module>.struct9_3), 28U);
				}
				else
				{
					*(*(ref <Module>.struct123_0 + int_16 * 4) + 2) = 2;
					<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2284, (void*)(&<Module>.struct9_4), 28U);
				}
				if (ptr[65504] != 0 && ptr[65504] != 255)
				{
					<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(ptr + 65504), 32U);
				}
				else if (<Module>.memcmp((void*)(&struct28), (void*)(ptr + 9088), 16U) == null)
				{
					<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(&<Module>.struct74_0), 10U);
				}
				else if (<Module>.memcmp((void*)(&struct29), (void*)(ptr + 9088), 16U) == null)
				{
					<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(&<Module>.struct74_1), 10U);
					if (ptr[20480] == 2)
					{
						<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(&<Module>.struct74_2), 10U);
					}
					if (ptr[23883] == 22)
					{
						<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(&<Module>.struct74_3), 10U);
					}
				}
				else
				{
					<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(&<Module>.struct23_40), 5U);
				}
				uint num2;
				for (num2 = 16406U; num2 < 20480U; num2 += 42U)
				{
					if (<Module>.memcmp((void*)(ptr + num2), (void*)(&struct4), 20U) == null)
					{
						*(*(ref <Module>.struct123_0 + int_16 * 4) + 296) = (int)(num2 - 42U + 4U);
						<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 280, (void*)(ptr + (num2 - 42U + 4U)), 16U);
						break;
					}
				}
				if (num2 > 18912U)
				{
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					MessageBox.Show("Drive Key not found", "Parse Firmware", MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
					return 0;
				}
				if (int_16 == 0 && <Module>.memcmp(*(ref <Module>.struct123_0 + int_16 * 4) + 280, (void*)(&struct40), 16U) == null)
				{
					this.method_53();
					this.method_54();
				}
			}
			else if (num == 8370)
			{
				*(*(ref <Module>.struct123_0 + int_16 * 4)) = 2;
				num = 245760;
				while (num < 253952 && (ptr[num] != 5 || ptr[num + 1] != 128 || ptr[num + 2] != 0 || ptr[num + 3] != 50 || ptr[num + 5] != 0 || ptr[num + 7] != 0))
				{
					num++;
				}
				if (num == 253952)
				{
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					MessageBox.Show("Inquiry string not found", "Parse Firmware", MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
					return 0;
				}
				*(*(ref <Module>.struct123_0 + int_16 * 4) + 560) = num;
				i = 245760;
				while (i < 253952 && (ptr[i] != 192 || ptr[i + 1] != 133 || ptr[i + 2] != 0 || ptr[i + 3] != 0 || ptr[i + 4] != 0 || ptr[i + 5] != 0))
				{
					i++;
				}
				if (i == 253952)
				{
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					MessageBox.Show("Identify string not found", "Parse Firmware", MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
					return 0;
				}
				*(*(ref <Module>.struct123_0 + int_16 * 4) + 564) = i;
				<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 568, (void*)(ptr + num), 96U);
				<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2316, (void*)(ptr + (num + 8)), 28U);
				<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 780, (void*)(ptr + i), 180U);
				uint num3 = (uint)this.method_30(int_16);
				if (num3 == 0U)
				{
					return 0;
				}
				*(*(ref <Module>.struct123_0 + int_16 * 4) + 2) = (short)num3;
				*(*(ref <Module>.struct123_0 + int_16 * 4) + 296) = 20224;
				<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 280, (void*)(ptr + 20224), 16U);
				if (num3 == 1U)
				{
					<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2284, (void*)(&<Module>.struct9_5), 28U);
				}
				else if (num3 == 2U)
				{
					<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2284, (void*)(&<Module>.struct9_6), 28U);
				}
				else if (num3 == 3U)
				{
					<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2284, (void*)(&<Module>.struct9_7), 28U);
				}
				else if (num3 == 4U)
				{
					<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2284, (void*)(&<Module>.struct9_8), 28U);
				}
				else if (num3 == 5U)
				{
					<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2284, (void*)(&<Module>.struct9_9), 28U);
				}
				else if (num3 == 6U)
				{
					<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2284, (void*)(&<Module>.struct9_2), 28U);
				}
				else if (num3 == 7U)
				{
					<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2284, (void*)(&<Module>.struct9_10), 28U);
				}
				else if (num3 == 8U)
				{
					<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2284, (void*)(&<Module>.struct9_11), 28U);
					*(*(ref <Module>.struct123_0 + int_16 * 4) + 296) = 19200;
					<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 280, (void*)(ptr + 19200), 16U);
				}
				else if (num3 == 9U)
				{
					<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2284, (void*)(&<Module>.struct9_11), 28U);
					*(*(ref <Module>.struct123_0 + int_16 * 4) + 296) = 19504;
					<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 280, (void*)(ptr + 19504), 16U);
				}
				else if (num3 == 10U)
				{
					<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2284, (void*)(&<Module>.struct9_11), 28U);
					*(*(ref <Module>.struct123_0 + int_16 * 4) + 296) = 19744;
					<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 280, (void*)(ptr + 19744), 16U);
				}
				else if (num3 == 11U)
				{
					<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2284, (void*)(&<Module>.struct9_11), 28U);
					*(*(ref <Module>.struct123_0 + int_16 * 4) + 296) = 19984;
					<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 280, (void*)(ptr + 19984), 16U);
				}
				else if (num3 == 12U)
				{
					<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2284, (void*)(&<Module>.struct9_12), 28U);
					*(*(ref <Module>.struct123_0 + int_16 * 4) + 296) = 19200;
					<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 280, (void*)(ptr + 19200), 16U);
				}
				else if (num3 == 13U)
				{
					<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2284, (void*)(&<Module>.struct9_12), 28U);
					*(*(ref <Module>.struct123_0 + int_16 * 4) + 296) = 19504;
					<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 280, (void*)(ptr + 19504), 16U);
				}
				else if (num3 == 14U)
				{
					<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2284, (void*)(&<Module>.struct9_12), 28U);
					*(*(ref <Module>.struct123_0 + int_16 * 4) + 296) = 19744;
					<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 280, (void*)(ptr + 19744), 16U);
				}
				else if (num3 == 15U)
				{
					<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2284, (void*)(&<Module>.struct9_12), 28U);
					*(*(ref <Module>.struct123_0 + int_16 * 4) + 296) = 19984;
					<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 280, (void*)(ptr + 19984), 16U);
				}
				<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2028, (void*)(ptr + 20352), 20U);
				*(*(ref <Module>.struct123_0 + int_16 * 4) + 2024) = 20352;
				uint num4 = (uint)((int)ptr[255999] << 24 | (int)ptr[255998] << 16 | (int)ptr[255997] << 8 | (int)ptr[255996]);
				*(*(ref <Module>.struct123_0 + int_16 * 4) + 2020) = (int)num4;
				if (ptr[14320] != 255)
				{
					<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(ptr + 14320), 32U);
				}
				else if (ptr[13428] == 255)
				{
					<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(&<Module>.struct23_40), 5U);
				}
				else if (ptr[13428] == 0)
				{
					<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(&<Module>.struct15_2), 12U);
				}
				else if (ptr[13381] == 252)
				{
					<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(&<Module>.struct15_3), 12U);
				}
				else if (ptr[14000] != 255)
				{
					<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(&<Module>.struct15_4), 12U);
				}
				else if (ptr[14336] != 255)
				{
					<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(&<Module>.struct15_5), 12U);
				}
				else if (ptr[13428] != 0)
				{
					<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(&<Module>.struct15_5), 12U);
				}
				else
				{
					<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(&<Module>.struct23_40), 5U);
				}
			}
			else if (num == 11776)
			{
				*(*(ref <Module>.struct123_0 + int_16 * 4)) = 4;
				if (<Module>.memcmp((void*)(ptr + 11776), (void*)(&<Module>.struct29_35), 36U) == null)
				{
					*(*(ref <Module>.struct123_0 + int_16 * 4) + 2) = 1;
					<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2284, (void*)(&<Module>.struct9_13), 28U);
				}
				else if (<Module>.memcmp((void*)(ptr + 11776), (void*)(&<Module>.struct29_30), 36U) == null)
				{
					*(*(ref <Module>.struct123_0 + int_16 * 4) + 2) = 2;
					<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2284, (void*)(&<Module>.struct9_14), 28U);
					if (<Module>.memcmp((void*)(ptr + 12032), (void*)(&<Module>.struct29_17), 36U) == null)
					{
						*(*(ref <Module>.struct123_0 + int_16 * 4) + 2) = 3;
					}
				}
				else if (<Module>.memcmp((void*)(ptr + 11776), (void*)(&<Module>.struct29_5), 36U) == null)
				{
					*(*(ref <Module>.struct123_0 + int_16 * 4) + 2) = 4;
					<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2284, (void*)(&<Module>.struct9_15), 28U);
				}
				else if (<Module>.memcmp((void*)(ptr + 11776), (void*)(&<Module>.struct29_24), 36U) == null)
				{
					*(*(ref <Module>.struct123_0 + int_16 * 4) + 2) = 5;
					<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2284, (void*)(&<Module>.struct9_16), 28U);
				}
				else if (<Module>.memcmp((void*)(ptr + 11776), (void*)(&<Module>.struct29_31), 36U) == null)
				{
					*(*(ref <Module>.struct123_0 + int_16 * 4)) = 5;
					*(*(ref <Module>.struct123_0 + int_16 * 4) + 2) = 1;
					if (this.method_72() == 0)
					{
						<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
						MessageBox.Show("Key sector area is incomplete or invalid !", "Parse Firmware", MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
						<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
						return 0;
					}
					<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2284, (void*)(&<Module>.struct9_17), 28U);
				}
				else if (<Module>.memcmp((void*)(ptr + 11776), (void*)(&<Module>.struct29_33), 36U) == null)
				{
					*(*(ref <Module>.struct123_0 + int_16 * 4)) = 5;
					*(*(ref <Module>.struct123_0 + int_16 * 4) + 2) = 2;
					if (this.method_74() == 0)
					{
						<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
						MessageBox.Show("Key sector area is incomplete or invalid !", "Parse Firmware", MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
						<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
						return 0;
					}
					<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2284, (void*)(&<Module>.struct9_18), 28U);
				}
				else if (<Module>.memcmp((void*)(ptr + 11776), (void*)(&<Module>.struct29_7), 36U) == null)
				{
					*(*(ref <Module>.struct123_0 + int_16 * 4)) = 5;
					*(*(ref <Module>.struct123_0 + int_16 * 4) + 2) = 3;
					if (this.method_76() == 0)
					{
						<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
						MessageBox.Show("Key sector area is incomplete or invalid !", "Parse Firmware", MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
						<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
						return 0;
					}
					<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2284, (void*)(&<Module>.struct9_19), 28U);
				}
				else if (<Module>.memcmp((void*)(ptr + 11776), (void*)(&<Module>.struct29_0), 36U) == null)
				{
					*(*(ref <Module>.struct123_0 + int_16 * 4)) = 5;
					*(*(ref <Module>.struct123_0 + int_16 * 4) + 2) = 4;
					if (this.method_72() == 0)
					{
						<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
						MessageBox.Show("Key sector area is incomplete or invalid !", "Parse Firmware", MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
						<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
						return 0;
					}
					<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2284, (void*)(&<Module>.struct9_20), 28U);
				}
				else if (<Module>.memcmp((void*)(ptr + 11776), (void*)(&<Module>.struct29_19), 36U) == null)
				{
					*(*(ref <Module>.struct123_0 + int_16 * 4)) = 5;
					*(*(ref <Module>.struct123_0 + int_16 * 4) + 2) = 5;
					if (this.method_78() == 0)
					{
						<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
						MessageBox.Show("Key sector area is incomplete or invalid !", "Parse Firmware", MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
						<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
						return 0;
					}
					<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2284, (void*)(&<Module>.struct9_21), 28U);
				}
				else if (<Module>.memcmp((void*)(ptr + 11776), (void*)(&<Module>.struct29_8), 36U) == null)
				{
					*(*(ref <Module>.struct123_0 + int_16 * 4) + 2) = 1;
					*(*(ref <Module>.struct123_0 + int_16 * 4) + 2382) = 1;
					*(*(ref <Module>.struct123_0 + int_16 * 4) + 2384) = 1;
					<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2284, (void*)(&<Module>.struct9_3), 28U);
				}
				else if (<Module>.memcmp((void*)(ptr + 11776), (void*)(&<Module>.struct29_11), 36U) == null)
				{
					*(*(ref <Module>.struct123_0 + int_16 * 4) + 2) = 1;
					*(*(ref <Module>.struct123_0 + int_16 * 4) + 2382) = 1;
					*(*(ref <Module>.struct123_0 + int_16 * 4) + 2384) = 2;
					<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2284, (void*)(&<Module>.struct9_4), 28U);
				}
				else if (<Module>.memcmp((void*)(ptr + 11776), (void*)(&<Module>.struct29_36), 36U) == null)
				{
					*(*(ref <Module>.struct123_0 + int_16 * 4) + 2) = 1;
					*(*(ref <Module>.struct123_0 + int_16 * 4) + 2382) = 2;
					*(*(ref <Module>.struct123_0 + int_16 * 4) + 2384) = 1;
					<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2284, (void*)(&<Module>.struct9_5), 28U);
				}
				else if (<Module>.memcmp((void*)(ptr + 11776), (void*)(&<Module>.struct29_15), 36U) == null)
				{
					*(*(ref <Module>.struct123_0 + int_16 * 4) + 2) = 1;
					*(*(ref <Module>.struct123_0 + int_16 * 4) + 2382) = 2;
					*(*(ref <Module>.struct123_0 + int_16 * 4) + 2384) = 2;
					<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2284, (void*)(&<Module>.struct9_6), 28U);
				}
				else if (<Module>.memcmp((void*)(ptr + 11776), (void*)(&<Module>.struct29_2), 36U) == null)
				{
					*(*(ref <Module>.struct123_0 + int_16 * 4) + 2) = 1;
					*(*(ref <Module>.struct123_0 + int_16 * 4) + 2382) = 2;
					*(*(ref <Module>.struct123_0 + int_16 * 4) + 2384) = 3;
					<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2284, (void*)(&<Module>.struct9_7), 28U);
				}
				else if (<Module>.memcmp((void*)(ptr + 11776), (void*)(&<Module>.struct29_1), 36U) == null)
				{
					*(*(ref <Module>.struct123_0 + int_16 * 4) + 2) = 1;
					*(*(ref <Module>.struct123_0 + int_16 * 4) + 2382) = 2;
					*(*(ref <Module>.struct123_0 + int_16 * 4) + 2384) = 4;
					<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2284, (void*)(&<Module>.struct9_8), 28U);
				}
				else if (<Module>.memcmp((void*)(ptr + 11776), (void*)(&<Module>.struct29_29), 36U) == null)
				{
					*(*(ref <Module>.struct123_0 + int_16 * 4) + 2) = 1;
					*(*(ref <Module>.struct123_0 + int_16 * 4) + 2382) = 2;
					*(*(ref <Module>.struct123_0 + int_16 * 4) + 2384) = 5;
					<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2284, (void*)(&<Module>.struct9_9), 28U);
				}
				else if (<Module>.memcmp((void*)(ptr + 11776), (void*)(&<Module>.struct29_27), 36U) == null)
				{
					*(*(ref <Module>.struct123_0 + int_16 * 4) + 2) = 1;
					*(*(ref <Module>.struct123_0 + int_16 * 4) + 2382) = 2;
					*(*(ref <Module>.struct123_0 + int_16 * 4) + 2384) = 6;
					<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2284, (void*)(&<Module>.struct9_2), 28U);
				}
				else if (<Module>.memcmp((void*)(ptr + 11776), (void*)(&<Module>.struct29_10), 36U) == null)
				{
					*(*(ref <Module>.struct123_0 + int_16 * 4) + 2) = 1;
					*(*(ref <Module>.struct123_0 + int_16 * 4) + 2382) = 2;
					*(*(ref <Module>.struct123_0 + int_16 * 4) + 2384) = 7;
					<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2284, (void*)(&<Module>.struct9_10), 28U);
				}
				else if (<Module>.memcmp((void*)(ptr + 11776), (void*)(&<Module>.struct29_3), 36U) == null)
				{
					*(*(ref <Module>.struct123_0 + int_16 * 4) + 2) = 1;
					*(*(ref <Module>.struct123_0 + int_16 * 4) + 2382) = 2;
					*(*(ref <Module>.struct123_0 + int_16 * 4) + 2384) = 8;
					<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2284, (void*)(&<Module>.struct9_11), 28U);
				}
				else if (<Module>.memcmp((void*)(ptr + 11776), (void*)(&<Module>.struct29_21), 36U) == null)
				{
					*(*(ref <Module>.struct123_0 + int_16 * 4) + 2) = 1;
					*(*(ref <Module>.struct123_0 + int_16 * 4) + 2382) = 2;
					*(*(ref <Module>.struct123_0 + int_16 * 4) + 2384) = 12;
					<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2284, (void*)(&<Module>.struct9_12), 28U);
				}
				else if (<Module>.memcmp((void*)(ptr + 11776), (void*)(&<Module>.struct29_34), 36U) == null)
				{
					*(*(ref <Module>.struct123_0 + int_16 * 4) + 2) = 1;
					*(*(ref <Module>.struct123_0 + int_16 * 4) + 2382) = 3;
					*(*(ref <Module>.struct123_0 + int_16 * 4) + 2384) = 1;
					<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2284, (void*)(&<Module>.struct9_22), 28U);
				}
				else
				{
					if (<Module>.memcmp((void*)(ptr + 11776), (void*)(&<Module>.struct29_25), 36U) != null)
					{
						return 0;
					}
					*(*(ref <Module>.struct123_0 + int_16 * 4) + 2) = 1;
					*(*(ref <Module>.struct123_0 + int_16 * 4) + 2382) = 3;
					*(*(ref <Module>.struct123_0 + int_16 * 4) + 2384) = 2;
					<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2284, (void*)(&<Module>.struct9_23), 28U);
				}
				<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(ptr + 24512), 32U);
				*(*(ref <Module>.struct123_0 + int_16 * 4) + 296) = 41008;
				<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 280, (void*)(ptr + 41008), 16U);
				Struct46 struct43;
				<Module>.memcpy((void*)(&struct43), *(ref <Module>.struct123_0 + int_16 * 4) + 780, 180U);
				for (int j = 46; j < 93; j += 2)
				{
					*(*(ref <Module>.struct123_0 + int_16 * 4) + 780 + j) = *(ref struct43 + (j + 1));
					*(*(ref <Module>.struct123_0 + int_16 * 4) + 780 + (j + 1)) = *(ref struct43 + j);
				}
				*(*(ref <Module>.struct123_0 + int_16 * 4) + 800) = 54;
				*(*(ref <Module>.struct123_0 + int_16 * 4) + 801) = 68;
				for (int j = 20; j < 40; j += 2)
				{
					*(*(ref <Module>.struct123_0 + int_16 * 4) + 780 + j) = *(ref struct43 + (j + 1));
					*(*(ref <Module>.struct123_0 + int_16 * 4) + 780 + (j + 1)) = *(ref struct43 + j);
				}
				<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2028, (void*)(ptr + 130816), 224U);
				*(*(ref <Module>.struct123_0 + int_16 * 4) + 2024) = 130816;
				if (int_16 == 1)
				{
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					MessageBox.Show("Dummy files are not suitable for flashing.", "Parse Firmware", MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
					return 0;
				}
			}
			else
			{
				Struct46 struct43;
				uint num5;
				if (num != 9530 && num != 11607)
				{
					if (num != 9888)
					{
						if (num != 9893)
						{
							if (num != 11612)
							{
								if (num == 9948)
								{
									*(*(ref <Module>.struct123_0 + int_16 * 4)) = 3;
									*(*(ref <Module>.struct123_0 + int_16 * 4) + 2) = 3;
									<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2284, (void*)(&<Module>.struct9_24), 28U);
									if (ptr[24544] != 0)
									{
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(ptr + 24544), 32U);
									}
									else if (ptr[53760] == 126)
									{
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(&<Module>.struct72_2), 11U);
									}
									else if (<Module>.memcmp((void*)(&struct26), (void*)(ptr + 86016), 16U) == null)
									{
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(&<Module>.struct72_3), 11U);
									}
									else if (<Module>.memcmp((void*)(&struct25), (void*)(ptr + 53600), 16U) == null)
									{
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(&<Module>.struct15_4), 12U);
									}
									else if (<Module>.memcmp((void*)(&struct24), (void*)(ptr + 53248), 16U) == null)
									{
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(&<Module>.struct72_4), 11U);
									}
									else
									{
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(&<Module>.struct23_40), 5U);
									}
									for (num5 = 40960U; num5 < 61440U; num5 += 4096U)
									{
										if (num5 != 53248U)
										{
											if (<Module>.memcmp((void*)(ptr + (num5 + 4080U)), (void*)(&struct3), 16U) == null)
											{
												uint num2;
												for (num2 = 32U; num2 < 4096U; num2 += 16U)
												{
													if (<Module>.memcmp((void*)(ptr + (num5 + num2 + 16U)), (void*)(&struct3), 16U) == null)
													{
														*(*(ref <Module>.struct123_0 + int_16 * 4) + 296) = (int)(num2 + num5);
														<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 280, (void*)(ptr + (num5 + num2)), 16U);
														break;
													}
												}
												if (num2 < 4096U)
												{
													break;
												}
											}
										}
									}
									if (num5 == 61440U)
									{
										<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
										MessageBox.Show("Drive Key not found", "Parse Firmware", MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
										<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
										return 0;
									}
									<Module>.memcpy((void*)(&struct43), *(ref <Module>.struct123_0 + int_16 * 4) + 780, 180U);
									for (int j = 20; j < 93; j += 2)
									{
										*(*(ref <Module>.struct123_0 + int_16 * 4) + 780 + j) = *(ref struct43 + (j + 1));
										*(*(ref <Module>.struct123_0 + int_16 * 4) + 780 + (j + 1)) = *(ref struct43 + j);
									}
									<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2028, (void*)(ptr + 65280), 80U);
									*(*(ref <Module>.struct123_0 + int_16 * 4) + 2024) = 65280;
									goto IL_6AFF;
								}
								else
								{
									if (num != 12288)
									{
										goto IL_6AFF;
									}
									num = 69632;
									while (num < 86016 && (ptr[num] != 5 || ptr[num + 1] != 128 || ptr[num + 2] != 0 || ptr[num + 3] != 50 || ptr[num + 5] != 0 || ptr[num + 7] != 0))
									{
										num++;
									}
									if (num == 70628 | num == 73464 | num == 82278)
									{
										this.textBox6.AppendText("Kreon Inquiry found" + "\r\n");
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 568, (void*)(ptr + num), 96U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2284, (void*)(ptr + (num + 8)), 28U);
										*(*(ref <Module>.struct123_0 + int_16 * 4) + 560) = num;
										i = 69632;
										while (i < 1396736 && (ptr[i] != 192 || ptr[i + 1] != 133 || ptr[i + 2] != 0 || ptr[i + 3] != 0 || ptr[i + 4] != 0 || ptr[i + 5] != 0))
										{
											i++;
										}
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 780, (void*)(ptr + i), 180U);
										*(*(ref <Module>.struct123_0 + int_16 * 4) + 564) = i;
										*(*(ref <Module>.struct123_0 + int_16 * 4)) = 9;
										return 3;
									}
									if (<Module>.memcmp((void*)(&struct42), (void*)ptr, 32U) == null)
									{
										this.textBox6.AppendText("Encrypted Hitachi f/w detected" + "\r\n");
										this.method_392(ptr, pByte_, 262144);
										<Module>.memcpy((void*)ptr, (void*)pByte_, 262144U);
										this.textBox6.AppendText("DeCrypting " + "\r\n");
										return 2;
									}
									if (<Module>.memcmp((void*)(ptr + 82176), (void*)(&<Module>.struct43_16), 256U) == null)
									{
										*(*(ref <Module>.struct123_0 + int_16 * 4)) = 4;
										*(*(ref <Module>.struct123_0 + int_16 * 4) + 2) = 1;
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2284, (void*)(&<Module>.struct9_13), 28U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 568, (void*)(&<Module>.struct29_35), 96U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 684, (void*)(&<Module>.struct29_32), 96U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 780, (void*)(&<Module>.struct46_5), 180U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(&<Module>.struct23_40), 5U);
									}
									else if (<Module>.memcmp((void*)(ptr + 82176), (void*)(&<Module>.struct43_24), 256U) == null)
									{
										*(*(ref <Module>.struct123_0 + int_16 * 4)) = 4;
										*(*(ref <Module>.struct123_0 + int_16 * 4) + 2) = 2;
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2284, (void*)(&<Module>.struct9_14), 28U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 568, (void*)(&<Module>.struct29_30), 96U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 684, (void*)(&<Module>.struct29_26), 96U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 780, (void*)(&<Module>.struct46_3), 180U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(&<Module>.struct23_40), 5U);
									}
									else if (<Module>.memcmp((void*)(ptr + 82176), (void*)(&<Module>.struct43_13), 256U) == null)
									{
										*(*(ref <Module>.struct123_0 + int_16 * 4)) = 4;
										*(*(ref <Module>.struct123_0 + int_16 * 4) + 2) = 3;
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2284, (void*)(&<Module>.struct9_14), 28U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 568, (void*)(&<Module>.struct29_30), 96U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 684, (void*)(&<Module>.struct29_17), 96U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 780, (void*)(&<Module>.struct46_3), 180U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(&<Module>.struct23_40), 5U);
									}
									else if (<Module>.memcmp((void*)(ptr + 82176), (void*)(&<Module>.struct43_22), 256U) == null)
									{
										*(*(ref <Module>.struct123_0 + int_16 * 4)) = 4;
										*(*(ref <Module>.struct123_0 + int_16 * 4) + 2) = 4;
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2284, (void*)(&<Module>.struct9_15), 28U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 568, (void*)(&<Module>.struct29_5), 96U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 684, (void*)(&<Module>.struct29_32), 96U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 780, (void*)(&<Module>.struct46_24), 180U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(&<Module>.struct23_40), 5U);
									}
									else if (<Module>.memcmp((void*)(ptr + 82176), (void*)(&<Module>.struct43_15), 256U) == null)
									{
										*(*(ref <Module>.struct123_0 + int_16 * 4)) = 4;
										*(*(ref <Module>.struct123_0 + int_16 * 4) + 2) = 5;
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2284, (void*)(&<Module>.struct9_16), 28U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 568, (void*)(&<Module>.struct29_24), 96U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 684, (void*)(&<Module>.struct29_13), 96U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 780, (void*)(&<Module>.struct46_14), 180U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(&<Module>.struct23_40), 5U);
									}
									else if (<Module>.memcmp((void*)(ptr + 82176), (void*)(&<Module>.struct43_7), 256U) == null)
									{
										*(*(ref <Module>.struct123_0 + int_16 * 4)) = 4;
										*(*(ref <Module>.struct123_0 + int_16 * 4) + 2) = 2;
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2284, (void*)(&<Module>.struct9_14), 28U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 568, (void*)(&<Module>.struct29_30), 96U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 684, (void*)(&<Module>.struct29_26), 96U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 780, (void*)(&<Module>.struct46_3), 180U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(&<Module>.struct23_40), 5U);
									}
									else if (<Module>.memcmp((void*)(ptr + 82176), (void*)(&<Module>.struct43_14), 256U) == null)
									{
										*(*(ref <Module>.struct123_0 + int_16 * 4)) = 4;
										*(*(ref <Module>.struct123_0 + int_16 * 4) + 2) = 3;
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2284, (void*)(&<Module>.struct9_14), 28U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 568, (void*)(&<Module>.struct29_30), 96U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 684, (void*)(&<Module>.struct29_17), 96U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 780, (void*)(&<Module>.struct46_3), 180U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(&<Module>.struct23_40), 5U);
									}
									else if (<Module>.memcmp((void*)(ptr + 81920), (void*)(&<Module>.struct43_8), 256U) == null)
									{
										*(*(ref <Module>.struct123_0 + int_16 * 4)) = 5;
										*(*(ref <Module>.struct123_0 + int_16 * 4) + 2) = 1;
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2284, (void*)(&<Module>.struct9_17), 28U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 568, (void*)(&<Module>.struct29_31), 96U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 684, (void*)(&<Module>.struct29_20), 96U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 780, (void*)(&<Module>.struct46_15), 180U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(&<Module>.struct23_40), 5U);
									}
									else if (<Module>.memcmp((void*)(ptr + 81920), (void*)(&<Module>.struct43_20), 256U) == null)
									{
										*(*(ref <Module>.struct123_0 + int_16 * 4)) = 5;
										*(*(ref <Module>.struct123_0 + int_16 * 4) + 2) = 2;
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2284, (void*)(&<Module>.struct9_18), 28U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 568, (void*)(&<Module>.struct29_33), 96U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 684, (void*)(&<Module>.struct29_18), 96U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 780, (void*)(&<Module>.struct46_2), 180U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(&<Module>.struct23_40), 5U);
									}
									else if (<Module>.memcmp((void*)(ptr + 81920), (void*)(&<Module>.struct43_9), 256U) == null)
									{
										*(*(ref <Module>.struct123_0 + int_16 * 4)) = 5;
										*(*(ref <Module>.struct123_0 + int_16 * 4) + 2) = 3;
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2284, (void*)(&<Module>.struct9_19), 28U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 568, (void*)(&<Module>.struct29_7), 96U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 684, (void*)(&<Module>.struct29_22), 96U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 780, (void*)(&<Module>.struct46_6), 180U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(&<Module>.struct23_40), 5U);
									}
									else if (<Module>.memcmp((void*)(ptr + 81920), (void*)(&<Module>.struct43_1), 256U) == null)
									{
										*(*(ref <Module>.struct123_0 + int_16 * 4)) = 5;
										*(*(ref <Module>.struct123_0 + int_16 * 4) + 2) = 4;
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2284, (void*)(&<Module>.struct9_20), 28U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 568, (void*)(&<Module>.struct29_0), 96U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 684, (void*)(&<Module>.struct29_23), 96U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 780, (void*)(&<Module>.struct46_13), 180U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(&<Module>.struct23_40), 5U);
									}
									else if (<Module>.memcmp((void*)(ptr + 81920), (void*)(&<Module>.struct43_9), 256U) == null)
									{
										*(*(ref <Module>.struct123_0 + int_16 * 4)) = 5;
										*(*(ref <Module>.struct123_0 + int_16 * 4) + 2) = 3;
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2284, (void*)(&<Module>.struct9_19), 28U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 568, (void*)(&<Module>.struct29_7), 96U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 684, (void*)(&<Module>.struct29_22), 96U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 780, (void*)(&<Module>.struct46_6), 180U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(&<Module>.struct23_40), 5U);
									}
									else if (<Module>.memcmp((void*)(ptr + 81920), (void*)(&<Module>.struct43_18), 256U) == null)
									{
										*(*(ref <Module>.struct123_0 + int_16 * 4)) = 5;
										*(*(ref <Module>.struct123_0 + int_16 * 4) + 2) = 5;
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2284, (void*)(&<Module>.struct9_21), 28U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 568, (void*)(&<Module>.struct29_19), 96U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 684, (void*)(&<Module>.struct29_4), 96U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 780, (void*)(&<Module>.struct46_16), 180U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(&<Module>.struct23_40), 5U);
									}
									else if (<Module>.memcmp((void*)(ptr + 81920), (void*)(&<Module>.struct43_11), 256U) == null)
									{
										*(*(ref <Module>.struct123_0 + int_16 * 4)) = 6;
										*(*(ref <Module>.struct123_0 + int_16 * 4) + 2) = 1;
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2284, (void*)(&<Module>.struct9_25), 28U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 568, (void*)(&<Module>.struct29_28), 96U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 684, (void*)(&<Module>.struct29_12), 96U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 780, (void*)(&<Module>.struct46_18), 180U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(&<Module>.struct24_7), 8U);
									}
									else if (<Module>.memcmp((void*)(ptr + 81920), (void*)(&<Module>.struct43_12), 256U) == null)
									{
										if (ptr[123952] == 93)
										{
											*(*(ref <Module>.struct123_0 + int_16 * 4)) = 6;
											*(*(ref <Module>.struct123_0 + int_16 * 4) + 2) = 3;
											<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2284, (void*)(&<Module>.struct9_26), 28U);
											<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 568, (void*)(&<Module>.struct29_9), 96U);
											<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 780, (void*)(&<Module>.struct46_4), 180U);
											<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(&<Module>.struct24_7), 8U);
										}
										else if (ptr[123952] == 85)
										{
											*(*(ref <Module>.struct123_0 + int_16 * 4)) = 6;
											*(*(ref <Module>.struct123_0 + int_16 * 4) + 2) = 4;
											<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2284, (void*)(&<Module>.struct9_27), 28U);
											<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 568, (void*)(&<Module>.struct29_9), 96U);
											<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 780, (void*)(&<Module>.struct46_4), 180U);
											<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(&<Module>.struct24_7), 8U);
										}
									}
									else if (<Module>.memcmp((void*)(ptr + 81920), (void*)(&<Module>.struct43_19), 256U) == null)
									{
										*(*(ref <Module>.struct123_0 + int_16 * 4)) = 6;
										*(*(ref <Module>.struct123_0 + int_16 * 4) + 2) = 5;
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2284, (void*)(&<Module>.struct9_18), 28U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 568, (void*)(&<Module>.struct29_33), 96U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 684, (void*)(&<Module>.struct29_18), 96U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 780, (void*)(&<Module>.struct46_2), 180U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(&<Module>.struct24_7), 8U);
									}
									else if (<Module>.memcmp((void*)(ptr + 81920), (void*)(&<Module>.struct43_5), 256U) == null)
									{
										*(*(ref <Module>.struct123_0 + int_16 * 4)) = 6;
										*(*(ref <Module>.struct123_0 + int_16 * 4) + 2) = 6;
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2284, (void*)(&<Module>.struct9_19), 28U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 568, (void*)(&<Module>.struct29_7), 96U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 684, (void*)(&<Module>.struct29_22), 96U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 780, (void*)(&<Module>.struct46_6), 180U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(&<Module>.struct24_7), 8U);
									}
									else if (<Module>.memcmp((void*)(ptr + 81920), (void*)(&<Module>.struct43_3), 256U) == null)
									{
										*(*(ref <Module>.struct123_0 + int_16 * 4)) = 6;
										*(*(ref <Module>.struct123_0 + int_16 * 4) + 2) = 7;
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2284, (void*)(&<Module>.struct9_21), 28U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 568, (void*)(&<Module>.struct29_19), 96U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 684, (void*)(&<Module>.struct29_4), 96U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 780, (void*)(&<Module>.struct46_16), 180U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(&<Module>.struct24_7), 8U);
									}
									else if (<Module>.memcmp((void*)(ptr + 81920), (void*)(&<Module>.struct43_23), 256U) == null)
									{
										*(*(ref <Module>.struct123_0 + int_16 * 4)) = 6;
										*(*(ref <Module>.struct123_0 + int_16 * 4) + 2) = 2;
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2284, (void*)(&<Module>.struct9_28), 28U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 568, (void*)(&<Module>.struct29_6), 96U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 684, (void*)(&<Module>.struct29_14), 96U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 780, (void*)(&<Module>.struct46_21), 180U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(&<Module>.struct24_7), 8U);
									}
									else if (<Module>.memcmp((void*)(ptr + 82176), (void*)(&<Module>.struct43_2), 256U) == null)
									{
										*(*(ref <Module>.struct123_0 + int_16 * 4)) = 7;
										*(*(ref <Module>.struct123_0 + int_16 * 4) + 2) = 1;
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2284, (void*)(&<Module>.struct9_25), 28U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 568, (void*)(&<Module>.struct29_28), 96U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 684, (void*)(&<Module>.struct29_12), 96U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 780, (void*)(&<Module>.struct46_18), 180U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(&<Module>.struct7_4), 9U);
										if (ptr[80176] == 3)
										{
											<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2284, (void*)(&<Module>.struct9_26), 28U);
											<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 568, (void*)(&<Module>.struct29_9), 96U);
											<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 780, (void*)(&<Module>.struct46_4), 180U);
											*(*(ref <Module>.struct123_0 + int_16 * 4) + 2) = 3;
										}
										if (ptr[80176] == 11)
										{
											<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2284, (void*)(&<Module>.struct9_27), 28U);
											<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 568, (void*)(&<Module>.struct29_16), 96U);
											<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 780, (void*)(&<Module>.struct46_8), 180U);
											*(*(ref <Module>.struct123_0 + int_16 * 4) + 2) = 4;
										}
									}
									else if (<Module>.memcmp((void*)(ptr + 82176), (void*)(&<Module>.struct43_10), 256U) == null)
									{
										*(*(ref <Module>.struct123_0 + int_16 * 4)) = 7;
										*(*(ref <Module>.struct123_0 + int_16 * 4) + 2) = 2;
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2284, (void*)(&<Module>.struct9_28), 28U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 568, (void*)(&<Module>.struct29_6), 96U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 684, (void*)(&<Module>.struct29_12), 96U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 780, (void*)(&<Module>.struct46_21), 180U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(&<Module>.struct7_4), 9U);
									}
									else if (<Module>.memcmp((void*)(ptr + 82176), (void*)(&<Module>.struct43_6), 256U) == null)
									{
										*(*(ref <Module>.struct123_0 + int_16 * 4)) = 7;
										*(*(ref <Module>.struct123_0 + int_16 * 4) + 2) = 5;
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2284, (void*)(&<Module>.struct9_20), 28U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 568, (void*)(&<Module>.struct29_0), 96U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 684, (void*)(&<Module>.struct29_23), 96U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 780, (void*)(&<Module>.struct46_13), 180U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(&<Module>.struct7_4), 9U);
									}
									else if (<Module>.memcmp((void*)(ptr + 82176), (void*)(&<Module>.struct43_17), 256U) == null)
									{
										*(*(ref <Module>.struct123_0 + int_16 * 4)) = 7;
										*(*(ref <Module>.struct123_0 + int_16 * 4) + 2) = 6;
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2284, (void*)(&<Module>.struct9_18), 28U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 568, (void*)(&<Module>.struct29_33), 96U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 684, (void*)(&<Module>.struct29_18), 96U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 780, (void*)(&<Module>.struct46_2), 180U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(&<Module>.struct7_4), 9U);
									}
									else if (<Module>.memcmp((void*)(ptr + 82176), (void*)(&<Module>.struct43_4), 256U) == null)
									{
										*(*(ref <Module>.struct123_0 + int_16 * 4)) = 7;
										*(*(ref <Module>.struct123_0 + int_16 * 4) + 2) = 7;
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2284, (void*)(&<Module>.struct9_19), 28U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 568, (void*)(&<Module>.struct29_7), 96U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 684, (void*)(&<Module>.struct29_22), 96U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 780, (void*)(&<Module>.struct46_6), 180U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(&<Module>.struct7_4), 9U);
									}
									else
									{
										if (<Module>.memcmp((void*)(ptr + 82176), (void*)(&<Module>.struct43_0), 256U) != null)
										{
											return 0;
										}
										*(*(ref <Module>.struct123_0 + int_16 * 4)) = 7;
										*(*(ref <Module>.struct123_0 + int_16 * 4) + 2) = 8;
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2284, (void*)(&<Module>.struct9_21), 28U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 568, (void*)(&<Module>.struct29_19), 96U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 684, (void*)(&<Module>.struct29_4), 96U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 780, (void*)(&<Module>.struct46_16), 180U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(&<Module>.struct7_4), 9U);
									}
									*(*(ref <Module>.struct123_0 + int_16 * 4) + 296) = 114688;
									if (<Module>.memcmp((void*)(&struct38), (void*)(ptr + 118784), 6U) == null)
									{
										*(*(ref <Module>.struct123_0 + int_16 * 4) + 296) = 106496;
									}
									else if (<Module>.memcmp((void*)(&struct36), (void*)(ptr + 118784), 6U) == null)
									{
										*(*(ref <Module>.struct123_0 + int_16 * 4) + 296) = 114688;
									}
									else if (<Module>.memcmp((void*)(&struct37), (void*)(ptr + 118784), 6U) == null)
									{
										*(*(ref <Module>.struct123_0 + int_16 * 4) + 296) = 122880;
									}
									else if (<Module>.memcmp((void*)(&struct39), (void*)(ptr + 118784), 6U) == null)
									{
										*(*(ref <Module>.struct123_0 + int_16 * 4) + 296) = 110592;
									}
									else if (*(*(ref <Module>.struct123_0 + int_16 * 4)) == 5 && *(*(ref <Module>.struct123_0 + int_16 * 4) + 2) == 1)
									{
										*(*(ref <Module>.struct123_0 + int_16 * 4) + 296) = 172032;
									}
									else if (*(*(ref <Module>.struct123_0 + int_16 * 4)) == 5 && *(*(ref <Module>.struct123_0 + int_16 * 4) + 2) == 2)
									{
										*(*(ref <Module>.struct123_0 + int_16 * 4) + 296) = 172032;
									}
									else if (*(*(ref <Module>.struct123_0 + int_16 * 4)) == 5 && *(*(ref <Module>.struct123_0 + int_16 * 4) + 2) == 3)
									{
										*(*(ref <Module>.struct123_0 + int_16 * 4) + 296) = 172032;
									}
									else if (*(*(ref <Module>.struct123_0 + int_16 * 4)) == 5 && *(*(ref <Module>.struct123_0 + int_16 * 4) + 2) == 4)
									{
										*(*(ref <Module>.struct123_0 + int_16 * 4) + 296) = 172032;
									}
									else if (*(*(ref <Module>.struct123_0 + int_16 * 4)) == 5 && *(*(ref <Module>.struct123_0 + int_16 * 4) + 2) == 5)
									{
										*(*(ref <Module>.struct123_0 + int_16 * 4) + 296) = 172032;
									}
									else if (*(*(ref <Module>.struct123_0 + int_16 * 4)) == 6 && *(*(ref <Module>.struct123_0 + int_16 * 4) + 2) == 1)
									{
										*(*(ref <Module>.struct123_0 + int_16 * 4) + 296) = 126960;
									}
									else if (*(*(ref <Module>.struct123_0 + int_16 * 4)) == 6 && *(*(ref <Module>.struct123_0 + int_16 * 4) + 2) == 2)
									{
										*(*(ref <Module>.struct123_0 + int_16 * 4) + 296) = 126960;
									}
									else if (*(*(ref <Module>.struct123_0 + int_16 * 4)) == 6 && *(*(ref <Module>.struct123_0 + int_16 * 4) + 2) == 3)
									{
										*(*(ref <Module>.struct123_0 + int_16 * 4) + 296) = 126960;
									}
									else if (*(*(ref <Module>.struct123_0 + int_16 * 4)) == 6 && *(*(ref <Module>.struct123_0 + int_16 * 4) + 2) == 4)
									{
										*(*(ref <Module>.struct123_0 + int_16 * 4) + 296) = 126960;
									}
									else if (*(*(ref <Module>.struct123_0 + int_16 * 4)) == 6 && *(*(ref <Module>.struct123_0 + int_16 * 4) + 2) == 5)
									{
										*(*(ref <Module>.struct123_0 + int_16 * 4) + 296) = 126960;
									}
									else if (*(*(ref <Module>.struct123_0 + int_16 * 4)) == 6 && *(*(ref <Module>.struct123_0 + int_16 * 4) + 2) == 6)
									{
										*(*(ref <Module>.struct123_0 + int_16 * 4) + 296) = 126960;
									}
									else if (*(*(ref <Module>.struct123_0 + int_16 * 4)) == 6 && *(*(ref <Module>.struct123_0 + int_16 * 4) + 2) == 7)
									{
										*(*(ref <Module>.struct123_0 + int_16 * 4) + 296) = 126960;
									}
									else if (*(*(ref <Module>.struct123_0 + int_16 * 4)) == 7 && *(*(ref <Module>.struct123_0 + int_16 * 4) + 2) == 1)
									{
										*(*(ref <Module>.struct123_0 + int_16 * 4) + 296) = 114688;
									}
									else if (*(*(ref <Module>.struct123_0 + int_16 * 4)) == 7 && *(*(ref <Module>.struct123_0 + int_16 * 4) + 2) == 2)
									{
										*(*(ref <Module>.struct123_0 + int_16 * 4) + 296) = 114688;
									}
									else if (*(*(ref <Module>.struct123_0 + int_16 * 4)) == 7 && *(*(ref <Module>.struct123_0 + int_16 * 4) + 2) == 3)
									{
										*(*(ref <Module>.struct123_0 + int_16 * 4) + 296) = 114688;
									}
									else
									{
										if (*(*(ref <Module>.struct123_0 + int_16 * 4)) != 7 || *(*(ref <Module>.struct123_0 + int_16 * 4) + 2) != 4)
										{
											<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
											MessageBox.Show("Drive Key not found", "Parse Firmware", MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
											<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
											return 0;
										}
										*(*(ref <Module>.struct123_0 + int_16 * 4) + 296) = 114688;
									}
									*(*(ref <Module>.struct123_0 + int_16 * 4) + 280) = ptr[*(*(ref <Module>.struct123_0 + int_16 * 4) + 296) + 312];
									*(*(ref <Module>.struct123_0 + int_16 * 4) + 281) = ptr[*(*(ref <Module>.struct123_0 + int_16 * 4) + 296) + 2796];
									*(*(ref <Module>.struct123_0 + int_16 * 4) + 282) = ptr[*(*(ref <Module>.struct123_0 + int_16 * 4) + 296) + 1858];
									*(*(ref <Module>.struct123_0 + int_16 * 4) + 283) = ptr[*(*(ref <Module>.struct123_0 + int_16 * 4) + 296) + 1664];
									*(*(ref <Module>.struct123_0 + int_16 * 4) + 284) = ptr[*(*(ref <Module>.struct123_0 + int_16 * 4) + 296) + 3789];
									*(*(ref <Module>.struct123_0 + int_16 * 4) + 285) = ptr[*(*(ref <Module>.struct123_0 + int_16 * 4) + 296) + 2868];
									*(*(ref <Module>.struct123_0 + int_16 * 4) + 286) = ptr[*(*(ref <Module>.struct123_0 + int_16 * 4) + 296) + 2111];
									*(*(ref <Module>.struct123_0 + int_16 * 4) + 287) = ptr[*(*(ref <Module>.struct123_0 + int_16 * 4) + 296) + 1829];
									*(*(ref <Module>.struct123_0 + int_16 * 4) + 288) = ptr[*(*(ref <Module>.struct123_0 + int_16 * 4) + 296) + 1322];
									*(*(ref <Module>.struct123_0 + int_16 * 4) + 289) = ptr[*(*(ref <Module>.struct123_0 + int_16 * 4) + 296) + 513];
									*(*(ref <Module>.struct123_0 + int_16 * 4) + 290) = ptr[*(*(ref <Module>.struct123_0 + int_16 * 4) + 296) + 2527];
									*(*(ref <Module>.struct123_0 + int_16 * 4) + 291) = ptr[*(*(ref <Module>.struct123_0 + int_16 * 4) + 296) + 35];
									*(*(ref <Module>.struct123_0 + int_16 * 4) + 292) = ptr[*(*(ref <Module>.struct123_0 + int_16 * 4) + 296) + 1184];
									*(*(ref <Module>.struct123_0 + int_16 * 4) + 293) = ptr[*(*(ref <Module>.struct123_0 + int_16 * 4) + 296) + 1434];
									*(*(ref <Module>.struct123_0 + int_16 * 4) + 294) = ptr[*(*(ref <Module>.struct123_0 + int_16 * 4) + 296) + 1022];
									*(*(ref <Module>.struct123_0 + int_16 * 4) + 295) = ptr[*(*(ref <Module>.struct123_0 + int_16 * 4) + 296) + 3913];
									if (*(*(ref <Module>.struct123_0 + int_16 * 4)) == 5 && *(*(ref <Module>.struct123_0 + int_16 * 4) + 2) == 2)
									{
										this.method_79(int_16);
									}
									if (*(*(ref <Module>.struct123_0 + int_16 * 4)) == 5 && *(*(ref <Module>.struct123_0 + int_16 * 4) + 2) == 3)
									{
										this.method_80(int_16);
									}
									if (*(*(ref <Module>.struct123_0 + int_16 * 4)) == 5 && *(*(ref <Module>.struct123_0 + int_16 * 4) + 2) == 5)
									{
										this.method_81(int_16);
									}
									if (*(*(ref <Module>.struct123_0 + int_16 * 4)) == 6 && *(*(ref <Module>.struct123_0 + int_16 * 4) + 2) == 1)
									{
										this.method_34(ptr + 126960, *(ref <Module>.struct123_0 + int_16 * 4) + 280);
									}
									if (*(*(ref <Module>.struct123_0 + int_16 * 4)) == 6 && *(*(ref <Module>.struct123_0 + int_16 * 4) + 2) == 2)
									{
										this.method_34(ptr + 126960, *(ref <Module>.struct123_0 + int_16 * 4) + 280);
									}
									if (*(*(ref <Module>.struct123_0 + int_16 * 4)) == 6 && *(*(ref <Module>.struct123_0 + int_16 * 4) + 2) == 3)
									{
										this.method_34(ptr + 126960, *(ref <Module>.struct123_0 + int_16 * 4) + 280);
									}
									if (*(*(ref <Module>.struct123_0 + int_16 * 4)) == 6 && *(*(ref <Module>.struct123_0 + int_16 * 4) + 2) == 4)
									{
										this.method_34(ptr + 126960, *(ref <Module>.struct123_0 + int_16 * 4) + 280);
									}
									if (*(*(ref <Module>.struct123_0 + int_16 * 4)) == 6 && *(*(ref <Module>.struct123_0 + int_16 * 4) + 2) == 5)
									{
										this.method_34(ptr + 126960, *(ref <Module>.struct123_0 + int_16 * 4) + 280);
									}
									if (*(*(ref <Module>.struct123_0 + int_16 * 4)) == 6 && *(*(ref <Module>.struct123_0 + int_16 * 4) + 2) == 6)
									{
										this.method_34(ptr + 126960, *(ref <Module>.struct123_0 + int_16 * 4) + 280);
									}
									if (*(*(ref <Module>.struct123_0 + int_16 * 4)) == 6 && *(*(ref <Module>.struct123_0 + int_16 * 4) + 2) == 7)
									{
										this.method_34(ptr + 126960, *(ref <Module>.struct123_0 + int_16 * 4) + 280);
									}
									if (<Module>.memcmp((void*)(&struct8), (void*)(ptr + 81888), 18U) == null)
									{
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(&<Module>.struct0_1), 17U);
									}
									else if (<Module>.memcmp((void*)(&struct7), (void*)(ptr + 81888), 18U) == null)
									{
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(&<Module>.struct0_2), 17U);
									}
									else if (<Module>.memcmp((void*)(&struct9), (void*)(ptr + 81888), 18U) == null)
									{
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(&<Module>.struct75_0), 32U);
									}
									else if (<Module>.memcmp((void*)(&struct11), (void*)(ptr + 81888), 18U) == null)
									{
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(&<Module>.struct75_1), 32U);
									}
									else if (<Module>.memcmp((void*)(&struct10), (void*)(ptr + 81888), 18U) == null)
									{
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(&<Module>.struct75_2), 32U);
									}
									else if (*(*(ref <Module>.struct123_0 + int_16 * 4)) == 7 && *(*(ref <Module>.struct123_0 + int_16 * 4) + 2) == 1)
									{
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(&<Module>.struct7_4), 9U);
									}
									else if (*(*(ref <Module>.struct123_0 + int_16 * 4)) == 7 && *(*(ref <Module>.struct123_0 + int_16 * 4) + 2) == 2)
									{
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(&<Module>.struct7_4), 9U);
									}
									else if (*(*(ref <Module>.struct123_0 + int_16 * 4)) == 7 && *(*(ref <Module>.struct123_0 + int_16 * 4) + 2) == 3)
									{
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(&<Module>.struct7_4), 9U);
									}
									else if (*(*(ref <Module>.struct123_0 + int_16 * 4)) == 7 && *(*(ref <Module>.struct123_0 + int_16 * 4) + 2) == 4)
									{
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(&<Module>.struct7_4), 9U);
									}
									else if (*(*(ref <Module>.struct123_0 + int_16 * 4)) == 7 && *(*(ref <Module>.struct123_0 + int_16 * 4) + 2) == 5)
									{
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(&<Module>.struct7_4), 9U);
									}
									else if (*(*(ref <Module>.struct123_0 + int_16 * 4)) == 7 && *(*(ref <Module>.struct123_0 + int_16 * 4) + 2) == 6)
									{
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(&<Module>.struct7_4), 9U);
									}
									else if (*(*(ref <Module>.struct123_0 + int_16 * 4)) == 7 && *(*(ref <Module>.struct123_0 + int_16 * 4) + 2) == 7)
									{
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(&<Module>.struct7_4), 9U);
									}
									else if (*(*(ref <Module>.struct123_0 + int_16 * 4)) == 7 && *(*(ref <Module>.struct123_0 + int_16 * 4) + 2) == 8)
									{
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(&<Module>.struct7_4), 9U);
									}
									else if (<Module>.memcmp((void*)(&struct30), (void*)(ptr + 126976), 16U) == null)
									{
										if (<Module>.memcmp((void*)(&struct31), (void*)(ptr + 251056), 16U) == null)
										{
											<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(&<Module>.struct74_0), 10U);
										}
										else if (<Module>.memcmp((void*)(&struct32), (void*)(ptr + 251056), 16U) == null)
										{
											<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(&<Module>.struct65_2), 14U);
											if (ptr[112435] == 178)
											{
												<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(&<Module>.struct65_3), 14U);
												if (ptr[251104] == 105)
												{
													<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(&<Module>.struct65_4), 14U);
													if (ptr[127900] == 80)
													{
														<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(&<Module>.struct65_5), 14U);
													}
												}
												if (ptr[249856] == 74)
												{
													<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(&<Module>.struct65_6), 14U);
												}
											}
											if (ptr[112275] == 58)
											{
												<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(&<Module>.struct65_7), 14U);
											}
										}
										else if (<Module>.memcmp((void*)(&struct33), (void*)(ptr + 251056), 16U) == null)
										{
											<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(&<Module>.struct22_4), 7U);
										}
									}
									else if (<Module>.memcmp((void*)(&struct12), (void*)(ptr + 81888), 18U) == null)
									{
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(&<Module>.struct23_40), 5U);
									}
									else if (<Module>.memcmp((void*)(&struct13), (void*)(ptr + 81888), 18U) == null)
									{
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(&<Module>.struct23_40), 5U);
									}
									else if (<Module>.memcmp((void*)(&struct14), (void*)(ptr + 81888), 18U) == null)
									{
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(&<Module>.struct23_40), 5U);
									}
									else if (<Module>.memcmp((void*)(&struct15), (void*)(ptr + 81888), 18U) == null)
									{
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(&<Module>.struct23_40), 5U);
									}
									else if (<Module>.memcmp((void*)(&struct16), (void*)(ptr + 81888), 18U) == null)
									{
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(&<Module>.struct23_40), 5U);
									}
									else if (<Module>.memcmp((void*)(&struct17), (void*)(ptr + 81888), 18U) == null)
									{
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(&<Module>.struct23_40), 5U);
									}
									else if (<Module>.memcmp((void*)(&struct18), (void*)(ptr + 81888), 18U) == null)
									{
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(&<Module>.struct23_40), 5U);
									}
									else if (<Module>.memcmp((void*)(&struct34), (void*)(ptr + 148448), 16U) == null)
									{
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(&<Module>.struct22_4), 7U);
									}
									else if (<Module>.memcmp((void*)(&struct35), (void*)(ptr + 148448), 16U) == null)
									{
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(&<Module>.struct23_40), 5U);
									}
									else if (<Module>.memcmp((void*)(&struct27), (void*)(ptr + 148448), 16U) == null)
									{
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(&<Module>.struct72_4), 11U);
										if (ptr[195959] == 247 && ptr[195960] == 83)
										{
											<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(&<Module>.struct15_4), 12U);
										}
										if (ptr[196079] == 255 && ptr[196080] == 208)
										{
											<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(&<Module>.struct65_8), 14U);
										}
										if (ptr[258235] == 18 && ptr[258236] == 190)
										{
											<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(&<Module>.struct65_6), 14U);
										}
										if (ptr[185719] == 118 && ptr[185720] == 251)
										{
											<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(&<Module>.struct65_7), 14U);
										}
										if (ptr[184541] == 16 && ptr[184542] == 137)
										{
											<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(&<Module>.struct65_7), 14U);
										}
									}
									if (<Module>.memcmp(*(ref <Module>.struct123_0 + 4) + 2348, (void*)(&<Module>.struct74_0), 10U) == null && *(*(ref <Module>.struct123_0 + 4)) == 4)
									{
										<Module>.memcpy((void*)(ptr + 81408), (void*)(&<Module>.struct47_7), 276U);
										<Module>.memset(*(ref <Module>.struct123_0 + int_16 * 4) + 2316, 0, 32U);
										for (int j = 0; j < 20; j++)
										{
											*(*(ref <Module>.struct123_0 + int_16 * 4) + 568 + (j + 42)) = ptr[j + 130816];
											*(*(ref <Module>.struct123_0 + int_16 * 4) + 780 + (j + 20)) = ptr[j + 130816];
										}
										for (int j = 0; j < 2; j++)
										{
											*(*(ref <Module>.struct123_0 + int_16 * 4) + 568 + (j + 38)) = ptr[j + 130856];
											*(*(ref <Module>.struct123_0 + int_16 * 4) + 568 + (j + 40)) = ptr[j + 130892];
										}
									}
									else if (<Module>.memcmp(*(ref <Module>.struct123_0 + 4) + 2348, (void*)(&<Module>.struct22_4), 7U) == null && *(*(ref <Module>.struct123_0 + 4)) == 4)
									{
										<Module>.memcpy((void*)(ptr + 81408), (void*)(&<Module>.struct47_7), 276U);
										<Module>.memset(*(ref <Module>.struct123_0 + int_16 * 4) + 2316, 0, 32U);
										for (int j = 0; j < 20; j++)
										{
											*(*(ref <Module>.struct123_0 + int_16 * 4) + 568 + (j + 42)) = ptr[j + 130816];
											*(*(ref <Module>.struct123_0 + int_16 * 4) + 780 + (j + 20)) = ptr[j + 130816];
										}
										for (int j = 0; j < 2; j++)
										{
											*(*(ref <Module>.struct123_0 + int_16 * 4) + 568 + (j + 38)) = ptr[j + 130856];
											*(*(ref <Module>.struct123_0 + int_16 * 4) + 568 + (j + 40)) = ptr[j + 130892];
										}
									}
									else if (<Module>.memcmp((void*)(&<Module>.struct47_8), (void*)(ptr + 81408), 276U) == null)
									{
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2316, (void*)(&<Module>.struct9_3), 28U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 568, (void*)(&<Module>.struct29_8), 96U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 780, (void*)(&<Module>.struct46_0), 180U);
									}
									else if (<Module>.memcmp((void*)(&<Module>.struct47_6), (void*)(ptr + 81408), 276U) == null)
									{
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2316, (void*)(&<Module>.struct9_4), 28U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 568, (void*)(&<Module>.struct29_11), 96U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 780, (void*)(&<Module>.struct46_1), 180U);
									}
									else if (<Module>.memcmp((void*)(&<Module>.struct47_1), (void*)(ptr + 81408), 276U) == null)
									{
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2316, (void*)(&<Module>.struct9_22), 28U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 568, (void*)(&<Module>.struct29_34), 96U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 780, (void*)(&<Module>.struct46_22), 180U);
									}
									else if (<Module>.memcmp((void*)(&<Module>.struct47_5), (void*)(ptr + 81408), 276U) == null)
									{
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2316, (void*)(&<Module>.struct9_23), 28U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 568, (void*)(&<Module>.struct29_25), 96U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 780, (void*)(&<Module>.struct46_9), 180U);
									}
									else if (<Module>.memcmp((void*)(&<Module>.struct47_2), (void*)(ptr + 81408), 276U) == null)
									{
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2316, (void*)(&<Module>.struct9_5), 28U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 568, (void*)(&<Module>.struct29_36), 96U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 780, (void*)(&<Module>.struct46_23), 180U);
									}
									else if (<Module>.memcmp((void*)(&<Module>.struct47_0), (void*)(ptr + 81408), 276U) == null)
									{
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2316, (void*)(&<Module>.struct9_6), 28U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 568, (void*)(&<Module>.struct29_15), 96U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 780, (void*)(&<Module>.struct46_17), 180U);
									}
									else if (<Module>.memcmp((void*)(&<Module>.struct47_10), (void*)(ptr + 81408), 276U) == null)
									{
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2316, (void*)(&<Module>.struct9_7), 28U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 568, (void*)(&<Module>.struct29_2), 96U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 780, (void*)(&<Module>.struct46_20), 180U);
									}
									else if (<Module>.memcmp((void*)(&<Module>.struct47_4), (void*)(ptr + 81408), 276U) == null)
									{
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2316, (void*)(&<Module>.struct9_8), 28U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 568, (void*)(&<Module>.struct29_1), 96U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 780, (void*)(&<Module>.struct46_25), 180U);
									}
									else if (<Module>.memcmp((void*)(&<Module>.struct47_3), (void*)(ptr + 81408), 276U) == null)
									{
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2316, (void*)(&<Module>.struct9_9), 28U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 568, (void*)(&<Module>.struct29_29), 96U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 780, (void*)(&<Module>.struct46_10), 180U);
									}
									else if (<Module>.memcmp((void*)(&<Module>.struct47_12), (void*)(ptr + 81408), 276U) == null)
									{
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2316, (void*)(&<Module>.struct9_2), 28U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 568, (void*)(&<Module>.struct29_27), 96U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 780, (void*)(&<Module>.struct46_7), 180U);
									}
									else if (<Module>.memcmp((void*)(&<Module>.struct47_11), (void*)(ptr + 81408), 276U) == null)
									{
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2316, (void*)(&<Module>.struct9_10), 28U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 568, (void*)(&<Module>.struct29_10), 96U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 780, (void*)(&<Module>.struct46_19), 180U);
									}
									else if (<Module>.memcmp((void*)(&<Module>.struct47_9), (void*)(ptr + 81408), 276U) == null)
									{
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2316, (void*)(&<Module>.struct9_11), 28U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 568, (void*)(&<Module>.struct29_3), 96U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 780, (void*)(&<Module>.struct46_12), 180U);
									}
									else if (<Module>.memcmp((void*)(&<Module>.struct47_13), (void*)(ptr + 81408), 276U) == null)
									{
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2316, (void*)(&<Module>.struct9_12), 28U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 568, (void*)(&<Module>.struct29_21), 96U);
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 780, (void*)(&<Module>.struct46_11), 180U);
									}
									else
									{
										<Module>.memset(*(ref <Module>.struct123_0 + int_16 * 4) + 2316, 0, 32U);
										if (*(*(ref <Module>.struct123_0 + int_16 * 4)) == 4)
										{
											for (int j = 0; j < 20; j++)
											{
												*(*(ref <Module>.struct123_0 + int_16 * 4) + 568 + (j + 42)) = ptr[j + 130816];
												*(*(ref <Module>.struct123_0 + int_16 * 4) + 780 + (j + 20)) = ptr[j + 130816];
											}
											for (int j = 0; j < 2; j++)
											{
												*(*(ref <Module>.struct123_0 + int_16 * 4) + 568 + (j + 38)) = ptr[j + 130856];
												*(*(ref <Module>.struct123_0 + int_16 * 4) + 568 + (j + 40)) = ptr[j + 130892];
											}
										}
										else if (*(*(ref <Module>.struct123_0 + int_16 * 4)) == 5)
										{
											for (int j = 0; j < 20; j++)
											{
												*(*(ref <Module>.struct123_0 + int_16 * 4) + 568 + (j + 96)) = ptr[j + 130816];
												*(*(ref <Module>.struct123_0 + int_16 * 4) + 780 + (j + 20)) = ptr[j + 130816];
											}
											for (int j = 0; j < 2; j++)
											{
												*(*(ref <Module>.struct123_0 + int_16 * 4) + 568 + (j + 52)) = ptr[j + 130856];
												*(*(ref <Module>.struct123_0 + int_16 * 4) + 568 + (j + 54)) = ptr[j + 130892];
											}
										}
										else if (*(*(ref <Module>.struct123_0 + int_16 * 4)) == 6)
										{
											if (*(*(ref <Module>.struct123_0 + int_16 * 4) + 2) != 1 && *(*(ref <Module>.struct123_0 + int_16 * 4) + 2) != 2 && *(*(ref <Module>.struct123_0 + int_16 * 4) + 2) != 5 && *(*(ref <Module>.struct123_0 + int_16 * 4) + 2) != 6)
											{
												if (*(*(ref <Module>.struct123_0 + int_16 * 4) + 2) != 7)
												{
													for (int j = 0; j < 20; j++)
													{
														*(*(ref <Module>.struct123_0 + int_16 * 4) + 568 + (j + 96)) = ptr[j + 261888];
													}
													goto IL_63CF;
												}
											}
											for (int j = 0; j < 20; j++)
											{
												*(*(ref <Module>.struct123_0 + int_16 * 4) + 568 + (j + 96)) = ptr[j + 261888];
											}
											for (int j = 0; j < 20; j += 2)
											{
												*(*(ref <Module>.struct123_0 + int_16 * 4) + 780 + (j + 20)) = ptr[j + 261889];
												*(*(ref <Module>.struct123_0 + int_16 * 4) + 780 + (j + 21)) = ptr[j + 261888];
											}
											for (int j = 0; j < 2; j++)
											{
												*(*(ref <Module>.struct123_0 + int_16 * 4) + 568 + (j + 52)) = ptr[j + 261928];
												*(*(ref <Module>.struct123_0 + int_16 * 4) + 568 + (j + 54)) = ptr[j + 261964];
											}
										}
										else if (*(*(ref <Module>.struct123_0 + int_16 * 4)) == 7)
										{
											if (*(*(ref <Module>.struct123_0 + int_16 * 4) + 2) != 1)
											{
												if (*(*(ref <Module>.struct123_0 + int_16 * 4) + 2) != 2)
												{
													for (int j = 0; j < 20; j++)
													{
														*(*(ref <Module>.struct123_0 + int_16 * 4) + 568 + (j + 96)) = ptr[j + 130816];
													}
													goto IL_63CF;
												}
											}
											for (int j = 0; j < 20; j++)
											{
												*(*(ref <Module>.struct123_0 + int_16 * 4) + 568 + (j + 96)) = ptr[j + 130816];
											}
											for (int j = 0; j < 20; j += 2)
											{
												*(*(ref <Module>.struct123_0 + int_16 * 4) + 780 + (j + 20)) = ptr[j + 130817];
												*(*(ref <Module>.struct123_0 + int_16 * 4) + 780 + (j + 21)) = ptr[j + 130816];
											}
											for (int j = 0; j < 2; j++)
											{
												*(*(ref <Module>.struct123_0 + int_16 * 4) + 568 + (j + 52)) = ptr[j + 130856];
												*(*(ref <Module>.struct123_0 + int_16 * 4) + 568 + (j + 54)) = ptr[j + 130892];
											}
										}
									}
									IL_63CF:
									<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2028, (void*)(ptr + 130816), 224U);
									*(*(ref <Module>.struct123_0 + int_16 * 4) + 2024) = 130816;
									if (*(*(ref <Module>.struct123_0 + int_16 * 4)) == 6)
									{
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2028, (void*)(ptr + 261888), 256U);
										*(*(ref <Module>.struct123_0 + int_16 * 4) + 2024) = 261888;
									}
									if (*(*(ref <Module>.struct123_0 + int_16 * 4)) == 7)
									{
										<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2028, (void*)(ptr + 130816), 80U);
										*(*(ref <Module>.struct123_0 + int_16 * 4) + 2024) = 130816;
										goto IL_6AFF;
									}
									goto IL_6AFF;
								}
							}
						}
						*(*(ref <Module>.struct123_0 + int_16 * 4)) = 3;
						*(*(ref <Module>.struct123_0 + int_16 * 4) + 2) = 2;
						<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2284, (void*)(&<Module>.struct9_23), 28U);
						if (ptr[24544] != 0)
						{
							<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(ptr + 24544), 32U);
						}
						else if (<Module>.memcmp((void*)(&struct19), (void*)(ptr + 64176), 16U) == null)
						{
							if (<Module>.memcmp((void*)(&struct21), (void*)(ptr + 91520), 16U) == null)
							{
								<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(&<Module>.struct74_0), 10U);
								if (ptr[118790] == 67)
								{
									<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(&<Module>.struct65_1), 14U);
								}
								else if (ptr[63096] == 84)
								{
									<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(&<Module>.struct65_2), 14U);
								}
							}
							if (<Module>.memcmp((void*)(&struct22), (void*)(ptr + 91520), 16U) == null)
							{
								<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(&<Module>.struct22_4), 7U);
							}
							if (<Module>.memcmp((void*)(&struct23), (void*)(ptr + 91520), 16U) == null)
							{
								<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(&<Module>.struct72_1), 11U);
							}
						}
						else
						{
							<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(&<Module>.struct23_40), 5U);
						}
						for (num5 = 40960U; num5 < 61440U; num5 += 4096U)
						{
							if (num5 != 53248U)
							{
								if (<Module>.memcmp((void*)(ptr + (num5 + 4080U)), (void*)(&struct3), 16U) == null)
								{
									uint num2;
									for (num2 = 32U; num2 < 4096U; num2 += 16U)
									{
										if (<Module>.memcmp((void*)(ptr + (num5 + num2 + 16U)), (void*)(&struct3), 16U) == null)
										{
											*(*(ref <Module>.struct123_0 + int_16 * 4) + 296) = (int)(num2 + num5);
											<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 280, (void*)(ptr + (num5 + num2)), 16U);
											break;
										}
									}
									if (num2 < 4096U)
									{
										break;
									}
								}
							}
						}
						if (num5 == 61440U)
						{
							<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
							MessageBox.Show("Drive Key not found", "Parse Firmware", MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
							<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
							return 0;
						}
						<Module>.memcpy((void*)(&struct43), *(ref <Module>.struct123_0 + int_16 * 4) + 780, 180U);
						for (int j = 20; j < 93; j += 2)
						{
							*(*(ref <Module>.struct123_0 + int_16 * 4) + 780 + j) = *(ref struct43 + (j + 1));
							*(*(ref <Module>.struct123_0 + int_16 * 4) + 780 + (j + 1)) = *(ref struct43 + j);
						}
						<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2028, (void*)(ptr + 65280), 80U);
						*(*(ref <Module>.struct123_0 + int_16 * 4) + 2024) = 65280;
						goto IL_6AFF;
					}
				}
				*(*(ref <Module>.struct123_0 + int_16 * 4)) = 3;
				*(*(ref <Module>.struct123_0 + int_16 * 4) + 2) = 1;
				<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2284, (void*)(&<Module>.struct9_22), 28U);
				if (ptr[24544] != 0)
				{
					<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(ptr + 24544), 32U);
				}
				else if (<Module>.memcmp((void*)(&struct19), (void*)(ptr + 64176), 16U) == null)
				{
					if (<Module>.memcmp((void*)(&struct21), (void*)(ptr + 91520), 16U) == null)
					{
						<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(&<Module>.struct74_0), 10U);
						if (ptr[118790] == 67)
						{
							<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(&<Module>.struct65_1), 14U);
						}
						else if (ptr[63096] == 84)
						{
							<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(&<Module>.struct65_2), 14U);
						}
					}
					if (<Module>.memcmp((void*)(&struct22), (void*)(ptr + 91520), 16U) == null)
					{
						<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(&<Module>.struct22_4), 7U);
					}
					if (<Module>.memcmp((void*)(&struct23), (void*)(ptr + 91520), 16U) == null)
					{
						<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(&<Module>.struct72_1), 11U);
					}
				}
				else
				{
					<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2348, (void*)(&<Module>.struct23_40), 5U);
				}
				for (num5 = 40960U; num5 < 61440U; num5 += 4096U)
				{
					if (num5 != 53248U)
					{
						if (<Module>.memcmp((void*)(ptr + (num5 + 4080U)), (void*)(&struct3), 16U) == null)
						{
							uint num2;
							for (num2 = 32U; num2 < 4096U; num2 += 16U)
							{
								if (<Module>.memcmp((void*)(ptr + (num5 + num2 + 16U)), (void*)(&struct3), 16U) == null)
								{
									*(*(ref <Module>.struct123_0 + int_16 * 4) + 296) = (int)(num5 + num2);
									<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 280, (void*)(ptr + (num5 + num2)), 16U);
									break;
								}
							}
							if (num2 < 4096U)
							{
								break;
							}
						}
					}
				}
				if (num5 == 61440U)
				{
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					MessageBox.Show("Drive Key not found", "Parse Firmware", MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
					return 0;
				}
				<Module>.memcpy((void*)(&struct43), *(ref <Module>.struct123_0 + int_16 * 4) + 780, 180U);
				for (int j = 20; j < 93; j += 2)
				{
					*(*(ref <Module>.struct123_0 + int_16 * 4) + 780 + j) = *(ref struct43 + (j + 1));
					*(*(ref <Module>.struct123_0 + int_16 * 4) + 780 + (j + 1)) = *(ref struct43 + j);
				}
				<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 2028, (void*)(ptr + 65280), 80U);
				*(*(ref <Module>.struct123_0 + int_16 * 4) + 2024) = 65280;
			}
			IL_6AFF:
			ptr = *(ref <Module>.struct123_0 + int_16 * 4) + 2316;
			if (<Module>.memcmp(*(ref <Module>.struct123_0 + int_16 * 4) + 2316, (void*)(&<Module>.struct9_3), 28U) == null)
			{
				*(*(ref <Module>.struct123_0 + int_16 * 4) + 2382) = 1;
				*(*(ref <Module>.struct123_0 + int_16 * 4) + 2384) = 1;
			}
			else if (<Module>.memcmp(*(ref <Module>.struct123_0 + int_16 * 4) + 2316, (void*)(&<Module>.struct9_4), 28U) == null)
			{
				*(*(ref <Module>.struct123_0 + int_16 * 4) + 2382) = 1;
				*(*(ref <Module>.struct123_0 + int_16 * 4) + 2384) = 2;
			}
			else if (<Module>.memcmp(*(ref <Module>.struct123_0 + int_16 * 4) + 2316, (void*)(&<Module>.struct9_5), 28U) == null)
			{
				*(*(ref <Module>.struct123_0 + int_16 * 4) + 2382) = 2;
				*(*(ref <Module>.struct123_0 + int_16 * 4) + 2384) = 1;
			}
			else if (<Module>.memcmp(*(ref <Module>.struct123_0 + int_16 * 4) + 2316, (void*)(&<Module>.struct9_6), 28U) == null)
			{
				*(*(ref <Module>.struct123_0 + int_16 * 4) + 2382) = 2;
				*(*(ref <Module>.struct123_0 + int_16 * 4) + 2384) = 2;
			}
			else if (<Module>.memcmp(*(ref <Module>.struct123_0 + int_16 * 4) + 2316, (void*)(&<Module>.struct9_7), 28U) == null)
			{
				*(*(ref <Module>.struct123_0 + int_16 * 4) + 2382) = 2;
				*(*(ref <Module>.struct123_0 + int_16 * 4) + 2384) = 3;
			}
			else if (<Module>.memcmp(*(ref <Module>.struct123_0 + int_16 * 4) + 2316, (void*)(&<Module>.struct9_8), 28U) == null)
			{
				*(*(ref <Module>.struct123_0 + int_16 * 4) + 2382) = 2;
				*(*(ref <Module>.struct123_0 + int_16 * 4) + 2384) = 4;
			}
			else if (<Module>.memcmp(*(ref <Module>.struct123_0 + int_16 * 4) + 2316, (void*)(&<Module>.struct9_9), 28U) == null)
			{
				*(*(ref <Module>.struct123_0 + int_16 * 4) + 2382) = 2;
				*(*(ref <Module>.struct123_0 + int_16 * 4) + 2384) = 5;
			}
			else if (<Module>.memcmp(*(ref <Module>.struct123_0 + int_16 * 4) + 2316, (void*)(&<Module>.struct9_2), 28U) == null)
			{
				*(*(ref <Module>.struct123_0 + int_16 * 4) + 2382) = 2;
				*(*(ref <Module>.struct123_0 + int_16 * 4) + 2384) = 6;
			}
			else if (<Module>.memcmp(*(ref <Module>.struct123_0 + int_16 * 4) + 2316, (void*)(&<Module>.struct9_10), 28U) == null)
			{
				*(*(ref <Module>.struct123_0 + int_16 * 4) + 2382) = 2;
				*(*(ref <Module>.struct123_0 + int_16 * 4) + 2384) = 7;
			}
			else if (<Module>.memcmp(*(ref <Module>.struct123_0 + int_16 * 4) + 2316, (void*)(&<Module>.struct9_11), 28U) == null)
			{
				*(*(ref <Module>.struct123_0 + int_16 * 4) + 2382) = 2;
				*(*(ref <Module>.struct123_0 + int_16 * 4) + 2384) = 8;
			}
			else if (<Module>.memcmp(*(ref <Module>.struct123_0 + int_16 * 4) + 2316, (void*)(&<Module>.struct9_12), 28U) == null)
			{
				*(*(ref <Module>.struct123_0 + int_16 * 4) + 2382) = 2;
				*(*(ref <Module>.struct123_0 + int_16 * 4) + 2384) = 12;
			}
			else if (<Module>.memcmp(*(ref <Module>.struct123_0 + int_16 * 4) + 2316, (void*)(&<Module>.struct9_22), 28U) == null)
			{
				*(*(ref <Module>.struct123_0 + int_16 * 4) + 2382) = 3;
				*(*(ref <Module>.struct123_0 + int_16 * 4) + 2384) = 1;
			}
			else if (<Module>.memcmp(*(ref <Module>.struct123_0 + int_16 * 4) + 2316, (void*)(&<Module>.struct9_23), 28U) == null)
			{
				*(*(ref <Module>.struct123_0 + int_16 * 4) + 2382) = 3;
				*(*(ref <Module>.struct123_0 + int_16 * 4) + 2384) = 2;
			}
			else if (<Module>.memcmp(*(ref <Module>.struct123_0 + int_16 * 4) + 2316, (void*)(&<Module>.struct9_13), 28U) == null)
			{
				*(*(ref <Module>.struct123_0 + int_16 * 4) + 2382) = 4;
				*(*(ref <Module>.struct123_0 + int_16 * 4) + 2384) = 1;
			}
			else if (<Module>.memcmp(*(ref <Module>.struct123_0 + int_16 * 4) + 2316, (void*)(&<Module>.struct9_14), 28U) == null)
			{
				*(*(ref <Module>.struct123_0 + int_16 * 4) + 2382) = 4;
				*(*(ref <Module>.struct123_0 + int_16 * 4) + 2384) = 2;
			}
			else if (<Module>.memcmp(*(ref <Module>.struct123_0 + int_16 * 4) + 2316, (void*)(&<Module>.struct9_15), 28U) == null)
			{
				*(*(ref <Module>.struct123_0 + int_16 * 4) + 2382) = 4;
				*(*(ref <Module>.struct123_0 + int_16 * 4) + 2384) = 4;
			}
			else if (<Module>.memcmp(*(ref <Module>.struct123_0 + int_16 * 4) + 2316, (void*)(&<Module>.struct9_16), 28U) == null)
			{
				*(*(ref <Module>.struct123_0 + int_16 * 4) + 2382) = 4;
				*(*(ref <Module>.struct123_0 + int_16 * 4) + 2384) = 5;
			}
			else if (<Module>.memcmp(*(ref <Module>.struct123_0 + int_16 * 4) + 2316, (void*)(&<Module>.struct9_17), 28U) == null)
			{
				*(*(ref <Module>.struct123_0 + int_16 * 4) + 2382) = 5;
				*(*(ref <Module>.struct123_0 + int_16 * 4) + 2384) = 1;
			}
			else if (<Module>.memcmp(*(ref <Module>.struct123_0 + int_16 * 4) + 2316, (void*)(&<Module>.struct9_18), 28U) == null)
			{
				*(*(ref <Module>.struct123_0 + int_16 * 4) + 2382) = 5;
				*(*(ref <Module>.struct123_0 + int_16 * 4) + 2384) = 2;
			}
			else if (<Module>.memcmp(*(ref <Module>.struct123_0 + int_16 * 4) + 2316, (void*)(&<Module>.struct9_19), 28U) == null)
			{
				*(*(ref <Module>.struct123_0 + int_16 * 4) + 2382) = 5;
				*(*(ref <Module>.struct123_0 + int_16 * 4) + 2384) = 3;
			}
			else if (<Module>.memcmp(*(ref <Module>.struct123_0 + int_16 * 4) + 2316, (void*)(&<Module>.struct9_20), 28U) == null)
			{
				*(*(ref <Module>.struct123_0 + int_16 * 4) + 2382) = 5;
				*(*(ref <Module>.struct123_0 + int_16 * 4) + 2384) = 4;
			}
			else if (<Module>.memcmp(*(ref <Module>.struct123_0 + int_16 * 4) + 2316, (void*)(&<Module>.struct9_25), 28U) == null)
			{
				*(*(ref <Module>.struct123_0 + int_16 * 4) + 2382) = 6;
				*(*(ref <Module>.struct123_0 + int_16 * 4) + 2384) = 1;
			}
			else if (<Module>.memcmp(*(ref <Module>.struct123_0 + int_16 * 4) + 2316, (void*)(&<Module>.struct9_28), 28U) == null)
			{
				*(*(ref <Module>.struct123_0 + int_16 * 4) + 2382) = 6;
				*(*(ref <Module>.struct123_0 + int_16 * 4) + 2384) = 2;
			}
			else if (<Module>.memcmp(*(ref <Module>.struct123_0 + int_16 * 4) + 2316, (void*)(&<Module>.struct9_26), 28U) == null)
			{
				*(*(ref <Module>.struct123_0 + int_16 * 4) + 2382) = 8;
				*(*(ref <Module>.struct123_0 + int_16 * 4) + 2384) = 1;
			}
			else if (<Module>.memcmp(*(ref <Module>.struct123_0 + int_16 * 4) + 2316, (void*)(&<Module>.struct9_27), 28U) == null)
			{
				*(*(ref <Module>.struct123_0 + int_16 * 4) + 2382) = 8;
				*(*(ref <Module>.struct123_0 + int_16 * 4) + 2384) = 2;
			}
			if (<Module>.memcmp(*(ref <Module>.struct123_0 + int_16 * 4) + 2284, *(ref <Module>.struct123_0 + int_16 * 4) + 2316, 28U) == null)
			{
				<Module>.memset(*(ref <Module>.struct123_0 + int_16 * 4) + 2316, 0, 32U);
				*(*(ref <Module>.struct123_0 + int_16 * 4) + 2382) = 0;
				*(*(ref <Module>.struct123_0 + int_16 * 4) + 2384) = 0;
			}
			<Module>.sprintf((sbyte*)(&struct41), (sbyte*)(&<Module>.struct35_124), *(*(ref <Module>.struct123_0 + int_16 * 4) + 296));
			string text = new string((sbyte*)(&<Module>.struct18_10));
			text += new string((sbyte*)(&struct41));
			if (*(*(ref <Module>.struct123_0 + int_16 * 4) + 296) == 114688 || *(*(ref <Module>.struct123_0 + int_16 * 4) + 296) == 122880 || *(*(ref <Module>.struct123_0 + int_16 * 4) + 296) == 110592 || *(*(ref <Module>.struct123_0 + int_16 * 4) + 296) == 106496 || *(*(ref <Module>.struct123_0 + int_16 * 4) + 296) == 172032)
			{
				text = new string((sbyte*)(&<Module>.struct25_9));
			}
			string text2 = "";
			<Module>.sprintf((sbyte*)(&struct41), (sbyte*)(&<Module>.struct19_0));
			for (i = 0; i < 16; i++)
			{
				<Module>.sprintf((sbyte*)(&struct41), (sbyte*)(&<Module>.struct10_20), ref struct41, *(*(ref <Module>.struct123_0 + int_16 * 4) + 280 + i));
			}
			text2 += new string((sbyte*)(&struct41));
			this.textBox6.AppendText("Drive key @ " + text + " " + text2 + "\r\n");
			string text3 = "";
			<Module>.sprintf((sbyte*)(&struct41), (sbyte*)(&<Module>.struct19_0));
			<Module>.sprintf((sbyte*)(&struct41), *(ref <Module>.struct123_0 + int_16 * 4) + 2284);
			text3 += new string((sbyte*)(&struct41));
			this.textBox6.AppendText("Firmware Osig: [" + text3 + "]" + "\r\n");
			if (*(*(ref <Module>.struct123_0 + int_16 * 4) + 2382) != 0)
			{
				string text4 = "";
				<Module>.sprintf((sbyte*)(&struct41), (sbyte*)(&<Module>.struct19_0));
				<Module>.sprintf((sbyte*)(&struct41), *(ref <Module>.struct123_0 + int_16 * 4) + 2316);
				text4 += new string((sbyte*)(&struct41));
				this.textBox6.AppendText("Spoofed As:" + "    [" + text4 + "]" + "\r\n");
			}
			return 1;
		}

		// Token: 0x060001EC RID: 492 RVA: 0x0015092C File Offset: 0x0015092C
		private unsafe uint method_32(uint uint_0, int* pInt_0)
		{
			uint num = 0U;
			for (int i = 0; i < 32; i++)
			{
				uint num2 = (uint_0 & 1U << pInt_0[i]) >> pInt_0[i];
				num = (num << 1 | num2);
			}
			return num;
		}

		// Token: 0x060001ED RID: 493 RVA: 0x00112C8C File Offset: 0x00112C8C
		private unsafe byte method_33(byte byte_0, int* pInt_0)
		{
			sbyte b = 0;
			for (int i = 0; i < 8; i++)
			{
				sbyte b2 = (sbyte)(((int)byte_0 & 1 << pInt_0[i]) >> pInt_0[i]);
				b = (sbyte)((int)b << 1 | (int)b2);
			}
			return (byte)b;
		}

		// Token: 0x060001EE RID: 494 RVA: 0x00112CC8 File Offset: 0x00112CC8
		private unsafe void method_34(byte* pByte_0, byte* pByte_1)
		{
			Struct78 @struct = 5;
			*(ref @struct + 4) = 4;
			*(ref @struct + 8) = 1;
			*(ref @struct + 12) = 0;
			*(ref @struct + 16) = 7;
			*(ref @struct + 20) = 6;
			*(ref @struct + 24) = 3;
			*(ref @struct + 28) = 2;
			Struct28 struct2 = 111;
			*(ref struct2 + 1) = 159;
			*(ref struct2 + 2) = 163;
			*(ref struct2 + 3) = 191;
			*(ref struct2 + 4) = 58;
			*(ref struct2 + 5) = 35;
			*(ref struct2 + 6) = 187;
			*(ref struct2 + 7) = 173;
			*(ref struct2 + 8) = 111;
			*(ref struct2 + 9) = 59;
			*(ref struct2 + 10) = 238;
			*(ref struct2 + 11) = 254;
			*(ref struct2 + 12) = 45;
			*(ref struct2 + 13) = 125;
			*(ref struct2 + 14) = 124;
			*(ref struct2 + 15) = 188;
			for (int i = 0; i < 16; i++)
			{
				byte byte_ = pByte_0[i];
				byte b = this.method_33(byte_, (int*)(&@struct));
				pByte_1[i] = (b ^ *(ref struct2 + i));
			}
		}

		// Token: 0x060001EF RID: 495 RVA: 0x00112DC0 File Offset: 0x00112DC0
		private unsafe void method_35(byte* pByte_0, byte* pByte_1)
		{
			Struct78 @struct = 3;
			*(ref @struct + 4) = 2;
			*(ref @struct + 8) = 7;
			*(ref @struct + 12) = 6;
			*(ref @struct + 16) = 1;
			*(ref @struct + 20) = 0;
			*(ref @struct + 24) = 5;
			*(ref @struct + 28) = 4;
			Struct28 struct2 = 111;
			*(ref struct2 + 1) = 159;
			*(ref struct2 + 2) = 163;
			*(ref struct2 + 3) = 191;
			*(ref struct2 + 4) = 58;
			*(ref struct2 + 5) = 35;
			*(ref struct2 + 6) = 187;
			*(ref struct2 + 7) = 173;
			*(ref struct2 + 8) = 111;
			*(ref struct2 + 9) = 59;
			*(ref struct2 + 10) = 238;
			*(ref struct2 + 11) = 254;
			*(ref struct2 + 12) = 45;
			*(ref struct2 + 13) = 125;
			*(ref struct2 + 14) = 124;
			*(ref struct2 + 15) = 188;
			for (int i = 0; i < 16; i++)
			{
				byte byte_ = pByte_0[i] ^ *(ref struct2 + i);
				byte b = this.method_33(byte_, (int*)(&@struct));
				pByte_1[i] = b;
			}
		}

		// Token: 0x060001F0 RID: 496 RVA: 0x00112EB8 File Offset: 0x00112EB8
		private unsafe int method_36(string string_25, int int_16)
		{
			string text = new string((sbyte*)(&<Module>.struct19_0));
			int num = 1;
			if (int_16 == 5)
			{
				int_16 = 0;
				num = 0;
			}
			<Module>.memset(*(ref <Module>.struct123_0 + int_16 * 4), 0, 2392U);
			Struct68 @struct;
			<Module>.memset((void*)(&@struct), 0, 260U);
			string text2 = new string((sbyte*)(&<Module>.struct19_0));
			text2 = Path.GetFullPath(string_25);
			void* ptr = null;
			IntPtr intPtr = Marshal.StringToHGlobalAnsi(text2);
			IntPtr value = intPtr;
			ptr = (void*)value;
			int result;
			try
			{
				<Module>.memcpy((void*)(&@struct), (void*)ptr, 260U);
				goto IL_C1;
			}
			catch (Exception ex)
			{
				string message = ex.Message;
				if (<Module>.memcmp((void*)(&@struct), (void*)ptr, <Module>.strlen((sbyte*)(&@struct))) == null)
				{
					goto IL_C1;
				}
				this.textBox6.AppendText("Debug:: Memcpy failed" + "\r\n");
				result = 0;
			}
			return result;
			IL_C1:
			<Module>.GetLongPathNameA((sbyte*)(&@struct), *(ref <Module>.struct123_0 + int_16 * 4) + 300, 260);
			<Module>.memcpy((void*)(&@struct), *(ref <Module>.struct123_0 + int_16 * 4) + 300, 260U);
			text2 = Path.GetFileName(new string((sbyte*)(&@struct)));
			ptr = null;
			IntPtr intPtr2 = Marshal.StringToHGlobalAnsi(text2);
			IntPtr value2 = intPtr2;
			ptr = (void*)value2;
			if (*(ref <Module>.struct123_0 + int_16 * 4) + 4 == 0)
			{
				this.textBox6.AppendText("Debug:: Gotcha 2" + text2 + "\r\n");
			}
			int result2;
			try
			{
				<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 4, (void*)ptr, 260U);
				goto IL_1BD;
			}
			catch (Exception ex2)
			{
				string message2 = ex2.Message;
				if (<Module>.memcmp(*(ref <Module>.struct123_0 + int_16 * 4) + 4, (void*)ptr, <Module>.strlen(ref <Module>.struct121_0 + int_16 * 2392 + 4)) == null)
				{
					goto IL_1BD;
				}
				this.textBox6.AppendText("Debug:: Memcpy failed" + "\r\n");
				result2 = 0;
			}
			return result2;
			IL_1BD:
			this.textBox6.AppendText("Loading firmware file " + new string((sbyte*)(&@struct)) + "\r\n");
			GStruct93 gstruct;
			<Module>.smethod_111(ref gstruct);
			int result3;
			try
			{
				GStruct19 gstruct2;
				GStruct19* pGstruct19_ = <Module>.smethod_91(ref gstruct2, (sbyte*)(&@struct));
				GStruct19 gstruct3;
				<Module>.smethod_114(ref gstruct, &gstruct3, (GStruct19*)pGstruct19_);
				try
				{
					GStruct19 gstruct4;
					GStruct19* pGstruct19_2 = <Module>.smethod_91(ref gstruct4, (sbyte*)(&@struct));
					Struct28 struct2;
					<Module>.smethod_116(ref gstruct, (GStruct19*)pGstruct19_2, (byte*)(&struct2));
					<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 264, (void*)(&struct2), 16U);
					text = new string(<Module>.smethod_94(ref gstruct3));
					this.textBox6.AppendText("MD5 hash:  " + text + "\r\n");
					this.method_45(text);
					this.method_44(*(ref <Module>.struct123_0 + int_16 * 4) + 300, int_16);
					int num2 = this.method_31(int_16);
					if (num2 == 2)
					{
						num2 = this.method_31(int_16);
					}
					if (num2 != 3)
					{
						goto IL_34F;
					}
					if (int_16 != 0)
					{
						goto IL_2F6;
					}
					this.method_40();
					this.method_39();
					this.tabControl5.SelectedTab = this.Firmtools;
					result3 = 0;
				}
				catch
				{
					<Module>.__CxxCallUnwindDtor(<Module>.ppInt_14, (void*)(&gstruct3));
					throw;
				}
				<Module>.smethod_92(ref gstruct3);
			}
			catch
			{
				<Module>.__CxxCallUnwindDtor(<Module>.ppInt_13, (void*)(&gstruct));
				throw;
			}
			<Module>.smethod_112(ref gstruct);
			return result3;
			int result4;
			try
			{
				GStruct19 gstruct3;
				try
				{
					IL_2F6:
					if (int_16 != 1)
					{
						goto IL_34F;
					}
					this.method_43();
					this.method_42();
					this.tabControl5.SelectedTab = this.Firmtools;
					result4 = 0;
				}
				catch
				{
					<Module>.__CxxCallUnwindDtor(<Module>.ppInt_14, (void*)(&gstruct3));
					throw;
				}
				<Module>.smethod_92(ref gstruct3);
			}
			catch
			{
				<Module>.__CxxCallUnwindDtor(<Module>.ppInt_13, (void*)(&gstruct));
				throw;
			}
			<Module>.smethod_112(ref gstruct);
			return result4;
			int result5;
			try
			{
				GStruct19 gstruct3;
				try
				{
					IL_34F:
					int num2;
					if (num2 != 0)
					{
						goto IL_3B8;
					}
					if (int_16 == 0)
					{
						this.method_40();
					}
					if (int_16 == 1)
					{
						this.method_43();
					}
					this.textBox6.AppendText("Parse Failed !" + "\r\n\r\n");
					result5 = 0;
				}
				catch
				{
					<Module>.__CxxCallUnwindDtor(<Module>.ppInt_14, (void*)(&gstruct3));
					throw;
				}
				<Module>.smethod_92(ref gstruct3);
			}
			catch
			{
				<Module>.__CxxCallUnwindDtor(<Module>.ppInt_13, (void*)(&gstruct));
				throw;
			}
			<Module>.smethod_112(ref gstruct);
			return result5;
			int result6;
			try
			{
				GStruct19 gstruct3;
				try
				{
					IL_3B8:
					this.string_0 = "";
					this.method_7(*(ref <Module>.struct123_0 + int_16 * 4) + 2348);
					this.textBox6.AppendText("Firmware is:  " + this.string_0 + "\r\n");
					if (int_16 == 0)
					{
						this.method_40();
						this.method_38();
						if (*<Module>.struct123_0 == 4 && num == 1)
						{
							this.method_48();
						}
						if (num == 1)
						{
							this.tabControl5.SelectedTab = this.Firmtools;
							if (this.method_49() == 1)
							{
								this.method_46();
								this.method_47();
								this.method_41();
							}
						}
					}
					else if (int_16 == 1)
					{
						this.method_43();
						this.method_41();
					}
					if (*<Module>.struct123_0 != 0 && *(*(ref <Module>.struct123_0 + 4)) != 0)
					{
						this.button6.Enabled = true;
					}
					this.tabControl5.SelectedTab = this.Firmtools;
					result6 = 1;
				}
				catch
				{
					<Module>.__CxxCallUnwindDtor(<Module>.ppInt_14, (void*)(&gstruct3));
					throw;
				}
				<Module>.smethod_92(ref gstruct3);
			}
			catch
			{
				<Module>.__CxxCallUnwindDtor(<Module>.ppInt_13, (void*)(&gstruct));
				throw;
			}
			<Module>.smethod_112(ref gstruct);
			return result6;
		}

		// Token: 0x060001F1 RID: 497 RVA: 0x00113488 File Offset: 0x00113488
		private unsafe int method_37(string string_25, int int_16, byte* pByte_0)
		{
			int num = 1;
			if (int_16 == 5)
			{
				int_16 = 0;
				num = 0;
			}
			this.textBox6.AppendText("Loading firmware from buffer" + "\r\n");
			<Module>.memset(*(ref <Module>.struct123_0 + int_16 * 4), 0, 2392U);
			Struct68 @struct;
			<Module>.memset((void*)(&@struct), 0, 260U);
			if (string.Compare(string_25, "") != 0)
			{
				string text = Path.GetFullPath(string_25);
				void* ptr = null;
				IntPtr intPtr = Marshal.StringToHGlobalAnsi(text);
				IntPtr value = intPtr;
				ptr = (void*)value;
				int result;
				try
				{
					<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 300, (void*)ptr, 260U);
					goto IL_ED;
				}
				catch (Exception ex)
				{
					string message = ex.Message;
					if (<Module>.memcmp(*(ref <Module>.struct123_0 + int_16 * 4) + 300, (void*)ptr, <Module>.strlen((sbyte*)(&@struct))) == null)
					{
						goto IL_ED;
					}
					this.textBox6.AppendText("Debug:: Memcpy failed" + "\r\n");
					result = 0;
				}
				return result;
				IL_ED:
				<Module>.memcpy((void*)(&@struct), *(ref <Module>.struct123_0 + int_16 * 4) + 300, 260U);
				text = Path.GetFileName(string_25);
				ptr = null;
				IntPtr intPtr2 = Marshal.StringToHGlobalAnsi(text);
				IntPtr value2 = intPtr2;
				ptr = (void*)value2;
				if (*(ref <Module>.struct123_0 + int_16 * 4) + 4 == 0)
				{
					this.textBox6.AppendText("Debug:: Gotcha 2" + text + "\r\n");
				}
				int result2;
				try
				{
					<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 4, (void*)ptr, 260U);
					goto IL_1C6;
				}
				catch (Exception ex2)
				{
					string message2 = ex2.Message;
					if (<Module>.memcmp(*(ref <Module>.struct123_0 + int_16 * 4) + 4, (void*)ptr, <Module>.strlen(ref <Module>.struct121_0 + int_16 * 2392 + 4)) == null)
					{
						goto IL_1C6;
					}
					this.textBox6.AppendText("Debug:: Memcpy failed" + "\r\n");
					result2 = 0;
				}
				return result2;
			}
			IL_1C6:
			<Module>.memcpy(*(ref <Module>.struct121_0 + int_16 * 2392 + 2388), (void*)pByte_0, 262144U);
			int num2 = this.method_31(int_16);
			if (num2 == 3)
			{
				if (int_16 == 0)
				{
					this.method_40();
					this.method_39();
					this.tabControl5.SelectedTab = this.Firmtools;
					return 0;
				}
				if (int_16 == 1)
				{
					this.method_43();
					this.method_42();
					this.tabControl5.SelectedTab = this.Firmtools;
					return 0;
				}
			}
			int result3;
			if (num2 == 0)
			{
				if (int_16 == 0)
				{
					this.method_40();
				}
				if (int_16 == 1)
				{
					this.method_43();
				}
				this.textBox6.AppendText("Parse Failed !" + "\r\n\r\n");
				result3 = 0;
			}
			else
			{
				this.string_0 = "";
				this.method_7(*(ref <Module>.struct123_0 + int_16 * 4) + 2348);
				this.textBox6.AppendText("Firmware is:  " + this.string_0 + "\r\n");
				if (int_16 == 0)
				{
					this.method_40();
					this.method_38();
					if (!this.bool_4)
					{
						this.method_27();
					}
					if (*<Module>.struct123_0 == 4)
					{
						this.method_48();
					}
					if (num == 1)
					{
						this.tabControl5.SelectedTab = this.Firmtools;
						if (this.method_49() == 1)
						{
							this.method_46();
							this.method_47();
							this.method_41();
						}
					}
				}
				else if (int_16 == 1)
				{
					this.method_43();
					this.method_41();
				}
				if (*<Module>.struct123_0 != 0 && *(*(ref <Module>.struct123_0 + 4)) != 0)
				{
					this.button6.Enabled = true;
				}
				this.tabControl5.SelectedTab = this.Firmtools;
				result3 = 1;
			}
			return result3;
		}

		// Token: 0x060001F2 RID: 498 RVA: 0x003BFDD4 File Offset: 0x00307DD4
		private unsafe void method_38()
		{
			Struct68 @struct = 0;
			initblk(ref @struct + 1, 0, 259);
			if (*<Module>.struct123_0 == *(<Module>.struct123_0 + 2382) && *(<Module>.struct123_0 + 2) == *(<Module>.struct123_0 + 2384))
			{
				<Module>.memset(<Module>.struct123_0 + 2316, 0, 28U);
				*(<Module>.struct123_0 + 2382) = 0;
				*(<Module>.struct123_0 + 2384) = 0;
			}
			string str = new string((sbyte*)(&<Module>.struct19_0));
			<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct19_0));
			<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct35_124), *(<Module>.struct123_0 + 296));
			this.label37.Text = str + new string((sbyte*)(&@struct));
			if (*(<Module>.struct123_0 + 296) == 114688 || *(<Module>.struct123_0 + 296) == 122880 || *(<Module>.struct123_0 + 296) == 106496 || *(<Module>.struct123_0 + 296) == 110592 || *(<Module>.struct123_0 + 296) == 172032)
			{
				this.label37.Text = "n/a";
			}
			this.label38.Text = this.label37.Text;
			string str2 = "";
			<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct19_0));
			for (int i = 0; i < 16; i++)
			{
				<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct10_20), ref @struct, *(<Module>.struct123_0 + 280 + i));
			}
			this.textBox9.Text = str2 + new string((sbyte*)(&@struct));
			this.textBox3.Text = this.textBox9.Text;
			string str3 = "";
			<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct19_0));
			<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct35_125), <Module>.struct123_0 + 2284);
			this.label44.Text = str3 + new string((sbyte*)(&@struct));
			this.label45.Text = this.label44.Text;
			if (*<Module>.struct123_0 == 2)
			{
				string str4 = "";
				<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct19_0));
				<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct10_21), *(<Module>.struct123_0 + 2020));
				this.label101.Text = str4 + new string((sbyte*)(&@struct));
				this.label128.Text = this.label101.Text;
			}
			string str5 = "";
			<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct19_0));
			<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct35_125), <Module>.struct123_0 + 2316);
			this.label40.Text = str5 + new string((sbyte*)(&@struct));
			this.label39.Text = this.label40.Text;
			if (*(<Module>.struct123_0 + 2384) == 0)
			{
				this.label42.Visible = false;
				this.label41.Visible = false;
				this.label40.Visible = false;
				this.label39.Visible = false;
			}
			else
			{
				this.label42.Visible = true;
				this.label41.Visible = true;
				this.label40.Visible = true;
				this.label39.Visible = true;
			}
			<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct19_0));
			<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct18_9), <Module>.struct123_0 + 300);
			this.textBox15.Text = str + new string((sbyte*)(&@struct));
			this.textBox16.Text = this.textBox15.Text;
			if (*<Module>.struct123_0 == 1)
			{
				this.label6.Text = "Samsung";
				this.label7.Text = "TS-H943A";
				if (*(<Module>.struct123_0 + 2) == 1)
				{
					this.label8.Text = "MS25";
				}
				else if (*(<Module>.struct123_0 + 2) == 2)
				{
					this.label8.Text = "MS28";
				}
			}
			else if (*<Module>.struct123_0 == 2)
			{
				this.label6.Text = "Hitachi";
				this.label7.Text = "GDR3120L";
				if (*(<Module>.struct123_0 + 2) == 1)
				{
					this.label8.Text = "0032";
				}
				else if (*(<Module>.struct123_0 + 2) == 2)
				{
					this.label8.Text = "0036";
				}
				else if (*(<Module>.struct123_0 + 2) == 3)
				{
					this.label8.Text = "0040";
				}
				else if (*(<Module>.struct123_0 + 2) == 4)
				{
					this.label8.Text = "0046";
				}
				else if (*(<Module>.struct123_0 + 2) == 5)
				{
					this.label8.Text = "0047";
				}
				else if (*(<Module>.struct123_0 + 2) == 6)
				{
					this.label8.Text = "0058";
				}
				else if (*(<Module>.struct123_0 + 2) == 7)
				{
					this.label8.Text = "0059";
				}
				else if (*(<Module>.struct123_0 + 2) == 8)
				{
					this.label8.Text = "0078";
				}
				else if (*(<Module>.struct123_0 + 2) == 9)
				{
					this.label8.Text = "0078";
				}
				else if (*(<Module>.struct123_0 + 2) == 10)
				{
					this.label8.Text = "0078";
				}
				else if (*(<Module>.struct123_0 + 2) == 11)
				{
					this.label8.Text = "0078";
				}
				else if (*(<Module>.struct123_0 + 2) == 12)
				{
					this.label8.Text = "0079";
				}
				else if (*(<Module>.struct123_0 + 2) == 13)
				{
					this.label8.Text = "0079";
				}
				else if (*(<Module>.struct123_0 + 2) == 14)
				{
					this.label8.Text = "0079";
				}
				else if (*(<Module>.struct123_0 + 2) == 15)
				{
					this.label8.Text = "0079";
				}
			}
			else if (*<Module>.struct123_0 == 3)
			{
				this.label6.Text = "Benq";
				this.label7.Text = "VAD6038";
				if (*(<Module>.struct123_0 + 2) == 1)
				{
					this.label8.Text = "62430C";
				}
				else if (*(<Module>.struct123_0 + 2) == 2)
				{
					this.label8.Text = "64930C";
				}
				else if (*(<Module>.struct123_0 + 2) == 3)
				{
					this.label8.Text = "04421C";
				}
			}
			else if (*<Module>.struct123_0 == 4)
			{
				this.label6.Text = "Lite-On";
				this.label7.Text = "DG-16D2S";
				if (*(<Module>.struct123_0 + 2) == 1)
				{
					this.label8.Text = "74850C";
				}
				else if (*(<Module>.struct123_0 + 2) == 2)
				{
					this.label8.Text = "83850C";
				}
				else if (*(<Module>.struct123_0 + 2) == 3)
				{
					this.label8.Text = "83850Cv2";
				}
				else if (*(<Module>.struct123_0 + 2) == 4)
				{
					this.label8.Text = "93450C";
				}
				else if (*(<Module>.struct123_0 + 2) == 5)
				{
					this.label8.Text = "02510C";
				}
			}
			else if (*<Module>.struct123_0 == 5)
			{
				this.label6.Text = "Lite-On";
				this.label7.Text = "DG-16D4S";
				if (*(<Module>.struct123_0 + 2) == 1)
				{
					this.label8.Text = "9504";
				}
				if (*(<Module>.struct123_0 + 2) == 2)
				{
					this.label8.Text = "0225";
				}
				if (*(<Module>.struct123_0 + 2) == 3)
				{
					this.label8.Text = "0401";
				}
				if (*(<Module>.struct123_0 + 2) == 4)
				{
					this.label8.Text = "0272";
				}
				if (*(<Module>.struct123_0 + 2) == 5)
				{
					this.label8.Text = "1071";
				}
			}
			else if (*<Module>.struct123_0 == 6)
			{
				this.label6.Text = "Lite-On";
				this.label7.Text = "DG-16D5S";
				if (*(<Module>.struct123_0 + 2) == 1)
				{
					this.label8.Text = "1175";
				}
				if (*(<Module>.struct123_0 + 2) == 2)
				{
					this.label8.Text = "1532";
				}
				if (*(<Module>.struct123_0 + 2) == 3)
				{
					this.label8.Text = "0500";
				}
				if (*(<Module>.struct123_0 + 2) == 4)
				{
					this.label8.Text = "0502";
				}
				if (*(<Module>.struct123_0 + 2) == 5)
				{
					this.label8.Text = "0225";
				}
				if (*(<Module>.struct123_0 + 2) == 6)
				{
					this.label8.Text = "0401";
				}
				if (*(<Module>.struct123_0 + 2) == 7)
				{
					this.label8.Text = "1071";
				}
			}
			else if (*<Module>.struct123_0 == 7)
			{
				this.label6.Text = "Xecuter";
				this.label7.Text = "LTU2";
				if (*(<Module>.struct123_0 + 2) == 1)
				{
					this.label8.Text = "1175";
				}
				if (*(<Module>.struct123_0 + 2) == 2)
				{
					this.label8.Text = "1532";
				}
				if (*(<Module>.struct123_0 + 2) == 3)
				{
					this.label8.Text = "0500";
				}
				if (*(<Module>.struct123_0 + 2) == 4)
				{
					this.label8.Text = "0502";
				}
				if (*(<Module>.struct123_0 + 2) == 5)
				{
					this.label8.Text = "0272";
				}
				if (*(<Module>.struct123_0 + 2) == 6)
				{
					this.label8.Text = "0225";
				}
				if (*(<Module>.struct123_0 + 2) == 7)
				{
					this.label8.Text = "0401";
				}
				if (*(<Module>.struct123_0 + 2) == 8)
				{
					this.label8.Text = "1071";
				}
			}
			this.label26.Text = this.label6.Text;
			this.label25.Text = this.label7.Text;
			this.label24.Text = this.label8.Text;
			this.string_0 = "";
			this.method_7(<Module>.struct123_0 + 2348);
			this.label16.Text = this.string_0;
			this.label22.Text = this.label16.Text;
			this.string_0 = "";
			this.method_5(<Module>.struct123_0 + 568, 96U, 0U);
			this.textBox7.Text = this.string_0;
			if (*<Module>.struct123_0 == 6 || *<Module>.struct123_0 == 5 || *<Module>.struct123_0 == 7)
			{
				this.string_0 = "";
				this.method_5(<Module>.struct123_0 + 568, 116U, 0U);
				this.textBox7.Text = this.string_0;
			}
			this.string_0 = "";
			this.method_5(<Module>.struct123_0 + 780, 180U, 0U);
			this.textBox10.Text = this.string_0;
			this.string_0 = "";
			if (*<Module>.struct123_0 != 3)
			{
				if (*<Module>.struct123_0 != 4)
				{
					if (*<Module>.struct123_0 == 5)
					{
						this.method_5(<Module>.struct123_0 + 2028, 224U, 0U);
						goto IL_C60;
					}
					if (*<Module>.struct123_0 == 6)
					{
						this.method_5(<Module>.struct123_0 + 2028, 96U, 0U);
						goto IL_C60;
					}
					if (*<Module>.struct123_0 == 7)
					{
						this.method_5(<Module>.struct123_0 + 2028, 96U, 0U);
						goto IL_C60;
					}
					if (*<Module>.struct123_0 == 2)
					{
						this.method_5(<Module>.struct123_0 + 2028, 20U, 0U);
						goto IL_C60;
					}
					goto IL_C60;
				}
			}
			this.method_5(<Module>.struct123_0 + 2028, 80U, 0U);
			IL_C60:
			this.textBox12.Text = this.string_0;
			this.DumpDrive.Enabled = true;
			this.menuItem_6.Enabled = true;
			this.menuItem_7.Enabled = true;
			this.menuItem_13.Enabled = true;
			this.menuItem_19.Enabled = true;
			this.menuItem_33.Enabled = true;
		}

		// Token: 0x060001F3 RID: 499 RVA: 0x001144D0 File Offset: 0x001144D0
		private unsafe void method_39()
		{
			Struct68 @struct = 0;
			initblk(ref @struct + 1, 0, 259);
			Struct71 struct2 = 0;
			initblk(ref struct2 + 1, 0, 15);
			Struct71 struct3 = 0;
			initblk(ref struct3 + 1, 0, 15);
			string str = "";
			<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct19_0));
			<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct18_9), <Module>.struct123_0 + 2284);
			this.label44.Text = str + new string((sbyte*)(&@struct));
			this.label45.Text = this.label44.Text;
			string str2 = "";
			<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct19_0));
			<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct18_9), <Module>.struct123_0 + 300);
			this.textBox15.Text = str2 + new string((sbyte*)(&@struct));
			this.textBox16.Text = this.textBox15.Text;
			this.label6.Text = "Samsung";
			this.label26.Text = this.label6.Text;
			string str3 = "";
			<Module>.memcpy((void*)(&struct2), <Module>.struct123_0 + 2300, 8U);
			<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct19_0));
			<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct18_9), ref struct2);
			this.label7.Text = str3 + new string((sbyte*)(&@struct));
			this.label25.Text = this.label7.Text;
			string str4 = "";
			<Module>.memcpy((void*)(&struct3), <Module>.struct123_0 + 2308, 4U);
			<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct19_0));
			<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct18_9), ref struct3);
			this.label8.Text = str4 + new string((sbyte*)(&@struct));
			this.label24.Text = this.label8.Text;
			this.string_0 = "";
			this.method_7(<Module>.struct123_0 + 2348);
			this.label16.Text = this.string_0;
			this.label22.Text = this.label16.Text;
			this.string_0 = "";
			this.method_5(<Module>.struct123_0 + 568, 96U, 0U);
			this.textBox7.Text = this.string_0;
			this.string_0 = "";
			this.method_5(<Module>.struct123_0 + 780, 180U, 0U);
			this.textBox10.Text = this.string_0;
			this.menuItem_6.Enabled = true;
		}

		// Token: 0x060001F4 RID: 500 RVA: 0x00114768 File Offset: 0x00114768
		private void method_40()
		{
			this.textBox3.Text = "";
			this.textBox7.Text = "";
			this.textBox9.Text = "";
			this.textBox10.Text = "";
			this.textBox12.Text = "";
			this.textBox15.Text = "";
			this.textBox16.Text = "";
			this.label6.Text = "";
			this.label7.Text = "";
			this.label8.Text = "";
			this.label16.Text = "";
			this.label22.Text = "";
			this.label24.Text = "";
			this.label25.Text = "";
			this.label26.Text = "";
			this.label37.Text = "";
			this.label38.Text = "";
			this.label39.Text = "";
			this.label40.Text = "";
			this.label44.Text = "";
			this.label45.Text = "";
			this.label101.Text = "";
			this.label128.Text = "";
			this.button6.Enabled = false;
			this.bool_10 = false;
			this.DumpDrive.Enabled = false;
			this.menuItem_6.Enabled = false;
			this.menuItem_7.Enabled = false;
			this.menuItem_13.Enabled = false;
			this.menuItem_19.Enabled = false;
			this.menuItem_33.Enabled = false;
		}

		// Token: 0x060001F5 RID: 501 RVA: 0x003C0A9C File Offset: 0x00308A9C
		private unsafe void method_41()
		{
			Struct68 @struct = 0;
			initblk(ref @struct + 1, 0, 259);
			if (*(*(ref <Module>.struct123_0 + 4)) == *(*(ref <Module>.struct123_0 + 4) + 2382) && *(*(ref <Module>.struct123_0 + 4) + 2) == *(*(ref <Module>.struct123_0 + 4) + 2384))
			{
				<Module>.memset(*(ref <Module>.struct123_0 + 4) + 2316, 0, 28U);
				*(*(ref <Module>.struct123_0 + 4) + 2382) = 0;
				*(*(ref <Module>.struct123_0 + 4) + 2384) = 0;
			}
			string str = new string((sbyte*)(&<Module>.struct19_0));
			<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct19_0));
			<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct35_124), *(*(ref <Module>.struct123_0 + 4) + 296));
			this.label55.Text = str + new string((sbyte*)(&@struct));
			if (*(*(ref <Module>.struct123_0 + 4) + 296) == 114688 || *(*(ref <Module>.struct123_0 + 4) + 296) == 122880 || *(*(ref <Module>.struct123_0 + 4) + 296) == 106496 || *(*(ref <Module>.struct123_0 + 4) + 296) == 110592 || *(*(ref <Module>.struct123_0 + 4) + 296) == 172032)
			{
				this.label55.Text = "n/a";
			}
			this.label56.Text = this.label55.Text;
			string str2 = "";
			<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct19_0));
			for (int i = 0; i < 16; i++)
			{
				<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct10_20), ref @struct, *(*(ref <Module>.struct123_0 + 4) + 280 + i));
			}
			this.textBox11.Text = str2 + new string((sbyte*)(&@struct));
			this.textBox1.Text = this.textBox11.Text;
			string str3 = "";
			<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct19_0));
			<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct35_125), *(ref <Module>.struct123_0 + 4) + 2284);
			this.label48.Text = str3 + new string((sbyte*)(&@struct));
			this.label53.Text = this.label48.Text;
			if (*(*(ref <Module>.struct123_0 + 4)) == 2)
			{
				string str4 = "";
				<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct19_0));
				<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct10_21), *(*(ref <Module>.struct123_0 + 4) + 2020));
				this.label71.Text = str4 + new string((sbyte*)(&@struct));
				this.label129.Text = this.label71.Text;
			}
			string str5 = "";
			<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct19_0));
			<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct35_125), *(ref <Module>.struct123_0 + 4) + 2316);
			this.label50.Text = str5 + new string((sbyte*)(&@struct));
			this.label54.Text = this.label50.Text;
			if (*(*(ref <Module>.struct123_0 + 4) + 2384) == 0)
			{
				this.label49.Visible = false;
				this.label50.Visible = false;
				this.label54.Visible = false;
				this.label52.Visible = false;
			}
			else
			{
				this.label49.Visible = true;
				this.label50.Visible = true;
				this.label54.Visible = true;
				this.label52.Visible = true;
			}
			<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct19_0));
			<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct18_9), *(ref <Module>.struct123_0 + 4) + 300);
			this.textBox17.Text = str + new string((sbyte*)(&@struct));
			this.textBox18.Text = this.textBox17.Text;
			if (*(*(ref <Module>.struct123_0 + 4)) == 1)
			{
				this.label11.Text = "Samsung";
				this.label10.Text = "TS-H943A";
				if (*(*(ref <Module>.struct123_0 + 4) + 2) == 1)
				{
					this.label9.Text = "MS25";
				}
				else if (*(*(ref <Module>.struct123_0 + 4) + 2) == 2)
				{
					this.label9.Text = "MS28";
				}
			}
			else if (*(*(ref <Module>.struct123_0 + 4)) == 2)
			{
				this.label11.Text = "Hitachi";
				this.label10.Text = "GDR3120L";
				if (*(*(ref <Module>.struct123_0 + 4) + 2) == 1)
				{
					this.label9.Text = "0032";
				}
				else if (*(*(ref <Module>.struct123_0 + 4) + 2) == 2)
				{
					this.label9.Text = "0036";
				}
				else if (*(*(ref <Module>.struct123_0 + 4) + 2) == 3)
				{
					this.label9.Text = "0040";
				}
				else if (*(*(ref <Module>.struct123_0 + 4) + 2) == 4)
				{
					this.label9.Text = "0046";
				}
				else if (*(*(ref <Module>.struct123_0 + 4) + 2) == 5)
				{
					this.label9.Text = "0047";
				}
				else if (*(*(ref <Module>.struct123_0 + 4) + 2) == 6)
				{
					this.label9.Text = "0058";
				}
				else if (*(*(ref <Module>.struct123_0 + 4) + 2) == 7)
				{
					this.label9.Text = "0059";
				}
				else if (*(*(ref <Module>.struct123_0 + 4) + 2) == 8)
				{
					this.label9.Text = "0078";
				}
				else if (*(*(ref <Module>.struct123_0 + 4) + 2) == 9)
				{
					this.label9.Text = "0078";
				}
				else if (*(*(ref <Module>.struct123_0 + 4) + 2) == 10)
				{
					this.label9.Text = "0078";
				}
				else if (*(*(ref <Module>.struct123_0 + 4) + 2) == 11)
				{
					this.label9.Text = "0078";
				}
				else if (*(*(ref <Module>.struct123_0 + 4) + 2) == 12)
				{
					this.label9.Text = "0079";
				}
				else if (*(*(ref <Module>.struct123_0 + 4) + 2) == 13)
				{
					this.label9.Text = "0079";
				}
				else if (*(*(ref <Module>.struct123_0 + 4) + 2) == 14)
				{
					this.label9.Text = "0079";
				}
				else if (*(*(ref <Module>.struct123_0 + 4) + 2) == 15)
				{
					this.label9.Text = "0079";
				}
			}
			else if (*(*(ref <Module>.struct123_0 + 4)) == 3)
			{
				this.label11.Text = "Benq";
				this.label10.Text = "VAD6038";
				if (*(*(ref <Module>.struct123_0 + 4) + 2) == 1)
				{
					this.label9.Text = "62430C";
				}
				else if (*(*(ref <Module>.struct123_0 + 4) + 2) == 2)
				{
					this.label9.Text = "64930C";
				}
				else if (*(*(ref <Module>.struct123_0 + 4) + 2) == 3)
				{
					this.label9.Text = "04421C";
				}
			}
			else if (*(*(ref <Module>.struct123_0 + 4)) == 4)
			{
				this.label11.Text = "Lite-On";
				this.label10.Text = "DG-16D2S";
				if (*(*(ref <Module>.struct123_0 + 4) + 2) == 1)
				{
					this.label9.Text = "74850C";
				}
				else if (*(*(ref <Module>.struct123_0 + 4) + 2) == 2)
				{
					this.label9.Text = "83850C";
				}
				else if (*(*(ref <Module>.struct123_0 + 4) + 2) == 3)
				{
					this.label9.Text = "83850Cv2";
				}
				else if (*(*(ref <Module>.struct123_0 + 4) + 2) == 4)
				{
					this.label9.Text = "93450C";
				}
				else if (*(*(ref <Module>.struct123_0 + 4) + 2) == 5)
				{
					this.label9.Text = "02510C";
				}
			}
			else if (*(*(ref <Module>.struct123_0 + 4)) == 5)
			{
				this.label11.Text = "Lite-On";
				this.label10.Text = "DG-16D4S";
				if (*(*(ref <Module>.struct123_0 + 4) + 2) == 1)
				{
					this.label9.Text = "9504";
				}
				if (*(*(ref <Module>.struct123_0 + 4) + 2) == 2)
				{
					this.label9.Text = "0225";
				}
				if (*(*(ref <Module>.struct123_0 + 4) + 2) == 3)
				{
					this.label9.Text = "0401";
				}
				if (*(*(ref <Module>.struct123_0 + 4) + 2) == 4)
				{
					this.label9.Text = "0272";
				}
				if (*(*(ref <Module>.struct123_0 + 4) + 2) == 5)
				{
					this.label9.Text = "1071";
				}
			}
			else if (*(*(ref <Module>.struct123_0 + 4)) == 6)
			{
				this.label11.Text = "Lite-On";
				this.label10.Text = "DG-16D5S";
				if (*(*(ref <Module>.struct123_0 + 4) + 2) == 1)
				{
					this.label9.Text = "1175";
				}
				if (*(*(ref <Module>.struct123_0 + 4) + 2) == 2)
				{
					this.label9.Text = "1532";
				}
				if (*(*(ref <Module>.struct123_0 + 4) + 2) == 3)
				{
					this.label9.Text = "0500";
				}
				if (*(*(ref <Module>.struct123_0 + 4) + 2) == 4)
				{
					this.label9.Text = "0502";
				}
				if (*(*(ref <Module>.struct123_0 + 4) + 2) == 5)
				{
					this.label9.Text = "0225";
				}
				if (*(*(ref <Module>.struct123_0 + 4) + 2) == 6)
				{
					this.label9.Text = "0401";
				}
				if (*(*(ref <Module>.struct123_0 + 4) + 2) == 7)
				{
					this.label9.Text = "1071";
				}
			}
			else if (*(*(ref <Module>.struct123_0 + 4)) == 7)
			{
				this.label11.Text = "Xecuter";
				this.label10.Text = "LTU2";
				if (*(*(ref <Module>.struct123_0 + 4) + 2) == 1)
				{
					this.label9.Text = "1175";
				}
				if (*(*(ref <Module>.struct123_0 + 4) + 2) == 2)
				{
					this.label9.Text = "1532";
				}
				if (*(*(ref <Module>.struct123_0 + 4) + 2) == 3)
				{
					this.label9.Text = "0500";
				}
				if (*(*(ref <Module>.struct123_0 + 4) + 2) == 4)
				{
					this.label9.Text = "0502";
				}
				if (*(*(ref <Module>.struct123_0 + 4) + 2) == 5)
				{
					this.label9.Text = "0272";
				}
				if (*(*(ref <Module>.struct123_0 + 4) + 2) == 6)
				{
					this.label9.Text = "0225";
				}
				if (*(*(ref <Module>.struct123_0 + 4) + 2) == 7)
				{
					this.label9.Text = "0401";
				}
				if (*(*(ref <Module>.struct123_0 + 4) + 2) == 8)
				{
					this.label9.Text = "1071";
				}
			}
			this.label32.Text = this.label11.Text;
			this.label31.Text = this.label10.Text;
			this.label30.Text = this.label9.Text;
			this.string_0 = "";
			this.method_7(*(ref <Module>.struct123_0 + 4) + 2348);
			this.label17.Text = this.string_0;
			this.label1.Text = this.label17.Text;
			this.string_0 = "";
			this.method_5(*(ref <Module>.struct123_0 + 4) + 568, 96U, 0U);
			this.textBox2.Text = this.string_0;
			if (*(*(ref <Module>.struct123_0 + 4)) == 6 || *(*(ref <Module>.struct123_0 + 4)) == 5 || *(*(ref <Module>.struct123_0 + 4)) == 7)
			{
				this.string_0 = "";
				this.method_5(*(ref <Module>.struct123_0 + 4) + 568, 116U, 0U);
				this.textBox2.Text = this.string_0;
			}
			this.string_0 = "";
			this.method_5(*(ref <Module>.struct123_0 + 4) + 780, 180U, 0U);
			this.textBox4.Text = this.string_0;
			this.string_0 = "";
			if (*(*(ref <Module>.struct123_0 + 4)) != 3)
			{
				if (*(*(ref <Module>.struct123_0 + 4)) != 4)
				{
					if (*(*(ref <Module>.struct123_0 + 4)) == 5)
					{
						this.method_5(*(ref <Module>.struct123_0 + 4) + 2028, 224U, 0U);
						goto IL_D17;
					}
					if (*(*(ref <Module>.struct123_0 + 4)) == 6)
					{
						this.method_5(*(ref <Module>.struct123_0 + 4) + 2028, 96U, 0U);
						goto IL_D17;
					}
					if (*(*(ref <Module>.struct123_0 + 4)) == 7)
					{
						this.method_5(*(ref <Module>.struct123_0 + 4) + 2028, 96U, 0U);
						goto IL_D17;
					}
					if (*(*(ref <Module>.struct123_0 + 4)) == 2)
					{
						this.method_5(*(ref <Module>.struct123_0 + 4) + 2028, 20U, 0U);
						goto IL_D17;
					}
					goto IL_D17;
				}
			}
			this.method_5(*(ref <Module>.struct123_0 + 4) + 2028, 80U, 0U);
			IL_D17:
			this.textBox13.Text = this.string_0;
			this.button29.Enabled = true;
			this.SaveTarget.Enabled = true;
			this.menuItem_4.Enabled = true;
			if (*(*(ref <Module>.struct123_0 + 4)) == 4)
			{
				this.menuItem_11.Enabled = true;
			}
			this.menuItem_20.Enabled = true;
			this.menuItem_32.Enabled = true;
			if (*(*(ref <Module>.struct123_0 + 4)) == 6 || *(*(ref <Module>.struct123_0 + 4)) == 7)
			{
				this.menuItem_37.Enabled = true;
				this.menuItem_37.Visible = true;
			}
		}

		// Token: 0x060001F6 RID: 502 RVA: 0x001156D0 File Offset: 0x001156D0
		private unsafe void method_42()
		{
			Struct68 @struct = 0;
			initblk(ref @struct + 1, 0, 259);
			Struct71 struct2 = 0;
			initblk(ref struct2 + 1, 0, 15);
			Struct71 struct3 = 0;
			initblk(ref struct3 + 1, 0, 15);
			string str = "";
			<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct19_0));
			<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct18_9), *(ref <Module>.struct123_0 + 4) + 2284);
			this.label48.Text = str + new string((sbyte*)(&@struct));
			this.label53.Text = this.label48.Text;
			string str2 = "";
			<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct19_0));
			<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct18_9), *(ref <Module>.struct123_0 + 4) + 300);
			this.textBox17.Text = str2 + new string((sbyte*)(&@struct));
			this.textBox18.Text = this.textBox17.Text;
			this.label11.Text = "Samsung";
			this.label32.Text = this.label11.Text;
			string str3 = "";
			<Module>.memcpy((void*)(&struct2), *(ref <Module>.struct123_0 + 4) + 2300, 8U);
			<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct19_0));
			<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct18_9), ref struct2);
			this.label10.Text = str3 + new string((sbyte*)(&@struct));
			this.label31.Text = this.label10.Text;
			string str4 = "";
			<Module>.memcpy((void*)(&struct3), *(ref <Module>.struct123_0 + 4) + 2308, 4U);
			<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct19_0));
			<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct18_9), ref struct3);
			this.label9.Text = str4 + new string((sbyte*)(&@struct));
			this.label30.Text = this.label9.Text;
			this.string_0 = "";
			this.method_7(*(ref <Module>.struct123_0 + 4) + 2348);
			this.label17.Text = this.string_0;
			this.label1.Text = this.label17.Text;
			this.string_0 = "";
			this.method_5(*(ref <Module>.struct123_0 + 4) + 568, 96U, 0U);
			this.textBox2.Text = this.string_0;
			this.string_0 = "";
			this.method_5(*(ref <Module>.struct123_0 + 4) + 780, 180U, 0U);
			this.textBox4.Text = this.string_0;
			this.menuItem_4.Enabled = true;
		}

		// Token: 0x060001F7 RID: 503 RVA: 0x00115978 File Offset: 0x00115978
		private void method_43()
		{
			this.textBox1.Text = "";
			this.textBox2.Text = "";
			this.textBox4.Text = "";
			this.textBox11.Text = "";
			this.textBox13.Text = "";
			this.textBox17.Text = "";
			this.textBox18.Text = "";
			this.label1.Text = "";
			this.label9.Text = "";
			this.label10.Text = "";
			this.label11.Text = "";
			this.label17.Text = "";
			this.label30.Text = "";
			this.label31.Text = "";
			this.label32.Text = "";
			this.label48.Text = "";
			this.label50.Text = "";
			this.label53.Text = "";
			this.label54.Text = "";
			this.label55.Text = "";
			this.label56.Text = "";
			this.label71.Text = "";
			this.label129.Text = "";
			this.SaveTarget.Enabled = false;
			this.button6.Enabled = false;
			this.button29.Enabled = false;
			this.menuItem_4.Enabled = false;
			this.menuItem_11.Enabled = false;
			this.menuItem_20.Enabled = false;
			this.menuItem_32.Enabled = false;
			this.menuItem_37.Enabled = false;
			this.menuItem_37.Visible = false;
			this.bool_10 = false;
			this.bool_11 = false;
		}

		// Token: 0x060001F8 RID: 504 RVA: 0x00115B70 File Offset: 0x00115B70
		private unsafe int method_44(sbyte* pSbyte_0, int int_16)
		{
			GStruct5* ptr = <Module>.fopen((sbyte*)pSbyte_0, (sbyte*)(&<Module>.struct18_4));
			int result;
			if (ptr == null)
			{
				<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
				MessageBox.Show("Firmware file not found", "Parse Firmware", MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
				<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
				result = 0;
			}
			else
			{
				<Module>.fseek(ptr, 0, 2);
				uint num = <Module>.ftell(ptr);
				<Module>.rewind(ptr);
				if (num != 262144U)
				{
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					MessageBox.Show("Firmware file must be 256Kb", "Parse Firmware", MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
					<Module>.fclose(ptr);
					result = 0;
				}
				else if (<Module>.fread(*(ref <Module>.struct121_0 + int_16 * 2392 + 2388), 262144U, 1U, ptr) != 1)
				{
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					MessageBox.Show("Firmware file should be 256Kbytes", "Loading File", MessageBoxButtons.OK);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
					<Module>.fclose(ptr);
					result = 0;
				}
				else
				{
					<Module>.fclose(ptr);
					result = 1;
				}
			}
			return result;
		}

		// Token: 0x060001F9 RID: 505 RVA: 0x00115CB4 File Offset: 0x00115CB4
		private int method_45(string string_25)
		{
			int result;
			if (string.Compare(string_25, "84e8290978447d9363762e57e5414054") == 0)
			{
				this.textBox6.AppendText("Genuine Lite-On iXtreme 1.5 rev 3" + "\r\n");
				result = 0;
			}
			else if (string.Compare(string_25, "bc0309442c06e442e89f4c55d2c2859f") == 0)
			{
				this.textBox6.AppendText("Genuine Lite-On iXtreme 1.5 rev 4" + "\r\n");
				result = 0;
			}
			else if (string.Compare(string_25, "d0ff1f977f35d40a57d476ba5957c93b") == 0)
			{
				this.textBox6.AppendText("Genuine Lite-On iXtreme 1.5 rev 5" + "\r\n");
				result = 0;
			}
			else if (string.Compare(string_25, "499c26f34c3093f13e9ef8d0198f80c8") == 0)
			{
				this.textBox6.AppendText("Genuine Lite-On iXtreme 1.5 rev 6" + "\r\n");
				result = 0;
			}
			else if (string.Compare(string_25, "a6d4c666c0014cadd0ca51c98cd3c80b") == 0)
			{
				this.textBox6.AppendText("Genuine Benq iXtreme 1.5 Final" + "\r\n");
				result = 0;
			}
			else if (string.Compare(string_25, "4bc77f39c4cc65d61b7cdc2574119912") == 0)
			{
				this.textBox6.AppendText("Genuine Sammy iXtreme 1.5 Final" + "\r\n");
				result = 0;
			}
			else if (string.Compare(string_25, "d8aaa30797c7680109b395bc3a380d5f") == 0)
			{
				this.textBox6.AppendText("Genuine Lite-On iXtreme 1.5 Final" + "\r\n");
				result = 0;
			}
			else if (string.Compare(string_25, "933ed9c64d5839c69628059fc1e2806d") == 0)
			{
				this.textBox6.AppendText("Genuine Lite-On iXtreme 1.51" + "\r\n");
				result = 0;
			}
			else if (string.Compare(string_25, "23f5a368839dfc10dabb8231ba64567a") == 0)
			{
				this.textBox6.AppendText("Genuine Samsung iXtreme 1.6" + "\r\n");
				result = 0;
			}
			else if (string.Compare(string_25, "c3a17c9726f4be3cc3e597797caba7f9") == 0)
			{
				this.textBox6.AppendText("Genuine Lite-On iXtreme 1.6" + "\r\n");
				result = 0;
			}
			else if (string.Compare(string_25, "bc61fac4efd37b69f88dfabe6e104117") == 0)
			{
				this.textBox6.AppendText("Genuine Lite-On 83850c iXtreme 1.6" + "\r\n");
				result = 0;
			}
			else if (string.Compare(string_25, "f36c85c5bfba325b283417f8643d7c27") == 0)
			{
				this.textBox6.AppendText("Genuine Benq iXtreme 1.6" + "\r\n");
				result = 0;
			}
			else if (string.Compare(string_25, "d9b4a4b8c668e28268066ce639e9866e") == 0)
			{
				this.textBox6.AppendText("Genuine Lite-On iXtreme 1.61" + "\r\n");
				result = 0;
			}
			else if (string.Compare(string_25, "6695c239a716e84de3d6eefe64f9c3a7") == 0)
			{
				this.textBox6.AppendText("Genuine Lite-On iXtreme 1.61" + "\r\n");
				result = 0;
			}
			else if (string.Compare(string_25, "7f2140e6f44b0d5fc59b4cbac0fc7f8a") == 0)
			{
				this.textBox6.AppendText("Genuine Lite-On iXtreme 1.61" + "\r\n");
				result = 0;
			}
			else if (string.Compare(string_25, "2f30e817ad4bd1b85743289738fbc1c3") == 0)
			{
				this.textBox6.AppendText("Genuine Lite-On iXtreme 1.61" + "\r\n");
				result = 0;
			}
			else if (string.Compare(string_25, "b951b7e08650e775886b78a2c1901a08") == 0)
			{
				this.textBox6.AppendText("Genuine iXtreme Lite-Touch" + "\r\n");
				result = 0;
			}
			else if (string.Compare(string_25, "187ee5780d863922d49ec1d2ed0d9f48") == 0)
			{
				this.textBox6.AppendText("Genuine iXtreme Lite-Touch" + "\r\n");
				result = 0;
			}
			else if (string.Compare(string_25, "7381f964ffef44da7bf94aa1dc067fb2") == 0)
			{
				this.textBox6.AppendText("Genuine iXtreme Lite-Touch" + "\r\n");
				result = 0;
			}
			else if (string.Compare(string_25, "a6a01f28f4582afdefb6cf5367912a1d") == 0)
			{
				this.textBox6.AppendText("Genuine iXtreme Lite-Touch" + "\r\n");
				result = 0;
			}
			else if (string.Compare(string_25, "b93c95db4fac3ca37c89c727e61c2453") == 0)
			{
				this.textBox6.AppendText("Genuine iXtreme Lite-Touch 1.1" + "\r\n");
				result = 0;
			}
			else if (string.Compare(string_25, "3de7ccb1e529ce588d66bbaacbdf353a") == 0)
			{
				this.textBox6.AppendText("Genuine iXtreme Lite-Touch 1.1" + "\r\n");
				result = 0;
			}
			else if (string.Compare(string_25, "7eb4e4ceeb720e24e6c1a77e4e2a66ae") == 0)
			{
				this.textBox6.AppendText("Genuine iXtreme Lite-Touch 1.1" + "\r\n");
				result = 0;
			}
			else if (string.Compare(string_25, "483ee55c9bbaf9db83331d8c8f6a551d") == 0)
			{
				this.textBox6.AppendText("Genuine iXtreme Lite-Touch 1.1" + "\r\n");
				result = 0;
			}
			else if (string.Compare(string_25, "c95fc1cf2f6f35bf1b84ae546cf58b97") == 0)
			{
				this.textBox6.AppendText("Genuine LT-Plus" + "\r\n");
				result = 0;
			}
			else if (string.Compare(string_25, "f5ec9fa4b16d624ca71074ac6e6641d9") == 0)
			{
				this.textBox6.AppendText("Genuine LT-Plus" + "\r\n");
				result = 0;
			}
			else if (string.Compare(string_25, "4cb38e41d87c204df72a395c6354fc7a") == 0)
			{
				this.textBox6.AppendText("Genuine LT-Plus" + "\r\n");
				result = 0;
			}
			else if (string.Compare(string_25, "dc6b675de4c58a353d830f99a4a03d2e") == 0)
			{
				this.textBox6.AppendText("Genuine LT-Plus" + "\r\n");
				result = 0;
			}
			else if (string.Compare(string_25, "53786fac70e9c6b895b2e99144c7fb6d") == 0)
			{
				this.textBox6.AppendText("Genuine LT plus v1.1" + "\r\n");
				result = 0;
			}
			else if (string.Compare(string_25, "020325ef05290fa80baec9863041a11c") == 0)
			{
				this.textBox6.AppendText("Genuine LT plus v1.1" + "\r\n");
				result = 0;
			}
			else if (string.Compare(string_25, "acc8ce739377578df2ca33ba3680ff54") == 0)
			{
				this.textBox6.AppendText("Genuine LT plus v1.1" + "\r\n");
				result = 0;
			}
			else if (string.Compare(string_25, "d1671296ac52b8a67838f637f435fa6a") == 0)
			{
				this.textBox6.AppendText("Genuine LT plus v1.1" + "\r\n");
				result = 0;
			}
			else if (string.Compare(string_25, "71cfb6569fd42a1d4eb243dbd4d3b159") == 0)
			{
				this.textBox6.AppendText("Genuine LT plus v1.9" + "\r\n");
				result = 0;
			}
			else if (string.Compare(string_25, "5b94b528591d1028f6b1a9d7884c7a55") == 0)
			{
				this.textBox6.AppendText("Genuine LT plus v1.91" + "\r\n");
				result = 0;
			}
			else if (string.Compare(string_25, "0264149996f783b54629c1598072e50e") == 0)
			{
				this.textBox6.AppendText("Genuine LT plus v2.0" + "\r\n");
				result = 0;
			}
			else if (string.Compare(string_25, "d14fe82b96741b7a18e5c1e7adbf0a98") == 0)
			{
				this.textBox6.AppendText("Genuine LT plus v3.0" + "\r\n");
				result = 0;
			}
			else if (string.Compare(string_25, "693cfff56a632029f008295b06ce1021") == 0)
			{
				this.textBox6.AppendText("Genuine LT plus v1.9" + "\r\n");
				result = 0;
			}
			else if (string.Compare(string_25, "21ea0e6d5c8f04f21f95bfb40ff1ae1e") == 0)
			{
				this.textBox6.AppendText("Genuine LT plus v1.9 (9504 upgrade)" + "\r\n");
				result = 0;
			}
			else if (string.Compare(string_25, "bd05e901e072c08a92364ed864395fb3") == 0)
			{
				this.textBox6.AppendText("Genuine LT plus v1.9" + "\r\n");
				result = 0;
			}
			else if (string.Compare(string_25, "37d3222c404a1f841584b2cd50a308ad") == 0)
			{
				this.textBox6.AppendText("Genuine LT plus v1.9" + "\r\n");
				result = 0;
			}
			else if (string.Compare(string_25, "5a14a34b933602a94f8375f9ce88f803") == 0)
			{
				this.textBox6.AppendText("Genuine LT plus v1.91" + "\r\n");
				result = 0;
			}
			else if (string.Compare(string_25, "c51e40b948dfd2591420111c57beca8e") == 0)
			{
				this.textBox6.AppendText("Genuine LT plus v1.91 (9504 upgrade)" + "\r\n");
				result = 0;
			}
			else if (string.Compare(string_25, "b161fcb485d1aafa9d9986c82c0f5a20") == 0)
			{
				this.textBox6.AppendText("Genuine LT plus v1.91" + "\r\n");
				result = 0;
			}
			else if (string.Compare(string_25, "02e542648c5d42f291e9c2a206c48770") == 0)
			{
				this.textBox6.AppendText("Genuine LT plus v1.91" + "\r\n");
				result = 0;
			}
			else if (string.Compare(string_25, "55828ef0e599d07f33698e482c85af19") == 0)
			{
				this.textBox6.AppendText("Genuine LT plus v1.91" + "\r\n");
				result = 0;
			}
			else if (string.Compare(string_25, "c3f45b669000bb2d178394fa4164896d") == 0)
			{
				this.textBox6.AppendText("Genuine LT plus v1.92" + "\r\n");
				result = 0;
			}
			else if (string.Compare(string_25, "2b4fce3f4da264939858d428971ce45b") == 0)
			{
				this.textBox6.AppendText("Genuine LT plus v1.92 (9504 upgrade)" + "\r\n");
				result = 0;
			}
			else if (string.Compare(string_25, "3128442eae48cb5f9ffb0ce9778a3bd0") == 0)
			{
				this.textBox6.AppendText("Genuine LT plus v1.92" + "\r\n");
				result = 0;
			}
			else if (string.Compare(string_25, "26c9114d31ff459123fa8af7f50b93e3") == 0)
			{
				this.textBox6.AppendText("Genuine LT plus v1.92" + "\r\n");
				result = 0;
			}
			else if (string.Compare(string_25, "92504d007f30c0e6bceeb12a092600be") == 0)
			{
				this.textBox6.AppendText("Genuine LT plus v1.92" + "\r\n");
				result = 0;
			}
			else if (string.Compare(string_25, "1012021472620cad9adf1f838497668e") == 0)
			{
				this.textBox6.AppendText("Genuine LT plus v2.0" + "\r\n");
				result = 0;
			}
			else if (string.Compare(string_25, "a28aa0c2386925550f05b4b5af62d81b") == 0)
			{
				this.textBox6.AppendText("Genuine LT plus v2.0 (9504 upgrade)" + "\r\n");
				result = 0;
			}
			else if (string.Compare(string_25, "0270d5174a07385eeb313c8371b547f8") == 0)
			{
				this.textBox6.AppendText("Genuine LT plus v2.0" + "\r\n");
				result = 0;
			}
			else if (string.Compare(string_25, "e89c22ad8eecf634a3b27510901999c8") == 0)
			{
				this.textBox6.AppendText("Genuine LT plus v2.0" + "\r\n");
				result = 0;
			}
			else if (string.Compare(string_25, "2811f396793a42c2f284c4ac8f9c4dbc") == 0)
			{
				this.textBox6.AppendText("Genuine LT plus v2.0" + "\r\n");
				result = 0;
			}
			else if (string.Compare(string_25, "1a38d3a2a6519339599fa1866642c513") == 0)
			{
				this.textBox6.AppendText("Genuine LT plus v3.0" + "\r\n");
				result = 0;
			}
			else if (string.Compare(string_25, "db5c70eaaabb53501c2c4f53dce9abfd") == 0)
			{
				this.textBox6.AppendText("Genuine LT plus v3.0 (9504 upgrade)" + "\r\n");
				result = 0;
			}
			else if (string.Compare(string_25, "faf085ff40fcbedf6a352318d55879c0") == 0)
			{
				this.textBox6.AppendText("Genuine LT plus v3.0 (0401 downgrade)" + "\r\n");
				result = 0;
			}
			else if (string.Compare(string_25, "87fba52607d01d3c73722f9f818588c9") == 0)
			{
				this.textBox6.AppendText("Genuine LT plus v3.0" + "\r\n");
				result = 0;
			}
			else if (string.Compare(string_25, "76b991307ddd5b2af581d0608e671b36") == 0)
			{
				this.textBox6.AppendText("Genuine LT plus v3.0" + "\r\n");
				result = 0;
			}
			else if (string.Compare(string_25, "3d1243454d9c6c1cd2760b8ea5f5c648") == 0)
			{
				this.textBox6.AppendText("Genuine LT plus v3.0" + "\r\n");
				result = 0;
			}
			else if (string.Compare(string_25, "be5a7720962eb20340d403004717931a") == 0)
			{
				this.textBox6.AppendText("Genuine iXtreme Benq LT" + "\r\n");
				result = 0;
			}
			else if (string.Compare(string_25, "c89cc7d1740f421d5d48bd002120571b") == 0)
			{
				this.textBox6.AppendText("Genuine iXtreme Benq LT 1.1" + "\r\n");
				result = 0;
			}
			else if (string.Compare(string_25, "26a2add0da187dbf6aebce59fd73a1d2") == 0)
			{
				this.textBox6.AppendText("Genuine iXtreme Benq LT 1.2" + "\r\n");
				result = 0;
			}
			else if (string.Compare(string_25, "ef3a351f05699a3ee0ad86d63375725e") == 0)
			{
				this.textBox6.AppendText("Genuine LT plus v1.0" + "\r\n");
				result = 0;
			}
			else if (string.Compare(string_25, "c45d60fbd68cc642b2235ba12e5aad7d") == 0)
			{
				this.textBox6.AppendText("Genuine LT plus v1.1" + "\r\n");
				result = 0;
			}
			else if (string.Compare(string_25, "cf132deb838212288f8b365bd16e9d24") == 0)
			{
				this.textBox6.AppendText("Genuine LT plus v1.9" + "\r\n");
				result = 0;
			}
			else if (string.Compare(string_25, "6a146d19c9c52c0933ed737305cb8383") == 0)
			{
				this.textBox6.AppendText("Genuine LT plus v1.91" + "\r\n");
				result = 0;
			}
			else if (string.Compare(string_25, "847700a6b5f12a88c61cfe31a5514772") == 0)
			{
				this.textBox6.AppendText("Genuine LT plus v2.0" + "\r\n");
				result = 0;
			}
			else if (string.Compare(string_25, "8784e0f4ce27941a2a3293c8a5ac85e4") == 0)
			{
				this.textBox6.AppendText("Genuine LT plus v3.0" + "\r\n");
				result = 0;
			}
			else if (string.Compare(string_25, "6f7dd0c34da043f4b5d29828b661bba0") == 0)
			{
				this.textBox6.AppendText("Genuine iXtreme Samsung LT" + "\r\n");
				result = 0;
			}
			else if (string.Compare(string_25, "dc3bceed3b58e39133df3e186d1e4271") == 0)
			{
				this.textBox6.AppendText("Genuine LT v1.9" + "\r\n");
				result = 0;
			}
			else if (string.Compare(string_25, "9e9ecbed96b490375497e9acef8326ac") == 0)
			{
				this.textBox6.AppendText("Genuine LT v2.0" + "\r\n");
				result = 0;
			}
			else if (string.Compare(string_25, "d66252800c1c072bc612f2f72d1e3c76") == 0)
			{
				this.textBox6.AppendText("Genuine LT v2.01" + "\r\n");
				result = 0;
			}
			else if (string.Compare(string_25, "fb7b3d4487cc17c6518b14e57ae82cc2") == 0)
			{
				this.textBox6.AppendText("Genuine Lite-On Slim 9504 LT" + "\r\n");
				result = 0;
			}
			else if (string.Compare(string_25, "24305e18770955635041fd9221de4710") == 0)
			{
				this.textBox6.AppendText("Genuine Benq iXtreme 1.6 0800" + "\r\n");
				<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
				MessageBox.Show("0800 f/w should not be used in a console, it is for external use only", "Warning", MessageBoxButtons.OK);
				<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
				this.bool_11 = true;
				result = 0;
			}
			else if (string.Compare(string_25, "83bd1232eb853b00e3f18c7d24b0e3c7") == 0)
			{
				this.textBox6.AppendText("Genuine Samsung iXtreme 1.6 0800" + "\r\n");
				<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
				MessageBox.Show("0800 f/w should not be used in a console, it is for external use only", "Warning", MessageBoxButtons.OK);
				<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
				this.bool_11 = true;
				result = 0;
			}
			else if (string.Compare(string_25, "bbc6a11e18d0a01842e63bfba6dcba1c") == 0)
			{
				this.textBox6.AppendText("Genuine Lite-On iXtreme 1.6 0800" + "\r\n");
				<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
				MessageBox.Show("0800 f/w should not be used in a console, it is for external use only", "Warning", MessageBoxButtons.OK);
				<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
				this.bool_11 = true;
				result = 0;
			}
			else if (string.Compare(string_25, "777e8c2d89e0f57f891aa6735ed1cc95") == 0)
			{
				this.textBox6.AppendText("Genuine Lite-On LT 0800 v3" + "\r\n");
				<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
				MessageBox.Show("0800 f/w should not be used in a console, it is for external use only", "Warning", MessageBoxButtons.OK);
				<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
				this.bool_11 = true;
				result = 0;
			}
			else if (string.Compare(string_25, "31b7a19fa0e92c27060a77bb0cf37fcf") == 0)
			{
				this.textBox6.AppendText("Genuine Benq LT 0800 v3" + "\r\n");
				<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
				MessageBox.Show("0800 f/w should not be used in a console, it is for external use only", "Warning", MessageBoxButtons.OK);
				<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
				this.bool_11 = true;
				result = 0;
			}
			else if (string.Compare(string_25, "17eb69239a0b09774e8048e65f0fec73") == 0)
			{
				this.textBox6.AppendText("Genuine SH-D162C Kreon V1.00" + "\r\n");
				result = 1;
			}
			else if (string.Compare(string_25, "6360057764b8c982ddad06de1c657378") == 0)
			{
				this.textBox6.AppendText("Genuine SH-D162D Kreon V1.00" + "\r\n");
				result = 1;
			}
			else if (string.Compare(string_25, "102564b8bc50918a68a25587e8b281ff") == 0)
			{
				this.textBox6.AppendText("Genuine SH-D163A Kreon V1.00" + "\r\n");
				result = 1;
			}
			else if (string.Compare(string_25, "356331d88a72bd20937dd8ebd1305f5a") == 0)
			{
				this.textBox6.AppendText("Genuine SH-D163B Kreon V1.00" + "\r\n");
				result = 1;
			}
			else if (string.Compare(string_25, "acb3a39456d2dd0e9380d365b4e6b122") == 0)
			{
				this.textBox6.AppendText("Genuine SH-D162C Kreon V0.80" + "\r\n");
				result = 1;
			}
			else if (string.Compare(string_25, "16f38161d1db01ad96da6ec566377d99") == 0)
			{
				this.textBox6.AppendText("Genuine SH-D162C Kreon V0.81" + "\r\n");
				result = 1;
			}
			else if (string.Compare(string_25, "7722d31323e6d5d70b2f28a6755303f8") == 0)
			{
				this.textBox6.AppendText("Genuine LTU v1.0" + "\r\n");
				result = 0;
			}
			else if (string.Compare(string_25, "d354a7c0681302300cfcd7e2e35c0e66") == 0)
			{
				this.textBox6.AppendText("Genuine LTU v1.0" + "\r\n");
				result = 0;
			}
			else if (string.Compare(string_25, "7c66816d5e144af6e638cc5e4ff39c55") == 0)
			{
				this.textBox6.AppendText("Genuine LTU v1.0" + "\r\n");
				result = 0;
			}
			else if (string.Compare(string_25, "5af581cd3c86022c5d1187a8a5cb51dd") == 0)
			{
				this.textBox6.AppendText("Genuine LTU v1.0" + "\r\n");
				result = 0;
			}
			else if (string.Compare(string_25, "b20d3c83f3205c21375d8747d9c40cc8") == 0)
			{
				this.textBox6.AppendText("Genuine LTU v1.0" + "\r\n");
				result = 0;
			}
			else if (string.Compare(string_25, "b2912a15a6f571e5b39d758a10cdd791") == 0)
			{
				this.textBox6.AppendText("Genuine LTU v1.0" + "\r\n");
				result = 0;
			}
			else if (string.Compare(string_25, "9ef0587eaf725808ccd251384b89aef8") == 0)
			{
				this.textBox6.AppendText("Genuine LTU v1.0" + "\r\n");
				result = 0;
			}
			else
			{
				result = 0;
			}
			return result;
		}

		// Token: 0x060001FA RID: 506 RVA: 0x00116E70 File Offset: 0x00116E70
		private unsafe int method_46()
		{
			int result;
			if (*<Module>.struct123_0 == 0)
			{
				<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
				MessageBox.Show("No Source f/w loaded", "Spoof Target", MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
				<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
				result = 0;
			}
			else if (*(*(ref <Module>.struct123_0 + 4)) == 0)
			{
				<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
				MessageBox.Show("No Target f/w loaded", "Spoof Target", MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
				<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
				result = 0;
			}
			else
			{
				this.textBox6.AppendText("Spoofing Target" + "\r\n");
				if (<Module>.memcmp(*(ref <Module>.struct123_0 + 4) + 280, <Module>.struct123_0 + 280, 16U) != null)
				{
					<Module>.memcpy(*(ref <Module>.struct123_0 + 4) + 280, <Module>.struct123_0 + 280, 16U);
					this.textBox6.AppendText("DVD Key copied to target" + "\r\n");
				}
				else
				{
					this.textBox6.AppendText("DVD Key already matches" + "\r\n");
				}
				if (*(*(ref <Module>.struct123_0 + 4)) == 5)
				{
					<Module>.memcpy(*(ref <Module>.struct121_0 + 4780) + 172032, *(ref <Module>.struct121_0 + 2388) + 172032, 4096U);
					this.textBox6.AppendText("Key Sector copied from Source to Target" + "\r\n");
				}
				if (*<Module>.struct123_0 == 6)
				{
					if (*(*(ref <Module>.struct123_0 + 4)) == 6)
					{
						<Module>.memcpy(*(ref <Module>.struct121_0 + 4780) + 62464, *(ref <Module>.struct121_0 + 2388) + 62464, 3059U);
						<Module>.memcpy(*(ref <Module>.struct121_0 + 4780) + 127488, *(ref <Module>.struct121_0 + 2388) + 127488, 3572U);
						<Module>.memcpy(*(ref <Module>.struct121_0 + 4780) + 193024, *(ref <Module>.struct121_0 + 2388) + 193024, 2907U);
					}
					if (*(*(ref <Module>.struct123_0 + 4)) == 7)
					{
						for (int i = 0; i < 3059; i++)
						{
							*(*(ref <Module>.struct121_0 + 4780) + (i + 186624)) = (*(*(ref <Module>.struct121_0 + 2388) + (i + 62464)) ^ *(ref <Module>.struct58_0 + i));
						}
						for (int i = 0; i < 3572; i++)
						{
							*(*(ref <Module>.struct121_0 + 4780) + (i + 189683)) = (*(*(ref <Module>.struct121_0 + 2388) + (i + 127488)) ^ *(ref <Module>.struct56_0 + i));
						}
						for (int i = 0; i < 2907; i++)
						{
							*(*(ref <Module>.struct121_0 + 4780) + (i + 193255)) = (*(*(ref <Module>.struct121_0 + 2388) + (i + 193024)) ^ *(ref <Module>.struct49_0 + i));
						}
						<Module>.memcpy(*(ref <Module>.struct121_0 + 4780) + 130816, *(ref <Module>.struct121_0 + 2388) + 261888, 80U);
						<Module>.memcpy(*(ref <Module>.struct123_0 + 4) + 2028, <Module>.struct123_0 + 2028, 80U);
					}
				}
				if (*<Module>.struct123_0 == 7)
				{
					if (*(*(ref <Module>.struct123_0 + 4)) == 7)
					{
						<Module>.memcpy(*(ref <Module>.struct121_0 + 4780) + 186624, *(ref <Module>.struct121_0 + 2388) + 186624, 9538U);
					}
					if (*(*(ref <Module>.struct123_0 + 4)) == 6)
					{
						for (int i = 0; i < 3059; i++)
						{
							*(*(ref <Module>.struct121_0 + 4780) + (i + 62464)) = (*(*(ref <Module>.struct121_0 + 2388) + (i + 186624)) ^ *(ref <Module>.struct58_0 + i));
						}
						for (int i = 0; i < 3572; i++)
						{
							*(*(ref <Module>.struct121_0 + 4780) + (i + 127488)) = (*(*(ref <Module>.struct121_0 + 2388) + (i + 189683)) ^ *(ref <Module>.struct56_0 + i));
						}
						for (int i = 0; i < 2907; i++)
						{
							*(*(ref <Module>.struct121_0 + 4780) + (i + 193024)) = (*(*(ref <Module>.struct121_0 + 2388) + (i + 193255)) ^ *(ref <Module>.struct49_0 + i));
						}
						<Module>.memcpy(*(ref <Module>.struct121_0 + 4780) + 261888, *(ref <Module>.struct121_0 + 2388) + 130816, 80U);
						<Module>.memcpy(*(ref <Module>.struct123_0 + 4) + 2028, <Module>.struct123_0 + 2028, 80U);
					}
				}
				if (*(<Module>.struct123_0 + 2382) == 0)
				{
					<Module>.memcpy(*(ref <Module>.struct123_0 + 4) + 2316, <Module>.struct123_0 + 2284, 28U);
					*(*(ref <Module>.struct123_0 + 4) + 2382) = (short)(*<Module>.struct123_0);
					*(*(ref <Module>.struct123_0 + 4) + 2384) = (short)(*(<Module>.struct123_0 + 2));
				}
				else
				{
					<Module>.memcpy(*(ref <Module>.struct123_0 + 4) + 2316, <Module>.struct123_0 + 2316, 28U);
					*(*(ref <Module>.struct123_0 + 4) + 2382) = (short)(*(<Module>.struct123_0 + 2382));
					*(*(ref <Module>.struct123_0 + 4) + 2384) = (short)(*(<Module>.struct123_0 + 2384));
				}
				if (*(*(ref <Module>.struct123_0 + 4)) == 4 && <Module>.memcmp(*(ref <Module>.struct123_0 + 4) + 2348, (void*)(&<Module>.struct74_0), 10U) == null)
				{
					this.textBox6.AppendText("Target is LT - ID strings not copied to Target" + "\r\n");
				}
				else if (*(*(ref <Module>.struct123_0 + 4)) == 4 && <Module>.memcmp(*(ref <Module>.struct123_0 + 4) + 2348, (void*)(&<Module>.struct22_4), 7U) == null)
				{
					this.textBox6.AppendText("Target is LT - ID strings not copied to Target" + "\r\n");
				}
				else if (*(*(ref <Module>.struct123_0 + 4)) == 4 && *(*(ref <Module>.struct123_0 + 4) + 2) == 5)
				{
					this.textBox6.AppendText("Target is LT - ID strings not copied to Target" + "\r\n");
				}
				else if (*(*(ref <Module>.struct123_0 + 4)) == 5)
				{
					this.textBox6.AppendText("Target is LT - ID strings not copied to Target" + "\r\n");
				}
				else if (*(*(ref <Module>.struct123_0 + 4)) == 3 && *(*(ref <Module>.struct123_0 + 4) + 2) == 3)
				{
					this.textBox6.AppendText("Target is LT - ID strings not copied to Target" + "\r\n");
				}
				else if (<Module>.memcmp(*(ref <Module>.struct123_0 + 4) + 568, <Module>.struct123_0 + 568, 96U) != null)
				{
					<Module>.memcpy(*(ref <Module>.struct123_0 + 4) + 568, <Module>.struct123_0 + 568, 96U);
					this.textBox6.AppendText("Inquiry string copied to Target" + "\r\n");
					<Module>.memcpy(*(ref <Module>.struct123_0 + 4) + 780, <Module>.struct123_0 + 780, 180U);
					this.textBox6.AppendText("Identify string copied to Target" + "\r\n");
				}
				else if (<Module>.memcmp(*(ref <Module>.struct123_0 + 4) + 568, <Module>.struct123_0 + 568, 116U) != null)
				{
					<Module>.memcpy(*(ref <Module>.struct123_0 + 4) + 568, <Module>.struct123_0 + 568, 116U);
					this.textBox6.AppendText("Inquiry string copied to Target" + "\r\n");
					<Module>.memcpy(*(ref <Module>.struct123_0 + 4) + 780, <Module>.struct123_0 + 780, 180U);
					this.textBox6.AppendText("Identify string copied to Target" + "\r\n");
				}
				else
				{
					this.textBox6.AppendText("ID strings already match" + "\r\n");
				}
				if (*<Module>.struct123_0 == *(*(ref <Module>.struct123_0 + 4)) && <Module>.memcmp(*(ref <Module>.struct123_0 + 4) + 2028, <Module>.struct123_0 + 2028, 80U) != null)
				{
					if (*(*(ref <Module>.struct123_0 + 4)) == 2)
					{
						<Module>.memcpy(*(ref <Module>.struct123_0 + 4) + 2028, <Module>.struct123_0 + 2028, 20U);
					}
					else if (*(*(ref <Module>.struct123_0 + 4)) == 3 && *(*(ref <Module>.struct123_0 + 4) + 2) != 3)
					{
						<Module>.memcpy(*(ref <Module>.struct123_0 + 4) + 2028, <Module>.struct123_0 + 2028, 80U);
					}
					else if (*(*(ref <Module>.struct123_0 + 4)) == 4 && *(*(ref <Module>.struct123_0 + 4) + 2) != 5)
					{
						<Module>.memcpy(*(ref <Module>.struct123_0 + 4) + 2028, <Module>.struct123_0 + 2028, 80U);
					}
					else if (*(*(ref <Module>.struct123_0 + 4)) == 5)
					{
						<Module>.memcpy(*(ref <Module>.struct123_0 + 4) + 2028, <Module>.struct123_0 + 2028, 80U);
						if (*(<Module>.struct123_0 + 2156) != 0)
						{
							<Module>.memcpy(*(ref <Module>.struct123_0 + 4) + 2028, <Module>.struct123_0 + 2028, 144U);
						}
						if (*(<Module>.struct123_0 + 2187) != 0)
						{
							<Module>.memcpy(*(ref <Module>.struct123_0 + 4) + 2028, <Module>.struct123_0 + 2028, 224U);
						}
					}
					else if (*(*(ref <Module>.struct123_0 + 4)) == 6)
					{
						<Module>.memcpy(*(ref <Module>.struct123_0 + 4) + 2028, <Module>.struct123_0 + 2028, 256U);
					}
					else if (*(*(ref <Module>.struct123_0 + 4)) == 7)
					{
						<Module>.memcpy(*(ref <Module>.struct123_0 + 4) + 2028, <Module>.struct123_0 + 2028, 80U);
					}
					if (*(*(ref <Module>.struct123_0 + 4)) != 1 && *(*(ref <Module>.struct123_0 + 4)) == 4 && *(*(ref <Module>.struct123_0 + 4) + 2) != 5)
					{
						this.textBox6.AppendText("Serial data copied from Source to Target" + "\r\n");
					}
				}
				else if (<Module>.memcmp(*(ref <Module>.struct123_0 + 4) + 2028, <Module>.struct123_0 + 2028, 80U) == null && *(*(ref <Module>.struct123_0 + 4)) != 1)
				{
					this.textBox6.AppendText("Serial data already matches" + "\r\n");
				}
				this.textBox6.AppendText("\r\n");
				if (<Module>.memcmp(*(ref <Module>.struct123_0 + 4) + 2284, *(ref <Module>.struct123_0 + 4) + 2316, 28U) == null)
				{
					<Module>.memset(*(ref <Module>.struct123_0 + 4) + 2316, 0, 32U);
					*(*(ref <Module>.struct123_0 + 4) + 2382) = 0;
					*(*(ref <Module>.struct123_0 + 4) + 2384) = 0;
				}
				if (*(*(ref <Module>.struct123_0 + 4)) == 4 && *(*(ref <Module>.struct123_0 + 4) + 2382) == 4)
				{
					<Module>.memset(*(ref <Module>.struct123_0 + 4) + 2316, 0, 32U);
					*(*(ref <Module>.struct123_0 + 4) + 2382) = 0;
					*(*(ref <Module>.struct123_0 + 4) + 2384) = 0;
				}
				if (*(*(ref <Module>.struct123_0 + 4)) == 4 && <Module>.memcmp(*(ref <Module>.struct123_0 + 4) + 2348, (void*)(&<Module>.struct74_0), 10U) == null)
				{
					<Module>.memset(*(ref <Module>.struct123_0 + 4) + 2316, 0, 32U);
					*(*(ref <Module>.struct123_0 + 4) + 2382) = 0;
					*(*(ref <Module>.struct123_0 + 4) + 2384) = 0;
				}
				if (*(*(ref <Module>.struct123_0 + 4)) == 4 && <Module>.memcmp(*(ref <Module>.struct123_0 + 4) + 2348, (void*)(&<Module>.struct22_4), 7U) == null)
				{
					<Module>.memset(*(ref <Module>.struct123_0 + 4) + 2316, 0, 32U);
					*(*(ref <Module>.struct123_0 + 4) + 2382) = 0;
					*(*(ref <Module>.struct123_0 + 4) + 2384) = 0;
				}
				if (*(*(ref <Module>.struct123_0 + 4)) == 5)
				{
					<Module>.memset(*(ref <Module>.struct123_0 + 4) + 2316, 0, 32U);
					*(*(ref <Module>.struct123_0 + 4) + 2382) = 0;
					*(*(ref <Module>.struct123_0 + 4) + 2384) = 0;
				}
				if (*(*(ref <Module>.struct123_0 + 4)) == 4 && *(*(ref <Module>.struct123_0 + 4) + 2) == 5)
				{
					<Module>.memset(*(ref <Module>.struct123_0 + 4) + 2316, 0, 32U);
					*(*(ref <Module>.struct123_0 + 4) + 2382) = 0;
					*(*(ref <Module>.struct123_0 + 4) + 2384) = 0;
				}
				if (*(*(ref <Module>.struct123_0 + 4)) == 3 && *(*(ref <Module>.struct123_0 + 4) + 2) == 3)
				{
					<Module>.memset(*(ref <Module>.struct123_0 + 4) + 2316, 0, 32U);
					*(*(ref <Module>.struct123_0 + 4) + 2382) = 0;
					*(*(ref <Module>.struct123_0 + 4) + 2384) = 0;
				}
				this.bool_10 = true;
				result = 1;
			}
			return result;
		}

		// Token: 0x060001FB RID: 507 RVA: 0x00117B98 File Offset: 0x00117B98
		private unsafe int method_47()
		{
			byte* ptr = *(ref <Module>.struct121_0 + 4780);
			if (*(*(ref <Module>.struct123_0 + 4)) == 1)
			{
				<Module>.memcpy((void*)(ptr + *(*(ref <Module>.struct123_0 + 4) + 560)), *(ref <Module>.struct123_0 + 4) + 568, 96U);
				<Module>.memcpy((void*)(ptr + *(*(ref <Module>.struct123_0 + 4) + 564)), *(ref <Module>.struct123_0 + 4) + 780, 180U);
				<Module>.memcpy((void*)(ptr + *(*(ref <Module>.struct123_0 + 4) + 296)), *(ref <Module>.struct123_0 + 4) + 280, 16U);
			}
			if (*(*(ref <Module>.struct123_0 + 4)) == 2)
			{
				<Module>.memcpy((void*)(ptr + *(*(ref <Module>.struct123_0 + 4) + 560)), *(ref <Module>.struct123_0 + 4) + 568, 96U);
				<Module>.memcpy((void*)(ptr + *(*(ref <Module>.struct123_0 + 4) + 564)), *(ref <Module>.struct123_0 + 4) + 780, 180U);
				<Module>.memcpy((void*)(ptr + *(*(ref <Module>.struct123_0 + 4) + 296)), *(ref <Module>.struct123_0 + 4) + 280, 16U);
				<Module>.memcpy((void*)(ptr + *(*(ref <Module>.struct123_0 + 4) + 2024)), *(ref <Module>.struct123_0 + 4) + 2028, 20U);
				ptr[255996] = (byte)(*(*(ref <Module>.struct123_0 + 4) + 2020) & 255);
				ptr[255997] = (byte)((uint)(*(*(ref <Module>.struct123_0 + 4) + 2020) & 65280) >> 8);
				ptr[255998] = (byte)((uint)(*(*(ref <Module>.struct123_0 + 4) + 2020) & 16711680) >> 16);
				ptr[255999] = (byte)((uint)(*(*(ref <Module>.struct123_0 + 4) + 2020) & -16777216) >> 24);
			}
			if (*(*(ref <Module>.struct123_0 + 4)) == 3)
			{
				<Module>.memcpy((void*)(ptr + *(*(ref <Module>.struct123_0 + 4) + 560)), *(ref <Module>.struct123_0 + 4) + 568, 96U);
				<Module>.memcpy((void*)(ptr + (*(*(ref <Module>.struct123_0 + 4) + 560) + 65536)), *(ref <Module>.struct123_0 + 4) + 568, 96U);
				<Module>.memcpy((void*)(ptr + (*(*(ref <Module>.struct123_0 + 4) + 560) + 131072)), *(ref <Module>.struct123_0 + 4) + 568, 96U);
				<Module>.memcpy((void*)(ptr + (*(*(ref <Module>.struct123_0 + 4) + 560) + 196608)), *(ref <Module>.struct123_0 + 4) + 568, 96U);
				Struct46 @struct;
				<Module>.memcpy((void*)(&@struct), *(ref <Module>.struct123_0 + 4) + 780, 180U);
				for (int i = 20; i < 93; i += 2)
				{
					*(ref @struct + (i + 1)) = *(*(ref <Module>.struct123_0 + 4) + 780 + i);
					*(ref @struct + i) = *(*(ref <Module>.struct123_0 + 4) + 780 + (i + 1));
				}
				<Module>.memcpy((void*)(ptr + *(*(ref <Module>.struct123_0 + 4) + 564)), (void*)(&@struct), 180U);
				<Module>.memcpy((void*)(ptr + (*(*(ref <Module>.struct123_0 + 4) + 564) + 65536)), (void*)(&@struct), 180U);
				<Module>.memcpy((void*)(ptr + (*(*(ref <Module>.struct123_0 + 4) + 564) + 131072)), (void*)(&@struct), 180U);
				<Module>.memcpy((void*)(ptr + (*(*(ref <Module>.struct123_0 + 4) + 564) + 196608)), (void*)(&@struct), 180U);
				<Module>.memcpy((void*)(ptr + *(*(ref <Module>.struct123_0 + 4) + 296)), *(ref <Module>.struct123_0 + 4) + 280, 16U);
				<Module>.memcpy((void*)(ptr + *(*(ref <Module>.struct123_0 + 4) + 2024)), *(ref <Module>.struct123_0 + 4) + 2028, 80U);
			}
			if (*(*(ref <Module>.struct123_0 + 4)) == 4)
			{
				ptr[*(*(ref <Module>.struct123_0 + 4) + 296) + 312] = *(*(ref <Module>.struct123_0 + 4) + 280);
				ptr[*(*(ref <Module>.struct123_0 + 4) + 296) + 2796] = *(*(ref <Module>.struct123_0 + 4) + 281);
				ptr[*(*(ref <Module>.struct123_0 + 4) + 296) + 1858] = *(*(ref <Module>.struct123_0 + 4) + 282);
				ptr[*(*(ref <Module>.struct123_0 + 4) + 296) + 1664] = *(*(ref <Module>.struct123_0 + 4) + 283);
				ptr[*(*(ref <Module>.struct123_0 + 4) + 296) + 3789] = *(*(ref <Module>.struct123_0 + 4) + 284);
				ptr[*(*(ref <Module>.struct123_0 + 4) + 296) + 2868] = *(*(ref <Module>.struct123_0 + 4) + 285);
				ptr[*(*(ref <Module>.struct123_0 + 4) + 296) + 2111] = *(*(ref <Module>.struct123_0 + 4) + 286);
				ptr[*(*(ref <Module>.struct123_0 + 4) + 296) + 1829] = *(*(ref <Module>.struct123_0 + 4) + 287);
				ptr[*(*(ref <Module>.struct123_0 + 4) + 296) + 1322] = *(*(ref <Module>.struct123_0 + 4) + 288);
				ptr[*(*(ref <Module>.struct123_0 + 4) + 296) + 513] = *(*(ref <Module>.struct123_0 + 4) + 289);
				ptr[*(*(ref <Module>.struct123_0 + 4) + 296) + 2527] = *(*(ref <Module>.struct123_0 + 4) + 290);
				ptr[*(*(ref <Module>.struct123_0 + 4) + 296) + 35] = *(*(ref <Module>.struct123_0 + 4) + 291);
				ptr[*(*(ref <Module>.struct123_0 + 4) + 296) + 1184] = *(*(ref <Module>.struct123_0 + 4) + 292);
				ptr[*(*(ref <Module>.struct123_0 + 4) + 296) + 1434] = *(*(ref <Module>.struct123_0 + 4) + 293);
				ptr[*(*(ref <Module>.struct123_0 + 4) + 296) + 1022] = *(*(ref <Module>.struct123_0 + 4) + 294);
				ptr[*(*(ref <Module>.struct123_0 + 4) + 296) + 3913] = *(*(ref <Module>.struct123_0 + 4) + 295);
				if (*(*(ref <Module>.struct123_0 + 4) + 2) == 5)
				{
					this.textBox6.AppendText("Target rev is LT 02510C, serial info not copied" + "\r\n");
					return 1;
				}
				<Module>.memcpy((void*)(ptr + *(*(ref <Module>.struct123_0 + 4) + 2024)), *(ref <Module>.struct123_0 + 4) + 2028, 80U);
				if (<Module>.memcmp(*(ref <Module>.struct123_0 + 4) + 2348, (void*)(&<Module>.struct74_0), 10U) == null)
				{
					<Module>.memset(*(ref <Module>.struct123_0 + 4) + 2316, 0, 32U);
					*(*(ref <Module>.struct123_0 + 4) + 2382) = 0;
					*(*(ref <Module>.struct123_0 + 4) + 2384) = 0;
					for (int i = 0; i < 20; i++)
					{
						*(*(ref <Module>.struct123_0 + 4) + 568 + (i + 42)) = ptr[i + 130816];
						*(*(ref <Module>.struct123_0 + 4) + 780 + (i + 20)) = ptr[i + 130816];
					}
					for (int i = 0; i < 2; i++)
					{
						*(*(ref <Module>.struct123_0 + 4) + 568 + (i + 38)) = ptr[i + 130856];
						*(*(ref <Module>.struct123_0 + 4) + 568 + (i + 40)) = ptr[i + 130892];
					}
				}
				else if (<Module>.memcmp(*(ref <Module>.struct123_0 + 4) + 2348, (void*)(&<Module>.struct22_4), 7U) == null)
				{
					<Module>.memset(*(ref <Module>.struct123_0 + 4) + 2316, 0, 32U);
					*(*(ref <Module>.struct123_0 + 4) + 2382) = 0;
					*(*(ref <Module>.struct123_0 + 4) + 2384) = 0;
					for (int i = 0; i < 20; i++)
					{
						*(*(ref <Module>.struct123_0 + 4) + 568 + (i + 42)) = ptr[i + 130816];
						*(*(ref <Module>.struct123_0 + 4) + 780 + (i + 20)) = ptr[i + 130816];
					}
					for (int i = 0; i < 2; i++)
					{
						*(*(ref <Module>.struct123_0 + 4) + 568 + (i + 38)) = ptr[i + 130856];
						*(*(ref <Module>.struct123_0 + 4) + 568 + (i + 40)) = ptr[i + 130892];
					}
				}
				else if (*(*(ref <Module>.struct123_0 + 4) + 2382) == 1)
				{
					if (*(*(ref <Module>.struct123_0 + 4) + 2384) == 1)
					{
						<Module>.memcpy((void*)(ptr + 81408), (void*)(&<Module>.struct47_8), 276U);
					}
					else if (*(*(ref <Module>.struct123_0 + 4) + 2384) == 2)
					{
						<Module>.memcpy((void*)(ptr + 81408), (void*)(&<Module>.struct47_6), 276U);
					}
				}
				else if (*(*(ref <Module>.struct123_0 + 4) + 2382) == 2)
				{
					if (*(*(ref <Module>.struct123_0 + 4) + 2384) == 1)
					{
						<Module>.memcpy((void*)(ptr + 81408), (void*)(&<Module>.struct47_2), 276U);
					}
					else if (*(*(ref <Module>.struct123_0 + 4) + 2384) == 2)
					{
						<Module>.memcpy((void*)(ptr + 81408), (void*)(&<Module>.struct47_0), 276U);
					}
					else if (*(*(ref <Module>.struct123_0 + 4) + 2384) == 3)
					{
						<Module>.memcpy((void*)(ptr + 81408), (void*)(&<Module>.struct47_10), 276U);
					}
					else if (*(*(ref <Module>.struct123_0 + 4) + 2384) == 4)
					{
						<Module>.memcpy((void*)(ptr + 81408), (void*)(&<Module>.struct47_4), 276U);
					}
					else if (*(*(ref <Module>.struct123_0 + 4) + 2384) == 5)
					{
						<Module>.memcpy((void*)(ptr + 81408), (void*)(&<Module>.struct47_3), 276U);
					}
					else if (*(*(ref <Module>.struct123_0 + 4) + 2384) == 6)
					{
						<Module>.memcpy((void*)(ptr + 81408), (void*)(&<Module>.struct47_12), 276U);
					}
					else if (*(*(ref <Module>.struct123_0 + 4) + 2384) == 7)
					{
						<Module>.memcpy((void*)(ptr + 81408), (void*)(&<Module>.struct47_11), 276U);
					}
					else if (*(*(ref <Module>.struct123_0 + 4) + 2384) == 8)
					{
						<Module>.memcpy((void*)(ptr + 81408), (void*)(&<Module>.struct47_9), 276U);
					}
					else if (*(*(ref <Module>.struct123_0 + 4) + 2384) == 9)
					{
						<Module>.memcpy((void*)(ptr + 81408), (void*)(&<Module>.struct47_9), 276U);
					}
					else if (*(*(ref <Module>.struct123_0 + 4) + 2384) == 10)
					{
						<Module>.memcpy((void*)(ptr + 81408), (void*)(&<Module>.struct47_9), 276U);
					}
					else if (*(*(ref <Module>.struct123_0 + 4) + 2384) == 11)
					{
						<Module>.memcpy((void*)(ptr + 81408), (void*)(&<Module>.struct47_9), 276U);
					}
					else if (*(*(ref <Module>.struct123_0 + 4) + 2384) == 12)
					{
						<Module>.memcpy((void*)(ptr + 81408), (void*)(&<Module>.struct47_13), 276U);
					}
					else if (*(*(ref <Module>.struct123_0 + 4) + 2384) == 13)
					{
						<Module>.memcpy((void*)(ptr + 81408), (void*)(&<Module>.struct47_13), 276U);
					}
					else if (*(*(ref <Module>.struct123_0 + 4) + 2384) == 14)
					{
						<Module>.memcpy((void*)(ptr + 81408), (void*)(&<Module>.struct47_13), 276U);
					}
					else if (*(*(ref <Module>.struct123_0 + 4) + 2384) == 15)
					{
						<Module>.memcpy((void*)(ptr + 81408), (void*)(&<Module>.struct47_13), 276U);
					}
				}
				else if (*(*(ref <Module>.struct123_0 + 4) + 2382) == 3)
				{
					if (*(*(ref <Module>.struct123_0 + 4) + 2384) == 1)
					{
						<Module>.memcpy((void*)(ptr + 81408), (void*)(&<Module>.struct47_1), 276U);
					}
					else if (*(*(ref <Module>.struct123_0 + 4) + 2384) == 2)
					{
						<Module>.memcpy((void*)(ptr + 81408), (void*)(&<Module>.struct47_5), 276U);
					}
				}
				else if (*(*(ref <Module>.struct123_0 + 4) + 2382) == 0)
				{
					for (int i = 0; i < 20; i++)
					{
						*(*(ref <Module>.struct123_0 + 4) + 568 + (i + 42)) = ptr[i + 130816];
						*(*(ref <Module>.struct123_0 + 4) + 780 + (i + 20)) = ptr[i + 130816];
					}
					for (int i = 0; i < 2; i++)
					{
						*(*(ref <Module>.struct123_0 + 4) + 568 + (i + 38)) = ptr[i + 130856];
						*(*(ref <Module>.struct123_0 + 4) + 568 + (i + 40)) = ptr[i + 130892];
					}
				}
			}
			if (*(*(ref <Module>.struct123_0 + 4)) == 5)
			{
				if (*(*(ref <Module>.struct123_0 + 4) + 2) == 1)
				{
					*(*(ref <Module>.struct123_0 + 4) + 2045) = 0;
					*(*(ref <Module>.struct123_0 + 4) + 2046) = 0;
					*(*(ref <Module>.struct123_0 + 4) + 2047) = 0;
				}
				else if (*(*(ref <Module>.struct123_0 + 4) + 2) == 2 && ptr[126976] == 96)
				{
					*(*(ref <Module>.struct123_0 + 4) + 2045) = 0;
					*(*(ref <Module>.struct123_0 + 4) + 2046) = 0;
					*(*(ref <Module>.struct123_0 + 4) + 2047) = 0;
				}
				else
				{
					*(*(ref <Module>.struct123_0 + 4) + 2045) = 32;
					*(*(ref <Module>.struct123_0 + 4) + 2046) = 32;
					*(*(ref <Module>.struct123_0 + 4) + 2047) = 32;
				}
				<Module>.memcpy((void*)(ptr + *(*(ref <Module>.struct123_0 + 4) + 2024)), *(ref <Module>.struct123_0 + 4) + 2028, 80U);
				if (*(*(ref <Module>.struct123_0 + 4) + 2156) != 0)
				{
					<Module>.memcpy((void*)(ptr + *(*(ref <Module>.struct123_0 + 4) + 2024)), *(ref <Module>.struct123_0 + 4) + 2028, 144U);
				}
				if (*(*(ref <Module>.struct123_0 + 4) + 2187) != 0)
				{
					<Module>.memcpy((void*)(ptr + *(*(ref <Module>.struct123_0 + 4) + 2024)), *(ref <Module>.struct123_0 + 4) + 2028, 224U);
				}
				if (*(*(ref <Module>.struct121_0 + 2388) + 258048) != 0)
				{
					*(*(ref <Module>.struct121_0 + 4780) + 258048) = *(*(ref <Module>.struct121_0 + 2388) + 258048);
					*(*(ref <Module>.struct121_0 + 4780) + 258049) = *(*(ref <Module>.struct121_0 + 2388) + 258049);
					if (*(*(ref <Module>.struct121_0 + 2388) + 258050) != 229 && *(*(ref <Module>.struct121_0 + 4780) + 258050) != 229 && *(*(ref <Module>.struct121_0 + 2388) + 258050) != 0)
					{
						*(*(ref <Module>.struct121_0 + 4780) + 258050) = *(*(ref <Module>.struct121_0 + 2388) + 258050);
						*(*(ref <Module>.struct121_0 + 4780) + 258051) = *(*(ref <Module>.struct121_0 + 2388) + 258051);
						if (*(*(ref <Module>.struct121_0 + 2388) + 258052) != 229 && *(*(ref <Module>.struct121_0 + 4780) + 258052) != 229 && *(*(ref <Module>.struct121_0 + 2388) + 258052) != 0)
						{
							*(*(ref <Module>.struct121_0 + 4780) + 258052) = *(*(ref <Module>.struct121_0 + 2388) + 258052);
							*(*(ref <Module>.struct121_0 + 4780) + 258053) = *(*(ref <Module>.struct121_0 + 2388) + 258053);
						}
					}
				}
			}
			if (*(*(ref <Module>.struct123_0 + 4)) == 6)
			{
				this.method_35(*(ref <Module>.struct123_0 + 4) + 280, *(ref <Module>.struct121_0 + 4780) + 126960);
				<Module>.memcpy((void*)(ptr + *(*(ref <Module>.struct123_0 + 4) + 2024)), *(ref <Module>.struct123_0 + 4) + 2028, 256U);
				if (*(*(ref <Module>.struct123_0 + 4) + 2) != 1)
				{
					if (*(*(ref <Module>.struct123_0 + 4) + 2) != 2)
					{
						for (int i = 0; i < 20; i++)
						{
							*(*(ref <Module>.struct123_0 + 4) + 568 + (i + 96)) = *(*(ref <Module>.struct123_0 + 4) + 2028 + i);
						}
						goto IL_1146;
					}
				}
				for (int i = 0; i < 20; i++)
				{
					*(*(ref <Module>.struct123_0 + 4) + 568 + (i + 96)) = *(*(ref <Module>.struct123_0 + 4) + 2028 + i);
				}
				for (int i = 0; i < 20; i += 2)
				{
					*(*(ref <Module>.struct123_0 + 4) + 780 + (i + 20)) = *(*(ref <Module>.struct123_0 + 4) + 2028 + (i + 1));
					*(*(ref <Module>.struct123_0 + 4) + 780 + (i + 21)) = *(*(ref <Module>.struct123_0 + 4) + 2028 + i);
				}
				for (int i = 0; i < 2; i++)
				{
					*(*(ref <Module>.struct123_0 + 4) + 568 + (i + 52)) = *(*(ref <Module>.struct123_0 + 4) + 2028 + (i + 40));
					*(*(ref <Module>.struct123_0 + 4) + 568 + (i + 54)) = *(*(ref <Module>.struct123_0 + 4) + 2028 + (i + 76));
				}
			}
			IL_1146:
			if (*(*(ref <Module>.struct123_0 + 4)) == 7)
			{
				ptr[*(*(ref <Module>.struct123_0 + 4) + 296) + 312] = *(*(ref <Module>.struct123_0 + 4) + 280);
				ptr[*(*(ref <Module>.struct123_0 + 4) + 296) + 2796] = *(*(ref <Module>.struct123_0 + 4) + 281);
				ptr[*(*(ref <Module>.struct123_0 + 4) + 296) + 1858] = *(*(ref <Module>.struct123_0 + 4) + 282);
				ptr[*(*(ref <Module>.struct123_0 + 4) + 296) + 1664] = *(*(ref <Module>.struct123_0 + 4) + 283);
				ptr[*(*(ref <Module>.struct123_0 + 4) + 296) + 3789] = *(*(ref <Module>.struct123_0 + 4) + 284);
				ptr[*(*(ref <Module>.struct123_0 + 4) + 296) + 2868] = *(*(ref <Module>.struct123_0 + 4) + 285);
				ptr[*(*(ref <Module>.struct123_0 + 4) + 296) + 2111] = *(*(ref <Module>.struct123_0 + 4) + 286);
				ptr[*(*(ref <Module>.struct123_0 + 4) + 296) + 1829] = *(*(ref <Module>.struct123_0 + 4) + 287);
				ptr[*(*(ref <Module>.struct123_0 + 4) + 296) + 1322] = *(*(ref <Module>.struct123_0 + 4) + 288);
				ptr[*(*(ref <Module>.struct123_0 + 4) + 296) + 513] = *(*(ref <Module>.struct123_0 + 4) + 289);
				ptr[*(*(ref <Module>.struct123_0 + 4) + 296) + 2527] = *(*(ref <Module>.struct123_0 + 4) + 290);
				ptr[*(*(ref <Module>.struct123_0 + 4) + 296) + 35] = *(*(ref <Module>.struct123_0 + 4) + 291);
				ptr[*(*(ref <Module>.struct123_0 + 4) + 296) + 1184] = *(*(ref <Module>.struct123_0 + 4) + 292);
				ptr[*(*(ref <Module>.struct123_0 + 4) + 296) + 1434] = *(*(ref <Module>.struct123_0 + 4) + 293);
				ptr[*(*(ref <Module>.struct123_0 + 4) + 296) + 1022] = *(*(ref <Module>.struct123_0 + 4) + 294);
				ptr[*(*(ref <Module>.struct123_0 + 4) + 296) + 3913] = *(*(ref <Module>.struct123_0 + 4) + 295);
				<Module>.memcpy((void*)(ptr + *(*(ref <Module>.struct123_0 + 4) + 2024)), *(ref <Module>.struct123_0 + 4) + 2028, 80U);
				if (*(*(ref <Module>.struct123_0 + 4) + 2) != 1)
				{
					if (*(*(ref <Module>.struct123_0 + 4) + 2) != 2)
					{
						for (int i = 0; i < 20; i++)
						{
							*(*(ref <Module>.struct123_0 + 4) + 568 + (i + 96)) = *(*(ref <Module>.struct123_0 + 4) + 2028 + i);
						}
						goto IL_1525;
					}
				}
				for (int i = 0; i < 20; i++)
				{
					*(*(ref <Module>.struct123_0 + 4) + 568 + (i + 96)) = *(*(ref <Module>.struct123_0 + 4) + 2028 + i);
				}
				for (int i = 0; i < 20; i += 2)
				{
					*(*(ref <Module>.struct123_0 + 4) + 780 + (i + 20)) = *(*(ref <Module>.struct123_0 + 4) + 2028 + (i + 1));
					*(*(ref <Module>.struct123_0 + 4) + 780 + (i + 21)) = *(*(ref <Module>.struct123_0 + 4) + 2028 + i);
				}
				for (int i = 0; i < 2; i++)
				{
					*(*(ref <Module>.struct123_0 + 4) + 568 + (i + 52)) = *(*(ref <Module>.struct123_0 + 4) + 2028 + (i + 40));
					*(*(ref <Module>.struct123_0 + 4) + 568 + (i + 54)) = *(*(ref <Module>.struct123_0 + 4) + 2028 + (i + 76));
				}
			}
			IL_1525:
			return 1;
		}

		// Token: 0x060001FC RID: 508 RVA: 0x001190DC File Offset: 0x001190DC
		private unsafe void method_48()
		{
			if (*<Module>.struct123_0 != 4 || *(<Module>.struct123_0 + 2) != 5)
			{
				byte* ptr = <Module>.struct123_0 + 2028;
				if (ptr[24] == ptr[25] & ptr[24] == ptr[26] & ptr[24] == ptr[27] & ptr[44] == ptr[45] & ptr[44] == ptr[46] & ptr[44] == ptr[47])
				{
					string text = new string(<Module>.struct123_0 + 4) + " is missing some drive specific information.     " + "\n\n";
					text = text + "If this is an old dummy.bin that predates ix1.5 then" + "\n";
					text = text + "if possible you should re-extract your drive info again" + "\n";
					text = text + "with the latest tools.." + new string((sbyte*)(&<Module>.struct6_7));
					text = text + "        1. JungleFlasher, this tool - DVDKey32 Tab" + "\n";
					text = text + "        2. Dosflash 1.7+" + new string((sbyte*)(&<Module>.struct6_7));
					text = text + "        3. DVDKey32 0.7+" + new string((sbyte*)(&<Module>.struct6_7));
					text = text + "You can rebuild the serial info if you have the original" + new string((sbyte*)(&<Module>.struct6_7));
					text = text + "drive available. Tick advanced view, select the Serial" + new string((sbyte*)(&<Module>.struct6_7));
					text = text + "sub-tab in the Source tab. Double-click the serial data" + new string((sbyte*)(&<Module>.struct18_11));
					text = text + "For some newer drives this info is blank by default, if" + new string((sbyte*)(&<Module>.struct6_7));
					text = text + "you are happy that this is the case then there is no" + new string((sbyte*)(&<Module>.struct6_7));
					text = text + "need to repair the serial info." + new string((sbyte*)(&<Module>.struct18_11));
					text = text + "Do you wish to proceed anyway ?" + "\n";
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					int num = (int)MessageBox.Show(this, text, "Loading Dummy.bin", MessageBoxButtons.YesNo, MessageBoxIcon.Hand, MessageBoxDefaultButton.Button2);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
					if (num == 7)
					{
						this.textBox6.AppendText("Dummy.bin not loaded" + "\r\n");
						this.method_40();
					}
					else
					{
						text = "";
						text = text + "Do you wish to repair the serial from drive barcodes ?" + "\n";
						<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
						num = (int)MessageBox.Show(this, text, "Loading Dummy.bin", MessageBoxButtons.YesNo, MessageBoxIcon.Hand, MessageBoxDefaultButton.Button2);
						<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
						if (num == 6)
						{
							this.method_52();
						}
					}
				}
			}
		}

		// Token: 0x060001FD RID: 509 RVA: 0x00119358 File Offset: 0x00119358
		private unsafe int method_49()
		{
			string text = null;
			string[] commandLineArgs = Environment.GetCommandLineArgs();
			while (string.Compare(commandLineArgs[0], "") == 0)
			{
				Environment.GetCommandLineArgs();
			}
			text = Path.GetDirectoryName(commandLineArgs[0]);
			string strB;
			if (*<Module>.struct123_0 == 1)
			{
				text += "\\firmware\\LT-sammy-v2.01.bin";
				strB = "d66252800c1c072bc612f2f72d1e3c76";
			}
			else if (*<Module>.struct123_0 == 3 && *(<Module>.struct123_0 + 2) == 1)
			{
				text += "\\firmware\\LTPlus-benq-v1.1.bin";
				strB = "c45d60fbd68cc642b2235ba12e5aad7d";
			}
			else if (*<Module>.struct123_0 == 3 && *(<Module>.struct123_0 + 2) == 2)
			{
				text += "\\firmware\\LTPlus-benq-v1.1.bin";
				strB = "c45d60fbd68cc642b2235ba12e5aad7d";
			}
			else if (*<Module>.struct123_0 == 3 && *(<Module>.struct123_0 + 2) == 3)
			{
				text += "\\firmware\\LTPlus-0442-v3.0.bin";
				strB = "8784e0f4ce27941a2a3293c8a5ac85e4";
			}
			else if (*<Module>.struct123_0 == 4 && *(<Module>.struct123_0 + 2) == 1)
			{
				text += "\\firmware\\LTPlus-748v1.1.bin";
				strB = "53786fac70e9c6b895b2e99144c7fb6d";
			}
			else if (*<Module>.struct123_0 == 4 && *(<Module>.struct123_0 + 2) == 2)
			{
				text += "\\firmware\\LTPlus-838v1.1.bin";
				strB = "020325ef05290fa80baec9863041a11c";
			}
			else if (*<Module>.struct123_0 == 4 && *(<Module>.struct123_0 + 2) == 3)
			{
				text += "\\firmware\\LTPlus-838v2v1.1.bin";
				strB = "acc8ce739377578df2ca33ba3680ff54";
			}
			else if (*<Module>.struct123_0 == 4 && *(<Module>.struct123_0 + 2) == 4)
			{
				text += "\\firmware\\LTPlus-934v1.1.bin";
				strB = "d1671296ac52b8a67838f637f435fa6a";
			}
			else if (*<Module>.struct123_0 == 4 && *(<Module>.struct123_0 + 2) == 5)
			{
				text += "\\firmware\\LTPlus-0251-v3.0.bin";
				strB = "d14fe82b96741b7a18e5c1e7adbf0a98";
			}
			else if (*<Module>.struct123_0 == 5 && *(<Module>.struct123_0 + 2) == 1)
			{
				text += "\\firmware\\LTPlus-9504.bin";
				strB = "fb7b3d4487cc17c6518b14e57ae82cc2";
			}
			else if (*<Module>.struct123_0 == 5 && *(<Module>.struct123_0 + 2) == 2)
			{
				if (*(*(ref <Module>.struct121_0 + 2388) + 126976) == 96)
				{
					text += "\\firmware\\LTPlus-0225-v3.0u.bin";
					strB = "db5c70eaaabb53501c2c4f53dce9abfd";
				}
				else if (*(*(ref <Module>.struct121_0 + 2388) + 126976) == 125)
				{
					text += "\\firmware\\LTPlus-0225-v3.0d.bin";
					strB = "faf085ff40fcbedf6a352318d55879c0";
				}
				else
				{
					text += "\\firmware\\LTPlus-0225-v3.0.bin";
					strB = "1a38d3a2a6519339599fa1866642c513";
				}
			}
			else if (*<Module>.struct123_0 == 5 && *(<Module>.struct123_0 + 2) == 3)
			{
				text += "\\firmware\\LTPlus-0401-v3.0.bin";
				strB = "87fba52607d01d3c73722f9f818588c9";
			}
			else if (*<Module>.struct123_0 == 5 && *(<Module>.struct123_0 + 2) == 4)
			{
				text += "\\firmware\\LTPlus-0272-v3.0.bin";
				strB = "76b991307ddd5b2af581d0608e671b36";
			}
			else
			{
				if (*<Module>.struct123_0 != 5 || *(<Module>.struct123_0 + 2) != 5)
				{
					return 0;
				}
				text += "\\firmware\\LTPlus-1071-v3.0.bin";
				strB = "3d1243454d9c6c1cd2760b8ea5f5c648";
			}
			if (!this.bool_2)
			{
				string text2 = this.label6.Text + " firmware loaded to Source buffer!" + "\n" + "Do you wish to auto-load " + this.label6.Text + " LT-Plus ?";
				<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
				int num = (int)MessageBox.Show(this, text2, "Loading Source", MessageBoxButtons.YesNo, MessageBoxIcon.Question, MessageBoxDefaultButton.Button1);
				<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
				if (num == 7)
				{
					return 0;
				}
			}
			IntPtr intPtr = Marshal.StringToHGlobalAnsi(text);
			IntPtr value = intPtr;
			sbyte* pSbyte_ = (sbyte*)((void*)value);
			int result;
			if (<Module>.fopen((sbyte*)pSbyte_, (sbyte*)(&<Module>.struct18_4)) == null)
			{
				<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
				MessageBox.Show(this, "Can't open file" + " " + text, "Auto-Load iXtreme", MessageBoxButtons.OK);
				<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
				result = 0;
			}
			else
			{
				GStruct93 gstruct;
				<Module>.smethod_111(ref gstruct);
				int result2;
				try
				{
					GStruct19 gstruct2;
					GStruct19* pGstruct19_ = <Module>.smethod_91(ref gstruct2, (sbyte*)pSbyte_);
					GStruct19 gstruct3;
					<Module>.smethod_114(ref gstruct, &gstruct3, (GStruct19*)pGstruct19_);
					try
					{
						string strA = new string(<Module>.smethod_94(ref gstruct3));
						if (string.Compare(strA, strB) == 0)
						{
							goto IL_4B0;
						}
						<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
						MessageBox.Show(this, "iXtreme file failed MD5 hash check!", "Load iXtreme", MessageBoxButtons.OK);
						<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
						result2 = 0;
					}
					catch
					{
						<Module>.__CxxCallUnwindDtor(<Module>.ppInt_14, (void*)(&gstruct3));
						throw;
					}
					<Module>.smethod_92(ref gstruct3);
				}
				catch
				{
					<Module>.__CxxCallUnwindDtor(<Module>.ppInt_13, (void*)(&gstruct));
					throw;
				}
				<Module>.smethod_112(ref gstruct);
				return result2;
				int num2;
				try
				{
					GStruct19 gstruct3;
					try
					{
						IL_4B0:
						this.textBox6.AppendText(string.Concat("Auto-"));
						this.method_36(text, 1);
						num2 = 1;
					}
					catch
					{
						<Module>.__CxxCallUnwindDtor(<Module>.ppInt_14, (void*)(&gstruct3));
						throw;
					}
					<Module>.smethod_92(ref gstruct3);
				}
				catch
				{
					<Module>.__CxxCallUnwindDtor(<Module>.ppInt_13, (void*)(&gstruct));
					throw;
				}
				<Module>.smethod_112(ref gstruct);
				result = num2;
			}
			return result;
		}

		// Token: 0x060001FE RID: 510 RVA: 0x001198D0 File Offset: 0x001198D0
		private void OpenSource_Click(object sender, EventArgs e)
		{
			this.method_50(0);
		}

		// Token: 0x060001FF RID: 511 RVA: 0x001198E4 File Offset: 0x001198E4
		private void method_50(int int_16)
		{
			this.method_40();
			OpenFileDialog openFileDialog = new OpenFileDialog();
			openFileDialog.Filter = "Firmware file (*.bin)|*.bin|All Files (*.*)|*.*";
			openFileDialog.FileName = "Orig.bin";
			openFileDialog.DefaultExt = ".bin";
			openFileDialog.CheckFileExists = true;
			openFileDialog.CheckPathExists = true;
			openFileDialog.RestoreDirectory = false;
			if (this.bool_2)
			{
				openFileDialog.InitialDirectory = this.string_10;
			}
			if (openFileDialog.ShowDialog() == DialogResult.OK)
			{
				string fullPath = Path.GetFullPath(openFileDialog.FileName);
				this.method_36(fullPath, int_16);
			}
		}

		// Token: 0x06000200 RID: 512 RVA: 0x0011996C File Offset: 0x0011996C
		private void tabPage12_DragDrop(object sender, DragEventArgs e)
		{
			this.method_40();
			string[] array = (string[])e.Data.GetData(DataFormats.FileDrop);
			string string_ = array[0];
			this.method_36(string_, 0);
		}

		// Token: 0x06000201 RID: 513 RVA: 0x001199A8 File Offset: 0x001199A8
		private void textBox19_TextChanged(object sender, EventArgs e)
		{
			if (string.Compare(this.textBox19.Text, "EasyToFindSource") != 0)
			{
				if (string.Compare(this.textBox19.Text, "DoDVDKey") == 0)
				{
					this.method_60();
				}
				else if (string.Compare(this.textBox19.Text, "DoBadFlash") == 0)
				{
					this.method_198();
				}
				else
				{
					this.method_36(this.textBox19.Text, 0);
				}
				this.textBox19.Text = "EasyToFindSource";
			}
		}

		// Token: 0x06000202 RID: 514 RVA: 0x00119A30 File Offset: 0x00119A30
		private void textBox20_TextChanged(object sender, EventArgs e)
		{
			if (string.Compare(this.textBox20.Text, "EasyToFindUpdate") != 0)
			{
				this.method_43();
				this.method_36(this.textBox20.Text, 5);
				this.method_27();
				this.textBox20.Text = "EasyToFindUpdate";
			}
		}

		// Token: 0x06000203 RID: 515 RVA: 0x00119A84 File Offset: 0x00119A84
		private void tabPage12_DragEnter(object sender, DragEventArgs e)
		{
			if (e.Data.GetDataPresent(DataFormats.FileDrop))
			{
				e.Effect = DragDropEffects.All;
			}
			else
			{
				e.Effect = DragDropEffects.None;
			}
			string[] array = (string[])e.Data.GetData(DataFormats.FileDrop);
			if (array.Length > 1)
			{
				e.Effect = DragDropEffects.None;
			}
		}

		// Token: 0x06000204 RID: 516 RVA: 0x00119ADC File Offset: 0x00119ADC
		private void menuItem_5_Click(object sender, EventArgs e)
		{
			this.method_50(0);
		}

		// Token: 0x06000205 RID: 517 RVA: 0x00119AF0 File Offset: 0x00119AF0
		private void menuItem_6_Click(object sender, EventArgs e)
		{
			<Module>.memset(<Module>.struct123_0, 0, 2392U);
			this.method_40();
		}

		// Token: 0x06000206 RID: 518 RVA: 0x00119B18 File Offset: 0x00119B18
		private void menuItem_7_Click(object sender, EventArgs e)
		{
			if (!this.bool_4)
			{
				this.method_27();
			}
		}

		// Token: 0x06000207 RID: 519 RVA: 0x00119B34 File Offset: 0x00119B34
		private void menuItem_12_Click(object sender, EventArgs e)
		{
			DataBaseView dataBaseView = new DataBaseView();
			dataBaseView.int_0 = 0;
			if (dataBaseView.ShowDialog(this) == DialogResult.OK)
			{
				this.string_10 = Path.GetDirectoryName(dataBaseView.textBox15.Text);
				this.string_9 = dataBaseView.textBox2.Text;
			}
		}

		// Token: 0x06000208 RID: 520 RVA: 0x00119B84 File Offset: 0x00119B84
		private void menuItem_13_Click(object sender, EventArgs e)
		{
			this.method_28();
		}

		// Token: 0x06000209 RID: 521 RVA: 0x00119B98 File Offset: 0x00119B98
		private void menuItem_19_Click(object sender, EventArgs e)
		{
			string text = null;
			if (this.method_69() == 0)
			{
				this.textBox6.AppendText("No drive present on port " + this.comboBox7.Text + "\r\n\r\n");
			}
			else
			{
				this.textBox6.AppendText("Attempting to verify Source Key to drive on port " + this.comboBox7.Text + "\r\n");
				string text2 = this.textBox9.Text;
				if (this.method_107(<Module>.struct123_0 + 280) == 1)
				{
					RegistryKey registryKey = Registry.CurrentUser.CreateSubKey("JF_KeyDB\\KeyList");
					if (registryKey.GetValue(text2) != null)
					{
						string text3 = registryKey.GetValue(text2).ToString();
						registryKey.Close();
						registryKey = Registry.CurrentUser.CreateSubKey("JF_KeyDB\\" + text3);
						if (registryKey.GetValue("JobName") != null)
						{
							text = registryKey.GetValue("JobName").ToString();
						}
						string text4;
						if (registryKey.GetValue("WorkingDir") != null)
						{
							text4 = registryKey.GetValue("WorkingDir").ToString();
						}
						else
						{
							text4 = "";
						}
						string strA;
						if (registryKey.GetValue("LastFile") != null)
						{
							strA = registryKey.GetValue("LastFile").ToString();
						}
						else
						{
							strA = "";
						}
						if (registryKey.GetValue("Index") != null)
						{
							text3 = registryKey.GetValue("Index").ToString();
						}
						this.toolTip_0.SetToolTip(this.pictureBox5, "Drive Key found in KeyDB (" + text3 + " - " + text + ")" + Environment.NewLine + "Key is: " + text2);
						this.toolTip_0.SetToolTip(this.pictureBox2, "Drive Key found in KeyDB (" + text3 + " - " + text + ")" + Environment.NewLine + "Key is: " + text2);
						this.pictureBox5.Visible = true;
						this.pictureBox7.Visible = false;
						this.pictureBox2.Visible = true;
						this.pictureBox6.Visible = false;
						if (string.Compare(strA, "") != 0)
						{
							this.menuItem_21.Enabled = true;
						}
						this.menuItem_22.Enabled = true;
						this.menuItem_23.Enabled = true;
						this.menuItem_24.Enabled = true;
						this.string_14 = text2;
						this.string_15 = text3;
						this.string_16 = strA;
						this.string_17 = text4;
						this.label133.Text = "Verified";
						this.label131.Text = "Verified";
						registryKey.Close();
						this.Cursor = Cursors.Arrow;
						this.textBox6.AppendText("\r\n" + "Key found in KeyDB at record (" + text3 + " - " + text + ")" + "\r\n" + "Key is: " + text2 + "\r\n" + "Key has been tested and verified, thanks C4eva ! " + "\r\n");
					}
					else
					{
						this.toolTip_0.SetToolTip(this.pictureBox5, "Drive Key NOT in KeyDB " + Environment.NewLine + "Key is: " + text2);
						this.toolTip_0.SetToolTip(this.pictureBox2, "Drive Key NOT in KeyDB " + Environment.NewLine + "Key is: " + text2);
						this.pictureBox5.Visible = true;
						this.pictureBox7.Visible = false;
						this.pictureBox2.Visible = true;
						this.pictureBox6.Visible = false;
						this.string_14 = text2;
						this.label133.Text = "Verified";
						this.label131.Text = "Verified";
						registryKey.Close();
						this.Cursor = Cursors.Arrow;
						if (this.bool_1)
						{
							this.textBox6.AppendText("\r\n" + "Key NOT in KeyDB " + "\r\n" + "Key is: " + text2 + "\r\n" + "Key has been tested and verified, thanks C4eva ! " + "\r\n");
						}
					}
				}
				else
				{
					this.textBox6.AppendText("\r\n" + "Source Key not verified against drive." + "\r\n");
				}
			}
		}

		// Token: 0x0600020A RID: 522 RVA: 0x00119F7C File Offset: 0x00119F7C
		private void menuItem_33_Click(object sender, EventArgs e)
		{
			bool flag = this.bool_2;
			this.bool_2 = true;
			if (this.method_49() == 1)
			{
				this.method_46();
				this.method_47();
				this.method_41();
			}
			this.bool_2 = flag;
		}

		// Token: 0x0600020B RID: 523 RVA: 0x00119FC0 File Offset: 0x00119FC0
		private void button41_Click(object sender, EventArgs e)
		{
			DataBaseView dataBaseView = new DataBaseView();
			dataBaseView.int_0 = 0;
			if (dataBaseView.ShowDialog(this) == DialogResult.OK)
			{
				this.string_10 = Path.GetDirectoryName(dataBaseView.textBox15.Text);
				this.string_9 = dataBaseView.textBox2.Text;
			}
		}

		// Token: 0x0600020C RID: 524 RVA: 0x003C1858 File Offset: 0x00309858
		private unsafe void DumpDrive_Click(object sender, EventArgs e)
		{
			SaveFileDialog saveFileDialog = new SaveFileDialog();
			saveFileDialog.Filter = "Firmware Images (*.bin)|*.bin|All Files (*.*)|*.*";
			saveFileDialog.DefaultExt = ".bin";
			saveFileDialog.FileName = "Key.bin";
			saveFileDialog.RestoreDirectory = false;
			if (this.bool_2)
			{
				saveFileDialog.InitialDirectory = this.string_10;
			}
			if (saveFileDialog.ShowDialog() == DialogResult.OK)
			{
				string fullPath = Path.GetFullPath(saveFileDialog.FileName);
				IntPtr intPtr = Marshal.StringToHGlobalAnsi(fullPath);
				IntPtr value = intPtr;
				sbyte* pSbyte_ = (sbyte*)((void*)value);
				GStruct5* ptr = <Module>.fopen((sbyte*)pSbyte_, (sbyte*)(&<Module>.struct18_5));
				if (ptr == null)
				{
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					MessageBox.Show(saveFileDialog.FileName.ToString(), "Can't open file", MessageBoxButtons.OK);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
					return;
				}
				this.textBox6.AppendText("Key data saved to " + saveFileDialog.FileName + "\r\n\r\n");
				<Module>.fwrite(<Module>.struct123_0 + 280, 16U, 1U, ptr);
				<Module>.fclose(ptr);
			}
			saveFileDialog.FileName = "Inquiry.bin";
			if (saveFileDialog.ShowDialog() == DialogResult.OK)
			{
				string fullPath2 = Path.GetFullPath(saveFileDialog.FileName);
				IntPtr intPtr2 = Marshal.StringToHGlobalAnsi(fullPath2);
				IntPtr value2 = intPtr2;
				sbyte* pSbyte_2 = (sbyte*)((void*)value2);
				GStruct5* ptr = <Module>.fopen((sbyte*)pSbyte_2, (sbyte*)(&<Module>.struct18_5));
				if (ptr == null)
				{
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					MessageBox.Show(saveFileDialog.FileName.ToString(), "Can't open file", MessageBoxButtons.OK);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
					return;
				}
				this.textBox6.AppendText("Inquiry data saved to " + saveFileDialog.FileName + "\r\n\r\n");
				if (*<Module>.struct123_0 != 7 && *<Module>.struct123_0 != 6)
				{
					if (*<Module>.struct123_0 != 5)
					{
						<Module>.fwrite(<Module>.struct123_0 + 568, 96U, 1U, ptr);
						goto IL_20F;
					}
				}
				<Module>.fwrite(<Module>.struct123_0 + 568, 116U, 1U, ptr);
				IL_20F:
				<Module>.fclose(ptr);
			}
			saveFileDialog.FileName = "Identify.bin";
			if (saveFileDialog.ShowDialog() == DialogResult.OK)
			{
				string fullPath3 = Path.GetFullPath(saveFileDialog.FileName);
				IntPtr intPtr3 = Marshal.StringToHGlobalAnsi(fullPath3);
				IntPtr value3 = intPtr3;
				sbyte* pSbyte_3 = (sbyte*)((void*)value3);
				GStruct5* ptr = <Module>.fopen((sbyte*)pSbyte_3, (sbyte*)(&<Module>.struct18_5));
				if (ptr == null)
				{
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					MessageBox.Show(saveFileDialog.FileName.ToString(), "Can't open file", MessageBoxButtons.OK);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
				}
				else
				{
					this.textBox6.AppendText("Identify data saved to " + saveFileDialog.FileName + "\r\n\r\n");
					<Module>.fwrite(<Module>.struct123_0 + 780, 180U, 1U, ptr);
					<Module>.fclose(ptr);
				}
			}
		}

		// Token: 0x0600020D RID: 525 RVA: 0x0011A300 File Offset: 0x0011A300
		private void button2_Click(object sender, EventArgs e)
		{
			this.method_18();
			this.method_51();
			this.method_19();
		}

		// Token: 0x0600020E RID: 526 RVA: 0x0011A320 File Offset: 0x0011A320
		private unsafe void method_51()
		{
			DumpFile dumpFile = new DumpFile();
			dumpFile.bool_4 = this.bool_2;
			dumpFile.string_1 = this.string_10;
			if (dumpFile.ShowDialog(this) == DialogResult.OK)
			{
				SaveFileDialog saveFileDialog = new SaveFileDialog();
				saveFileDialog.Filter = "Firmware Images (*.bin)|*.bin|All Files (*.*)|*.*";
				saveFileDialog.DefaultExt = ".bin";
				saveFileDialog.FileName = "dummy.bin";
				saveFileDialog.RestoreDirectory = false;
				if (this.bool_2)
				{
					saveFileDialog.InitialDirectory = this.string_10;
				}
				if (saveFileDialog.ShowDialog() == DialogResult.OK)
				{
					string fullPath = Path.GetFullPath(saveFileDialog.FileName);
					string fileName = Path.GetFileName(saveFileDialog.FileName);
					IntPtr intPtr = Marshal.StringToHGlobalAnsi(fullPath);
					IntPtr value = intPtr;
					sbyte* pSbyte_ = (sbyte*)((void*)value);
					GStruct5* ptr = <Module>.fopen((sbyte*)pSbyte_, (sbyte*)(&<Module>.struct18_5));
					if (ptr == null)
					{
						<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
						MessageBox.Show(fileName, "Can't open file", MessageBoxButtons.OK);
						<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
					}
					<Module>.fwrite((void*)dumpFile.pByte_4, 262144U, 1U, ptr);
					<Module>.fclose(ptr);
					this.textBox6.AppendText("\r\n" + "Loading DVDkey source file " + "\r\n");
					this.method_37(fullPath, 0, dumpFile.pByte_4);
					this.tabControl5.SelectedTab = this.Firmtools;
				}
			}
		}

		// Token: 0x0600020F RID: 527 RVA: 0x0011A484 File Offset: 0x0011A484
		private void textBox12_DoubleClick(object sender, EventArgs e)
		{
			this.method_52();
		}

		// Token: 0x06000210 RID: 528 RVA: 0x0011A498 File Offset: 0x0011A498
		private unsafe void method_52()
		{
			if (*<Module>.struct123_0 == 4 || *<Module>.struct123_0 == 5)
			{
				if (*<Module>.struct123_0 == 4)
				{
					<Module>.memset(ref <Module>.struct121_0 + 2028 + 64, 255, 12U);
					<Module>.memset(*(ref <Module>.struct121_0 + 2388) + 130880, 255, 12U);
				}
				else if (*<Module>.struct123_0 == 5)
				{
					<Module>.memset(ref <Module>.struct121_0 + 2028 + 64, 0, 12U);
					<Module>.memset(*(ref <Module>.struct121_0 + 2388) + 130880, 0, 12U);
				}
				FixSerial fixSerial = new FixSerial();
				if (fixSerial.pByte_0 != null)
				{
					<Module>.free((void*)fixSerial.pByte_0);
				}
				fixSerial.pByte_0 = <Module>.malloc(80U);
				<Module>.memcpy((void*)fixSerial.pByte_0, <Module>.struct123_0 + 2028, 80U);
				if (fixSerial.pByte_1 != null)
				{
					<Module>.free((void*)fixSerial.pByte_1);
				}
				fixSerial.pByte_1 = <Module>.malloc(262144U);
				<Module>.memcpy((void*)fixSerial.pByte_1, *(ref <Module>.struct121_0 + 2388), 262144U);
				fixSerial.uint_1 = (uint)(*<Module>.struct123_0);
				fixSerial.uint_2 = (uint)(*(<Module>.struct123_0 + 2));
				fixSerial.uint_0 = (uint)(*(<Module>.struct123_0 + 296));
				if (fixSerial.ShowDialog(this) == DialogResult.OK)
				{
					this.textBox6.AppendText("\r\n" + "Loading Fixed Dummy.bin file " + "\r\n");
					this.method_37(fixSerial.string_0, 0, fixSerial.pByte_1);
					this.tabControl5.SelectedTab = this.Firmtools;
				}
				if (fixSerial.pByte_1 != null)
				{
					<Module>.free((void*)fixSerial.pByte_1);
				}
				if (fixSerial.pByte_0 != null)
				{
					<Module>.free((void*)fixSerial.pByte_0);
				}
			}
		}

		// Token: 0x06000211 RID: 529 RVA: 0x0011A668 File Offset: 0x0011A668
		private unsafe void method_53()
		{
			Struct28 @struct = 255;
			*(ref @struct + 1) = byte.MaxValue;
			*(ref @struct + 2) = byte.MaxValue;
			*(ref @struct + 3) = byte.MaxValue;
			*(ref @struct + 4) = byte.MaxValue;
			*(ref @struct + 5) = byte.MaxValue;
			*(ref @struct + 6) = byte.MaxValue;
			*(ref @struct + 7) = byte.MaxValue;
			*(ref @struct + 8) = byte.MaxValue;
			*(ref @struct + 9) = byte.MaxValue;
			*(ref @struct + 10) = byte.MaxValue;
			*(ref @struct + 11) = byte.MaxValue;
			*(ref @struct + 12) = byte.MaxValue;
			*(ref @struct + 13) = byte.MaxValue;
			*(ref @struct + 14) = byte.MaxValue;
			*(ref @struct + 15) = byte.MaxValue;
			this.textBox6.AppendText("\r\n" + "Scanning sector 0x4000 for keys" + "\r\n\r\n");
			int num = 1;
			for (int i = 16410; i < 20480; i += 42)
			{
				byte* pByte_ = *(ref <Module>.struct121_0 + 2388) + i;
				this.method_6(pByte_, 16U, 0U);
				if (<Module>.memcmp((void*)pByte_, (void*)(&@struct), 16U) == null)
				{
					break;
				}
				Struct79 struct2;
				<Module>.sprintf((sbyte*)(&struct2), (sbyte*)(&<Module>.struct35_124), i);
				string str = "0x";
				str += new string((sbyte*)(&struct2));
				num++;
				this.textBox6.AppendText(str + "  " + this.string_0 + "\r\n");
			}
			this.textBox6.AppendText(Convert.ToString(num) + " keys populated " + "\r\n\r\n");
		}

		// Token: 0x06000212 RID: 530 RVA: 0x0011A7E4 File Offset: 0x0011A7E4
		private unsafe void method_54()
		{
			string text = null;
			Struct28 @struct = 255;
			*(ref @struct + 1) = byte.MaxValue;
			*(ref @struct + 2) = byte.MaxValue;
			*(ref @struct + 3) = byte.MaxValue;
			*(ref @struct + 4) = byte.MaxValue;
			*(ref @struct + 5) = byte.MaxValue;
			*(ref @struct + 6) = byte.MaxValue;
			*(ref @struct + 7) = byte.MaxValue;
			*(ref @struct + 8) = byte.MaxValue;
			*(ref @struct + 9) = byte.MaxValue;
			*(ref @struct + 10) = byte.MaxValue;
			*(ref @struct + 11) = byte.MaxValue;
			*(ref @struct + 12) = byte.MaxValue;
			*(ref @struct + 13) = byte.MaxValue;
			*(ref @struct + 14) = byte.MaxValue;
			*(ref @struct + 15) = byte.MaxValue;
			Struct28 struct2 = 187;
			*(ref struct2 + 1) = 187;
			*(ref struct2 + 2) = 187;
			*(ref struct2 + 3) = byte.MaxValue;
			*(ref struct2 + 4) = byte.MaxValue;
			*(ref struct2 + 5) = byte.MaxValue;
			*(ref struct2 + 6) = byte.MaxValue;
			*(ref struct2 + 7) = byte.MaxValue;
			*(ref struct2 + 8) = byte.MaxValue;
			*(ref struct2 + 9) = byte.MaxValue;
			*(ref struct2 + 10) = byte.MaxValue;
			*(ref struct2 + 11) = byte.MaxValue;
			*(ref struct2 + 12) = byte.MaxValue;
			*(ref struct2 + 13) = byte.MaxValue;
			*(ref struct2 + 14) = byte.MaxValue;
			*(ref struct2 + 15) = byte.MaxValue;
			Struct28 struct3 = 0;
			*(ref struct3 + 1) = 0;
			*(ref struct3 + 2) = 0;
			*(ref struct3 + 3) = 0;
			*(ref struct3 + 4) = 0;
			*(ref struct3 + 5) = 0;
			*(ref struct3 + 6) = 0;
			*(ref struct3 + 7) = 0;
			*(ref struct3 + 8) = 0;
			*(ref struct3 + 9) = 0;
			*(ref struct3 + 10) = 0;
			*(ref struct3 + 11) = 0;
			*(ref struct3 + 12) = 0;
			*(ref struct3 + 13) = 0;
			*(ref struct3 + 14) = 0;
			*(ref struct3 + 15) = 0;
			int num2;
			int value;
			for (int i = 16410; i < 20480; i += 42)
			{
				byte* pByte_ = *(ref <Module>.struct121_0 + 2388) + i;
				int num = 1;
				Struct79 struct4;
				<Module>.sprintf((sbyte*)(&struct4), (sbyte*)(&<Module>.struct35_124), i);
				string text2 = "0x";
				text2 += new string((sbyte*)(&struct4));
				if (<Module>.memcmp((void*)pByte_, (void*)(&@struct), 16U) == null)
				{
					break;
				}
				if (<Module>.memcmp((void*)pByte_, (void*)(&struct2), 16U) != null && <Module>.memcmp((void*)pByte_, (void*)(&struct3), 16U) != null)
				{
					num2 = i;
					this.method_6(pByte_, 16U, (uint)i);
					for (int j = 1; j < 256; j++)
					{
						byte* ptr = *(ref <Module>.struct121_0 + 2388) + (i + 42);
						if (<Module>.memcmp((void*)pByte_, (void*)ptr, 16U) != null)
						{
							break;
						}
						num++;
						i += 42;
					}
					this.textBox6.AppendText(text2 + "  " + this.string_0 + " x " + Convert.ToString(num) + "\r\n");
					text = text2;
					value = num;
				}
			}
			<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
			int num3 = (int)MessageBox.Show("Last good key " + this.string_0 + " found " + Convert.ToString(value) + " times, starting at " + text + "\n" + "Do you wish to revert to this key ?" + "\n\n" + "Press yes to proceed.", "Sammy-Un-Lock Repair", MessageBoxButtons.YesNo, MessageBoxIcon.Question, MessageBoxDefaultButton.Button2);
			<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
			if (num3 == 6)
			{
				this.textBox6.AppendText("Reverting to last good key " + this.string_0 + " found at " + text + "\r\n");
				Struct32 struct5;
				<Module>.memcpy((void*)(&struct5), *(ref <Module>.struct121_0 + 2388), 262144U);
				for (int k = num2 + 16; k < 20480; k++)
				{
					*(ref struct5 + k) = byte.MaxValue;
				}
				SaveFileDialog saveFileDialog = new SaveFileDialog();
				saveFileDialog.Filter = "Firmware Images (*.bin)|*.bin|All Files (*.*)|*.*";
				saveFileDialog.DefaultExt = ".bin";
				saveFileDialog.FileName = "SAM-OFW-Fixed.bin";
				saveFileDialog.RestoreDirectory = false;
				if (this.bool_2)
				{
					saveFileDialog.InitialDirectory = this.string_10;
				}
				if (saveFileDialog.ShowDialog() == DialogResult.OK)
				{
					string fullPath = Path.GetFullPath(saveFileDialog.FileName);
					string fileName = Path.GetFileName(saveFileDialog.FileName);
					IntPtr intPtr = Marshal.StringToHGlobalAnsi(fullPath);
					IntPtr value2 = intPtr;
					sbyte* pSbyte_ = (sbyte*)((void*)value2);
					this.string_13 = saveFileDialog.FileName;
					GStruct5* ptr2 = <Module>.fopen((sbyte*)pSbyte_, (sbyte*)(&<Module>.struct18_5));
					if (ptr2 == null)
					{
						<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
						MessageBox.Show(fileName, "Can't open file", MessageBoxButtons.OK);
						<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
					}
					else
					{
						<Module>.fwrite((void*)(&struct5), 262144U, 1U, ptr2);
						<Module>.fclose(ptr2);
						this.textBox6.AppendText("\r\n" + "F/W file saved to " + fileName + "\r\n");
						this.method_37(fullPath, 0, (byte*)(&struct5));
					}
				}
			}
		}

		// Token: 0x06000213 RID: 531 RVA: 0x0011ACB8 File Offset: 0x0011ACB8
		private void OpeniXtreme_Click(object sender, EventArgs e)
		{
			this.method_55();
		}

		// Token: 0x06000214 RID: 532 RVA: 0x0011ACCC File Offset: 0x0011ACCC
		private void method_55()
		{
			OpenFileDialog openFileDialog = new OpenFileDialog();
			openFileDialog.Filter = "Firmware file (*.bin)|*.bin|All Files (*.*)|*.*";
			openFileDialog.FileName = "ix16.bin";
			openFileDialog.DefaultExt = ".bin";
			openFileDialog.CheckFileExists = true;
			openFileDialog.CheckPathExists = true;
			openFileDialog.RestoreDirectory = false;
			if (this.bool_2)
			{
				openFileDialog.InitialDirectory = this.string_10;
			}
			if (openFileDialog.ShowDialog() == DialogResult.OK)
			{
				string fullPath = Path.GetFullPath(openFileDialog.FileName);
				this.method_36(fullPath, 1);
			}
		}

		// Token: 0x06000215 RID: 533 RVA: 0x0011AD4C File Offset: 0x0011AD4C
		private void method_56()
		{
			string[] commandLineArgs = Environment.GetCommandLineArgs();
			string directoryName = Path.GetDirectoryName(commandLineArgs[0]);
			OpenFileDialog openFileDialog = new OpenFileDialog();
			openFileDialog.Filter = "LTPlus files |LTPlus-*.bin;LT-*.bin|All Files (*.*)|*.*";
			openFileDialog.FileName = "LTPlus.bin";
			openFileDialog.DefaultExt = ".bin";
			openFileDialog.CheckFileExists = true;
			openFileDialog.CheckPathExists = true;
			openFileDialog.RestoreDirectory = false;
			openFileDialog.InitialDirectory = directoryName + "\\firmware";
			if (openFileDialog.ShowDialog() == DialogResult.OK)
			{
				string fullPath = Path.GetFullPath(openFileDialog.FileName);
				this.method_36(fullPath, 1);
			}
		}

		// Token: 0x06000216 RID: 534 RVA: 0x0011ADDC File Offset: 0x0011ADDC
		private void textBox5_TextChanged(object sender, EventArgs e)
		{
			if (string.Compare(this.textBox5.Text, "EasyToFindTarget") != 0)
			{
				this.method_36(this.textBox5.Text, 1);
				this.textBox5.Text = "EasyToFindTarget";
			}
		}

		// Token: 0x06000217 RID: 535 RVA: 0x0011AE24 File Offset: 0x0011AE24
		private void tabPage13_DragDrop(object sender, DragEventArgs e)
		{
			string[] array = (string[])e.Data.GetData(DataFormats.FileDrop);
			string string_ = array[0];
			this.method_36(string_, 1);
		}

		// Token: 0x06000218 RID: 536 RVA: 0x0011AE58 File Offset: 0x0011AE58
		private void menuItem_2_Click(object sender, EventArgs e)
		{
			this.method_55();
		}

		// Token: 0x06000219 RID: 537 RVA: 0x0011AE6C File Offset: 0x0011AE6C
		private void menuItem_3_Click(object sender, EventArgs e)
		{
			this.method_56();
		}

		// Token: 0x0600021A RID: 538 RVA: 0x0011AE80 File Offset: 0x0011AE80
		private unsafe void menuItem_4_Click(object sender, EventArgs e)
		{
			<Module>.memset(*(ref <Module>.struct123_0 + 4), 0, 2392U);
			this.method_43();
		}

		// Token: 0x0600021B RID: 539 RVA: 0x0011AEA8 File Offset: 0x0011AEA8
		private void menuItem_11_Click(object sender, EventArgs e)
		{
			this.method_59();
		}

		// Token: 0x0600021C RID: 540 RVA: 0x0011AEBC File Offset: 0x0011AEBC
		private unsafe void menuItem_20_Click(object sender, EventArgs e)
		{
			string text = null;
			if (this.method_69() == 0)
			{
				this.textBox6.AppendText("No drive present on port " + this.comboBox7.Text + "\r\n\r\n");
			}
			else
			{
				this.textBox6.AppendText("Attempting to verify Target Key to drive on port " + this.comboBox7.Text + "\r\n");
				string text2 = this.textBox11.Text;
				if (this.method_107(*(ref <Module>.struct123_0 + 4) + 280) == 1)
				{
					RegistryKey registryKey = Registry.CurrentUser.CreateSubKey("JF_KeyDB\\KeyList");
					if (registryKey.GetValue(text2) != null)
					{
						string text3 = registryKey.GetValue(text2).ToString();
						registryKey.Close();
						registryKey = Registry.CurrentUser.CreateSubKey("JF_KeyDB\\" + text3);
						if (registryKey.GetValue("JobName") != null)
						{
							text = registryKey.GetValue("JobName").ToString();
						}
						string text4;
						if (registryKey.GetValue("WorkingDir") != null)
						{
							text4 = registryKey.GetValue("WorkingDir").ToString();
						}
						else
						{
							text4 = "";
						}
						string strA;
						if (registryKey.GetValue("LastFile") != null)
						{
							strA = registryKey.GetValue("LastFile").ToString();
						}
						else
						{
							strA = "";
						}
						if (registryKey.GetValue("Index") != null)
						{
							text3 = registryKey.GetValue("Index").ToString();
						}
						this.toolTip_0.SetToolTip(this.pictureBox5, "Drive Key found in KeyDB (" + text3 + " - " + text + ")" + Environment.NewLine + "Key is: " + text2);
						this.toolTip_0.SetToolTip(this.pictureBox2, "Drive Key found in KeyDB (" + text3 + " - " + text + ")" + Environment.NewLine + "Key is: " + text2);
						this.pictureBox5.Visible = true;
						this.pictureBox7.Visible = false;
						this.pictureBox2.Visible = true;
						this.pictureBox6.Visible = false;
						if (string.Compare(strA, "") != 0)
						{
							this.menuItem_21.Enabled = true;
						}
						this.menuItem_22.Enabled = true;
						this.menuItem_23.Enabled = true;
						this.menuItem_24.Enabled = true;
						this.string_14 = text2;
						this.string_15 = text3;
						this.string_16 = strA;
						this.string_17 = text4;
						this.label133.Text = "Verified";
						this.label131.Text = "Verified";
						registryKey.Close();
						this.Cursor = Cursors.Arrow;
						this.textBox6.AppendText("\r\n" + "Key found in KeyDB at record (" + text3 + " - " + text + ")" + "\r\n" + "Key is: " + text2 + "\r\n" + "Key has been tested and verified, thanks C4eva ! " + "\r\n");
					}
					else
					{
						this.toolTip_0.SetToolTip(this.pictureBox5, "Drive Key NOT in KeyDB " + Environment.NewLine + "Key is: " + text2);
						this.toolTip_0.SetToolTip(this.pictureBox2, "Drive Key NOT in KeyDB " + Environment.NewLine + "Key is: " + text2);
						this.pictureBox5.Visible = true;
						this.pictureBox7.Visible = false;
						this.pictureBox2.Visible = true;
						this.pictureBox6.Visible = false;
						this.string_14 = text2;
						this.label133.Text = "Verified";
						this.label131.Text = "Verified";
						registryKey.Close();
						this.Cursor = Cursors.Arrow;
						if (this.bool_1)
						{
							this.textBox6.AppendText("\r\n" + "Key NOT in KeyDB " + "\r\n" + "Key is: " + text2 + "\r\n" + "Key has been tested and verified, thanks C4eva ! " + "\r\n");
						}
					}
				}
				else
				{
					this.textBox6.AppendText("\r\n" + "Target Key not verified against drive." + "\r\n");
				}
			}
		}

		// Token: 0x0600021D RID: 541 RVA: 0x0011B2A0 File Offset: 0x0011B2A0
		private void menuItem_32_Click(object sender, EventArgs e)
		{
			this.method_194();
		}

		// Token: 0x0600021E RID: 542 RVA: 0x0011B2B4 File Offset: 0x0011B2B4
		private unsafe void menuItem_37_Click(object sender, EventArgs e)
		{
			KeyCR keyCR = new KeyCR();
			keyCR.bool_4 = this.bool_2;
			keyCR.string_0 = this.string_10;
			Struct32 @struct;
			<Module>.memcpy((void*)(&@struct), *(ref <Module>.struct121_0 + 4780), 262144U);
			if (keyCR.ShowDialog(this) == DialogResult.OK)
			{
				Struct32 struct2;
				<Module>.memcpy((void*)(&struct2), (void*)keyCR.pByte_0, 262144U);
				if (*(*(ref <Module>.struct123_0 + 4)) == 6)
				{
					this.method_35(ref struct2 + 126960, ref @struct + 126960);
					Struct64 struct3;
					for (int i = 0; i < 3059; i++)
					{
						*(ref struct3 + i) = (*(ref struct2 + (i + 186624)) ^ *(ref <Module>.struct58_0 + i));
					}
					for (int i = 0; i < 3572; i++)
					{
						*(ref struct3 + (i + 3059)) = (*(ref struct2 + (i + 189683)) ^ *(ref <Module>.struct56_0 + i));
					}
					for (int i = 0; i < 2907; i++)
					{
						*(ref struct3 + (i + 6631)) = (*(ref struct2 + (i + 193255)) ^ *(ref <Module>.struct49_0 + i));
					}
					<Module>.memcpy(ref @struct + 62464, (void*)(&struct3), 3059U);
					<Module>.memcpy(ref @struct + 127488, ref struct3 + 3059, 3572U);
					<Module>.memcpy(ref @struct + 193024, ref struct3 + 6631, 2907U);
				}
				if (*(*(ref <Module>.struct123_0 + 4)) == 7)
				{
					<Module>.memcpy(ref @struct + 186624, ref struct2 + 186624, 9538U);
					*(ref @struct + 115000) = *(ref struct2 + 126960);
					*(ref @struct + 117484) = *(ref struct2 + 126961);
					*(ref @struct + 116546) = *(ref struct2 + 126962);
					*(ref @struct + 116352) = *(ref struct2 + 126963);
					*(ref @struct + 118477) = *(ref struct2 + 126964);
					*(ref @struct + 117556) = *(ref struct2 + 126965);
					*(ref @struct + 116799) = *(ref struct2 + 126966);
					*(ref @struct + 116517) = *(ref struct2 + 126967);
					*(ref @struct + 116010) = *(ref struct2 + 126968);
					*(ref @struct + 115201) = *(ref struct2 + 126969);
					*(ref @struct + 117215) = *(ref struct2 + 126970);
					*(ref @struct + 114723) = *(ref struct2 + 126971);
					*(ref @struct + 115872) = *(ref struct2 + 126972);
					*(ref @struct + 116122) = *(ref struct2 + 126973);
					*(ref @struct + 115710) = *(ref struct2 + 126974);
					*(ref @struct + 118601) = *(ref struct2 + 126975);
				}
				this.textBox6.AppendText("\r\n" + "re-parseing file " + "\r\n");
				this.method_37("", 1, (byte*)(&@struct));
				this.bool_10 = true;
				this.tabControl5.SelectedTab = this.Firmtools;
				Application.DoEvents();
				this.Cursor = Cursors.WaitCursor;
				Struct28 struct4;
				Struct28 struct5;
				if (*(*(ref <Module>.struct123_0 + 4)) == 6)
				{
					if (this.method_107(*(ref <Module>.struct123_0 + 4) + 280) == 1)
					{
						this.textBox6.AppendText("Key Verified " + "\r\n");
						if (this.method_57((byte*)(&struct4)) == 1)
						{
							if (string.Compare(this.label109.Text, 0, "DG-16D5S", 0, 8) == 0)
							{
								this.textBox6.AppendText("Grabbing RAM data " + "\r\n");
								if (this.method_91(2, 180, 96, (byte*)(&struct5)) == 0)
								{
									return;
								}
								<Module>.memcpy(ref @struct + 261888, (void*)(&struct5), 16U);
								this.textBox6.AppendText(".");
								Application.DoEvents();
								if (this.method_91(2, 180, 112, (byte*)(&struct5)) == 0)
								{
									return;
								}
								<Module>.memcpy(ref @struct + 261904, (void*)(&struct5), 4U);
								this.textBox6.AppendText(".");
								Application.DoEvents();
								if (this.method_91(3, 8, 208, (byte*)(&struct5)) == 0)
								{
									return;
								}
								<Module>.memcpy(ref @struct + 261912, ref struct5 + 8, 8U);
								this.textBox6.AppendText(".");
								Application.DoEvents();
								if (this.method_91(3, 8, 224, (byte*)(&struct5)) == 0)
								{
									return;
								}
								<Module>.memcpy(ref @struct + 261920, (void*)(&struct5), 16U);
								this.textBox6.AppendText(".");
								Application.DoEvents();
								if (this.method_91(3, 8, 240, (byte*)(&struct5)) == 0)
								{
									return;
								}
								<Module>.memcpy(ref @struct + 261936, (void*)(&struct5), 16U);
								this.textBox6.AppendText(".");
								Application.DoEvents();
								if (this.method_91(3, 9, 0, (byte*)(&struct5)) == 0)
								{
									return;
								}
								<Module>.memcpy(ref @struct + 261952, (void*)(&struct5), 16U);
								this.textBox6.AppendText(".");
								Application.DoEvents();
								if (this.method_91(3, 9, 16, (byte*)(&struct5)) == 0)
								{
									return;
								}
								<Module>.memcpy(ref @struct + 261968, (void*)(&struct5), 16U);
								this.textBox6.AppendText(".");
								Application.DoEvents();
								if (this.method_91(3, 9, 32, (byte*)(&struct5)) == 0)
								{
									return;
								}
								<Module>.memcpy(ref @struct + 261984, (void*)(&struct5), 16U);
								this.textBox6.AppendText(".");
								Application.DoEvents();
								if (this.method_91(3, 9, 48, (byte*)(&struct5)) == 0)
								{
									return;
								}
								<Module>.memcpy(ref @struct + 262016, (void*)(&struct5), 16U);
								this.textBox6.AppendText(".");
								Application.DoEvents();
								if (this.method_91(3, 9, 64, (byte*)(&struct5)) == 0)
								{
									return;
								}
								<Module>.memcpy(ref @struct + 262032, (void*)(&struct5), 16U);
								this.textBox6.AppendText(".");
								Application.DoEvents();
								if (this.method_91(3, 9, 80, (byte*)(&struct5)) == 0)
								{
									return;
								}
								<Module>.memcpy(ref @struct + 262048, (void*)(&struct5), 16U);
								this.textBox6.AppendText(".");
								Application.DoEvents();
								if (this.method_91(3, 9, 96, (byte*)(&struct5)) == 0)
								{
									return;
								}
								<Module>.memcpy(ref @struct + 262064, (void*)(&struct5), 16U);
								this.textBox6.AppendText(".");
								Application.DoEvents();
								if (this.method_91(3, 9, 112, (byte*)(&struct5)) == 0)
								{
									return;
								}
								<Module>.memcpy(ref @struct + 262080, (void*)(&struct5), 16U);
								this.textBox6.AppendText(".");
								Application.DoEvents();
								if (this.method_91(3, 9, 128, (byte*)(&struct5)) == 0)
								{
									return;
								}
								<Module>.memcpy(ref @struct + 262096, (void*)(&struct5), 16U);
								this.textBox6.AppendText(".");
								Application.DoEvents();
								if (this.method_91(3, 9, 144, (byte*)(&struct5)) == 0)
								{
									return;
								}
								<Module>.memcpy(ref @struct + 262128, (void*)(&struct5), 16U);
								this.textBox6.AppendText("." + "\r\n");
								Application.DoEvents();
							}
							else if (string.Compare(this.label109.Text, 0, "DG-16D4S", 0, 8) == 0)
							{
								this.textBox6.AppendText("Grabbing RAM data " + "\r\n");
								if (this.method_91(2, 181, 96, (byte*)(&struct5)) == 0)
								{
									return;
								}
								<Module>.memcpy(ref @struct + 130816, (void*)(&struct5), 16U);
								this.textBox6.AppendText(".");
								Application.DoEvents();
								if (this.method_91(2, 181, 112, (byte*)(&struct5)) == 0)
								{
									return;
								}
								<Module>.memcpy(ref @struct + 130832, (void*)(&struct5), 4U);
								this.textBox6.AppendText(".");
								Application.DoEvents();
								<Module>.memset(ref @struct + 130833, 0, 3U);
								<Module>.memset(ref @struct + 130836, 255, 4U);
								if (this.method_91(3, 8, 238, (byte*)(&struct5)) == 0)
								{
									return;
								}
								<Module>.memcpy(ref @struct + 130840, (void*)(&struct5), 8U);
								this.textBox6.AppendText(".");
								Application.DoEvents();
								if (this.method_91(3, 8, 246, (byte*)(&struct5)) == 0)
								{
									return;
								}
								<Module>.memcpy(ref @struct + 130848, (void*)(&struct5), 16U);
								this.textBox6.AppendText(".");
								Application.DoEvents();
								if (this.method_91(3, 9, 6, (byte*)(&struct5)) == 0)
								{
									return;
								}
								<Module>.memcpy(ref @struct + 130864, (void*)(&struct5), 16U);
								this.textBox6.AppendText(".");
								Application.DoEvents();
								if (this.method_91(3, 9, 22, (byte*)(&struct5)) == 0)
								{
									return;
								}
								<Module>.memcpy(ref @struct + 130880, (void*)(&struct5), 16U);
								this.textBox6.AppendText("." + "\r\n");
								Application.DoEvents();
							}
							else if (string.Compare(this.label109.Text, 0, "DVD-ROM DL10N", 0, 13) == 0)
							{
								<Module>.memcpy(ref @struct + 262128, (void*)(&struct4), 16U);
								this.method_83(ref @struct + 261888);
							}
						}
						this.textBox6.AppendText("\r\n" + "re-parseing file " + "\r\n");
						this.method_37("", 1, (byte*)(&@struct));
						this.bool_10 = true;
						this.tabControl5.SelectedTab = this.Firmtools;
					}
					else
					{
						this.textBox6.AppendText("Key Verification Failed !! " + "\r\n");
						this.textBox6.AppendText("Additional extracts not completed. " + "\r\n");
					}
				}
				if (*(*(ref <Module>.struct123_0 + 4)) == 7)
				{
					if (this.method_107(*(ref <Module>.struct123_0 + 4) + 280) == 1)
					{
						if (this.method_57((byte*)(&struct4)) == 1)
						{
							if (string.Compare(this.label109.Text, 0, "DG-16D5S", 0, 8) == 0)
							{
								this.textBox6.AppendText("Grabbing RAM data " + "\r\n");
								if (this.method_91(2, 180, 96, (byte*)(&struct5)) == 0)
								{
									return;
								}
								<Module>.memcpy(ref @struct + 130816, (void*)(&struct5), 16U);
								this.textBox6.AppendText(".");
								Application.DoEvents();
								if (this.method_91(2, 180, 112, (byte*)(&struct5)) == 0)
								{
									return;
								}
								<Module>.memcpy(ref @struct + 130832, (void*)(&struct5), 4U);
								this.textBox6.AppendText(".");
								Application.DoEvents();
								if (this.method_91(3, 8, 208, (byte*)(&struct5)) == 0)
								{
									return;
								}
								<Module>.memcpy(ref @struct + 130840, ref struct5 + 8, 8U);
								this.textBox6.AppendText(".");
								Application.DoEvents();
								if (this.method_91(3, 8, 224, (byte*)(&struct5)) == 0)
								{
									return;
								}
								<Module>.memcpy(ref @struct + 130848, (void*)(&struct5), 16U);
								this.textBox6.AppendText(".");
								Application.DoEvents();
								if (this.method_91(3, 8, 240, (byte*)(&struct5)) == 0)
								{
									return;
								}
								<Module>.memcpy(ref @struct + 130864, (void*)(&struct5), 16U);
								this.textBox6.AppendText(".");
								Application.DoEvents();
								if (this.method_91(3, 9, 0, (byte*)(&struct5)) == 0)
								{
									return;
								}
								<Module>.memcpy(ref @struct + 130880, (void*)(&struct5), 16U);
								this.textBox6.AppendText("." + "\r\n");
								Application.DoEvents();
							}
							else if (string.Compare(this.label109.Text, 0, "DG-16D4S", 0, 8) == 0)
							{
								this.textBox6.AppendText("Grabbing RAM data " + "\r\n");
								if (this.method_91(2, 181, 96, (byte*)(&struct5)) == 0)
								{
									return;
								}
								<Module>.memcpy(ref @struct + 130816, (void*)(&struct5), 16U);
								this.textBox6.AppendText(".");
								Application.DoEvents();
								if (this.method_91(2, 181, 112, (byte*)(&struct5)) == 0)
								{
									return;
								}
								<Module>.memcpy(ref @struct + 130832, (void*)(&struct5), 4U);
								this.textBox6.AppendText(".");
								Application.DoEvents();
								<Module>.memset(ref @struct + 130833, 0, 3U);
								<Module>.memset(ref @struct + 130836, 255, 4U);
								if (this.method_91(3, 8, 238, (byte*)(&struct5)) == 0)
								{
									return;
								}
								<Module>.memcpy(ref @struct + 130840, (void*)(&struct5), 8U);
								this.textBox6.AppendText(".");
								Application.DoEvents();
								if (this.method_91(3, 8, 246, (byte*)(&struct5)) == 0)
								{
									return;
								}
								<Module>.memcpy(ref @struct + 130848, (void*)(&struct5), 16U);
								this.textBox6.AppendText(".");
								Application.DoEvents();
								if (this.method_91(3, 9, 6, (byte*)(&struct5)) == 0)
								{
									return;
								}
								<Module>.memcpy(ref @struct + 130864, (void*)(&struct5), 16U);
								this.textBox6.AppendText(".");
								Application.DoEvents();
								if (this.method_91(3, 9, 22, (byte*)(&struct5)) == 0)
								{
									return;
								}
								<Module>.memcpy(ref @struct + 130880, (void*)(&struct5), 16U);
								this.textBox6.AppendText("." + "\r\n");
								Application.DoEvents();
							}
							else if (string.Compare(this.label109.Text, 0, "DVD-ROM DL10N", 0, 13) == 0)
							{
								this.method_83(ref @struct + 130816);
							}
						}
						this.textBox6.AppendText("\r\n" + "re-parseing file " + "\r\n");
						this.method_37("", 1, (byte*)(&@struct));
						this.bool_10 = true;
						this.tabControl5.SelectedTab = this.Firmtools;
					}
					else
					{
						this.textBox6.AppendText("Key Verification Failed !! " + "\r\n");
						this.textBox6.AppendText("Additional extracts not completed. " + "\r\n");
					}
				}
				this.Cursor = Cursors.Arrow;
				this.method_58();
			}
		}

		// Token: 0x0600021F RID: 543 RVA: 0x0011C0D4 File Offset: 0x0011C0D4
		private unsafe int method_57(byte* pByte_0)
		{
			Struct28 @struct;
			<Module>.memset((void*)(&@struct), 255, 16U);
			int result;
			if (this.comboBox1.Items.Count == 0)
			{
				result = 0;
			}
			else
			{
				int selectedIndex = this.comboBox1.SelectedIndex;
				ushort ushort_ = *(ref <Module>.struct38_0 + selectedIndex * 72);
				uint num = (uint)(*(ref <Module>.struct38_0 + selectedIndex * 72 + 4));
				uint num2;
				if (num == 160U)
				{
					num2 = 0U;
				}
				else
				{
					num2 = 16U;
				}
				GStruct3 gstruct;
				<Module>.smethod_21(&gstruct, ushort_, 0, 1, 10000U);
				Struct80 struct2;
				<Module>.memset((void*)(&struct2), 0, 42U);
				Struct52 struct3;
				<Module>.memset((void*)(&struct3), 0, 12U);
				struct3 = 90;
				*(ref struct3 + 2) = 37;
				*(ref struct3 + 8) = 26;
				uint num3;
				if (<Module>.smethod_16((byte*)(&struct3), 12U, (byte)num2, 512, (void*)(&struct2), &num3, 26U, 1, &gstruct) != null)
				{
					this.Cursor = Cursors.Arrow;
					result = 0;
				}
				else if (<Module>.memcmp((void*)(&@struct), ref struct2 + 10, 16U) == null)
				{
					this.Cursor = Cursors.Arrow;
					result = 0;
				}
				else
				{
					<Module>.memcpy((void*)pByte_0, ref struct2 + 10, 16U);
					this.Cursor = Cursors.Arrow;
					result = 1;
				}
			}
			return result;
		}

		// Token: 0x06000220 RID: 544 RVA: 0x0011C1D8 File Offset: 0x0011C1D8
		private void tabPage13_DragEnter(object sender, DragEventArgs e)
		{
			if (e.Data.GetDataPresent(DataFormats.FileDrop))
			{
				e.Effect = DragDropEffects.All;
			}
			else
			{
				e.Effect = DragDropEffects.None;
			}
			string[] array = (string[])e.Data.GetData(DataFormats.FileDrop);
			if (array.Length > 1)
			{
				e.Effect = DragDropEffects.None;
			}
		}

		// Token: 0x06000221 RID: 545 RVA: 0x0011C230 File Offset: 0x0011C230
		private void SaveTarget_Click(object sender, EventArgs e)
		{
			this.method_58();
		}

		// Token: 0x06000222 RID: 546 RVA: 0x0011C244 File Offset: 0x0011C244
		private unsafe void method_58()
		{
			if (!this.bool_10)
			{
				<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
				MessageBox.Show("Target hasn't been Spoofed", "Saving Target", MessageBoxButtons.OK, MessageBoxIcon.Asterisk);
				<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
			}
			SaveFileDialog saveFileDialog = new SaveFileDialog();
			saveFileDialog.Filter = "Firmware Images (*.bin)|*.bin|All Files (*.*)|*.*";
			saveFileDialog.DefaultExt = ".bin";
			saveFileDialog.RestoreDirectory = false;
			if (this.bool_2)
			{
				saveFileDialog.InitialDirectory = this.string_10;
			}
			if (*(*(ref <Module>.struct123_0 + 4)) == 2)
			{
				saveFileDialog.FileName = "Hit_CFW.bin";
			}
			else if (*(*(ref <Module>.struct123_0 + 4)) == 3)
			{
				saveFileDialog.FileName = "Benq_CFW.bin";
			}
			else if (*(*(ref <Module>.struct123_0 + 4)) == 1)
			{
				saveFileDialog.FileName = "Sam_CFW.bin";
			}
			else if (*(*(ref <Module>.struct123_0 + 4)) == 4)
			{
				saveFileDialog.FileName = "Lite_CFW.bin";
			}
			if (saveFileDialog.ShowDialog() == DialogResult.OK)
			{
				string fullPath = Path.GetFullPath(saveFileDialog.FileName);
				string fileName = Path.GetFileName(saveFileDialog.FileName);
				IntPtr intPtr = Marshal.StringToHGlobalAnsi(fullPath);
				IntPtr value = intPtr;
				sbyte* pSbyte_ = (sbyte*)((void*)value);
				GStruct5* ptr = <Module>.fopen((sbyte*)pSbyte_, (sbyte*)(&<Module>.struct18_5));
				if (ptr == null)
				{
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					MessageBox.Show(fileName, "Can't open file", MessageBoxButtons.OK);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
					return;
				}
				this.textBox6.AppendText("\r\n" + "Target f/w saved as: " + fileName + "\r\n");
				<Module>.fwrite(*(ref <Module>.struct121_0 + 4780), 262144U, 1U, ptr);
				<Module>.fclose(ptr);
				this.textBox17.Text = fullPath;
				this.textBox18.Text = fullPath;
			}
			if (*(*(ref <Module>.struct123_0 + 4)) == 2)
			{
				<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
				int num = (int)MessageBox.Show("Do you wish to save an Encrypted copy?", "Save Target", MessageBoxButtons.YesNo, MessageBoxIcon.Question, MessageBoxDefaultButton.Button2);
				<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
				if (num == 6)
				{
					SaveFileDialog saveFileDialog2 = new SaveFileDialog();
					saveFileDialog2.Filter = "Firmware Images (*.bin)|*.bin|All Files (*.*)|*.*";
					saveFileDialog2.DefaultExt = ".bin";
					saveFileDialog2.FileName = "Hit_CFW.e.bin";
					saveFileDialog2.RestoreDirectory = false;
					if (this.bool_2)
					{
						saveFileDialog2.InitialDirectory = this.string_10;
					}
					if (saveFileDialog2.ShowDialog() == DialogResult.OK)
					{
						string fullPath2 = Path.GetFullPath(saveFileDialog2.FileName);
						string fileName2 = Path.GetFileName(saveFileDialog2.FileName);
						IntPtr intPtr2 = Marshal.StringToHGlobalAnsi(fullPath2);
						IntPtr value2 = intPtr2;
						sbyte* pSbyte_2 = (sbyte*)((void*)value2);
						string fileName3 = saveFileDialog2.FileName;
						GStruct5* ptr = <Module>.fopen((sbyte*)pSbyte_2, (sbyte*)(&<Module>.struct18_5));
						if (ptr == null)
						{
							<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
							MessageBox.Show(fileName2, "Can't open file", MessageBoxButtons.OK);
							<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
						}
						else
						{
							this.textBox6.AppendText("EnCrypted target f/w saved as: " + fileName2 + "\r\n");
							this.method_391(*(ref <Module>.struct121_0 + 4780), *(ref <Module>.struct121_0 + 9564), 262144);
							<Module>.fwrite(*(ref <Module>.struct121_0 + 9564), 262144U, 1U, ptr);
							<Module>.fclose(ptr);
						}
					}
				}
			}
		}

		// Token: 0x06000223 RID: 547 RVA: 0x0011C5B8 File Offset: 0x0011C5B8
		private unsafe void method_59()
		{
			Struct34 @struct = 127;
			*(ref @struct + 1) = byte.MaxValue;
			*(ref @struct + 2) = byte.MaxValue;
			*(ref @struct + 3) = byte.MaxValue;
			*(ref @struct + 4) = byte.MaxValue;
			*(ref @struct + 5) = byte.MaxValue;
			*(ref @struct + 6) = byte.MaxValue;
			*(ref @struct + 7) = byte.MaxValue;
			*(ref @struct + 8) = byte.MaxValue;
			*(ref @struct + 9) = byte.MaxValue;
			*(ref @struct + 10) = byte.MaxValue;
			*(ref @struct + 11) = byte.MaxValue;
			*(ref @struct + 12) = byte.MaxValue;
			*(ref @struct + 13) = byte.MaxValue;
			*(ref @struct + 14) = byte.MaxValue;
			*(ref @struct + 15) = byte.MaxValue;
			*(ref @struct + 16) = byte.MaxValue;
			*(ref @struct + 17) = byte.MaxValue;
			*(ref @struct + 18) = byte.MaxValue;
			*(ref @struct + 19) = byte.MaxValue;
			*(ref @struct + 20) = byte.MaxValue;
			*(ref @struct + 21) = byte.MaxValue;
			*(ref @struct + 22) = byte.MaxValue;
			*(ref @struct + 23) = byte.MaxValue;
			*(ref @struct + 24) = byte.MaxValue;
			*(ref @struct + 25) = byte.MaxValue;
			*(ref @struct + 26) = byte.MaxValue;
			*(ref @struct + 27) = byte.MaxValue;
			*(ref @struct + 28) = byte.MaxValue;
			*(ref @struct + 29) = byte.MaxValue;
			*(ref @struct + 30) = byte.MaxValue;
			*(ref @struct + 31) = byte.MaxValue;
			*(ref @struct + 32) = 0;
			*(ref @struct + 33) = 17;
			*(ref @struct + 34) = 34;
			*(ref @struct + 35) = 51;
			*(ref @struct + 36) = 68;
			*(ref @struct + 37) = 85;
			*(ref @struct + 38) = 102;
			*(ref @struct + 39) = 119;
			*(ref @struct + 40) = 136;
			*(ref @struct + 41) = 153;
			*(ref @struct + 42) = 170;
			*(ref @struct + 43) = 187;
			*(ref @struct + 44) = 204;
			*(ref @struct + 45) = 221;
			*(ref @struct + 46) = 238;
			*(ref @struct + 47) = 250;
			Struct55 struct2 = 68;
			*(ref struct2 + 1) = 117;
			*(ref struct2 + 2) = 109;
			*(ref struct2 + 3) = 109;
			*(ref struct2 + 4) = 121;
			*(ref struct2 + 5) = 32;
			*(ref struct2 + 6) = 102;
			*(ref struct2 + 7) = 114;
			*(ref struct2 + 8) = 111;
			*(ref struct2 + 9) = 109;
			*(ref struct2 + 10) = 32;
			*(ref struct2 + 11) = 69;
			*(ref struct2 + 12) = 110;
			*(ref struct2 + 13) = 99;
			*(ref struct2 + 14) = 114;
			*(ref struct2 + 15) = 116;
			*(ref struct2 + 16) = 121;
			*(ref struct2 + 17) = 112;
			*(ref struct2 + 18) = 116;
			*(ref struct2 + 19) = 101;
			*(ref struct2 + 20) = 100;
			*(ref struct2 + 21) = 32;
			*(ref struct2 + 22) = 102;
			*(ref struct2 + 23) = 47;
			*(ref struct2 + 24) = 119;
			*(ref struct2 + 25) = 0;
			*(ref struct2 + 26) = 0;
			*(ref struct2 + 27) = 0;
			*(ref struct2 + 28) = 0;
			*(ref struct2 + 29) = 0;
			*(ref struct2 + 30) = 0;
			*(ref struct2 + 31) = 0;
			Struct30 struct3;
			<Module>.memset((void*)(&struct3), 0, 512U);
			Struct30 struct4;
			<Module>.memset((void*)(&struct4), 0, 512U);
			Struct29 struct5;
			<Module>.memset((void*)(&struct5), 0, 96U);
			Struct29 struct6;
			<Module>.memset((void*)(&struct6), 0, 96U);
			Struct81 struct7;
			<Module>.memset((void*)(&struct7), 0, 752U);
			if (*(*(ref <Module>.struct123_0 + 4) + 2) == 1)
			{
				<Module>.memcpy((void*)(&struct5), (void*)(&<Module>.struct29_35), 96U);
				<Module>.memcpy((void*)(&struct6), (void*)(&<Module>.struct29_32), 96U);
				<Module>.memcpy((void*)(&struct3), (void*)(&<Module>.struct46_5), 180U);
				<Module>.memcpy((void*)(&struct4), (void*)(&<Module>.struct46_5), 180U);
			}
			else if (*(*(ref <Module>.struct123_0 + 4) + 2) == 2)
			{
				<Module>.memcpy((void*)(&struct5), (void*)(&<Module>.struct29_30), 96U);
				<Module>.memcpy((void*)(&struct6), (void*)(&<Module>.struct29_26), 96U);
				<Module>.memcpy((void*)(&struct3), (void*)(&<Module>.struct46_3), 180U);
				<Module>.memcpy((void*)(&struct4), (void*)(&<Module>.struct46_3), 180U);
			}
			else if (*(*(ref <Module>.struct123_0 + 4) + 2) == 3)
			{
				<Module>.memcpy((void*)(&struct5), (void*)(&<Module>.struct29_30), 96U);
				<Module>.memcpy((void*)(&struct6), (void*)(&<Module>.struct29_17), 96U);
				<Module>.memcpy((void*)(&struct3), (void*)(&<Module>.struct46_3), 180U);
				<Module>.memcpy((void*)(&struct4), (void*)(&<Module>.struct46_3), 180U);
			}
			else if (*(*(ref <Module>.struct123_0 + 4) + 2) == 4)
			{
				<Module>.memcpy((void*)(&struct5), (void*)(&<Module>.struct29_5), 96U);
				<Module>.memcpy((void*)(&struct6), (void*)(&<Module>.struct29_32), 96U);
				<Module>.memcpy((void*)(&struct3), (void*)(&<Module>.struct46_24), 180U);
				<Module>.memcpy((void*)(&struct4), (void*)(&<Module>.struct46_24), 180U);
			}
			for (int i = 20; i < 93; i += 2)
			{
				*(ref struct3 + i) = *(ref struct4 + (i + 1));
				*(ref struct3 + (i + 1)) = *(ref struct4 + i);
			}
			Struct32 struct8;
			<Module>.memset((void*)(&struct8), 0, 262144U);
			Struct33 struct9;
			<Module>.memset((void*)(&struct9), 255, 4096U);
			byte* ptr = ref struct8 + 11264;
			<Module>.memcpy((void*)ptr, (void*)(&struct3), 512U);
			ptr = ref struct8 + 11776;
			<Module>.memcpy((void*)ptr, (void*)(&struct5), 96U);
			ptr = ref struct8 + 12032;
			<Module>.memcpy((void*)ptr, (void*)(&struct6), 96U);
			ptr = ref struct8 + 24512;
			<Module>.memcpy((void*)ptr, (void*)(&struct2), 32U);
			ptr = ref struct8 + 40960;
			<Module>.memcpy((void*)ptr, (void*)(&struct9), 4096U);
			ptr = ref struct8 + 40960;
			<Module>.memcpy((void*)ptr, (void*)(&@struct), 48U);
			ptr = ref struct8 + 41008;
			<Module>.memcpy((void*)ptr, *(ref <Module>.struct123_0 + 4) + 280, 16U);
			ptr = ref struct8 + 130816;
			<Module>.memcpy((void*)ptr, *(ref <Module>.struct123_0 + 4) + 2028, 224U);
			ptr = ref struct8 + 11284;
			<Module>.memcpy((void*)ptr, *(ref <Module>.struct123_0 + 4) + 2028, 20U);
			ptr = ref struct8 + 11818;
			<Module>.memcpy((void*)ptr, *(ref <Module>.struct123_0 + 4) + 2028, 20U);
			SaveFileDialog saveFileDialog = new SaveFileDialog();
			saveFileDialog.Filter = "Firmware Images (*.bin)|*.bin|All Files (*.*)|*.*";
			saveFileDialog.DefaultExt = ".bin";
			saveFileDialog.FileName = "Dummy.bin";
			saveFileDialog.RestoreDirectory = false;
			if (this.bool_2)
			{
				saveFileDialog.InitialDirectory = this.string_10;
			}
			if (saveFileDialog.ShowDialog() == DialogResult.OK)
			{
				string fullPath = Path.GetFullPath(saveFileDialog.FileName);
				IntPtr intPtr = Marshal.StringToHGlobalAnsi(fullPath);
				IntPtr value = intPtr;
				sbyte* pSbyte_ = (sbyte*)((void*)value);
				this.string_13 = saveFileDialog.FileName;
				GStruct5* ptr2 = <Module>.fopen((sbyte*)pSbyte_, (sbyte*)(&<Module>.struct18_5));
				if (ptr2 == null)
				{
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					MessageBox.Show(saveFileDialog.FileName.ToString(), "Can't open file", MessageBoxButtons.OK);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
				}
				else
				{
					this.textBox6.AppendText("Dummy from Lite-On f/w saved as: " + saveFileDialog.FileName + "\r\n");
					<Module>.fwrite((void*)(&struct8), 262144U, 1U, ptr2);
					<Module>.fclose(ptr2);
				}
			}
		}

		// Token: 0x06000224 RID: 548 RVA: 0x0011CC80 File Offset: 0x0011CC80
		private void button6_Click(object sender, EventArgs e)
		{
			this.method_46();
			this.method_47();
			this.method_41();
			this.bool_10 = true;
		}

		// Token: 0x06000225 RID: 549 RVA: 0x0011CCA8 File Offset: 0x0011CCA8
		private unsafe void button29_Click(object sender, EventArgs e)
		{
			FreeKey freeKey = new FreeKey();
			if (this.bool_2)
			{
				freeKey.string_0 = this.string_10;
				freeKey.bool_4 = this.bool_2;
			}
			freeKey.ushort_0 = *(*(ref <Module>.struct123_0 + 4));
			freeKey.ushort_1 = *(*(ref <Module>.struct123_0 + 4) + 2);
			freeKey.ushort_2 = *(*(ref <Module>.struct123_0 + 4) + 2382);
			freeKey.ushort_3 = *(*(ref <Module>.struct123_0 + 4) + 2384);
			freeKey.textBox1.Text = this.textBox11.Text;
			if (freeKey.pByte_0 != null)
			{
				<Module>.free((void*)freeKey.pByte_0);
			}
			freeKey.pByte_0 = <Module>.malloc(16U);
			<Module>.memcpy((void*)freeKey.pByte_0, *(ref <Module>.struct123_0 + 4) + 280, 16U);
			if (freeKey.pByte_1 != null)
			{
				<Module>.free((void*)freeKey.pByte_1);
			}
			freeKey.pByte_1 = <Module>.malloc(96U);
			<Module>.memcpy((void*)freeKey.pByte_1, *(ref <Module>.struct123_0 + 4) + 568, 96U);
			if (freeKey.pByte_2 != null)
			{
				<Module>.free((void*)freeKey.pByte_2);
			}
			freeKey.pByte_2 = <Module>.malloc(180U);
			<Module>.memcpy((void*)freeKey.pByte_2, *(ref <Module>.struct123_0 + 4) + 780, 180U);
			if (*(*(ref <Module>.struct123_0 + 4) + 2382) == 4)
			{
				this.method_9(*(ref <Module>.struct123_0 + 4) + 610, 20U);
				freeKey.textBox2.Text = this.string_0;
				if (freeKey.pByte_4 != null)
				{
					<Module>.free((void*)freeKey.pByte_4);
				}
				freeKey.pByte_4 = <Module>.malloc(20U);
				<Module>.memset((void*)freeKey.pByte_4, 32, 20U);
				<Module>.memcpy((void*)freeKey.pByte_4, *(ref <Module>.struct123_0 + 4) + 610, 20U);
			}
			if (freeKey.ShowDialog(this) == DialogResult.OK)
			{
				if (<Module>.memcmp(*(ref <Module>.struct123_0 + 4) + 280, (void*)freeKey.pByte_0, 16U) != null)
				{
					<Module>.memcpy(*(ref <Module>.struct123_0 + 4) + 280, (void*)freeKey.pByte_0, 16U);
					this.textBox6.AppendText("DVD Key copied to target" + "\r\n");
				}
				else
				{
					this.textBox6.AppendText("DVD Key already matches" + "\r\n");
				}
				if (<Module>.memcmp(*(ref <Module>.struct123_0 + 4) + 2348, (void*)(&<Module>.struct74_0), 10U) == null && *(*(ref <Module>.struct123_0 + 4)) == 4)
				{
					this.textBox6.AppendText("Target is LT - ID strings not copied to Target" + "\r\n");
				}
				if (<Module>.memcmp(*(ref <Module>.struct123_0 + 4) + 2348, (void*)(&<Module>.struct22_4), 7U) == null && *(*(ref <Module>.struct123_0 + 4)) == 4)
				{
					this.textBox6.AppendText("Target is LT - ID strings not copied to Target" + "\r\n");
				}
				if (<Module>.memcmp(*(ref <Module>.struct123_0 + 4) + 2348, (void*)(&<Module>.struct22_4), 7U) == null && *(*(ref <Module>.struct123_0 + 4)) == 5)
				{
					this.textBox6.AppendText("Target is LT - ID strings not copied to Target" + "\r\n");
				}
				else if (<Module>.memcmp(*(ref <Module>.struct123_0 + 4) + 568, (void*)freeKey.pByte_1, 96U) != null)
				{
					<Module>.memcpy(*(ref <Module>.struct123_0 + 4) + 568, (void*)freeKey.pByte_1, 96U);
					<Module>.memcpy(*(ref <Module>.struct123_0 + 4) + 2316, *(ref <Module>.struct123_0 + 4) + 576, 28U);
					this.textBox6.AppendText("Inquiry string copied to Target" + "\r\n");
					<Module>.memcpy(*(ref <Module>.struct123_0 + 4) + 780, (void*)freeKey.pByte_2, 180U);
					this.textBox6.AppendText("Identify string copied to Target" + "\r\n");
				}
				else
				{
					this.textBox6.AppendText("ID strings already match" + "\r\n");
				}
				if (*(*(ref <Module>.struct123_0 + 4) + 2382) == 2)
				{
					this.textBox6.AppendText(string.Concat("Setting Master Checksum."));
					*(*(ref <Module>.struct123_0 + 4) + 2020) = 0;
				}
				*(*(ref <Module>.struct123_0 + 4) + 2382) = (short)freeKey.ushort_2;
				*(*(ref <Module>.struct123_0 + 4) + 2384) = (short)freeKey.ushort_3;
				this.bool_10 = true;
				this.method_47();
				this.method_41();
			}
		}

		// Token: 0x06000226 RID: 550 RVA: 0x0011D108 File Offset: 0x0011D108
		private void button5_Click(object sender, EventArgs e)
		{
			this.method_18();
			this.method_60();
			this.Cursor = Cursors.Arrow;
			this.method_19();
		}

		// Token: 0x06000227 RID: 551 RVA: 0x0011D134 File Offset: 0x0011D134
		private unsafe void method_60()
		{
			if (this.pVoid_0 != null)
			{
				<Module>.SetCommMask(this.pVoid_0, 64);
			}
			this.method_61();
			int selectedIndex = this.comboBox10.SelectedIndex;
			if (this.checkBox9.CheckState == CheckState.Checked && *(ref <Module>.struct122_0 + selectedIndex * 324 + 8) == 2 && this.method_146() == 1)
			{
				this.method_123();
			}
		}

		// Token: 0x06000228 RID: 552 RVA: 0x0011D19C File Offset: 0x0011D19C
		private unsafe void method_61()
		{
			this.label88.Text = "";
			this.label87.Text = "";
			Application.DoEvents();
			this.method_172();
			if (string.Compare(Convert.ToString(this.label72.Text), "No Drive Detected!") == 0)
			{
				this.textBox6.AppendText("\r\n" + "No Drive Detected! DVDkey files extraction aborted! " + "\r\n\r\n");
				<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
				MessageBox.Show("        No Drive Detected!" + "\n" + "DVDkey files extraction aborted! ", "DVDkey Extract", MessageBoxButtons.OK, MessageBoxIcon.Hand);
				<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
				this.label88.Text = " ";
				this.label87.Text = " ";
			}
			else if (string.Compare(Convert.ToString(this.label72.Text), "Drive in Vendor Mode!") == 0)
			{
				this.textBox6.AppendText("\r\n" + "Drive in Vendor Mode! DVDkey files extraction aborted! " + "\r\n\r\n");
				<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
				MessageBox.Show("        Drive in Vendor Mode!" + "\n" + "DVDkey files extraction aborted! ", "DVDkey Extract", MessageBoxButtons.OK, MessageBoxIcon.Hand);
				<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
				this.label88.Text = " ";
				this.label87.Text = " ";
			}
			else if (this.method_62() == 0)
			{
				this.textBox6.AppendText("\r\n" + "DVDkey files extraction aborted! " + "\r\n\r\n");
				this.label88.Text = " ";
				this.label87.Text = " ";
			}
			else
			{
				if (this.checkBox8.CheckState == CheckState.Unchecked)
				{
					this.method_116();
				}
				if (this.method_63() == 0)
				{
					this.textBox6.AppendText("\r\n" + "DVDkey files extraction aborted! " + "\r\n\r\n");
					this.label88.Text = " ";
					this.label87.Text = " ";
				}
				else if (this.method_65() == 0)
				{
					this.textBox6.AppendText("\r\n" + "DVDkey files extraction aborted! " + "\r\n\r\n");
					this.label88.Text = " ";
					this.label87.Text = " ";
				}
				else if (this.method_66() == 0)
				{
					this.textBox6.AppendText("\r\n" + "DVDkey files extraction aborted! " + "\r\n\r\n");
					this.label88.Text = " ";
					this.label87.Text = " ";
				}
				else if (this.method_67() == 0)
				{
					this.textBox6.AppendText("\r\n" + "DVDkey files extraction aborted! " + "\r\n\r\n");
					this.label88.Text = " ";
					this.label87.Text = " ";
				}
				else
				{
					this.method_117();
					if (this.bool_2 && this.method_107(*(ref <Module>.struct123_0 + 4) + 280) == 1)
					{
						this.tabControl5.SelectedTab = this.Benq;
						this.pictureBox5.Visible = true;
						this.pictureBox7.Visible = false;
						this.pictureBox2.Visible = true;
						this.pictureBox6.Visible = false;
						this.label133.Text = "Verified";
						this.label131.Text = "Verified";
						this.textBox6.AppendText("Target Key verified, thanks C4eva" + "\r\n" + "Proceeding with LO-Erase" + "\r\n");
						this.method_14();
						this.method_207();
						this.method_15();
					}
				}
			}
		}

		// Token: 0x06000229 RID: 553 RVA: 0x003C1B4C File Offset: 0x00309B4C
		private unsafe int method_62()
		{
			string text = null;
			Struct52 @struct = 168;
			*(ref @struct + 1) = 0;
			*(ref @struct + 2) = 0;
			*(ref @struct + 3) = 0;
			*(ref @struct + 4) = 0;
			*(ref @struct + 5) = 0;
			*(ref @struct + 6) = 0;
			*(ref @struct + 7) = 0;
			*(ref @struct + 8) = 0;
			*(ref @struct + 9) = 0;
			*(ref @struct + 10) = 0;
			*(ref @struct + 11) = 0;
			Struct52 struct2 = 253;
			*(ref struct2 + 1) = 14;
			*(ref struct2 + 2) = 66;
			*(ref struct2 + 3) = 69;
			*(ref struct2 + 4) = 78;
			*(ref struct2 + 5) = 81;
			*(ref struct2 + 6) = 0;
			*(ref struct2 + 7) = 0;
			*(ref struct2 + 8) = 0;
			*(ref struct2 + 9) = 0;
			*(ref struct2 + 10) = 0;
			*(ref struct2 + 11) = 0;
			Struct55 struct3 = 68;
			*(ref struct3 + 1) = 86;
			*(ref struct3 + 2) = 68;
			*(ref struct3 + 3) = 75;
			*(ref struct3 + 4) = 101;
			*(ref struct3 + 5) = 121;
			*(ref struct3 + 6) = 51;
			*(ref struct3 + 7) = 50;
			*(ref struct3 + 8) = 32;
			*(ref struct3 + 9) = 101;
			*(ref struct3 + 10) = 120;
			*(ref struct3 + 11) = 116;
			*(ref struct3 + 12) = 114;
			*(ref struct3 + 13) = 97;
			*(ref struct3 + 14) = 99;
			*(ref struct3 + 15) = 116;
			*(ref struct3 + 16) = 0;
			*(ref struct3 + 17) = 0;
			*(ref struct3 + 18) = 0;
			*(ref struct3 + 19) = 0;
			*(ref struct3 + 20) = 0;
			*(ref struct3 + 21) = 0;
			*(ref struct3 + 22) = 0;
			*(ref struct3 + 23) = 0;
			*(ref struct3 + 24) = 0;
			*(ref struct3 + 25) = 0;
			*(ref struct3 + 26) = 0;
			*(ref struct3 + 27) = 0;
			*(ref struct3 + 28) = 0;
			*(ref struct3 + 29) = 0;
			*(ref struct3 + 30) = 0;
			*(ref struct3 + 31) = 0;
			int result;
			if (this.comboBox1.Items.Count == 0)
			{
				result = 0;
			}
			else
			{
				uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
				uint num = (uint)(*(ref <Module>.struct38_0 + selectedIndex * 72U + 4));
				ushort num2 = *(ref <Module>.struct38_0 + selectedIndex * 72U);
				uint selectedIndex2 = (uint)this.comboBox10.SelectedIndex;
				Struct84 struct4;
				<Module>.sprintf((sbyte*)(&struct4), (sbyte*)(&<Module>.struct10_22), Convert.ToString(new string(ref <Module>.struct122_0 + selectedIndex2 * 324U)));
				GStruct96 gstruct = 0;
				initblk(ref gstruct + 4, 0, 24);
				GStruct95 gstruct2 = 0;
				initblk(ref gstruct2 + 4, 0, 16);
				GStruct95 gstruct3 = 0;
				initblk(ref gstruct3 + 4, 0, 16);
				if (this.method_128() == 1)
				{
					<Module>.Sleep(500);
				}
				else if (num2 == 0)
				{
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					MessageBox.Show("Power on drive with tray half open.", "DVDKey32", MessageBoxButtons.OK, MessageBoxIcon.Asterisk);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
				}
				RegistryKey registryKey = Registry.CurrentUser.CreateSubKey("JungleFlasher");
				if (registryKey.GetValue("Delay32") != null)
				{
					text = registryKey.GetValue("Delay32").ToString();
				}
				else if (registryKey.GetValue("Delay32") == null)
				{
					registryKey.SetValue("Delay32", "0");
					text = "0";
				}
				registryKey.Close();
				int num3 = Convert.ToInt32(text) * 1000;
				if (num3 > 20000)
				{
					num3 = 20000;
				}
				if (num3 != 0)
				{
					int num4 = num3 / 250;
					this.textBox6.AppendText("DVDkey delayed by " + text + " seconds" + "\r\n");
					for (int i = 0; i < num4; i++)
					{
						this.textBox6.AppendText(".");
						<Module>.Sleep(250);
					}
					this.textBox6.AppendText("\r\n");
				}
				this.textBox6.AppendText("Sending DVDKey request to I/O port " + this.label123.Text);
				this.textBox6.AppendText(" and " + this.comboBox10.Text + "\r\n\r\n");
				this.label88.Text = " ";
				this.label87.Text = " ";
				Struct83 struct5;
				<Module>.memset((void*)(&struct5), 0, 24U);
				this.Cursor = Cursors.WaitCursor;
				GStruct3 gstruct4;
				<Module>.smethod_21(&gstruct4, num2, 0, 1, 10000U);
				if (num2 != 0)
				{
					<Module>.smethod_2(*(ref gstruct4 + 14), (byte)num);
					<Module>.smethod_2(*(ref gstruct4 + 18), 8);
					while ((<Module>.smethod_0(*(ref gstruct4 + 16)) & 128) != null)
					{
					}
				}
				for (uint num5 = 0U; num5 < 768U; num5 += 1U)
				{
					if (gstruct4 == null)
					{
						this.method_424(9);
					}
					else
					{
						<Module>.smethod_2(*(ref gstruct4 + 14), (byte)num);
						while ((<Module>.smethod_0(*(ref gstruct4 + 16)) & 128) != null)
						{
						}
						<Module>.smethod_2(*(ref gstruct4 + 18), 160);
						while ((<Module>.smethod_0(*(ref gstruct4 + 16)) & 128) != null)
						{
						}
						<Module>.smethod_3(gstruct4, 168);
						<Module>.smethod_3(gstruct4, 0);
						<Module>.smethod_3(gstruct4, 0);
						<Module>.smethod_3(gstruct4, 0);
						<Module>.smethod_3(gstruct4, 0);
						<Module>.smethod_3(gstruct4, 0);
					}
					if (num5 % 64U == 0U)
					{
						this.textBox6.AppendText(".");
					}
					Application.DoEvents();
				}
				*(ref gstruct2 + 16) = <Module>.CreateEventA(null, 1, 0, null);
				*(ref gstruct3 + 16) = <Module>.CreateEventA(null, 1, 0, null);
				void* ptr = <Module>.CreateFileA((sbyte*)(&struct4), -1073741824, 0, null, 3, 1073741952, null);
				if (ptr == -1)
				{
					this.textBox6.AppendText("\r\n" + "Failed to open com port " + Convert.ToString(new string(ref <Module>.struct122_0 + selectedIndex2 * 324U)) + "\r\n");
					this.Cursor = Cursors.Arrow;
					result = 0;
				}
				else
				{
					gstruct = 28;
					<Module>.GetCommState(ptr, &gstruct);
					*(ref gstruct + 4) = 115200;
					*(ref gstruct + 18) = 8;
					*(ref gstruct + 19) = 0;
					*(ref gstruct + 20) = 0;
					*(ref gstruct + 8) = (*(ref gstruct + 8) & -257);
					*(ref gstruct + 8) = (*(ref gstruct + 8) & -513);
					<Module>.SetCommState(ptr, &gstruct);
					GStruct94 gstruct5 = 20;
					*(ref gstruct5 + 8) = 20;
					*(ref gstruct5 + 4) = 20;
					*(ref gstruct5 + 16) = 20;
					*(ref gstruct5 + 12) = 20;
					<Module>.SetCommTimeouts(ptr, &gstruct5);
					uint num6;
					<Module>.ReadFile(ptr, (void*)(&struct5), 24, (uint*)(&num6), &gstruct2);
					for (uint num5 = 0U; num5 < 256U; num5 += 1U)
					{
						if (gstruct4 == null)
						{
							this.method_424(10);
						}
						else
						{
							<Module>.smethod_2(*(ref gstruct4 + 14), (byte)num);
							while ((<Module>.smethod_0(*(ref gstruct4 + 16)) & 128) != null)
							{
							}
							<Module>.smethod_2(*(ref gstruct4 + 18), 160);
							while ((<Module>.smethod_0(*(ref gstruct4 + 16)) & 128) != null)
							{
							}
							<Module>.smethod_3(gstruct4, 3837);
							<Module>.smethod_3(gstruct4, 17730);
							<Module>.smethod_3(gstruct4, 20814);
							<Module>.smethod_3(gstruct4, 0);
							<Module>.smethod_3(gstruct4, 0);
							<Module>.smethod_3(gstruct4, 0);
						}
						if (num5 % 64U == 0U)
						{
							this.textBox6.AppendText(".");
						}
						Application.DoEvents();
					}
					<Module>.GetOverlappedResult(ptr, &gstruct2, (uint*)(&num6), 1);
					Struct82 struct6;
					<Module>.memcpy((void*)(&struct6), (void*)(&struct5), 24U);
					this.Cursor = Cursors.Arrow;
					if (struct6 == 131 && *(ref struct6 + 4) == 131 && *(ref struct6 + 8) == 131 && *(ref struct6 + 12) == 131 && *(ref struct6 + 16) == 131 && *(ref struct6 + 20) == 131 && *(ref struct6 + 22) == 32 && *(ref struct6 + 23) == 32)
					{
						this.textBox6.AppendText(" Serial Data looks ok, " + " ");
						Struct28 struct7;
						<Module>.memcpy((void*)(&struct7), ref struct5 + 1, 3U);
						<Module>.memcpy(ref struct7 + 3, ref struct5 + 5, 3U);
						<Module>.memcpy(ref struct7 + 6, ref struct5 + 9, 3U);
						<Module>.memcpy(ref struct7 + 9, ref struct5 + 13, 3U);
						<Module>.memcpy(ref struct7 + 12, ref struct5 + 17, 3U);
						<Module>.memcpy(ref struct7 + 15, ref struct5 + 21, 1U);
						this.method_6((byte*)(&struct7), 16U, 0U);
						this.textBox6.AppendText("key returned: " + this.string_0 + "\r\n");
						this.label87.Text = this.string_0;
						this.label88.Text = "Good";
						this.Cursor = Cursors.Arrow;
						<Module>.CloseHandle(ptr);
						if (this.method_107((byte*)(&struct7)) != 1)
						{
							this.textBox6.AppendText("\r\n" + "Extracted drive key failed Verification !" + "\r\n\r\n");
							this.Cursor = Cursors.Arrow;
							this.label87.Text = "";
							this.label88.Text = "bad";
							result = 0;
						}
						else
						{
							this.textBox6.AppendText("\r\n" + "Extracted drive key passed Verification !" + "\r\n\r\n");
							<Module>.memcpy(*(ref <Module>.struct123_0 + 8) + 280, (void*)(&struct7), 16U);
							<Module>.memcpy(*(ref <Module>.struct123_0 + 8) + 2348, (void*)(&struct3), 32U);
							result = 1;
						}
					}
					else
					{
						this.textBox6.AppendText(" Serial Data is bad, " + "\r\n");
						<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
						MessageBox.Show("***WARNING*** Serial Data is bad", "DVDKey32", MessageBoxButtons.OK, MessageBoxIcon.Hand);
						<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
						this.label88.Text = "Bad";
						<Module>.CloseHandle(ptr);
						this.Cursor = Cursors.Arrow;
						result = 0;
					}
				}
			}
			return result;
		}

		// Token: 0x0600022A RID: 554 RVA: 0x0011DEF0 File Offset: 0x0011DEF0
		private unsafe int method_63()
		{
			int result;
			if (this.comboBox1.Items.Count == 0)
			{
				result = 0;
			}
			else
			{
				uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
				ushort ushort_ = *(ref <Module>.struct38_0 + selectedIndex * 72U);
				uint num;
				if (*(ref <Module>.struct38_0 + selectedIndex * 72U + 4) == 160)
				{
					num = 0U;
				}
				else
				{
					num = 16U;
				}
				GStruct3 gstruct;
				<Module>.smethod_21(&gstruct, ushort_, 0, 1, 10000U);
				Struct52 @struct;
				<Module>.memset((void*)(&@struct), 0, 12U);
				@struct = 18;
				*(ref @struct + 1) = 0;
				*(ref @struct + 2) = 0;
				*(ref @struct + 3) = 0;
				*(ref @struct + 4) = 96;
				*(ref @struct + 5) = 192;
				Struct29 struct2;
				uint num2;
				if (<Module>.smethod_16((byte*)(&@struct), 12U, (byte)num, 512, (void*)(&struct2), &num2, 96U, 1, &gstruct) != null)
				{
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					MessageBox.Show("Inquiry command returned an Error", "Warning", MessageBoxButtons.OK, MessageBoxIcon.Hand);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
					result = 0;
				}
				else
				{
					this.method_5((byte*)(&struct2), 96U, 0U);
					this.textBox6.AppendText(this.string_0 + "\r\n");
					<Module>.memcpy(*(ref <Module>.struct123_0 + 8) + 568, (void*)(&struct2), 96U);
					if (this.checkBox8.CheckState == CheckState.Unchecked)
					{
						if (this.bool_2)
						{
							string text = this.string_10 + "\\Inquiry.bin";
							if (!File.Exists(text))
							{
								IntPtr intPtr = Marshal.StringToHGlobalAnsi(text);
								IntPtr value = intPtr;
								sbyte* pSbyte_ = (sbyte*)((void*)value);
								this.string_13 = text;
								GStruct5* ptr = <Module>.fopen((sbyte*)pSbyte_, (sbyte*)(&<Module>.struct18_5));
								if (ptr != null)
								{
									<Module>.fwrite(*(ref <Module>.struct123_0 + 8) + 568, 96U, 1U, ptr);
									<Module>.fclose(ptr);
									this.textBox6.AppendText("\r\n" + "Inquiry String saved to " + text + "\r\n");
									return 1;
								}
								<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
								MessageBox.Show(text, "Can't open file", MessageBoxButtons.OK);
								<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
							}
						}
						SaveFileDialog saveFileDialog = new SaveFileDialog();
						saveFileDialog.Filter = "Firmware Images (*.bin)|*.bin|All Files (*.*)|*.*";
						saveFileDialog.DefaultExt = ".bin";
						saveFileDialog.FileName = "Inquiry.bin";
						saveFileDialog.RestoreDirectory = false;
						if (this.bool_2)
						{
							saveFileDialog.InitialDirectory = this.string_10;
						}
						if (saveFileDialog.ShowDialog() == DialogResult.OK)
						{
							string fullPath = Path.GetFullPath(saveFileDialog.FileName);
							IntPtr intPtr2 = Marshal.StringToHGlobalAnsi(fullPath);
							IntPtr value2 = intPtr2;
							sbyte* pSbyte_2 = (sbyte*)((void*)value2);
							GStruct5* ptr = <Module>.fopen((sbyte*)pSbyte_2, (sbyte*)(&<Module>.struct18_5));
							if (ptr == null)
							{
								<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
								MessageBox.Show(saveFileDialog.FileName.ToString(), "Can't open file", MessageBoxButtons.OK);
								<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
								return 0;
							}
							this.textBox6.AppendText("Inquiry String saved to " + saveFileDialog.FileName + "\r\n\r\n");
							<Module>.fwrite(*(ref <Module>.struct123_0 + 8) + 568, 96U, 1U, ptr);
							<Module>.fclose(ptr);
						}
					}
					result = 1;
				}
			}
			return result;
		}

		// Token: 0x0600022B RID: 555 RVA: 0x0011E224 File Offset: 0x0011E224
		private unsafe int method_64()
		{
			int result;
			if (this.comboBox1.Items.Count == 0)
			{
				result = 0;
			}
			else
			{
				uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
				ushort ushort_ = *(ref <Module>.struct38_0 + selectedIndex * 72U);
				uint num;
				if (*(ref <Module>.struct38_0 + selectedIndex * 72U + 4) == 160)
				{
					num = 0U;
				}
				else
				{
					num = 16U;
				}
				GStruct3 gstruct;
				<Module>.smethod_21(&gstruct, ushort_, 0, 1, 10000U);
				Struct52 @struct;
				<Module>.memset((void*)(&@struct), 0, 12U);
				@struct = 18;
				*(ref @struct + 1) = 0;
				*(ref @struct + 2) = 0;
				*(ref @struct + 3) = 0;
				*(ref @struct + 4) = 116;
				*(ref @struct + 5) = 192;
				Struct85 struct2;
				uint num2;
				if (<Module>.smethod_16((byte*)(&@struct), 12U, (byte)num, 512, (void*)(&struct2), &num2, 116U, 1, &gstruct) != null)
				{
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					MessageBox.Show("Inquiry command returned an Error", "Warning", MessageBoxButtons.OK, MessageBoxIcon.Hand);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
					result = 0;
				}
				else
				{
					this.method_5((byte*)(&struct2), 116U, 0U);
					this.textBox6.AppendText(this.string_0 + "\r\n");
					<Module>.memcpy(*(ref <Module>.struct123_0 + 8) + 568, (void*)(&struct2), 116U);
					<Module>.memcpy(*(ref <Module>.struct123_0 + 8) + 2028, ref struct2 + 96, 20U);
					if (this.checkBox8.CheckState == CheckState.Unchecked)
					{
						if (this.bool_2)
						{
							string text = this.string_10 + "\\Inquiry.bin";
							if (!File.Exists(text))
							{
								IntPtr intPtr = Marshal.StringToHGlobalAnsi(text);
								IntPtr value = intPtr;
								sbyte* pSbyte_ = (sbyte*)((void*)value);
								this.string_13 = text;
								GStruct5* ptr = <Module>.fopen((sbyte*)pSbyte_, (sbyte*)(&<Module>.struct18_5));
								if (ptr != null)
								{
									<Module>.fwrite(*(ref <Module>.struct123_0 + 8) + 568, 96U, 1U, ptr);
									<Module>.fclose(ptr);
									this.textBox6.AppendText("\r\n" + "Inquiry String saved to " + text + "\r\n");
									return 1;
								}
								<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
								MessageBox.Show(text, "Can't open file", MessageBoxButtons.OK);
								<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
							}
						}
						SaveFileDialog saveFileDialog = new SaveFileDialog();
						saveFileDialog.Filter = "Firmware Images (*.bin)|*.bin|All Files (*.*)|*.*";
						saveFileDialog.DefaultExt = ".bin";
						saveFileDialog.FileName = "Inquiry.bin";
						saveFileDialog.RestoreDirectory = false;
						if (this.bool_2)
						{
							saveFileDialog.InitialDirectory = this.string_10;
						}
						if (saveFileDialog.ShowDialog() == DialogResult.OK)
						{
							string fullPath = Path.GetFullPath(saveFileDialog.FileName);
							IntPtr intPtr2 = Marshal.StringToHGlobalAnsi(fullPath);
							IntPtr value2 = intPtr2;
							sbyte* pSbyte_2 = (sbyte*)((void*)value2);
							GStruct5* ptr = <Module>.fopen((sbyte*)pSbyte_2, (sbyte*)(&<Module>.struct18_5));
							if (ptr == null)
							{
								<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
								MessageBox.Show(saveFileDialog.FileName.ToString(), "Can't open file", MessageBoxButtons.OK);
								<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
								return 0;
							}
							this.textBox6.AppendText("Inquiry String saved to " + saveFileDialog.FileName + "\r\n\r\n");
							<Module>.fwrite(*(ref <Module>.struct123_0 + 8) + 568, 96U, 1U, ptr);
							<Module>.fclose(ptr);
						}
					}
					result = 1;
				}
			}
			return result;
		}

		// Token: 0x0600022C RID: 556 RVA: 0x0011E574 File Offset: 0x0011E574
		private unsafe int method_65()
		{
			int result;
			if (this.comboBox1.Items.Count == 0)
			{
				result = 0;
			}
			else
			{
				uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
				ushort ushort_ = *(ref <Module>.struct38_0 + selectedIndex * 72U);
				uint num;
				if (*(ref <Module>.struct38_0 + selectedIndex * 72U + 4) == 160)
				{
					num = 0U;
				}
				else
				{
					num = 16U;
				}
				GStruct3 gstruct;
				<Module>.smethod_21(&gstruct, ushort_, 0, 1, 10000U);
				Struct52 @struct;
				<Module>.memset((void*)(&@struct), 0, 12U);
				@struct = 18;
				*(ref @struct + 1) = 0;
				*(ref @struct + 2) = 0;
				*(ref @struct + 3) = 0;
				*(ref @struct + 4) = 96;
				*(ref @struct + 5) = 192;
				*(ref @struct + 6) = 0;
				*(ref @struct + 7) = 0;
				*(ref @struct + 8) = 80;
				*(ref @struct + 9) = 76;
				*(ref @struct + 10) = 68;
				*(ref @struct + 11) = 83;
				Struct29 struct2;
				uint num2;
				if (<Module>.smethod_16((byte*)(&@struct), 12U, (byte)num, 512, (void*)(&struct2), &num2, 96U, 1, &gstruct) != null)
				{
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					MessageBox.Show("Secret command returned an Error", "Warning", MessageBoxButtons.OK, MessageBoxIcon.Hand);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
					result = 0;
				}
				else
				{
					if (*(ref struct2 + 8) == 80 && *(ref struct2 + 9) == 76 && *(ref struct2 + 10) == 68)
					{
						if (*(ref struct2 + 11) == 83)
						{
							this.method_5((byte*)(&struct2), 96U, 0U);
							this.textBox6.AppendText(this.string_0 + "\r\n");
							<Module>.memcpy(*(ref <Module>.struct123_0 + 8) + 684, (void*)(&struct2), 96U);
							return 1;
						}
					}
					this.textBox6.AppendText("Drive is NOT Lite-On, Aborting ! ");
					result = 0;
				}
			}
			return result;
		}

		// Token: 0x0600022D RID: 557 RVA: 0x0011E718 File Offset: 0x0011E718
		private unsafe int method_66()
		{
			int result;
			if (this.comboBox1.Items.Count == 0)
			{
				result = 0;
			}
			else
			{
				uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
				ushort ushort_ = *(ref <Module>.struct38_0 + selectedIndex * 72U);
				uint num;
				if (*(ref <Module>.struct38_0 + selectedIndex * 72U + 4) == 160)
				{
					num = 0U;
				}
				else
				{
					num = 16U;
				}
				GStruct3 gstruct;
				<Module>.smethod_21(&gstruct, ushort_, 0, 1, 10000U);
				Struct30 @struct;
				uint num2;
				if (<Module>.smethod_12(161, (byte)num, null, null, 64, (void*)(&@struct), &num2, 512U, 512U, 1, &gstruct) != null)
				{
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					MessageBox.Show("Identify command returned an Error", "Warning", MessageBoxButtons.OK, MessageBoxIcon.Hand);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
					result = 0;
				}
				else
				{
					this.method_5((byte*)(&@struct), 180U, 0U);
					this.textBox6.AppendText(this.string_0 + "\r\n");
					<Module>.memcpy(*(ref <Module>.struct123_0 + 8) + 780, (void*)(&@struct), 180U);
					if (this.checkBox8.CheckState == CheckState.Unchecked)
					{
						if (this.bool_2)
						{
							string text = this.string_10 + "\\Identify.bin";
							if (!File.Exists(text))
							{
								IntPtr intPtr = Marshal.StringToHGlobalAnsi(text);
								IntPtr value = intPtr;
								sbyte* pSbyte_ = (sbyte*)((void*)value);
								this.string_13 = text;
								GStruct5* ptr = <Module>.fopen((sbyte*)pSbyte_, (sbyte*)(&<Module>.struct18_5));
								if (ptr != null)
								{
									<Module>.fwrite(*(ref <Module>.struct123_0 + 8) + 780, 180U, 1U, ptr);
									for (uint num3 = 0U; num3 < 332U; num3 += 1U)
									{
										<Module>.fputc(0, ptr);
									}
									<Module>.fclose(ptr);
									this.textBox6.AppendText("\r\n" + "Identify String saved to " + text + "\r\n");
									return 1;
								}
								<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
								MessageBox.Show(text, "Can't open file", MessageBoxButtons.OK);
								<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
							}
						}
						SaveFileDialog saveFileDialog = new SaveFileDialog();
						saveFileDialog.Filter = "Firmware Images (*.bin)|*.bin|All Files (*.*)|*.*";
						saveFileDialog.DefaultExt = ".bin";
						saveFileDialog.FileName = "Identify.bin";
						saveFileDialog.RestoreDirectory = false;
						if (this.bool_2)
						{
							saveFileDialog.InitialDirectory = this.string_10;
						}
						if (saveFileDialog.ShowDialog() == DialogResult.OK)
						{
							string fullPath = Path.GetFullPath(saveFileDialog.FileName);
							IntPtr intPtr2 = Marshal.StringToHGlobalAnsi(fullPath);
							IntPtr value2 = intPtr2;
							sbyte* pSbyte_2 = (sbyte*)((void*)value2);
							GStruct5* ptr = <Module>.fopen((sbyte*)pSbyte_2, (sbyte*)(&<Module>.struct18_5));
							if (ptr == null)
							{
								<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
								MessageBox.Show(saveFileDialog.FileName.ToString(), "Can't open file", MessageBoxButtons.OK);
								<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
								return 0;
							}
							this.textBox6.AppendText("Identify String saved to " + saveFileDialog.FileName + "\r\n\r\n");
							<Module>.fwrite(*(ref <Module>.struct123_0 + 8) + 780, 180U, 1U, ptr);
							for (uint num3 = 0U; num3 < 332U; num3 += 1U)
							{
								<Module>.fputc(0, ptr);
							}
							<Module>.fclose(ptr);
						}
					}
					result = 1;
				}
			}
			return result;
		}

		// Token: 0x0600022E RID: 558 RVA: 0x0011EA64 File Offset: 0x0011EA64
		private unsafe int method_67()
		{
			int result;
			if (this.comboBox1.Items.Count == 0)
			{
				result = 0;
			}
			else
			{
				uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
				uint num = (uint)(*(ref <Module>.struct38_0 + selectedIndex * 72U + 4));
				ushort ushort_ = *(ref <Module>.struct38_0 + selectedIndex * 72U);
				if (*(ref <Module>.struct38_0 + selectedIndex * 72U + 4) == 160)
				{
					num = 0U;
				}
				else
				{
					num = 16U;
				}
				GStruct3 gstruct;
				<Module>.smethod_21(&gstruct, ushort_, 0, 1, 10000U);
				Struct52 @struct;
				<Module>.memset((void*)(&@struct), 0, 12U);
				@struct = 18;
				*(ref @struct + 1) = 0;
				*(ref @struct + 2) = 0;
				*(ref @struct + 3) = 0;
				*(ref @struct + 4) = 96;
				*(ref @struct + 5) = 192;
				Struct29 struct2;
				uint num2;
				if (<Module>.smethod_16((byte*)(&@struct), 12U, (byte)num, 512, (void*)(&struct2), &num2, 96U, 1, &gstruct) != null)
				{
					result = 0;
				}
				else
				{
					<Module>.memset((void*)(&@struct), 0, 12U);
					@struct = 253;
					*(ref @struct + 1) = 4;
					*(ref @struct + 2) = 66;
					*(ref @struct + 3) = 69;
					*(ref @struct + 4) = 78;
					*(ref @struct + 5) = 81;
					*(ref @struct + 8) = 16;
					*(ref @struct + 10) = 0;
					Struct28 struct3;
					if (<Module>.smethod_16((byte*)(&@struct), 12U, (byte)num, 512, (void*)(&struct3), &num2, 16U, 1, &gstruct) != null)
					{
						result = 0;
					}
					else
					{
						<Module>.memset((void*)(&@struct), 0, 12U);
						@struct = 253;
						*(ref @struct + 1) = 4;
						*(ref @struct + 2) = 66;
						*(ref @struct + 3) = 69;
						*(ref @struct + 4) = 78;
						*(ref @struct + 5) = 81;
						*(ref @struct + 8) = 20;
						*(ref @struct + 10) = 2;
						Struct42 struct4;
						if (<Module>.smethod_16((byte*)(&@struct), 12U, (byte)num, 512, (void*)(&struct4), &num2, 20U, 1, &gstruct) != null)
						{
							result = 0;
						}
						else
						{
							<Module>.memset((void*)(&@struct), 0, 12U);
							@struct = 253;
							*(ref @struct + 1) = 4;
							*(ref @struct + 2) = 66;
							*(ref @struct + 3) = 69;
							*(ref @struct + 4) = 78;
							*(ref @struct + 5) = 81;
							*(ref @struct + 8) = 2;
							*(ref @struct + 10) = 18;
							Struct60 struct5;
							if (<Module>.smethod_16((byte*)(&@struct), 12U, (byte)num, 512, (void*)(&struct5), &num2, 2U, 1, &gstruct) != null)
							{
								result = 0;
							}
							else
							{
								<Module>.memset((void*)(&@struct), 0, 12U);
								@struct = 253;
								*(ref @struct + 1) = 4;
								*(ref @struct + 2) = 66;
								*(ref @struct + 3) = 69;
								*(ref @struct + 4) = 78;
								*(ref @struct + 5) = 81;
								*(ref @struct + 8) = 2;
								*(ref @struct + 10) = 20;
								Struct60 struct6;
								if (<Module>.smethod_16((byte*)(&@struct), 12U, (byte)num, 512, (void*)(&struct6), &num2, 2U, 1, &gstruct) != null)
								{
									result = 0;
								}
								else
								{
									Struct31 struct7;
									<Module>.memset((void*)(&struct7), 255, 80U);
									byte* ptr = ref struct2 + 42;
									<Module>.memcpy((void*)(&struct7), (void*)ptr, 20U);
									byte* ptr2 = ref struct7 + 24;
									<Module>.memcpy((void*)ptr2, (void*)(&struct3), 16U);
									ptr2 = ref struct7 + 40;
									<Module>.memcpy((void*)ptr2, (void*)(&struct5), 2U);
									ptr2 = ref struct7 + 44;
									<Module>.memcpy((void*)ptr2, (void*)(&struct4), 20U);
									ptr2 = ref struct7 + 76;
									<Module>.memcpy((void*)ptr2, (void*)(&struct6), 2U);
									<Module>.memcpy(*(ref <Module>.struct123_0 + 8) + 2028, (void*)(&struct7), 80U);
									this.method_5((byte*)(&struct7), 80U, 0U);
									this.textBox6.AppendText(this.string_0 + "\r\n");
									if (this.checkBox8.CheckState == CheckState.Unchecked)
									{
										if (this.bool_2)
										{
											string text = this.string_10 + "\\Serial.bin";
											if (!File.Exists(text))
											{
												IntPtr intPtr = Marshal.StringToHGlobalAnsi(text);
												IntPtr value = intPtr;
												sbyte* pSbyte_ = (sbyte*)((void*)value);
												this.string_13 = text;
												GStruct5* ptr3 = <Module>.fopen((sbyte*)pSbyte_, (sbyte*)(&<Module>.struct18_5));
												if (ptr3 != null)
												{
													<Module>.fwrite(*(ref <Module>.struct123_0 + 8) + 2028, 80U, 1U, ptr3);
													<Module>.fclose(ptr3);
													this.textBox6.AppendText("\r\n" + "Serial String saved to " + text + "\r\n");
													return 1;
												}
												<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
												MessageBox.Show(text, "Can't open file", MessageBoxButtons.OK);
												<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
											}
										}
										SaveFileDialog saveFileDialog = new SaveFileDialog();
										saveFileDialog.Filter = "Firmware Images (*.bin)|*.bin|All Files (*.*)|*.*";
										saveFileDialog.DefaultExt = ".bin";
										saveFileDialog.FileName = "Serial.bin";
										saveFileDialog.RestoreDirectory = false;
										if (this.bool_2)
										{
											saveFileDialog.InitialDirectory = this.string_10;
										}
										if (saveFileDialog.ShowDialog() == DialogResult.OK)
										{
											string fullPath = Path.GetFullPath(saveFileDialog.FileName);
											IntPtr intPtr2 = Marshal.StringToHGlobalAnsi(fullPath);
											IntPtr value2 = intPtr2;
											sbyte* pSbyte_2 = (sbyte*)((void*)value2);
											GStruct5* ptr3 = <Module>.fopen((sbyte*)pSbyte_2, (sbyte*)(&<Module>.struct18_5));
											if (ptr3 == null)
											{
												<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
												MessageBox.Show(saveFileDialog.FileName.ToString(), "Can't open file", MessageBoxButtons.OK);
												<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
												return 0;
											}
											this.textBox6.AppendText("Serial String saved to " + saveFileDialog.FileName + "\r\n\r\n");
											<Module>.fwrite(*(ref <Module>.struct123_0 + 8) + 2028, 80U, 1U, ptr3);
											<Module>.fclose(ptr3);
										}
									}
									result = 1;
								}
							}
						}
					}
				}
			}
			return result;
		}

		// Token: 0x0600022F RID: 559 RVA: 0x0011EF64 File Offset: 0x0011EF64
		private unsafe int method_68()
		{
			Struct86 @struct;
			<Module>.memcpy((void*)(&@struct), *(ref <Module>.struct123_0 + 8) + 2028, 224U);
			*(ref @struct + 20) = byte.MaxValue;
			*(ref @struct + 21) = byte.MaxValue;
			*(ref @struct + 22) = byte.MaxValue;
			*(ref @struct + 23) = byte.MaxValue;
			<Module>.memcpy(*(ref <Module>.struct123_0 + 8) + 2028, (void*)(&@struct), 80U);
			this.method_5((byte*)(&@struct), 80U, 0U);
			this.textBox6.AppendText(this.string_0 + "\r\n");
			if (this.checkBox8.CheckState == CheckState.Unchecked)
			{
				if (this.bool_2)
				{
					string text = this.string_10 + "\\Serial.bin";
					if (!File.Exists(text))
					{
						IntPtr intPtr = Marshal.StringToHGlobalAnsi(text);
						IntPtr value = intPtr;
						sbyte* pSbyte_ = (sbyte*)((void*)value);
						this.string_13 = text;
						GStruct5* ptr = <Module>.fopen((sbyte*)pSbyte_, (sbyte*)(&<Module>.struct18_5));
						if (ptr != null)
						{
							<Module>.fwrite(*(ref <Module>.struct123_0 + 8) + 2028, 224U, 1U, ptr);
							<Module>.fclose(ptr);
							this.textBox6.AppendText("\r\n" + "Serial String saved to " + text + "\r\n");
							return 1;
						}
						<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
						MessageBox.Show(text, "Can't open file", MessageBoxButtons.OK);
						<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
					}
				}
				SaveFileDialog saveFileDialog = new SaveFileDialog();
				saveFileDialog.Filter = "Firmware Images (*.bin)|*.bin|All Files (*.*)|*.*";
				saveFileDialog.DefaultExt = ".bin";
				saveFileDialog.FileName = "Serial.bin";
				saveFileDialog.RestoreDirectory = false;
				if (this.bool_2)
				{
					saveFileDialog.InitialDirectory = this.string_10;
				}
				if (saveFileDialog.ShowDialog() == DialogResult.OK)
				{
					string fullPath = Path.GetFullPath(saveFileDialog.FileName);
					IntPtr intPtr2 = Marshal.StringToHGlobalAnsi(fullPath);
					IntPtr value2 = intPtr2;
					sbyte* pSbyte_2 = (sbyte*)((void*)value2);
					GStruct5* ptr = <Module>.fopen((sbyte*)pSbyte_2, (sbyte*)(&<Module>.struct18_5));
					if (ptr == null)
					{
						<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
						MessageBox.Show(saveFileDialog.FileName.ToString(), "Can't open file", MessageBoxButtons.OK);
						<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
						return 0;
					}
					this.textBox6.AppendText("Serial String saved to " + saveFileDialog.FileName + "\r\n\r\n");
					<Module>.fwrite(*(ref <Module>.struct123_0 + 8) + 2028, 224U, 1U, ptr);
					<Module>.fclose(ptr);
				}
			}
			return 1;
		}

		// Token: 0x06000230 RID: 560 RVA: 0x0011F1F0 File Offset: 0x0011F1F0
		private unsafe int method_69()
		{
			int result;
			if (this.comboBox1.Items.Count == 0)
			{
				result = 0;
			}
			else
			{
				uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
				uint num = (uint)(*(ref <Module>.struct38_0 + selectedIndex * 72U + 4));
				ushort ushort_ = *(ref <Module>.struct38_0 + selectedIndex * 72U);
				if (*(ref <Module>.struct38_0 + selectedIndex * 72U + 4) == 160)
				{
					num = 0U;
				}
				else
				{
					num = 16U;
				}
				GStruct3 gstruct;
				<Module>.smethod_21(&gstruct, ushort_, 0, 1, 1000U);
				Struct52 @struct;
				<Module>.memset((void*)(&@struct), 0, 12U);
				@struct = 18;
				*(ref @struct + 1) = 0;
				*(ref @struct + 2) = 0;
				*(ref @struct + 3) = 0;
				*(ref @struct + 4) = 96;
				*(ref @struct + 5) = 192;
				Struct29 struct2;
				uint num2;
				if (<Module>.smethod_16((byte*)(&@struct), 12U, (byte)num, 512, (void*)(&struct2), &num2, 96U, 1, &gstruct) != null)
				{
					result = 0;
				}
				else
				{
					Struct42 struct3;
					<Module>.memset((void*)(&struct3), 255, 20U);
					byte* ptr = ref struct2 + 42;
					<Module>.memcpy((void*)(&struct3), (void*)ptr, 20U);
					<Module>.memcpy(*(ref <Module>.struct123_0 + 8) + 2028, (void*)(&struct3), 20U);
					this.method_5((byte*)(&struct3), 20U, 0U);
					result = 1;
				}
			}
			return result;
		}

		// Token: 0x06000231 RID: 561 RVA: 0x0011F300 File Offset: 0x0011F300
		private unsafe int method_70()
		{
			Struct68 @struct = 0;
			initblk(ref @struct + 1, 0, 259);
			string text = "";
			<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct19_0));
			int num = 0;
			Struct55 struct2 = 83;
			*(ref struct2 + 1) = 108;
			*(ref struct2 + 2) = 105;
			*(ref struct2 + 3) = 109;
			*(ref struct2 + 4) = 75;
			*(ref struct2 + 5) = 101;
			*(ref struct2 + 6) = 121;
			*(ref struct2 + 7) = 32;
			*(ref struct2 + 8) = 69;
			*(ref struct2 + 9) = 120;
			*(ref struct2 + 10) = 116;
			*(ref struct2 + 11) = 114;
			*(ref struct2 + 12) = 97;
			*(ref struct2 + 13) = 99;
			*(ref struct2 + 14) = 116;
			*(ref struct2 + 15) = 32;
			*(ref struct2 + 16) = 0;
			*(ref struct2 + 17) = 0;
			*(ref struct2 + 18) = 0;
			*(ref struct2 + 19) = 0;
			*(ref struct2 + 20) = 0;
			*(ref struct2 + 21) = 0;
			*(ref struct2 + 22) = 0;
			*(ref struct2 + 23) = 0;
			*(ref struct2 + 24) = 0;
			*(ref struct2 + 25) = 0;
			*(ref struct2 + 26) = 0;
			*(ref struct2 + 27) = 0;
			*(ref struct2 + 28) = 0;
			*(ref struct2 + 29) = 0;
			*(ref struct2 + 30) = 0;
			*(ref struct2 + 31) = 0;
			this.Cursor = Cursors.WaitCursor;
			this.method_82();
			this.method_84();
			<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
			int num2 = (int)MessageBox.Show("Do you wish to send Unlock to Slim", "SlimKey", MessageBoxButtons.YesNoCancel, MessageBoxIcon.Question);
			<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
			if (num2 == 6)
			{
				Struct28 struct3;
				this.method_85((byte*)(&struct3));
				if (this.method_87((byte*)(&struct3)) == 0)
				{
					this.Cursor = Cursors.Arrow;
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					num2 = (int)MessageBox.Show("Unlock failed", "SlimKey", MessageBoxButtons.OK, MessageBoxIcon.Asterisk);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
					return 0;
				}
			}
			else if (num2 == 2)
			{
				this.Cursor = Cursors.Arrow;
				return 0;
			}
			int result;
			if (this.method_200() == 0)
			{
				this.Cursor = Cursors.Arrow;
				result = 0;
			}
			else
			{
				Application.DoEvents();
				if (this.method_256() == 0U)
				{
					this.method_259();
					this.Cursor = Cursors.Arrow;
					result = 0;
				}
				else
				{
					for (int i = 0; i < 16; i++)
					{
						<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct10_20), ref @struct, *(*(ref <Module>.struct123_0 + 8) + 280 + i));
					}
					text += new string((sbyte*)(&@struct));
					Application.DoEvents();
					this.method_259();
					this.Cursor = Cursors.WaitCursor;
					for (int j = 0; j < 12; j++)
					{
						<Module>.Sleep(250);
						this.textBox6.AppendText(".");
					}
					if (this.method_107(*(ref <Module>.struct123_0 + 8) + 280) == 1)
					{
						this.textBox6.AppendText("\r\n" + "Key: " + text + " is verified, Thanks C4eva" + "\r\n");
						this.Cursor = Cursors.WaitCursor;
						this.textBox6.AppendText("\r\n" + "Grabbing Key sector: ");
						Struct28 struct4;
						Struct87 struct5;
						for (int k = 0; k < 16; k++)
						{
							int i = 0;
							while (i < 256)
							{
								if (this.method_91(0, (byte)k, (byte)i, (byte*)(&struct4)) == 0)
								{
									return 0;
								}
								<Module>.memcpy(ref struct5 + num, (void*)(&struct4), 16U);
								i += 16;
								num += 16;
							}
							this.textBox6.AppendText(".");
							Application.DoEvents();
						}
						this.textBox6.AppendText("\r\n");
						<Module>.memcpy(*(ref <Module>.struct121_0 + 7172), (void*)(&struct5), 4096U);
						num = 0;
						if (this.method_71() == 1)
						{
							this.textBox6.AppendText("Key Sector verified." + "\r\n");
						}
						else if (this.method_73() == 1)
						{
							this.textBox6.AppendText("Key Sector verified." + "\r\n");
						}
						else if (this.method_75() == 1)
						{
							this.textBox6.AppendText("Key Sector verified." + "\r\n");
						}
						else
						{
							if (this.method_77() != 1)
							{
								this.textBox6.AppendText("Key Sector NOT verified !" + "\r\n");
								return 0;
							}
							this.textBox6.AppendText("Key Sector verified." + "\r\n");
						}
						this.textBox6.AppendText("Grabbing Serial info: ");
						for (int k = 8; k < 10; k++)
						{
							int i = 0;
							while (i < 256)
							{
								if (this.method_91(3, (byte)k, (byte)(i + 6), (byte*)(&struct4)) == 0)
								{
									return 0;
								}
								<Module>.memcpy(ref struct5 + num, (void*)(&struct4), 16U);
								if (i % 64 == 0)
								{
									this.textBox6.AppendText(".");
									Application.DoEvents();
								}
								i += 16;
								num += 16;
							}
						}
						this.textBox6.AppendText("\r\n");
						<Module>.memset(*(ref <Module>.struct123_0 + 8) + 2028, 255, 224U);
						<Module>.memcpy(*(ref <Module>.struct123_0 + 8) + 2028, ref struct5 + 208, 80U);
						<Module>.memcpy(*(ref <Module>.struct123_0 + 8) + 2156, ref struct5 + 320, 96U);
						this.textBox6.AppendText(string.Concat("\r\n"));
						<Module>.memcpy(*(ref <Module>.struct123_0 + 8) + 2348, (void*)(&struct2), 32U);
						this.method_177();
						this.Cursor = Cursors.Arrow;
						result = 1;
					}
					else
					{
						this.textBox6.AppendText("\r\n" + "Key: " + text + " verification failed !" + "\r\n");
						result = 0;
					}
				}
			}
			return result;
		}

		// Token: 0x06000232 RID: 562 RVA: 0x0011F8AC File Offset: 0x0011F8AC
		private unsafe int method_71()
		{
			Struct33 @struct;
			<Module>.memcpy((void*)(&@struct), *(ref <Module>.struct121_0 + 7172), 4096U);
			Struct28 struct2;
			<Module>.memcpy((void*)(&struct2), *(ref <Module>.struct123_0 + 8) + 280, 16U);
			Struct28 struct3 = *(ref @struct + 312);
			*(ref struct3 + 1) = *(ref @struct + 2796);
			*(ref struct3 + 2) = *(ref @struct + 1858);
			*(ref struct3 + 3) = *(ref @struct + 1664);
			*(ref struct3 + 4) = *(ref @struct + 3789);
			*(ref struct3 + 5) = *(ref @struct + 2868);
			*(ref struct3 + 6) = *(ref @struct + 2111);
			*(ref struct3 + 7) = *(ref @struct + 1829);
			*(ref struct3 + 8) = *(ref @struct + 1322);
			*(ref struct3 + 9) = *(ref @struct + 513);
			*(ref struct3 + 10) = *(ref @struct + 2527);
			*(ref struct3 + 11) = *(ref @struct + 35);
			*(ref struct3 + 12) = *(ref @struct + 1184);
			*(ref struct3 + 13) = *(ref @struct + 1434);
			*(ref struct3 + 14) = *(ref @struct + 1022);
			*(ref struct3 + 15) = *(ref @struct + 3913);
			return (<Module>.memcmp((void*)(&struct3), (void*)(&struct2), 16U) != null) ? 0 : 1;
		}

		// Token: 0x06000233 RID: 563 RVA: 0x0011F9E0 File Offset: 0x0011F9E0
		private unsafe int method_72()
		{
			Struct33 @struct;
			<Module>.memcpy((void*)(&@struct), *(ref <Module>.struct121_0 + 2388) + 172032, 4096U);
			Struct28 struct2;
			<Module>.memcpy((void*)(&struct2), *(ref <Module>.struct121_0 + 2388) + 41008, 16U);
			Struct28 struct3 = *(ref @struct + 312);
			*(ref struct3 + 1) = *(ref @struct + 2796);
			*(ref struct3 + 2) = *(ref @struct + 1858);
			*(ref struct3 + 3) = *(ref @struct + 1664);
			*(ref struct3 + 4) = *(ref @struct + 3789);
			*(ref struct3 + 5) = *(ref @struct + 2868);
			*(ref struct3 + 6) = *(ref @struct + 2111);
			*(ref struct3 + 7) = *(ref @struct + 1829);
			*(ref struct3 + 8) = *(ref @struct + 1322);
			*(ref struct3 + 9) = *(ref @struct + 513);
			*(ref struct3 + 10) = *(ref @struct + 2527);
			*(ref struct3 + 11) = *(ref @struct + 35);
			*(ref struct3 + 12) = *(ref @struct + 1184);
			*(ref struct3 + 13) = *(ref @struct + 1434);
			*(ref struct3 + 14) = *(ref @struct + 1022);
			*(ref struct3 + 15) = *(ref @struct + 3913);
			return (<Module>.memcmp((void*)(&struct3), (void*)(&struct2), 16U) != null) ? 0 : 1;
		}

		// Token: 0x06000234 RID: 564 RVA: 0x0011FB20 File Offset: 0x0011FB20
		private unsafe int method_73()
		{
			Struct28 @struct = 195;
			*(ref @struct + 1) = 220;
			*(ref @struct + 2) = 18;
			*(ref @struct + 3) = 91;
			*(ref @struct + 4) = 110;
			*(ref @struct + 5) = 85;
			*(ref @struct + 6) = 183;
			*(ref @struct + 7) = 56;
			*(ref @struct + 8) = 43;
			*(ref @struct + 9) = 206;
			*(ref @struct + 10) = 241;
			*(ref @struct + 11) = 190;
			*(ref @struct + 12) = 19;
			*(ref @struct + 13) = 54;
			*(ref @struct + 14) = 68;
			*(ref @struct + 15) = 30;
			Struct28 struct2 = 0;
			initblk(ref struct2 + 1, 0, 15);
			Struct33 struct3;
			<Module>.memcpy((void*)(&struct3), *(ref <Module>.struct121_0 + 7172), 4096U);
			Struct28 struct4;
			<Module>.memcpy((void*)(&struct4), *(ref <Module>.struct123_0 + 8) + 665, 16U);
			Struct28 struct5;
			<Module>.memcpy((void*)(&struct5), *(ref <Module>.struct123_0 + 8) + 280, 16U);
			Struct28 struct6;
			for (int i = 0; i < 16; i++)
			{
				*(ref struct6 + i) = (*(ref struct4 + i) ^ *(ref @struct + i));
			}
			Struct28 struct7;
			this.method_89((byte*)(&struct6), (byte*)(&@struct), (byte*)(&struct2), (byte*)(&struct7));
			Struct28 struct8;
			for (int i = 0; i < 16; i++)
			{
				*(ref struct8 + i) = (byte)((*(ref struct7 + i) & 15) << 4);
			}
			Struct28 struct9;
			this.method_89((byte*)(&struct6), (byte*)(&struct7), (byte*)(&struct2), (byte*)(&struct9));
			Struct28 struct10;
			for (int i = 0; i < 16; i++)
			{
				*(ref struct10 + i) = (byte)((*(ref struct9 + i) & 240) >> 4);
			}
			Struct28 struct11;
			for (int i = 0; i < 16; i++)
			{
				*(ref struct11 + i) = (*(ref struct10 + i) | *(ref struct8 + i));
			}
			Struct28 struct12;
			for (int i = 0; i < 16; i++)
			{
				*(ref struct12 + i) = *(ref struct11 + i);
				if ((*(ref struct11 + i) & 15) == 15)
				{
					*(ref struct12 + i) = *(ref struct12 + i) - 1;
				}
			}
			Struct88 struct13;
			for (int i = 0; i < 16; i++)
			{
				*(ref struct13 + i * 2) = (short)((int)(*(ref struct12 + i)) << 4 | i);
			}
			Struct28 struct14;
			for (int i = 0; i < 16; i++)
			{
				*(ref struct14 + i) = *(ref struct3 + *(ref struct13 + i * 2));
			}
			Struct28 struct15;
			this.method_90((byte*)(&struct6), (byte*)(&@struct), (byte*)(&struct14), (byte*)(&struct15));
			return (<Module>.memcmp((void*)(&struct5), (void*)(&struct15), 16U) != null) ? 0 : 1;
		}

		// Token: 0x06000235 RID: 565 RVA: 0x0011FD34 File Offset: 0x0011FD34
		private unsafe int method_74()
		{
			Struct28 @struct = 195;
			*(ref @struct + 1) = 220;
			*(ref @struct + 2) = 18;
			*(ref @struct + 3) = 91;
			*(ref @struct + 4) = 110;
			*(ref @struct + 5) = 85;
			*(ref @struct + 6) = 183;
			*(ref @struct + 7) = 56;
			*(ref @struct + 8) = 43;
			*(ref @struct + 9) = 206;
			*(ref @struct + 10) = 241;
			*(ref @struct + 11) = 190;
			*(ref @struct + 12) = 19;
			*(ref @struct + 13) = 54;
			*(ref @struct + 14) = 68;
			*(ref @struct + 15) = 30;
			Struct28 struct2 = 0;
			initblk(ref struct2 + 1, 0, 15);
			Struct33 struct3;
			<Module>.memcpy((void*)(&struct3), *(ref <Module>.struct121_0 + 2388) + 172032, 4096U);
			Struct28 struct4;
			<Module>.memcpy((void*)(&struct4), *(ref <Module>.struct121_0 + 2388) + 130817, 16U);
			Struct28 struct5;
			<Module>.memcpy((void*)(&struct5), *(ref <Module>.struct121_0 + 2388) + 41008, 16U);
			Struct28 struct6;
			for (int i = 0; i < 16; i++)
			{
				*(ref struct6 + i) = (*(ref struct4 + i) ^ *(ref @struct + i));
			}
			Struct28 struct7;
			this.method_89((byte*)(&struct6), (byte*)(&@struct), (byte*)(&struct2), (byte*)(&struct7));
			Struct28 struct8;
			for (int i = 0; i < 16; i++)
			{
				*(ref struct8 + i) = (byte)((*(ref struct7 + i) & 15) << 4);
			}
			Struct28 struct9;
			this.method_89((byte*)(&struct6), (byte*)(&struct7), (byte*)(&struct2), (byte*)(&struct9));
			Struct28 struct10;
			for (int i = 0; i < 16; i++)
			{
				*(ref struct10 + i) = (byte)((*(ref struct9 + i) & 240) >> 4);
			}
			Struct28 struct11;
			for (int i = 0; i < 16; i++)
			{
				*(ref struct11 + i) = (*(ref struct10 + i) | *(ref struct8 + i));
			}
			Struct28 struct12;
			for (int i = 0; i < 16; i++)
			{
				*(ref struct12 + i) = *(ref struct11 + i);
				if ((*(ref struct11 + i) & 15) == 15)
				{
					*(ref struct12 + i) = *(ref struct12 + i) - 1;
				}
			}
			Struct88 struct13;
			for (int i = 0; i < 16; i++)
			{
				*(ref struct13 + i * 2) = (short)((int)(*(ref struct12 + i)) << 4 | i);
			}
			Struct28 struct14;
			for (int i = 0; i < 16; i++)
			{
				*(ref struct14 + i) = *(ref struct3 + *(ref struct13 + i * 2));
			}
			Struct28 struct15;
			this.method_90((byte*)(&struct6), (byte*)(&@struct), (byte*)(&struct14), (byte*)(&struct15));
			return (<Module>.memcmp((void*)(&struct5), (void*)(&struct15), 16U) != null) ? 0 : 1;
		}

		// Token: 0x06000236 RID: 566 RVA: 0x0011FF58 File Offset: 0x0011FF58
		private unsafe int method_75()
		{
			Struct28 @struct = 17;
			*(ref @struct + 1) = 177;
			*(ref @struct + 2) = 97;
			*(ref @struct + 3) = 5;
			*(ref @struct + 4) = 252;
			*(ref @struct + 5) = 42;
			*(ref @struct + 6) = 67;
			*(ref @struct + 7) = 32;
			*(ref @struct + 8) = 202;
			*(ref @struct + 9) = 129;
			*(ref @struct + 10) = 184;
			*(ref @struct + 11) = 79;
			*(ref @struct + 12) = 181;
			*(ref @struct + 13) = 92;
			*(ref @struct + 14) = 234;
			*(ref @struct + 15) = 122;
			Struct28 struct2 = 0;
			initblk(ref struct2 + 1, 0, 15);
			Struct33 struct3;
			<Module>.memcpy((void*)(&struct3), *(ref <Module>.struct121_0 + 7172), 4096U);
			Struct28 struct4;
			<Module>.memcpy((void*)(&struct4), *(ref <Module>.struct123_0 + 8) + 665, 16U);
			Struct28 struct5;
			<Module>.memcpy((void*)(&struct5), *(ref <Module>.struct123_0 + 8) + 280, 16U);
			Struct28 struct6;
			for (int i = 0; i < 16; i++)
			{
				*(ref struct6 + i) = (*(ref struct4 + i) ^ *(ref @struct + i));
			}
			Struct28 struct7;
			this.method_89((byte*)(&struct6), (byte*)(&@struct), (byte*)(&struct2), (byte*)(&struct7));
			Struct28 struct8;
			for (int i = 0; i < 16; i++)
			{
				*(ref struct8 + i) = (byte)((*(ref struct7 + i) & 15) << 4);
			}
			Struct28 struct9;
			this.method_89((byte*)(&struct6), (byte*)(&struct7), (byte*)(&struct2), (byte*)(&struct9));
			Struct28 struct10;
			for (int i = 0; i < 16; i++)
			{
				*(ref struct10 + i) = (byte)((*(ref struct9 + i) & 240) >> 4);
			}
			Struct28 struct11;
			for (int i = 0; i < 16; i++)
			{
				*(ref struct11 + i) = (*(ref struct10 + i) | *(ref struct8 + i));
			}
			Struct28 struct12;
			for (int i = 0; i < 16; i++)
			{
				*(ref struct12 + i) = *(ref struct11 + i);
				if ((*(ref struct11 + i) & 15) == 15)
				{
					*(ref struct12 + i) = *(ref struct12 + i) - 1;
				}
			}
			Struct88 struct13;
			for (int i = 0; i < 16; i++)
			{
				*(ref struct13 + i * 2) = (short)((int)(*(ref struct12 + i)) << 4 | i);
			}
			Struct28 struct14;
			for (int i = 0; i < 16; i++)
			{
				*(ref struct14 + i) = *(ref struct3 + *(ref struct13 + i * 2));
			}
			Struct28 struct15;
			this.method_90((byte*)(&struct6), (byte*)(&@struct), (byte*)(&struct14), (byte*)(&struct15));
			return (<Module>.memcmp((void*)(&struct5), (void*)(&struct15), 16U) != null) ? 0 : 1;
		}

		// Token: 0x06000237 RID: 567 RVA: 0x00120170 File Offset: 0x00120170
		private unsafe int method_76()
		{
			Struct28 @struct = 17;
			*(ref @struct + 1) = 177;
			*(ref @struct + 2) = 97;
			*(ref @struct + 3) = 5;
			*(ref @struct + 4) = 252;
			*(ref @struct + 5) = 42;
			*(ref @struct + 6) = 67;
			*(ref @struct + 7) = 32;
			*(ref @struct + 8) = 202;
			*(ref @struct + 9) = 129;
			*(ref @struct + 10) = 184;
			*(ref @struct + 11) = 79;
			*(ref @struct + 12) = 181;
			*(ref @struct + 13) = 92;
			*(ref @struct + 14) = 234;
			*(ref @struct + 15) = 122;
			Struct28 struct2 = 0;
			initblk(ref struct2 + 1, 0, 15);
			Struct33 struct3;
			<Module>.memcpy((void*)(&struct3), *(ref <Module>.struct121_0 + 2388) + 172032, 4096U);
			Struct28 struct4;
			<Module>.memcpy((void*)(&struct4), *(ref <Module>.struct121_0 + 2388) + 130817, 16U);
			Struct28 struct5;
			<Module>.memcpy((void*)(&struct5), *(ref <Module>.struct121_0 + 2388) + 41008, 16U);
			Struct28 struct6;
			for (int i = 0; i < 16; i++)
			{
				*(ref struct6 + i) = (*(ref struct4 + i) ^ *(ref @struct + i));
			}
			Struct28 struct7;
			this.method_89((byte*)(&struct6), (byte*)(&@struct), (byte*)(&struct2), (byte*)(&struct7));
			Struct28 struct8;
			for (int i = 0; i < 16; i++)
			{
				*(ref struct8 + i) = (byte)((*(ref struct7 + i) & 15) << 4);
			}
			Struct28 struct9;
			this.method_89((byte*)(&struct6), (byte*)(&struct7), (byte*)(&struct2), (byte*)(&struct9));
			Struct28 struct10;
			for (int i = 0; i < 16; i++)
			{
				*(ref struct10 + i) = (byte)((*(ref struct9 + i) & 240) >> 4);
			}
			Struct28 struct11;
			for (int i = 0; i < 16; i++)
			{
				*(ref struct11 + i) = (*(ref struct10 + i) | *(ref struct8 + i));
			}
			Struct28 struct12;
			for (int i = 0; i < 16; i++)
			{
				*(ref struct12 + i) = *(ref struct11 + i);
				if ((*(ref struct11 + i) & 15) == 15)
				{
					*(ref struct12 + i) = *(ref struct12 + i) - 1;
				}
			}
			Struct88 struct13;
			for (int i = 0; i < 16; i++)
			{
				*(ref struct13 + i * 2) = (short)((int)(*(ref struct12 + i)) << 4 | i);
			}
			Struct28 struct14;
			for (int i = 0; i < 16; i++)
			{
				*(ref struct14 + i) = *(ref struct3 + *(ref struct13 + i * 2));
			}
			Struct28 struct15;
			this.method_90((byte*)(&struct6), (byte*)(&@struct), (byte*)(&struct14), (byte*)(&struct15));
			return (<Module>.memcmp((void*)(&struct5), (void*)(&struct15), 16U) != null) ? 0 : 1;
		}

		// Token: 0x06000238 RID: 568 RVA: 0x00120394 File Offset: 0x00120394
		private unsafe int method_77()
		{
			Struct28 @struct = 237;
			*(ref @struct + 1) = 88;
			*(ref @struct + 2) = 152;
			*(ref @struct + 3) = 52;
			*(ref @struct + 4) = 81;
			*(ref @struct + 5) = 5;
			*(ref @struct + 6) = 89;
			*(ref @struct + 7) = 91;
			*(ref @struct + 8) = 177;
			*(ref @struct + 9) = 227;
			*(ref @struct + 10) = 223;
			*(ref @struct + 11) = 230;
			*(ref @struct + 12) = 15;
			*(ref @struct + 13) = 229;
			*(ref @struct + 14) = 172;
			*(ref @struct + 15) = 28;
			Struct28 struct2 = 0;
			initblk(ref struct2 + 1, 0, 15);
			Struct33 struct3;
			<Module>.memcpy((void*)(&struct3), *(ref <Module>.struct121_0 + 7172), 4096U);
			Struct28 struct4;
			<Module>.memcpy((void*)(&struct4), *(ref <Module>.struct123_0 + 8) + 665, 16U);
			Struct28 struct5;
			<Module>.memcpy((void*)(&struct5), *(ref <Module>.struct123_0 + 8) + 280, 16U);
			Struct28 struct6;
			for (int i = 0; i < 16; i++)
			{
				*(ref struct6 + i) = (*(ref struct4 + i) ^ *(ref @struct + i));
			}
			Struct28 struct7;
			this.method_89((byte*)(&struct6), (byte*)(&@struct), (byte*)(&struct2), (byte*)(&struct7));
			Struct28 struct8;
			for (int i = 0; i < 16; i++)
			{
				*(ref struct8 + i) = (byte)((*(ref struct7 + i) & 15) << 4);
			}
			Struct28 struct9;
			this.method_89((byte*)(&struct6), (byte*)(&struct7), (byte*)(&struct2), (byte*)(&struct9));
			Struct28 struct10;
			for (int i = 0; i < 16; i++)
			{
				*(ref struct10 + i) = (byte)((*(ref struct9 + i) & 240) >> 4);
			}
			Struct28 struct11;
			for (int i = 0; i < 16; i++)
			{
				*(ref struct11 + i) = (*(ref struct10 + i) | *(ref struct8 + i));
			}
			Struct28 struct12;
			for (int i = 0; i < 16; i++)
			{
				*(ref struct12 + i) = *(ref struct11 + i);
				if ((*(ref struct11 + i) & 15) == 15)
				{
					*(ref struct12 + i) = *(ref struct12 + i) - 1;
				}
			}
			Struct88 struct13;
			for (int i = 0; i < 16; i++)
			{
				*(ref struct13 + i * 2) = (short)((int)(*(ref struct12 + i)) << 4 | i);
			}
			Struct28 struct14;
			for (int i = 0; i < 16; i++)
			{
				*(ref struct14 + i) = *(ref struct3 + *(ref struct13 + i * 2));
			}
			Struct28 struct15;
			this.method_90((byte*)(&struct6), (byte*)(&@struct), (byte*)(&struct14), (byte*)(&struct15));
			return (<Module>.memcmp((void*)(&struct5), (void*)(&struct15), 16U) != null) ? 0 : 1;
		}

		// Token: 0x06000239 RID: 569 RVA: 0x001205AC File Offset: 0x001205AC
		private unsafe int method_78()
		{
			Struct28 @struct = 237;
			*(ref @struct + 1) = 88;
			*(ref @struct + 2) = 152;
			*(ref @struct + 3) = 52;
			*(ref @struct + 4) = 81;
			*(ref @struct + 5) = 5;
			*(ref @struct + 6) = 89;
			*(ref @struct + 7) = 91;
			*(ref @struct + 8) = 177;
			*(ref @struct + 9) = 227;
			*(ref @struct + 10) = 223;
			*(ref @struct + 11) = 230;
			*(ref @struct + 12) = 15;
			*(ref @struct + 13) = 229;
			*(ref @struct + 14) = 172;
			*(ref @struct + 15) = 28;
			Struct28 struct2 = 0;
			initblk(ref struct2 + 1, 0, 15);
			Struct33 struct3;
			<Module>.memcpy((void*)(&struct3), *(ref <Module>.struct121_0 + 2388) + 172032, 4096U);
			Struct28 struct4;
			<Module>.memcpy((void*)(&struct4), *(ref <Module>.struct121_0 + 2388) + 130817, 16U);
			Struct28 struct5;
			<Module>.memcpy((void*)(&struct5), *(ref <Module>.struct121_0 + 2388) + 41008, 16U);
			Struct28 struct6;
			for (int i = 0; i < 16; i++)
			{
				*(ref struct6 + i) = (*(ref struct4 + i) ^ *(ref @struct + i));
			}
			Struct28 struct7;
			this.method_89((byte*)(&struct6), (byte*)(&@struct), (byte*)(&struct2), (byte*)(&struct7));
			Struct28 struct8;
			for (int i = 0; i < 16; i++)
			{
				*(ref struct8 + i) = (byte)((*(ref struct7 + i) & 15) << 4);
			}
			Struct28 struct9;
			this.method_89((byte*)(&struct6), (byte*)(&struct7), (byte*)(&struct2), (byte*)(&struct9));
			Struct28 struct10;
			for (int i = 0; i < 16; i++)
			{
				*(ref struct10 + i) = (byte)((*(ref struct9 + i) & 240) >> 4);
			}
			Struct28 struct11;
			for (int i = 0; i < 16; i++)
			{
				*(ref struct11 + i) = (*(ref struct10 + i) | *(ref struct8 + i));
			}
			Struct28 struct12;
			for (int i = 0; i < 16; i++)
			{
				*(ref struct12 + i) = *(ref struct11 + i);
				if ((*(ref struct11 + i) & 15) == 15)
				{
					*(ref struct12 + i) = *(ref struct12 + i) - 1;
				}
			}
			Struct88 struct13;
			for (int i = 0; i < 16; i++)
			{
				*(ref struct13 + i * 2) = (short)((int)(*(ref struct12 + i)) << 4 | i);
			}
			Struct28 struct14;
			for (int i = 0; i < 16; i++)
			{
				*(ref struct14 + i) = *(ref struct3 + *(ref struct13 + i * 2));
			}
			Struct28 struct15;
			this.method_90((byte*)(&struct6), (byte*)(&@struct), (byte*)(&struct14), (byte*)(&struct15));
			return (<Module>.memcmp((void*)(&struct5), (void*)(&struct15), 16U) != null) ? 0 : 1;
		}

		// Token: 0x0600023A RID: 570 RVA: 0x001207D4 File Offset: 0x001207D4
		private unsafe int method_79(int int_16)
		{
			Struct28 @struct = 195;
			*(ref @struct + 1) = 220;
			*(ref @struct + 2) = 18;
			*(ref @struct + 3) = 91;
			*(ref @struct + 4) = 110;
			*(ref @struct + 5) = 85;
			*(ref @struct + 6) = 183;
			*(ref @struct + 7) = 56;
			*(ref @struct + 8) = 43;
			*(ref @struct + 9) = 206;
			*(ref @struct + 10) = 241;
			*(ref @struct + 11) = 190;
			*(ref @struct + 12) = 19;
			*(ref @struct + 13) = 54;
			*(ref @struct + 14) = 68;
			*(ref @struct + 15) = 30;
			Struct28 struct2 = 0;
			initblk(ref struct2 + 1, 0, 15);
			Struct33 struct3;
			<Module>.memcpy((void*)(&struct3), *(ref <Module>.struct121_0 + int_16 * 2392 + 2388) + 172032, 4096U);
			Struct28 struct4;
			<Module>.memcpy((void*)(&struct4), *(ref <Module>.struct121_0 + int_16 * 2392 + 2388) + 130817, 16U);
			Struct33 struct5;
			<Module>.memset((void*)(&struct5), 255, 4096U);
			int result;
			if (<Module>.memcmp((void*)(&struct3), (void*)(&struct5), 4096U) == null)
			{
				<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 280, (void*)(&struct5), 16U);
				result = 1;
			}
			else
			{
				Struct28 struct6;
				for (int i = 0; i < 16; i++)
				{
					*(ref struct6 + i) = (*(ref struct4 + i) ^ *(ref @struct + i));
				}
				Struct28 struct7;
				this.method_89((byte*)(&struct6), (byte*)(&@struct), (byte*)(&struct2), (byte*)(&struct7));
				Struct28 struct8;
				for (int i = 0; i < 16; i++)
				{
					*(ref struct8 + i) = (byte)((*(ref struct7 + i) & 15) << 4);
				}
				Struct28 struct9;
				this.method_89((byte*)(&struct6), (byte*)(&struct7), (byte*)(&struct2), (byte*)(&struct9));
				Struct28 struct10;
				for (int i = 0; i < 16; i++)
				{
					*(ref struct10 + i) = (byte)((*(ref struct9 + i) & 240) >> 4);
				}
				Struct28 struct11;
				for (int i = 0; i < 16; i++)
				{
					*(ref struct11 + i) = (*(ref struct10 + i) | *(ref struct8 + i));
				}
				Struct28 struct12;
				for (int i = 0; i < 16; i++)
				{
					*(ref struct12 + i) = *(ref struct11 + i);
					if ((*(ref struct11 + i) & 15) == 15)
					{
						*(ref struct12 + i) = *(ref struct12 + i) - 1;
					}
				}
				Struct88 struct13;
				for (int i = 0; i < 16; i++)
				{
					*(ref struct13 + i * 2) = (short)((int)(*(ref struct12 + i)) << 4 | i);
				}
				Struct28 struct14;
				for (int i = 0; i < 16; i++)
				{
					*(ref struct14 + i) = *(ref struct3 + *(ref struct13 + i * 2));
				}
				Struct28 struct15;
				this.method_90((byte*)(&struct6), (byte*)(&@struct), (byte*)(&struct14), (byte*)(&struct15));
				<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 280, (void*)(&struct15), 16U);
				result = 1;
			}
			return result;
		}

		// Token: 0x0600023B RID: 571 RVA: 0x00120A38 File Offset: 0x00120A38
		private unsafe int method_80(int int_16)
		{
			Struct28 @struct = 17;
			*(ref @struct + 1) = 177;
			*(ref @struct + 2) = 97;
			*(ref @struct + 3) = 5;
			*(ref @struct + 4) = 252;
			*(ref @struct + 5) = 42;
			*(ref @struct + 6) = 67;
			*(ref @struct + 7) = 32;
			*(ref @struct + 8) = 202;
			*(ref @struct + 9) = 129;
			*(ref @struct + 10) = 184;
			*(ref @struct + 11) = 79;
			*(ref @struct + 12) = 181;
			*(ref @struct + 13) = 92;
			*(ref @struct + 14) = 234;
			*(ref @struct + 15) = 122;
			Struct28 struct2 = 0;
			initblk(ref struct2 + 1, 0, 15);
			Struct33 struct3;
			<Module>.memcpy((void*)(&struct3), *(ref <Module>.struct121_0 + int_16 * 2392 + 2388) + 172032, 4096U);
			Struct28 struct4;
			<Module>.memcpy((void*)(&struct4), *(ref <Module>.struct121_0 + int_16 * 2392 + 2388) + 130817, 16U);
			Struct33 struct5;
			<Module>.memset((void*)(&struct5), 255, 4096U);
			int result;
			if (<Module>.memcmp((void*)(&struct3), (void*)(&struct5), 4096U) == null)
			{
				<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 280, (void*)(&struct5), 16U);
				result = 1;
			}
			else
			{
				Struct28 struct6;
				for (int i = 0; i < 16; i++)
				{
					*(ref struct6 + i) = (*(ref struct4 + i) ^ *(ref @struct + i));
				}
				Struct28 struct7;
				this.method_89((byte*)(&struct6), (byte*)(&@struct), (byte*)(&struct2), (byte*)(&struct7));
				Struct28 struct8;
				for (int i = 0; i < 16; i++)
				{
					*(ref struct8 + i) = (byte)((*(ref struct7 + i) & 15) << 4);
				}
				Struct28 struct9;
				this.method_89((byte*)(&struct6), (byte*)(&struct7), (byte*)(&struct2), (byte*)(&struct9));
				Struct28 struct10;
				for (int i = 0; i < 16; i++)
				{
					*(ref struct10 + i) = (byte)((*(ref struct9 + i) & 240) >> 4);
				}
				Struct28 struct11;
				for (int i = 0; i < 16; i++)
				{
					*(ref struct11 + i) = (*(ref struct10 + i) | *(ref struct8 + i));
				}
				Struct28 struct12;
				for (int i = 0; i < 16; i++)
				{
					*(ref struct12 + i) = *(ref struct11 + i);
					if ((*(ref struct11 + i) & 15) == 15)
					{
						*(ref struct12 + i) = *(ref struct12 + i) - 1;
					}
				}
				Struct88 struct13;
				for (int i = 0; i < 16; i++)
				{
					*(ref struct13 + i * 2) = (short)((int)(*(ref struct12 + i)) << 4 | i);
				}
				Struct28 struct14;
				for (int i = 0; i < 16; i++)
				{
					*(ref struct14 + i) = *(ref struct3 + *(ref struct13 + i * 2));
				}
				Struct28 struct15;
				this.method_90((byte*)(&struct6), (byte*)(&@struct), (byte*)(&struct14), (byte*)(&struct15));
				<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 280, (void*)(&struct15), 16U);
				result = 1;
			}
			return result;
		}

		// Token: 0x0600023C RID: 572 RVA: 0x00120C9C File Offset: 0x00120C9C
		private unsafe int method_81(int int_16)
		{
			Struct28 @struct = 237;
			*(ref @struct + 1) = 88;
			*(ref @struct + 2) = 152;
			*(ref @struct + 3) = 52;
			*(ref @struct + 4) = 81;
			*(ref @struct + 5) = 5;
			*(ref @struct + 6) = 89;
			*(ref @struct + 7) = 91;
			*(ref @struct + 8) = 177;
			*(ref @struct + 9) = 227;
			*(ref @struct + 10) = 223;
			*(ref @struct + 11) = 230;
			*(ref @struct + 12) = 15;
			*(ref @struct + 13) = 229;
			*(ref @struct + 14) = 172;
			*(ref @struct + 15) = 28;
			Struct28 struct2 = 0;
			initblk(ref struct2 + 1, 0, 15);
			Struct33 struct3;
			<Module>.memcpy((void*)(&struct3), *(ref <Module>.struct121_0 + int_16 * 2392 + 2388) + 172032, 4096U);
			Struct28 struct4;
			<Module>.memcpy((void*)(&struct4), *(ref <Module>.struct121_0 + int_16 * 2392 + 2388) + 130817, 16U);
			Struct33 struct5;
			<Module>.memset((void*)(&struct5), 255, 4096U);
			int result;
			if (<Module>.memcmp((void*)(&struct3), (void*)(&struct5), 4096U) == null)
			{
				<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 280, (void*)(&struct5), 16U);
				result = 1;
			}
			else
			{
				Struct28 struct6;
				for (int i = 0; i < 16; i++)
				{
					*(ref struct6 + i) = (*(ref struct4 + i) ^ *(ref @struct + i));
				}
				Struct28 struct7;
				this.method_89((byte*)(&struct6), (byte*)(&@struct), (byte*)(&struct2), (byte*)(&struct7));
				Struct28 struct8;
				for (int i = 0; i < 16; i++)
				{
					*(ref struct8 + i) = (byte)((*(ref struct7 + i) & 15) << 4);
				}
				Struct28 struct9;
				this.method_89((byte*)(&struct6), (byte*)(&struct7), (byte*)(&struct2), (byte*)(&struct9));
				Struct28 struct10;
				for (int i = 0; i < 16; i++)
				{
					*(ref struct10 + i) = (byte)((*(ref struct9 + i) & 240) >> 4);
				}
				Struct28 struct11;
				for (int i = 0; i < 16; i++)
				{
					*(ref struct11 + i) = (*(ref struct10 + i) | *(ref struct8 + i));
				}
				Struct28 struct12;
				for (int i = 0; i < 16; i++)
				{
					*(ref struct12 + i) = *(ref struct11 + i);
					if ((*(ref struct11 + i) & 15) == 15)
					{
						*(ref struct12 + i) = *(ref struct12 + i) - 1;
					}
				}
				Struct88 struct13;
				for (int i = 0; i < 16; i++)
				{
					*(ref struct13 + i * 2) = (short)((int)(*(ref struct12 + i)) << 4 | i);
				}
				Struct28 struct14;
				for (int i = 0; i < 16; i++)
				{
					*(ref struct14 + i) = *(ref struct3 + *(ref struct13 + i * 2));
				}
				Struct28 struct15;
				this.method_90((byte*)(&struct6), (byte*)(&@struct), (byte*)(&struct14), (byte*)(&struct15));
				<Module>.memcpy(*(ref <Module>.struct123_0 + int_16 * 4) + 280, (void*)(&struct15), 16U);
				result = 1;
			}
			return result;
		}

		// Token: 0x0600023D RID: 573 RVA: 0x00120F04 File Offset: 0x00120F04
		private unsafe int method_82()
		{
			int result;
			if (this.comboBox1.Items.Count == 0)
			{
				result = 0;
			}
			else
			{
				uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
				ushort ushort_ = *(ref <Module>.struct38_0 + selectedIndex * 72U);
				uint num;
				if (*(ref <Module>.struct38_0 + selectedIndex * 72U + 4) == 160)
				{
					num = 0U;
				}
				else
				{
					num = 16U;
				}
				GStruct3 gstruct;
				<Module>.smethod_21(&gstruct, ushort_, 0, 1, 10000U);
				Struct52 @struct;
				<Module>.memset((void*)(&@struct), 0, 12U);
				@struct = 18;
				*(ref @struct + 1) = 0;
				*(ref @struct + 2) = 0;
				*(ref @struct + 3) = 0;
				*(ref @struct + 4) = 116;
				*(ref @struct + 5) = 192;
				Struct85 struct2;
				uint num2;
				if (<Module>.smethod_16((byte*)(&@struct), 12U, (byte)num, 512, (void*)(&struct2), &num2, 116U, 1, &gstruct) != null)
				{
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					MessageBox.Show("Inquiry command returned an Error", "Warning", MessageBoxButtons.OK, MessageBoxIcon.Hand);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
					result = 0;
				}
				else
				{
					this.method_5((byte*)(&struct2), 116U, 0U);
					this.textBox6.AppendText("\r\n\r\n" + this.string_0 + "\r\n");
					<Module>.memcpy(*(ref <Module>.struct123_0 + 8) + 568, (void*)(&struct2), 116U);
					result = 1;
				}
			}
			return result;
		}

		// Token: 0x0600023E RID: 574 RVA: 0x00121044 File Offset: 0x00121044
		private unsafe int method_83(byte* pByte_0)
		{
			int result;
			if (this.comboBox1.Items.Count == 0)
			{
				result = 0;
			}
			else
			{
				uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
				ushort ushort_ = *(ref <Module>.struct38_0 + selectedIndex * 72U);
				uint num;
				if (*(ref <Module>.struct38_0 + selectedIndex * 72U + 4) == 160)
				{
					num = 0U;
				}
				else
				{
					num = 16U;
				}
				GStruct3 gstruct;
				<Module>.smethod_21(&gstruct, ushort_, 0, 1, 10000U);
				Struct52 @struct;
				<Module>.memset((void*)(&@struct), 0, 12U);
				@struct = 18;
				*(ref @struct + 1) = 0;
				*(ref @struct + 2) = 0;
				*(ref @struct + 3) = 0;
				*(ref @struct + 4) = 116;
				*(ref @struct + 5) = 192;
				Struct85 struct2;
				uint num2;
				if (<Module>.smethod_16((byte*)(&@struct), 12U, (byte)num, 512, (void*)(&struct2), &num2, 116U, 1, &gstruct) != null)
				{
					result = 0;
				}
				else
				{
					<Module>.memcpy((void*)pByte_0, ref struct2 + 96, 20U);
					result = 1;
				}
			}
			return result;
		}

		// Token: 0x0600023F RID: 575 RVA: 0x00121110 File Offset: 0x00121110
		private unsafe int method_84()
		{
			int result;
			if (this.comboBox1.Items.Count == 0)
			{
				result = 0;
			}
			else
			{
				uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
				ushort ushort_ = *(ref <Module>.struct38_0 + selectedIndex * 72U);
				uint num;
				if (*(ref <Module>.struct38_0 + selectedIndex * 72U + 4) == 160)
				{
					num = 0U;
				}
				else
				{
					num = 16U;
				}
				GStruct3 gstruct;
				<Module>.smethod_21(&gstruct, ushort_, 0, 1, 10000U);
				Struct30 @struct;
				uint num2;
				if (<Module>.smethod_12(161, (byte)num, null, null, 64, (void*)(&@struct), &num2, 512U, 512U, 1, &gstruct) != null)
				{
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					MessageBox.Show("Identify command returned an Error", "Warning", MessageBoxButtons.OK, MessageBoxIcon.Hand);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
					result = 0;
				}
				else
				{
					this.method_5((byte*)(&@struct), 512U, 0U);
					this.textBox6.AppendText(this.string_0 + "\r\n");
					<Module>.memcpy(*(ref <Module>.struct123_0 + 8) + 780, (void*)(&@struct), 180U);
					result = 1;
				}
			}
			return result;
		}

		// Token: 0x06000240 RID: 576 RVA: 0x00121224 File Offset: 0x00121224
		private unsafe int method_85(byte* pByte_0)
		{
			Struct28 @struct = 220;
			*(ref @struct + 1) = 175;
			*(ref @struct + 2) = 11;
			*(ref @struct + 3) = 192;
			*(ref @struct + 4) = 251;
			*(ref @struct + 5) = 44;
			*(ref @struct + 6) = 246;
			*(ref @struct + 7) = 3;
			*(ref @struct + 8) = 131;
			*(ref @struct + 9) = 13;
			*(ref @struct + 10) = 10;
			*(ref @struct + 11) = 150;
			*(ref @struct + 12) = 197;
			*(ref @struct + 13) = 165;
			*(ref @struct + 14) = 62;
			*(ref @struct + 15) = 217;
			Struct28 struct2 = 16;
			*(ref struct2 + 1) = 17;
			*(ref struct2 + 2) = 18;
			*(ref struct2 + 3) = 19;
			*(ref struct2 + 4) = 20;
			*(ref struct2 + 5) = 21;
			*(ref struct2 + 6) = 22;
			*(ref struct2 + 7) = 23;
			*(ref struct2 + 8) = 24;
			*(ref struct2 + 9) = 25;
			*(ref struct2 + 10) = 26;
			*(ref struct2 + 11) = 27;
			*(ref struct2 + 12) = 28;
			*(ref struct2 + 13) = 29;
			*(ref struct2 + 14) = 30;
			*(ref struct2 + 15) = 31;
			Struct28 struct3;
			<Module>.memcpy((void*)(&struct3), *(ref <Module>.struct123_0 + 8) + 664, 16U);
			Struct28 struct4;
			this.method_89((byte*)(&@struct), (byte*)(&struct2), (byte*)(&struct3), (byte*)(&struct4));
			<Module>.memcpy((void*)pByte_0, (void*)(&struct4), 16U);
			return 1;
		}

		// Token: 0x06000241 RID: 577 RVA: 0x0012136C File Offset: 0x0012136C
		private unsafe int method_86(byte* pByte_0)
		{
			Struct28 @struct = 247;
			*(ref @struct + 1) = 179;
			*(ref @struct + 2) = 204;
			*(ref @struct + 3) = 214;
			*(ref @struct + 4) = 232;
			*(ref @struct + 5) = 33;
			*(ref @struct + 6) = 206;
			*(ref @struct + 7) = 197;
			*(ref @struct + 8) = 112;
			*(ref @struct + 9) = 252;
			*(ref @struct + 10) = 170;
			*(ref @struct + 11) = 134;
			*(ref @struct + 12) = 45;
			*(ref @struct + 13) = 47;
			*(ref @struct + 14) = 101;
			*(ref @struct + 15) = 7;
			Struct28 struct2 = 16;
			*(ref struct2 + 1) = 17;
			*(ref struct2 + 2) = 18;
			*(ref struct2 + 3) = 19;
			*(ref struct2 + 4) = 20;
			*(ref struct2 + 5) = 21;
			*(ref struct2 + 6) = 22;
			*(ref struct2 + 7) = 23;
			*(ref struct2 + 8) = 24;
			*(ref struct2 + 9) = 25;
			*(ref struct2 + 10) = 26;
			*(ref struct2 + 11) = 27;
			*(ref struct2 + 12) = 28;
			*(ref struct2 + 13) = 29;
			*(ref struct2 + 14) = 30;
			*(ref struct2 + 15) = 31;
			Struct28 struct3;
			<Module>.memset((void*)(&struct3), 32, 16U);
			Struct28 struct4;
			<Module>.memcpy((void*)(&struct4), *(ref <Module>.struct123_0 + 8) + 664, 16U);
			if (<Module>.memcmp((void*)(&struct3), (void*)(&struct4), 16U) == null)
			{
				<Module>.memset((void*)(&struct4), 255, 16U);
			}
			Struct28 struct5;
			this.method_89((byte*)(&@struct), (byte*)(&struct2), (byte*)(&struct4), (byte*)(&struct5));
			<Module>.memcpy((void*)pByte_0, (void*)(&struct5), 16U);
			return 1;
		}

		// Token: 0x06000242 RID: 578 RVA: 0x001214DC File Offset: 0x001214DC
		private unsafe int method_87(byte* pByte_0)
		{
			int result;
			if (this.comboBox1.Items.Count == 0)
			{
				result = 0;
			}
			else
			{
				uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
				ushort ushort_ = *(ref <Module>.struct38_0 + selectedIndex * 72U);
				uint num;
				if (*(ref <Module>.struct38_0 + selectedIndex * 72U + 4) == 160)
				{
					num = 0U;
				}
				else
				{
					num = 16U;
				}
				GStruct3 gstruct;
				<Module>.smethod_21(&gstruct, ushort_, 0, 1, 1000U);
				Struct28 @struct;
				<Module>.memset((void*)(&@struct), 0, 16U);
				<Module>.memcpy((void*)(&@struct), (void*)pByte_0, 16U);
				Struct52 struct2;
				<Module>.memset((void*)(&struct2), 0, 12U);
				struct2 = 253;
				*(ref struct2 + 1) = 15;
				*(ref struct2 + 2) = 80;
				*(ref struct2 + 3) = 76;
				*(ref struct2 + 4) = 68;
				*(ref struct2 + 5) = 83;
				*(ref struct2 + 6) = 119;
				*(ref struct2 + 7) = 0;
				*(ref struct2 + 8) = 16;
				this.textBox6.AppendText("Sending Password to Drive on port " + this.label123.Text + "\r\n");
				uint num2;
				if (<Module>.smethod_17((byte*)(&struct2), 12U, (byte)num, 512, (void*)(&@struct), &num2, 16U, 1, &gstruct) != null)
				{
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					MessageBox.Show("Slim-Un-Lock command returned an Error", "Warning", MessageBoxButtons.OK, MessageBoxIcon.Asterisk);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
					result = 0;
				}
				else
				{
					this.textBox6.AppendText("Done!" + "\r\n");
					result = 1;
				}
			}
			return result;
		}

		// Token: 0x06000243 RID: 579 RVA: 0x00121644 File Offset: 0x00121644
		private unsafe int method_88(byte* pByte_0)
		{
			int result;
			if (this.comboBox1.Items.Count == 0)
			{
				result = 0;
			}
			else
			{
				uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
				ushort ushort_ = *(ref <Module>.struct38_0 + selectedIndex * 72U);
				uint num;
				if (*(ref <Module>.struct38_0 + selectedIndex * 72U + 4) == 160)
				{
					num = 0U;
				}
				else
				{
					num = 16U;
				}
				GStruct3 gstruct;
				<Module>.smethod_21(&gstruct, ushort_, 0, 1, 1000U);
				Struct28 @struct;
				<Module>.memset((void*)(&@struct), 0, 16U);
				<Module>.memcpy((void*)(&@struct), (void*)pByte_0, 16U);
				Struct52 struct2;
				<Module>.memset((void*)(&struct2), 0, 12U);
				struct2 = 253;
				*(ref struct2 + 1) = 15;
				*(ref struct2 + 2) = 80;
				*(ref struct2 + 3) = 76;
				*(ref struct2 + 4) = 68;
				*(ref struct2 + 5) = 83;
				*(ref struct2 + 6) = 0;
				*(ref struct2 + 7) = 0;
				*(ref struct2 + 8) = 16;
				this.textBox6.AppendText("Sending Password to Drive on port " + this.label123.Text + "\r\n");
				uint num2;
				if (<Module>.smethod_17((byte*)(&struct2), 12U, (byte)num, 512, (void*)(&@struct), &num2, 16U, 1, &gstruct) != null)
				{
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					MessageBox.Show("Slim-Un-Lock command returned an Error", "Warning", MessageBoxButtons.OK, MessageBoxIcon.Asterisk);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
					result = 0;
				}
				else
				{
					this.textBox6.AppendText("Done!" + "\r\n");
					result = 1;
				}
			}
			return result;
		}

		// Token: 0x06000244 RID: 580 RVA: 0x001217AC File Offset: 0x001217AC
		private unsafe void method_89(byte* pByte_0, byte* pByte_1, byte* pByte_2, byte* pByte_3)
		{
			Struct28 @struct;
			<Module>.memcpy((void*)(&@struct), (void*)pByte_0, 16U);
			Struct28 struct2;
			<Module>.memcpy((void*)(&struct2), (void*)pByte_1, 16U);
			Struct28 struct3;
			<Module>.memcpy((void*)(&struct3), (void*)pByte_2, 16U);
			for (int i = 0; i < 16; i++)
			{
				*(ref struct3 + i) = (*(ref struct3 + i) ^ *(ref struct2 + i));
			}
			Struct89 struct4;
			int int_ = <Module>.smethod_142((uint*)(&struct4), (byte*)(&@struct), 128);
			Struct28 struct5;
			<Module>.smethod_144((uint*)(&struct4), int_, (byte*)(&struct3), (byte*)(&struct5));
			<Module>.memcpy((void*)pByte_3, (void*)(&struct5), 16U);
		}

		// Token: 0x06000245 RID: 581 RVA: 0x00121820 File Offset: 0x00121820
		private unsafe void method_90(byte* pByte_0, byte* pByte_1, byte* pByte_2, byte* pByte_3)
		{
			Struct28 @struct;
			<Module>.memcpy((void*)(&@struct), (void*)pByte_0, 16U);
			Struct28 struct2;
			<Module>.memcpy((void*)(&struct2), (void*)pByte_1, 16U);
			Struct28 struct3;
			<Module>.memcpy((void*)(&struct3), (void*)pByte_2, 16U);
			Struct89 struct4;
			int int_ = <Module>.smethod_143((uint*)(&struct4), (byte*)(&@struct), 128);
			Struct28 struct5;
			<Module>.smethod_145((uint*)(&struct4), int_, (byte*)(&struct3), (byte*)(&struct5));
			for (int i = 0; i < 16; i++)
			{
				*(ref struct5 + i) = (*(ref struct5 + i) ^ *(ref struct2 + i));
			}
			<Module>.memcpy((void*)pByte_3, (void*)(&struct5), 16U);
		}

		// Token: 0x06000246 RID: 582 RVA: 0x00121894 File Offset: 0x00121894
		private unsafe int method_91(byte byte_0, byte byte_1, byte byte_2, byte* pByte_0)
		{
			Struct28 @struct = 74;
			*(ref @struct + 1) = 117;
			*(ref @struct + 2) = 110;
			*(ref @struct + 3) = 103;
			*(ref @struct + 4) = 108;
			*(ref @struct + 5) = 101;
			*(ref @struct + 6) = 32;
			*(ref @struct + 7) = 70;
			*(ref @struct + 8) = 108;
			*(ref @struct + 9) = 97;
			*(ref @struct + 10) = 115;
			*(ref @struct + 11) = 104;
			*(ref @struct + 12) = 101;
			*(ref @struct + 13) = 114;
			*(ref @struct + 14) = 32;
			*(ref @struct + 15) = 0;
			Struct28 struct2 = 0;
			*(ref struct2 + 1) = 1;
			*(ref struct2 + 2) = 2;
			*(ref struct2 + 3) = 3;
			*(ref struct2 + 4) = 4;
			*(ref struct2 + 5) = 5;
			*(ref struct2 + 6) = 6;
			*(ref struct2 + 7) = 7;
			*(ref struct2 + 8) = 8;
			*(ref struct2 + 9) = 9;
			*(ref struct2 + 10) = 10;
			*(ref struct2 + 11) = 11;
			*(ref struct2 + 12) = 12;
			*(ref struct2 + 13) = 13;
			*(ref struct2 + 14) = 14;
			*(ref struct2 + 15) = 15;
			Struct28 struct3 = 67;
			*(ref struct3 + 1) = 111;
			*(ref struct3 + 2) = 109;
			*(ref struct3 + 3) = 109;
			*(ref struct3 + 4) = 97;
			*(ref struct3 + 5) = 100;
			*(ref struct3 + 6) = 111;
			*(ref struct3 + 7) = 114;
			*(ref struct3 + 8) = 101;
			*(ref struct3 + 9) = 32;
			*(ref struct3 + 10) = 52;
			*(ref struct3 + 11) = 32;
			*(ref struct3 + 12) = 101;
			*(ref struct3 + 13) = 118;
			*(ref struct3 + 14) = 101;
			*(ref struct3 + 15) = 114;
			Struct28 struct4 = 4;
			*(ref struct4 + 1) = 0;
			*(ref struct4 + 2) = 0;
			*(ref struct4 + 3) = 0;
			*(ref struct4 + 4) = 0;
			*(ref struct4 + 5) = 0;
			*(ref struct4 + 6) = 0;
			*(ref struct4 + 7) = 0;
			*(ref struct4 + 8) = 0;
			*(ref struct4 + 9) = 0;
			*(ref struct4 + 10) = 0;
			*(ref struct4 + 11) = 16;
			*(ref struct4 + 12) = 0;
			*(ref struct4 + 13) = 0;
			*(ref struct4 + 14) = 0;
			*(ref struct4 + 15) = 0;
			Struct28 struct5 = 0;
			initblk(ref struct5 + 1, 0, 15);
			Struct28 struct6 = 0;
			initblk(ref struct6 + 1, 0, 15);
			<Module>.memset((void*)(&struct5), 0, 16U);
			<Module>.memset((void*)(&struct6), 255, 16U);
			Struct28 struct7 = 0;
			initblk(ref struct7 + 1, 0, 15);
			Struct4 struct8 = 0;
			*(ref struct8 + 1) = 56;
			*(ref struct8 + 2) = 0;
			*(ref struct8 + 3) = 0;
			*(ref struct8 + 4) = 0;
			*(ref struct8 + 5) = 0;
			*(ref struct8 + 6) = 0;
			*(ref struct8 + 7) = 0;
			*(ref struct8 + 8) = 33;
			*(ref struct8 + 9) = 48;
			*(ref struct8 + 10) = 0;
			*(ref struct8 + 11) = 0;
			*(ref struct8 + 12) = 0;
			*(ref struct8 + 13) = 0;
			*(ref struct8 + 14) = 0;
			*(ref struct8 + 15) = 0;
			*(ref struct8 + 16) = 0;
			*(ref struct8 + 17) = 0;
			*(ref struct8 + 18) = 0;
			*(ref struct8 + 19) = 0;
			*(ref struct8 + 20) = 0;
			*(ref struct8 + 21) = 0;
			*(ref struct8 + 22) = 0;
			*(ref struct8 + 23) = 0;
			*(ref struct8 + 24) = 0;
			*(ref struct8 + 25) = 0;
			*(ref struct8 + 26) = 0;
			*(ref struct8 + 27) = 0;
			*(ref struct8 + 28) = 0;
			*(ref struct8 + 29) = 0;
			*(ref struct8 + 30) = 0;
			*(ref struct8 + 31) = 0;
			*(ref struct8 + 32) = 0;
			*(ref struct8 + 33) = 0;
			*(ref struct8 + 34) = 0;
			*(ref struct8 + 35) = 0;
			*(ref struct8 + 36) = 0;
			*(ref struct8 + 37) = 0;
			*(ref struct8 + 38) = 0;
			*(ref struct8 + 39) = 0;
			*(ref struct8 + 40) = 0;
			*(ref struct8 + 41) = 0;
			*(ref struct8 + 42) = 0;
			*(ref struct8 + 43) = 0;
			*(ref struct8 + 44) = 0;
			*(ref struct8 + 45) = 0;
			*(ref struct8 + 46) = 0;
			*(ref struct8 + 47) = 0;
			*(ref struct8 + 48) = 0;
			*(ref struct8 + 49) = 0;
			*(ref struct8 + 50) = 0;
			*(ref struct8 + 51) = 0;
			*(ref struct8 + 52) = 0;
			*(ref struct8 + 53) = 0;
			*(ref struct8 + 54) = 0;
			*(ref struct8 + 55) = 0;
			*(ref struct8 + 56) = 0;
			*(ref struct8 + 57) = 0;
			*(ref struct8 + 58) = 0;
			*(ref struct8 + 59) = 0;
			*(ref struct8 + 60) = 0;
			*(ref struct8 + 61) = 0;
			*(ref struct8 + 62) = 0;
			*(ref struct8 + 63) = 0;
			*(ref struct4 + 5) = byte_0;
			*(ref struct4 + 6) = byte_1;
			*(ref struct4 + 7) = byte_2;
			int result;
			if (this.comboBox1.Items.Count == 0)
			{
				result = 0;
			}
			else
			{
				int selectedIndex = this.comboBox1.SelectedIndex;
				ushort ushort_ = *(ref <Module>.struct38_0 + selectedIndex * 72);
				uint num = (uint)(*(ref <Module>.struct38_0 + selectedIndex * 72 + 4));
				uint num2;
				if (num == 160U)
				{
					num2 = 0U;
				}
				else
				{
					num2 = 16U;
				}
				GStruct3 gstruct;
				<Module>.smethod_21(&gstruct, ushort_, 0, 1, 10000U);
				this.method_89((byte*)(&@struct), (byte*)(&struct2), (byte*)(&@struct), ref struct8 + 10);
				this.method_89((byte*)(&@struct), ref struct8 + 10, (byte*)(&struct5), ref struct8 + 26);
				this.method_89((byte*)(&@struct), ref struct8 + 26, (byte*)(&struct4), ref struct8 + 42);
				Struct52 struct9;
				<Module>.memset((void*)(&struct9), 0, 12U);
				Struct90 struct10;
				<Module>.memcpy((void*)(&struct10), (void*)(&struct8), 58U);
				struct9 = 85;
				*(ref struct9 + 8) = 58;
				uint num3;
				if (<Module>.smethod_17((byte*)(&struct9), 12U, (byte)num2, 512, (void*)(&struct10), &num3, 58U, 1, &gstruct) != null && <Module>.smethod_17((byte*)(&struct9), 12U, (byte)num2, 512, (void*)(&struct10), &num3, 58U, 1, &gstruct) != null)
				{
					this.textBox6.AppendText("\r\n" + "Stage 1 failed" + "\r\n");
					this.Cursor = Cursors.Arrow;
					result = 0;
				}
				else
				{
					<Module>.Sleep(1);
					if (*(ref <Module>.struct38_0 + selectedIndex * 72) == 0 && *(ref <Module>.struct38_0 + selectedIndex * 72 + 3) == 1)
					{
						this.method_424(88);
					}
					Struct90 struct11;
					<Module>.memset((void*)(&struct11), 0, 58U);
					<Module>.memset((void*)(&struct9), 0, 12U);
					struct9 = 90;
					*(ref struct9 + 2) = 33;
					*(ref struct9 + 8) = 58;
					if (<Module>.smethod_16((byte*)(&struct9), 12U, (byte)num2, 512, (void*)(&struct11), &num3, 58U, 1, &gstruct) != null && <Module>.smethod_16((byte*)(&struct9), 12U, (byte)num2, 512, (void*)(&struct11), &num3, 58U, 1, &gstruct) != null)
					{
						this.textBox6.AppendText("\r\n" + "Stage 2 failed" + "\r\n");
						this.Cursor = Cursors.Arrow;
						result = 0;
					}
					else
					{
						Struct31 struct12;
						this.method_90((byte*)(&@struct), (byte*)(&struct2), ref struct11 + 10, (byte*)(&struct12));
						this.method_90((byte*)(&@struct), ref struct11 + 10, ref struct11 + 26, ref struct12 + 16);
						this.method_90((byte*)(&@struct), ref struct11 + 26, ref struct11 + 42, ref struct12 + 32);
						this.method_90((byte*)(&@struct), (byte*)(&struct6), ref struct12 + 16, ref struct12 + 48);
						this.method_90((byte*)(&@struct), (byte*)(&struct5), ref struct12 + 48, ref struct12 + 64);
						if (<Module>.memcmp((void*)(&struct12), (void*)(&@struct), 16U) == null)
						{
							<Module>.memcpy((void*)pByte_0, ref struct12 + 64, 16U);
							result = 1;
						}
						else
						{
							result = 0;
						}
					}
				}
			}
			return result;
		}

		// Token: 0x06000247 RID: 583 RVA: 0x00121ECC File Offset: 0x00121ECC
		private unsafe int method_92(byte byte_0, byte byte_1, byte byte_2, byte* pByte_0)
		{
			Struct28 @struct = 74;
			*(ref @struct + 1) = 117;
			*(ref @struct + 2) = 110;
			*(ref @struct + 3) = 103;
			*(ref @struct + 4) = 108;
			*(ref @struct + 5) = 101;
			*(ref @struct + 6) = 32;
			*(ref @struct + 7) = 70;
			*(ref @struct + 8) = 108;
			*(ref @struct + 9) = 97;
			*(ref @struct + 10) = 115;
			*(ref @struct + 11) = 104;
			*(ref @struct + 12) = 101;
			*(ref @struct + 13) = 114;
			*(ref @struct + 14) = 32;
			*(ref @struct + 15) = 0;
			Struct28 struct2 = 0;
			*(ref struct2 + 1) = 1;
			*(ref struct2 + 2) = 2;
			*(ref struct2 + 3) = 3;
			*(ref struct2 + 4) = 4;
			*(ref struct2 + 5) = 5;
			*(ref struct2 + 6) = 6;
			*(ref struct2 + 7) = 7;
			*(ref struct2 + 8) = 8;
			*(ref struct2 + 9) = 9;
			*(ref struct2 + 10) = 10;
			*(ref struct2 + 11) = 11;
			*(ref struct2 + 12) = 12;
			*(ref struct2 + 13) = 13;
			*(ref struct2 + 14) = 14;
			*(ref struct2 + 15) = 15;
			Struct28 struct3 = 67;
			*(ref struct3 + 1) = 111;
			*(ref struct3 + 2) = 109;
			*(ref struct3 + 3) = 109;
			*(ref struct3 + 4) = 97;
			*(ref struct3 + 5) = 100;
			*(ref struct3 + 6) = 111;
			*(ref struct3 + 7) = 114;
			*(ref struct3 + 8) = 101;
			*(ref struct3 + 9) = 32;
			*(ref struct3 + 10) = 52;
			*(ref struct3 + 11) = 32;
			*(ref struct3 + 12) = 101;
			*(ref struct3 + 13) = 118;
			*(ref struct3 + 14) = 101;
			*(ref struct3 + 15) = 114;
			Struct28 struct4 = 0;
			*(ref struct4 + 1) = 0;
			*(ref struct4 + 2) = 0;
			*(ref struct4 + 3) = 0;
			*(ref struct4 + 4) = 0;
			*(ref struct4 + 5) = 0;
			*(ref struct4 + 6) = 0;
			*(ref struct4 + 7) = 0;
			*(ref struct4 + 8) = 0;
			*(ref struct4 + 9) = 0;
			*(ref struct4 + 10) = 0;
			*(ref struct4 + 11) = 0;
			*(ref struct4 + 12) = 0;
			*(ref struct4 + 13) = 16;
			*(ref struct4 + 14) = 1;
			*(ref struct4 + 15) = 0;
			Struct28 struct5 = 0;
			initblk(ref struct5 + 1, 0, 15);
			Struct28 struct6 = 0;
			initblk(ref struct6 + 1, 0, 15);
			<Module>.memset((void*)(&struct5), 0, 16U);
			<Module>.memset((void*)(&struct6), 255, 16U);
			Struct28 struct7 = 0;
			initblk(ref struct7 + 1, 0, 15);
			Struct4 struct8 = 0;
			*(ref struct8 + 1) = 56;
			*(ref struct8 + 2) = 0;
			*(ref struct8 + 3) = 0;
			*(ref struct8 + 4) = 0;
			*(ref struct8 + 5) = 0;
			*(ref struct8 + 6) = 0;
			*(ref struct8 + 7) = 0;
			*(ref struct8 + 8) = 36;
			*(ref struct8 + 9) = 48;
			*(ref struct8 + 10) = 0;
			*(ref struct8 + 11) = 0;
			*(ref struct8 + 12) = 0;
			*(ref struct8 + 13) = 0;
			*(ref struct8 + 14) = 0;
			*(ref struct8 + 15) = 0;
			*(ref struct8 + 16) = 0;
			*(ref struct8 + 17) = 0;
			*(ref struct8 + 18) = 0;
			*(ref struct8 + 19) = 0;
			*(ref struct8 + 20) = 0;
			*(ref struct8 + 21) = 0;
			*(ref struct8 + 22) = 0;
			*(ref struct8 + 23) = 0;
			*(ref struct8 + 24) = 0;
			*(ref struct8 + 25) = 0;
			*(ref struct8 + 26) = 0;
			*(ref struct8 + 27) = 0;
			*(ref struct8 + 28) = 0;
			*(ref struct8 + 29) = 0;
			*(ref struct8 + 30) = 0;
			*(ref struct8 + 31) = 0;
			*(ref struct8 + 32) = 0;
			*(ref struct8 + 33) = 0;
			*(ref struct8 + 34) = 0;
			*(ref struct8 + 35) = 0;
			*(ref struct8 + 36) = 0;
			*(ref struct8 + 37) = 0;
			*(ref struct8 + 38) = 0;
			*(ref struct8 + 39) = 0;
			*(ref struct8 + 40) = 0;
			*(ref struct8 + 41) = 0;
			*(ref struct8 + 42) = 0;
			*(ref struct8 + 43) = 0;
			*(ref struct8 + 44) = 0;
			*(ref struct8 + 45) = 0;
			*(ref struct8 + 46) = 0;
			*(ref struct8 + 47) = 0;
			*(ref struct8 + 48) = 0;
			*(ref struct8 + 49) = 0;
			*(ref struct8 + 50) = 0;
			*(ref struct8 + 51) = 0;
			*(ref struct8 + 52) = 0;
			*(ref struct8 + 53) = 0;
			*(ref struct8 + 54) = 0;
			*(ref struct8 + 55) = 0;
			*(ref struct8 + 56) = 0;
			*(ref struct8 + 57) = 0;
			*(ref struct8 + 58) = 0;
			*(ref struct8 + 59) = 0;
			*(ref struct8 + 60) = 0;
			*(ref struct8 + 61) = 0;
			*(ref struct8 + 62) = 0;
			*(ref struct8 + 63) = 0;
			*(ref struct4 + 5) = byte_0;
			*(ref struct4 + 6) = byte_1;
			*(ref struct4 + 7) = byte_2;
			int result;
			if (this.comboBox1.Items.Count == 0)
			{
				result = 0;
			}
			else
			{
				int selectedIndex = this.comboBox1.SelectedIndex;
				ushort ushort_ = *(ref <Module>.struct38_0 + selectedIndex * 72);
				uint num = (uint)(*(ref <Module>.struct38_0 + selectedIndex * 72 + 4));
				uint num2;
				if (num == 160U)
				{
					num2 = 0U;
				}
				else
				{
					num2 = 16U;
				}
				GStruct3 gstruct;
				<Module>.smethod_21(&gstruct, ushort_, 0, 1, 10000U);
				this.method_89((byte*)(&@struct), (byte*)(&struct2), (byte*)(&@struct), ref struct8 + 10);
				this.method_89((byte*)(&@struct), ref struct8 + 10, (byte*)(&struct5), ref struct8 + 26);
				this.method_89((byte*)(&@struct), ref struct8 + 26, (byte*)(&struct4), ref struct8 + 42);
				Struct52 struct9;
				<Module>.memset((void*)(&struct9), 0, 12U);
				Struct90 struct10;
				<Module>.memcpy((void*)(&struct10), (void*)(&struct8), 58U);
				struct9 = 85;
				*(ref struct9 + 8) = 58;
				uint num3;
				if (<Module>.smethod_17((byte*)(&struct9), 12U, (byte)num2, 512, (void*)(&struct10), &num3, 58U, 1, &gstruct) != null && <Module>.smethod_17((byte*)(&struct9), 12U, (byte)num2, 512, (void*)(&struct10), &num3, 58U, 1, &gstruct) != null)
				{
					this.textBox6.AppendText("\r\n" + "Stage 1 failed" + "\r\n");
					this.Cursor = Cursors.Arrow;
					result = 0;
				}
				else
				{
					<Module>.Sleep(1);
					if (*(ref <Module>.struct38_0 + selectedIndex * 72) == 0 && *(ref <Module>.struct38_0 + selectedIndex * 72 + 3) == 1)
					{
						this.method_424(88);
					}
					Struct90 struct11;
					<Module>.memset((void*)(&struct11), 0, 58U);
					<Module>.memset((void*)(&struct9), 0, 12U);
					struct9 = 90;
					*(ref struct9 + 2) = 33;
					*(ref struct9 + 8) = 58;
					if (<Module>.smethod_16((byte*)(&struct9), 12U, (byte)num2, 512, (void*)(&struct11), &num3, 58U, 1, &gstruct) != null && <Module>.smethod_16((byte*)(&struct9), 12U, (byte)num2, 512, (void*)(&struct11), &num3, 58U, 1, &gstruct) != null)
					{
						this.textBox6.AppendText("\r\n" + "Stage 2 failed" + "\r\n");
						this.Cursor = Cursors.Arrow;
						result = 0;
					}
					else
					{
						Struct31 struct12;
						this.method_90((byte*)(&@struct), (byte*)(&struct2), ref struct11 + 10, (byte*)(&struct12));
						this.method_90((byte*)(&@struct), ref struct11 + 10, ref struct11 + 26, ref struct12 + 16);
						this.method_90((byte*)(&@struct), ref struct11 + 26, ref struct11 + 42, ref struct12 + 32);
						this.method_90((byte*)(&@struct), (byte*)(&struct6), ref struct12 + 16, ref struct12 + 48);
						this.method_90((byte*)(&@struct), (byte*)(&struct5), ref struct12 + 48, ref struct12 + 64);
						<Module>.memcpy((void*)pByte_0, ref struct12 + 64, 16U);
						if (<Module>.memcmp((void*)(&struct12), (void*)(&@struct), 16U) == null)
						{
							<Module>.memcpy((void*)pByte_0, ref struct12 + 64, 16U);
							result = 1;
						}
						else
						{
							result = 0;
						}
					}
				}
			}
			return result;
		}

		// Token: 0x06000248 RID: 584 RVA: 0x00122510 File Offset: 0x00122510
		private unsafe int method_93(byte byte_0, byte byte_1, byte byte_2, byte* pByte_0)
		{
			Struct28 @struct = 74;
			*(ref @struct + 1) = 117;
			*(ref @struct + 2) = 110;
			*(ref @struct + 3) = 103;
			*(ref @struct + 4) = 108;
			*(ref @struct + 5) = 101;
			*(ref @struct + 6) = 32;
			*(ref @struct + 7) = 70;
			*(ref @struct + 8) = 108;
			*(ref @struct + 9) = 97;
			*(ref @struct + 10) = 115;
			*(ref @struct + 11) = 104;
			*(ref @struct + 12) = 101;
			*(ref @struct + 13) = 114;
			*(ref @struct + 14) = 32;
			*(ref @struct + 15) = 0;
			Struct28 struct2 = 0;
			*(ref struct2 + 1) = 1;
			*(ref struct2 + 2) = 2;
			*(ref struct2 + 3) = 3;
			*(ref struct2 + 4) = 4;
			*(ref struct2 + 5) = 5;
			*(ref struct2 + 6) = 6;
			*(ref struct2 + 7) = 7;
			*(ref struct2 + 8) = 8;
			*(ref struct2 + 9) = 9;
			*(ref struct2 + 10) = 10;
			*(ref struct2 + 11) = 11;
			*(ref struct2 + 12) = 12;
			*(ref struct2 + 13) = 13;
			*(ref struct2 + 14) = 14;
			*(ref struct2 + 15) = 15;
			Struct28 struct3 = 67;
			*(ref struct3 + 1) = 111;
			*(ref struct3 + 2) = 109;
			*(ref struct3 + 3) = 109;
			*(ref struct3 + 4) = 97;
			*(ref struct3 + 5) = 100;
			*(ref struct3 + 6) = 111;
			*(ref struct3 + 7) = 114;
			*(ref struct3 + 8) = 101;
			*(ref struct3 + 9) = 32;
			*(ref struct3 + 10) = 52;
			*(ref struct3 + 11) = 32;
			*(ref struct3 + 12) = 101;
			*(ref struct3 + 13) = 118;
			*(ref struct3 + 14) = 101;
			*(ref struct3 + 15) = 114;
			Struct28 struct4 = 0;
			*(ref struct4 + 1) = 0;
			*(ref struct4 + 2) = 0;
			*(ref struct4 + 3) = 0;
			*(ref struct4 + 4) = 0;
			*(ref struct4 + 5) = 0;
			*(ref struct4 + 6) = 0;
			*(ref struct4 + 7) = 0;
			*(ref struct4 + 8) = 0;
			*(ref struct4 + 9) = 0;
			*(ref struct4 + 10) = 0;
			*(ref struct4 + 11) = 0;
			*(ref struct4 + 12) = 0;
			*(ref struct4 + 13) = 2;
			*(ref struct4 + 14) = 1;
			*(ref struct4 + 15) = 0;
			Struct28 struct5 = 0;
			initblk(ref struct5 + 1, 0, 15);
			Struct28 struct6 = 0;
			initblk(ref struct6 + 1, 0, 15);
			<Module>.memset((void*)(&struct5), 0, 16U);
			<Module>.memset((void*)(&struct6), 255, 16U);
			Struct28 struct7 = 0;
			initblk(ref struct7 + 1, 0, 15);
			Struct4 struct8 = 0;
			*(ref struct8 + 1) = 56;
			*(ref struct8 + 2) = 0;
			*(ref struct8 + 3) = 0;
			*(ref struct8 + 4) = 0;
			*(ref struct8 + 5) = 0;
			*(ref struct8 + 6) = 0;
			*(ref struct8 + 7) = 0;
			*(ref struct8 + 8) = 36;
			*(ref struct8 + 9) = 48;
			*(ref struct8 + 10) = 0;
			*(ref struct8 + 11) = 0;
			*(ref struct8 + 12) = 0;
			*(ref struct8 + 13) = 0;
			*(ref struct8 + 14) = 0;
			*(ref struct8 + 15) = 0;
			*(ref struct8 + 16) = 0;
			*(ref struct8 + 17) = 0;
			*(ref struct8 + 18) = 0;
			*(ref struct8 + 19) = 0;
			*(ref struct8 + 20) = 0;
			*(ref struct8 + 21) = 0;
			*(ref struct8 + 22) = 0;
			*(ref struct8 + 23) = 0;
			*(ref struct8 + 24) = 0;
			*(ref struct8 + 25) = 0;
			*(ref struct8 + 26) = 0;
			*(ref struct8 + 27) = 0;
			*(ref struct8 + 28) = 0;
			*(ref struct8 + 29) = 0;
			*(ref struct8 + 30) = 0;
			*(ref struct8 + 31) = 0;
			*(ref struct8 + 32) = 0;
			*(ref struct8 + 33) = 0;
			*(ref struct8 + 34) = 0;
			*(ref struct8 + 35) = 0;
			*(ref struct8 + 36) = 0;
			*(ref struct8 + 37) = 0;
			*(ref struct8 + 38) = 0;
			*(ref struct8 + 39) = 0;
			*(ref struct8 + 40) = 0;
			*(ref struct8 + 41) = 0;
			*(ref struct8 + 42) = 0;
			*(ref struct8 + 43) = 0;
			*(ref struct8 + 44) = 0;
			*(ref struct8 + 45) = 0;
			*(ref struct8 + 46) = 0;
			*(ref struct8 + 47) = 0;
			*(ref struct8 + 48) = 0;
			*(ref struct8 + 49) = 0;
			*(ref struct8 + 50) = 0;
			*(ref struct8 + 51) = 0;
			*(ref struct8 + 52) = 0;
			*(ref struct8 + 53) = 0;
			*(ref struct8 + 54) = 0;
			*(ref struct8 + 55) = 2;
			*(ref struct8 + 56) = 1;
			*(ref struct8 + 57) = 0;
			*(ref struct8 + 58) = 0;
			*(ref struct8 + 59) = 0;
			*(ref struct8 + 60) = 0;
			*(ref struct8 + 61) = 0;
			*(ref struct8 + 62) = 0;
			*(ref struct8 + 63) = 0;
			*(ref struct4 + 14) = byte_2;
			*(ref struct4 + 13) = byte_1;
			*(ref struct8 + 8) = byte_0;
			*(ref struct8 + 55) = byte_1;
			*(ref struct8 + 56) = byte_2;
			int result;
			if (this.comboBox1.Items.Count == 0)
			{
				result = 0;
			}
			else
			{
				int selectedIndex = this.comboBox1.SelectedIndex;
				ushort ushort_ = *(ref <Module>.struct38_0 + selectedIndex * 72);
				uint num = (uint)(*(ref <Module>.struct38_0 + selectedIndex * 72 + 4));
				uint num2;
				if (num == 160U)
				{
					num2 = 0U;
				}
				else
				{
					num2 = 16U;
				}
				GStruct3 gstruct;
				<Module>.smethod_21(&gstruct, ushort_, 0, 1, 10000U);
				<Module>.memcpy(ref struct8 + 10, (void*)(&@struct), 16U);
				<Module>.memcpy(ref struct8 + 26, (void*)(&struct5), 16U);
				<Module>.memcpy(ref struct8 + 42, (void*)(&struct4), 16U);
				this.method_89((byte*)(&@struct), (byte*)(&struct2), (byte*)(&@struct), ref struct8 + 10);
				this.method_89((byte*)(&@struct), ref struct8 + 10, (byte*)(&struct5), ref struct8 + 26);
				this.method_89((byte*)(&@struct), ref struct8 + 26, (byte*)(&struct4), ref struct8 + 42);
				Struct52 struct9;
				<Module>.memset((void*)(&struct9), 0, 12U);
				Struct90 struct10;
				<Module>.memcpy((void*)(&struct10), (void*)(&struct8), 58U);
				struct9 = 85;
				*(ref struct9 + 8) = 58;
				<Module>.clock();
				uint num3;
				if (<Module>.smethod_17((byte*)(&struct9), 12U, (byte)num2, 512, (void*)(&struct10), &num3, 58U, 1, &gstruct) != null && <Module>.smethod_17((byte*)(&struct9), 12U, (byte)num2, 512, (void*)(&struct10), &num3, 58U, 1, &gstruct) != null)
				{
					this.textBox6.AppendText("\r\n" + "Stage 1 failed" + "\r\n");
					this.Cursor = Cursors.Arrow;
					result = 0;
				}
				else
				{
					<Module>.Sleep(1);
					if (*(ref <Module>.struct38_0 + selectedIndex * 72) == 0 && *(ref <Module>.struct38_0 + selectedIndex * 72 + 3) == 1)
					{
						this.method_424(88);
					}
					Struct90 struct11;
					<Module>.memset((void*)(&struct11), 0, 58U);
					<Module>.memset((void*)(&struct9), 0, 12U);
					struct9 = 90;
					*(ref struct9 + 2) = byte_0;
					*(ref struct9 + 8) = 58;
					if (<Module>.smethod_16((byte*)(&struct9), 12U, (byte)num2, 512, (void*)(&struct11), &num3, 58U, 1, &gstruct) != null && <Module>.smethod_16((byte*)(&struct9), 12U, (byte)num2, 512, (void*)(&struct11), &num3, 58U, 1, &gstruct) != null)
					{
						this.textBox6.AppendText("\r\n" + "Stage 2 failed" + "\r\n");
						this.Cursor = Cursors.Arrow;
						result = 0;
					}
					else
					{
						<Module>.clock();
						Struct31 struct12;
						this.method_90((byte*)(&@struct), (byte*)(&struct2), ref struct11 + 10, (byte*)(&struct12));
						this.method_90((byte*)(&@struct), ref struct11 + 10, ref struct11 + 26, ref struct12 + 16);
						this.method_90((byte*)(&@struct), ref struct11 + 26, ref struct11 + 42, ref struct12 + 32);
						this.method_90((byte*)(&@struct), (byte*)(&struct6), ref struct12 + 16, ref struct12 + 48);
						this.method_90((byte*)(&@struct), (byte*)(&struct5), ref struct12 + 48, ref struct12 + 64);
						if (<Module>.memcmp((void*)(&struct12), (void*)(&@struct), 16U) == null)
						{
							<Module>.memcpy((void*)pByte_0, ref struct12 + 64, 16U);
							result = 1;
						}
						else
						{
							result = 0;
						}
					}
				}
			}
			return result;
		}

		// Token: 0x06000249 RID: 585 RVA: 0x00122BA4 File Offset: 0x00122BA4
		private unsafe int method_94(byte* pByte_0)
		{
			Struct28 @struct = 239;
			*(ref @struct + 1) = 180;
			*(ref @struct + 2) = 134;
			*(ref @struct + 3) = 14;
			*(ref @struct + 4) = 51;
			*(ref @struct + 5) = 186;
			*(ref @struct + 6) = 40;
			*(ref @struct + 7) = 88;
			*(ref @struct + 8) = 99;
			*(ref @struct + 9) = 52;
			*(ref @struct + 10) = 85;
			*(ref @struct + 11) = 115;
			*(ref @struct + 12) = 79;
			*(ref @struct + 13) = 173;
			*(ref @struct + 14) = 24;
			*(ref @struct + 15) = 147;
			Struct28 struct2 = 233;
			*(ref struct2 + 1) = 143;
			*(ref struct2 + 2) = 129;
			*(ref struct2 + 3) = 159;
			*(ref struct2 + 4) = 139;
			*(ref struct2 + 5) = 28;
			*(ref struct2 + 6) = 132;
			*(ref struct2 + 7) = 131;
			*(ref struct2 + 8) = 143;
			*(ref struct2 + 9) = 225;
			*(ref struct2 + 10) = 194;
			*(ref struct2 + 11) = 44;
			*(ref struct2 + 12) = 49;
			*(ref struct2 + 13) = 73;
			*(ref struct2 + 14) = 107;
			*(ref struct2 + 15) = 185;
			Struct28 struct3 = 112;
			*(ref struct3 + 1) = 39;
			*(ref struct3 + 2) = 166;
			*(ref struct3 + 3) = 0;
			*(ref struct3 + 4) = 5;
			*(ref struct3 + 5) = 69;
			*(ref struct3 + 6) = 82;
			*(ref struct3 + 7) = 29;
			*(ref struct3 + 8) = 10;
			*(ref struct3 + 9) = 126;
			*(ref struct3 + 10) = 243;
			*(ref struct3 + 11) = 59;
			*(ref struct3 + 12) = 5;
			*(ref struct3 + 13) = 138;
			*(ref struct3 + 14) = 187;
			*(ref struct3 + 15) = 127;
			Struct28 struct4 = 178;
			*(ref struct4 + 1) = 65;
			*(ref struct4 + 2) = 6;
			*(ref struct4 + 3) = 55;
			*(ref struct4 + 4) = 12;
			*(ref struct4 + 5) = 241;
			*(ref struct4 + 6) = 202;
			*(ref struct4 + 7) = 107;
			*(ref struct4 + 8) = 168;
			*(ref struct4 + 9) = 68;
			*(ref struct4 + 10) = 235;
			*(ref struct4 + 11) = 11;
			*(ref struct4 + 12) = 39;
			*(ref struct4 + 13) = 121;
			*(ref struct4 + 14) = 40;
			*(ref struct4 + 15) = 246;
			Struct28 struct5 = 36;
			*(ref struct5 + 1) = 213;
			*(ref struct5 + 2) = 165;
			*(ref struct5 + 3) = 239;
			*(ref struct5 + 4) = 251;
			*(ref struct5 + 5) = 64;
			*(ref struct5 + 6) = 87;
			*(ref struct5 + 7) = 131;
			*(ref struct5 + 8) = 252;
			*(ref struct5 + 9) = 60;
			*(ref struct5 + 10) = 35;
			*(ref struct5 + 11) = 73;
			*(ref struct5 + 12) = 167;
			*(ref struct5 + 13) = 178;
			*(ref struct5 + 14) = 185;
			*(ref struct5 + 15) = 12;
			Struct28 struct6 = 50;
			*(ref struct6 + 1) = 135;
			*(ref struct6 + 2) = 14;
			*(ref struct6 + 3) = 221;
			*(ref struct6 + 4) = 144;
			*(ref struct6 + 5) = 47;
			*(ref struct6 + 6) = 221;
			*(ref struct6 + 7) = 3;
			*(ref struct6 + 8) = 226;
			*(ref struct6 + 9) = 142;
			*(ref struct6 + 10) = 17;
			*(ref struct6 + 11) = 138;
			*(ref struct6 + 12) = 183;
			*(ref struct6 + 13) = 75;
			*(ref struct6 + 14) = 133;
			*(ref struct6 + 15) = 251;
			Struct28 struct7 = 235;
			*(ref struct7 + 1) = 178;
			*(ref struct7 + 2) = 137;
			*(ref struct7 + 3) = 94;
			*(ref struct7 + 4) = 135;
			*(ref struct7 + 5) = 147;
			*(ref struct7 + 6) = 66;
			*(ref struct7 + 7) = 83;
			*(ref struct7 + 8) = 29;
			*(ref struct7 + 9) = 21;
			*(ref struct7 + 10) = 165;
			*(ref struct7 + 11) = 55;
			*(ref struct7 + 12) = 127;
			*(ref struct7 + 13) = 212;
			*(ref struct7 + 14) = 104;
			*(ref struct7 + 15) = 80;
			Struct28 struct8 = 83;
			*(ref struct8 + 1) = 214;
			*(ref struct8 + 2) = 249;
			*(ref struct8 + 3) = 171;
			*(ref struct8 + 4) = 241;
			*(ref struct8 + 5) = 114;
			*(ref struct8 + 6) = 63;
			*(ref struct8 + 7) = 51;
			*(ref struct8 + 8) = 64;
			*(ref struct8 + 9) = 125;
			*(ref struct8 + 10) = 176;
			*(ref struct8 + 11) = 211;
			*(ref struct8 + 12) = 170;
			*(ref struct8 + 13) = 11;
			*(ref struct8 + 14) = 5;
			*(ref struct8 + 15) = 49;
			Struct28 struct9 = 75;
			*(ref struct9 + 1) = 62;
			*(ref struct9 + 2) = 39;
			*(ref struct9 + 3) = 96;
			*(ref struct9 + 4) = 125;
			*(ref struct9 + 5) = 197;
			*(ref struct9 + 6) = 254;
			*(ref struct9 + 7) = 90;
			*(ref struct9 + 8) = 149;
			*(ref struct9 + 9) = 145;
			*(ref struct9 + 10) = 107;
			*(ref struct9 + 11) = 238;
			*(ref struct9 + 12) = 41;
			*(ref struct9 + 13) = 226;
			*(ref struct9 + 14) = 110;
			*(ref struct9 + 15) = 123;
			Struct28 struct10 = 229;
			*(ref struct10 + 1) = 122;
			*(ref struct10 + 2) = 224;
			*(ref struct10 + 3) = 171;
			*(ref struct10 + 4) = 193;
			*(ref struct10 + 5) = 43;
			*(ref struct10 + 6) = 7;
			*(ref struct10 + 7) = 212;
			*(ref struct10 + 8) = 136;
			*(ref struct10 + 9) = 184;
			*(ref struct10 + 10) = 101;
			*(ref struct10 + 11) = 76;
			*(ref struct10 + 12) = 154;
			*(ref struct10 + 13) = 21;
			*(ref struct10 + 14) = 175;
			*(ref struct10 + 15) = 152;
			Struct28 struct11 = 2;
			*(ref struct11 + 1) = 178;
			*(ref struct11 + 2) = 203;
			*(ref struct11 + 3) = 235;
			*(ref struct11 + 4) = 45;
			*(ref struct11 + 5) = 39;
			*(ref struct11 + 6) = 191;
			*(ref struct11 + 7) = 244;
			*(ref struct11 + 8) = 48;
			*(ref struct11 + 9) = 157;
			*(ref struct11 + 10) = 1;
			*(ref struct11 + 11) = 109;
			*(ref struct11 + 12) = 157;
			*(ref struct11 + 13) = 140;
			*(ref struct11 + 14) = 205;
			*(ref struct11 + 15) = 55;
			Struct28 struct12 = 92;
			*(ref struct12 + 1) = 0;
			*(ref struct12 + 2) = 69;
			*(ref struct12 + 3) = 25;
			*(ref struct12 + 4) = 167;
			*(ref struct12 + 5) = 129;
			*(ref struct12 + 6) = 184;
			*(ref struct12 + 7) = 182;
			*(ref struct12 + 8) = 93;
			*(ref struct12 + 9) = 126;
			*(ref struct12 + 10) = 202;
			*(ref struct12 + 11) = 161;
			*(ref struct12 + 12) = 8;
			*(ref struct12 + 13) = 217;
			*(ref struct12 + 14) = 157;
			*(ref struct12 + 15) = 233;
			Struct28 struct13 = 52;
			*(ref struct13 + 1) = 69;
			*(ref struct13 + 2) = 177;
			*(ref struct13 + 3) = 214;
			*(ref struct13 + 4) = 227;
			*(ref struct13 + 5) = 148;
			*(ref struct13 + 6) = 233;
			*(ref struct13 + 7) = 64;
			*(ref struct13 + 8) = 198;
			*(ref struct13 + 9) = 228;
			*(ref struct13 + 10) = 212;
			*(ref struct13 + 11) = 253;
			*(ref struct13 + 12) = 219;
			*(ref struct13 + 13) = 73;
			*(ref struct13 + 14) = 84;
			*(ref struct13 + 15) = 20;
			Struct28 struct14 = 173;
			*(ref struct14 + 1) = 93;
			*(ref struct14 + 2) = 213;
			*(ref struct14 + 3) = 175;
			*(ref struct14 + 4) = 36;
			*(ref struct14 + 5) = 62;
			*(ref struct14 + 6) = 179;
			*(ref struct14 + 7) = 178;
			*(ref struct14 + 8) = 139;
			*(ref struct14 + 9) = 110;
			*(ref struct14 + 10) = 252;
			*(ref struct14 + 11) = 111;
			*(ref struct14 + 12) = 210;
			*(ref struct14 + 13) = 75;
			*(ref struct14 + 14) = 191;
			*(ref struct14 + 15) = 112;
			Struct28 struct15 = 229;
			*(ref struct15 + 1) = 199;
			*(ref struct15 + 2) = 107;
			*(ref struct15 + 3) = 241;
			*(ref struct15 + 4) = 35;
			*(ref struct15 + 5) = 14;
			*(ref struct15 + 6) = 218;
			*(ref struct15 + 7) = 59;
			*(ref struct15 + 8) = 82;
			*(ref struct15 + 9) = 225;
			*(ref struct15 + 10) = 248;
			*(ref struct15 + 11) = 4;
			*(ref struct15 + 12) = 138;
			*(ref struct15 + 13) = 176;
			*(ref struct15 + 14) = 62;
			*(ref struct15 + 15) = 112;
			Struct28 struct16 = 195;
			*(ref struct16 + 1) = 149;
			*(ref struct16 + 2) = 97;
			*(ref struct16 + 3) = 101;
			*(ref struct16 + 4) = 48;
			*(ref struct16 + 5) = 144;
			*(ref struct16 + 6) = 153;
			*(ref struct16 + 7) = 252;
			*(ref struct16 + 8) = 145;
			*(ref struct16 + 9) = 83;
			*(ref struct16 + 10) = 39;
			*(ref struct16 + 11) = 204;
			*(ref struct16 + 12) = 227;
			*(ref struct16 + 13) = 129;
			*(ref struct16 + 14) = 240;
			*(ref struct16 + 15) = 107;
			Struct28 struct17 = 231;
			*(ref struct17 + 1) = 122;
			*(ref struct17 + 2) = 74;
			*(ref struct17 + 3) = 110;
			*(ref struct17 + 4) = 2;
			*(ref struct17 + 5) = 125;
			*(ref struct17 + 6) = 184;
			*(ref struct17 + 7) = 96;
			*(ref struct17 + 8) = 97;
			*(ref struct17 + 9) = 86;
			*(ref struct17 + 10) = 249;
			*(ref struct17 + 11) = 101;
			*(ref struct17 + 12) = 18;
			*(ref struct17 + 13) = 24;
			*(ref struct17 + 14) = 107;
			*(ref struct17 + 15) = 236;
			Struct28 struct18 = 26;
			*(ref struct18 + 1) = 194;
			*(ref struct18 + 2) = 56;
			*(ref struct18 + 3) = 208;
			*(ref struct18 + 4) = 231;
			*(ref struct18 + 5) = 48;
			*(ref struct18 + 6) = 102;
			*(ref struct18 + 7) = 115;
			*(ref struct18 + 8) = 147;
			*(ref struct18 + 9) = 121;
			*(ref struct18 + 10) = 237;
			*(ref struct18 + 11) = 217;
			*(ref struct18 + 12) = 109;
			*(ref struct18 + 13) = 141;
			*(ref struct18 + 14) = 64;
			*(ref struct18 + 15) = 46;
			Struct28 struct19 = 130;
			*(ref struct19 + 1) = 169;
			*(ref struct19 + 2) = 87;
			*(ref struct19 + 3) = 96;
			*(ref struct19 + 4) = 56;
			*(ref struct19 + 5) = 254;
			*(ref struct19 + 6) = 223;
			*(ref struct19 + 7) = 204;
			*(ref struct19 + 8) = 149;
			*(ref struct19 + 9) = 49;
			*(ref struct19 + 10) = 16;
			*(ref struct19 + 11) = 145;
			*(ref struct19 + 12) = 156;
			*(ref struct19 + 13) = 56;
			*(ref struct19 + 14) = 197;
			*(ref struct19 + 15) = 99;
			Struct28 struct20 = 234;
			*(ref struct20 + 1) = 75;
			*(ref struct20 + 2) = 126;
			*(ref struct20 + 3) = 134;
			*(ref struct20 + 4) = 13;
			*(ref struct20 + 5) = 199;
			*(ref struct20 + 6) = 205;
			*(ref struct20 + 7) = 69;
			*(ref struct20 + 8) = 98;
			*(ref struct20 + 9) = 27;
			*(ref struct20 + 10) = 97;
			*(ref struct20 + 11) = 234;
			*(ref struct20 + 12) = 28;
			*(ref struct20 + 13) = 138;
			*(ref struct20 + 14) = 129;
			*(ref struct20 + 15) = 3;
			Struct28 struct21 = 36;
			*(ref struct21 + 1) = 129;
			*(ref struct21 + 2) = 232;
			*(ref struct21 + 3) = 172;
			*(ref struct21 + 4) = 230;
			*(ref struct21 + 5) = 99;
			*(ref struct21 + 6) = 190;
			*(ref struct21 + 7) = 40;
			*(ref struct21 + 8) = 100;
			*(ref struct21 + 9) = 118;
			*(ref struct21 + 10) = 254;
			*(ref struct21 + 11) = 233;
			*(ref struct21 + 12) = 226;
			*(ref struct21 + 13) = 5;
			*(ref struct21 + 14) = 144;
			*(ref struct21 + 15) = 7;
			Struct28 struct22 = 64;
			*(ref struct22 + 1) = 116;
			*(ref struct22 + 2) = 220;
			*(ref struct22 + 3) = 208;
			*(ref struct22 + 4) = 84;
			*(ref struct22 + 5) = 22;
			*(ref struct22 + 6) = 95;
			*(ref struct22 + 7) = 210;
			*(ref struct22 + 8) = 63;
			*(ref struct22 + 9) = 201;
			*(ref struct22 + 10) = 208;
			*(ref struct22 + 11) = 33;
			*(ref struct22 + 12) = 129;
			*(ref struct22 + 13) = 190;
			*(ref struct22 + 14) = 153;
			*(ref struct22 + 15) = 53;
			Struct28 struct23 = 12;
			*(ref struct23 + 1) = 37;
			*(ref struct23 + 2) = 172;
			*(ref struct23 + 3) = 125;
			*(ref struct23 + 4) = 201;
			*(ref struct23 + 5) = 43;
			*(ref struct23 + 6) = 141;
			*(ref struct23 + 7) = 206;
			*(ref struct23 + 8) = 3;
			*(ref struct23 + 9) = 123;
			*(ref struct23 + 10) = 180;
			*(ref struct23 + 11) = 186;
			*(ref struct23 + 12) = 87;
			*(ref struct23 + 13) = 158;
			*(ref struct23 + 14) = 141;
			*(ref struct23 + 15) = 62;
			Struct28 struct24 = 239;
			*(ref struct24 + 1) = 38;
			*(ref struct24 + 2) = 68;
			*(ref struct24 + 3) = 173;
			*(ref struct24 + 4) = 46;
			*(ref struct24 + 5) = 160;
			*(ref struct24 + 6) = 197;
			*(ref struct24 + 7) = 217;
			*(ref struct24 + 8) = 54;
			*(ref struct24 + 9) = 174;
			*(ref struct24 + 10) = 13;
			*(ref struct24 + 11) = 174;
			*(ref struct24 + 12) = 201;
			*(ref struct24 + 13) = 203;
			*(ref struct24 + 14) = 23;
			*(ref struct24 + 15) = 143;
			Struct28 struct25 = 229;
			*(ref struct25 + 1) = 237;
			*(ref struct25 + 2) = 58;
			*(ref struct25 + 3) = 120;
			*(ref struct25 + 4) = 25;
			*(ref struct25 + 5) = 100;
			*(ref struct25 + 6) = 69;
			*(ref struct25 + 7) = 147;
			*(ref struct25 + 8) = 144;
			*(ref struct25 + 9) = 83;
			*(ref struct25 + 10) = 138;
			*(ref struct25 + 11) = 18;
			*(ref struct25 + 12) = 101;
			*(ref struct25 + 13) = 207;
			*(ref struct25 + 14) = 238;
			*(ref struct25 + 15) = 11;
			Struct28 struct26 = 197;
			*(ref struct26 + 1) = 202;
			*(ref struct26 + 2) = 102;
			*(ref struct26 + 3) = 58;
			*(ref struct26 + 4) = 174;
			*(ref struct26 + 5) = 1;
			*(ref struct26 + 6) = 96;
			*(ref struct26 + 7) = 167;
			*(ref struct26 + 8) = 57;
			*(ref struct26 + 9) = 182;
			*(ref struct26 + 10) = 239;
			*(ref struct26 + 11) = 239;
			*(ref struct26 + 12) = 27;
			*(ref struct26 + 13) = 168;
			*(ref struct26 + 14) = 143;
			*(ref struct26 + 15) = 202;
			Struct28 struct27 = 84;
			*(ref struct27 + 1) = 36;
			*(ref struct27 + 2) = 74;
			*(ref struct27 + 3) = 35;
			*(ref struct27 + 4) = 212;
			*(ref struct27 + 5) = 213;
			*(ref struct27 + 6) = 145;
			*(ref struct27 + 7) = 69;
			*(ref struct27 + 8) = 222;
			*(ref struct27 + 9) = 79;
			*(ref struct27 + 10) = 103;
			*(ref struct27 + 11) = 68;
			*(ref struct27 + 12) = 43;
			*(ref struct27 + 13) = 227;
			*(ref struct27 + 14) = 5;
			*(ref struct27 + 15) = 141;
			Struct28 struct28 = 86;
			*(ref struct28 + 1) = 44;
			*(ref struct28 + 2) = 199;
			*(ref struct28 + 3) = 238;
			*(ref struct28 + 4) = 98;
			*(ref struct28 + 5) = 227;
			*(ref struct28 + 6) = 25;
			*(ref struct28 + 7) = 133;
			*(ref struct28 + 8) = 98;
			*(ref struct28 + 9) = 179;
			*(ref struct28 + 10) = 71;
			*(ref struct28 + 11) = 81;
			*(ref struct28 + 12) = 47;
			*(ref struct28 + 13) = 101;
			*(ref struct28 + 14) = 242;
			*(ref struct28 + 15) = 39;
			Struct28 struct29 = 123;
			*(ref struct29 + 1) = 0;
			*(ref struct29 + 2) = 74;
			*(ref struct29 + 3) = 89;
			*(ref struct29 + 4) = 0;
			*(ref struct29 + 5) = 11;
			*(ref struct29 + 6) = 221;
			*(ref struct29 + 7) = 131;
			*(ref struct29 + 8) = 180;
			*(ref struct29 + 9) = 196;
			*(ref struct29 + 10) = 36;
			*(ref struct29 + 11) = 121;
			*(ref struct29 + 12) = 111;
			*(ref struct29 + 13) = 65;
			*(ref struct29 + 14) = 168;
			*(ref struct29 + 15) = 106;
			Struct28 struct30 = 158;
			*(ref struct30 + 1) = 124;
			*(ref struct30 + 2) = 239;
			*(ref struct30 + 3) = 181;
			*(ref struct30 + 4) = 247;
			*(ref struct30 + 5) = 242;
			*(ref struct30 + 6) = 162;
			*(ref struct30 + 7) = 36;
			*(ref struct30 + 8) = 240;
			*(ref struct30 + 9) = 220;
			*(ref struct30 + 10) = 10;
			*(ref struct30 + 11) = 40;
			*(ref struct30 + 12) = 57;
			*(ref struct30 + 13) = 85;
			*(ref struct30 + 14) = 231;
			*(ref struct30 + 15) = 228;
			Struct28 struct31 = 72;
			*(ref struct31 + 1) = 86;
			*(ref struct31 + 2) = 6;
			*(ref struct31 + 3) = 205;
			*(ref struct31 + 4) = 148;
			*(ref struct31 + 5) = 92;
			*(ref struct31 + 6) = 126;
			*(ref struct31 + 7) = 53;
			*(ref struct31 + 8) = 228;
			*(ref struct31 + 9) = 245;
			*(ref struct31 + 10) = 122;
			*(ref struct31 + 11) = 232;
			*(ref struct31 + 12) = 228;
			*(ref struct31 + 13) = 195;
			*(ref struct31 + 14) = 175;
			*(ref struct31 + 15) = 16;
			Struct28 struct32 = 24;
			*(ref struct32 + 1) = 75;
			*(ref struct32 + 2) = 102;
			*(ref struct32 + 3) = 215;
			*(ref struct32 + 4) = 233;
			*(ref struct32 + 5) = 244;
			*(ref struct32 + 6) = 199;
			*(ref struct32 + 7) = 163;
			*(ref struct32 + 8) = 59;
			*(ref struct32 + 9) = 48;
			*(ref struct32 + 10) = 40;
			*(ref struct32 + 11) = 178;
			*(ref struct32 + 12) = 71;
			*(ref struct32 + 13) = 115;
			*(ref struct32 + 14) = 214;
			*(ref struct32 + 15) = 54;
			Struct28 struct33 = 202;
			*(ref struct33 + 1) = 158;
			*(ref struct33 + 2) = 240;
			*(ref struct33 + 3) = 173;
			*(ref struct33 + 4) = 239;
			*(ref struct33 + 5) = 113;
			*(ref struct33 + 6) = 190;
			*(ref struct33 + 7) = 172;
			*(ref struct33 + 8) = 3;
			*(ref struct33 + 9) = 134;
			*(ref struct33 + 10) = 232;
			*(ref struct33 + 11) = 1;
			*(ref struct33 + 12) = 182;
			*(ref struct33 + 13) = 96;
			*(ref struct33 + 14) = 65;
			*(ref struct33 + 15) = 156;
			Struct28 struct34 = 73;
			*(ref struct34 + 1) = 183;
			*(ref struct34 + 2) = 194;
			*(ref struct34 + 3) = 34;
			*(ref struct34 + 4) = 8;
			*(ref struct34 + 5) = 131;
			*(ref struct34 + 6) = 14;
			*(ref struct34 + 7) = 85;
			*(ref struct34 + 8) = 143;
			*(ref struct34 + 9) = 114;
			*(ref struct34 + 10) = 15;
			*(ref struct34 + 11) = 209;
			*(ref struct34 + 12) = 70;
			*(ref struct34 + 13) = 187;
			*(ref struct34 + 14) = 54;
			*(ref struct34 + 15) = 147;
			Struct28 struct35 = 238;
			*(ref struct35 + 1) = 246;
			*(ref struct35 + 2) = 212;
			*(ref struct35 + 3) = 253;
			*(ref struct35 + 4) = 87;
			*(ref struct35 + 5) = 19;
			*(ref struct35 + 6) = 172;
			*(ref struct35 + 7) = 212;
			*(ref struct35 + 8) = 45;
			*(ref struct35 + 9) = 180;
			*(ref struct35 + 10) = 159;
			*(ref struct35 + 11) = 185;
			*(ref struct35 + 12) = 1;
			*(ref struct35 + 13) = 246;
			*(ref struct35 + 14) = 5;
			*(ref struct35 + 15) = 253;
			Struct43 struct36;
			<Module>.memcpy((void*)(&struct36), (void*)pByte_0, 256U);
			*(*(ref <Module>.struct121_0 + 7172) + 258048) = byte.MaxValue;
			*(*(ref <Module>.struct121_0 + 7172) + 258049) = byte.MaxValue;
			*(*(ref <Module>.struct121_0 + 7172) + 258050) = byte.MaxValue;
			*(*(ref <Module>.struct121_0 + 7172) + 258051) = byte.MaxValue;
			*(*(ref <Module>.struct121_0 + 7172) + 258052) = byte.MaxValue;
			*(*(ref <Module>.struct121_0 + 7172) + 258053) = byte.MaxValue;
			if (<Module>.memcmp((void*)(&struct36), (void*)(&@struct), 16U) == null)
			{
				*(*(ref <Module>.struct121_0 + 7172) + 258048) = byte.MaxValue;
				if (<Module>.memcmp(ref struct36 + 16, (void*)(&struct2), 16U) != null)
				{
					this.textBox6.AppendText("Unknown Hash 1" + "\r\n");
					return 0;
				}
				*(*(ref <Module>.struct121_0 + 7172) + 258049) = byte.MaxValue;
				if (<Module>.memcmp(ref struct36 + 32, (void*)(&struct3), 16U) != null)
				{
					this.textBox6.AppendText("Unknown Hash 2" + "\r\n");
					return 0;
				}
				*(*(ref <Module>.struct121_0 + 7172) + 258050) = byte.MaxValue;
				if (<Module>.memcmp(ref struct36 + 48, (void*)(&struct4), 16U) != null)
				{
					this.textBox6.AppendText("Unknown Hash 3" + "\r\n");
					return 0;
				}
				*(*(ref <Module>.struct121_0 + 7172) + 258051) = byte.MaxValue;
			}
			else if (<Module>.memcmp((void*)(&struct36), (void*)(&struct5), 16U) == null)
			{
				*(*(ref <Module>.struct121_0 + 7172) + 258048) = byte.MaxValue;
				*(*(ref <Module>.struct121_0 + 7172) + 126976) = 96;
				if (<Module>.memcmp(ref struct36 + 16, (void*)(&struct6), 16U) != null)
				{
					this.textBox6.AppendText("Unknown Hash 1" + "\r\n");
					return 0;
				}
				*(*(ref <Module>.struct121_0 + 7172) + 258049) = byte.MaxValue;
				if (<Module>.memcmp(ref struct36 + 32, (void*)(&struct7), 16U) != null)
				{
					this.textBox6.AppendText("Unknown Hash 2" + "\r\n");
					return 0;
				}
				*(*(ref <Module>.struct121_0 + 7172) + 258050) = byte.MaxValue;
				if (<Module>.memcmp(ref struct36 + 48, (void*)(&struct8), 16U) != null)
				{
					this.textBox6.AppendText("Unknown Hash 3" + "\r\n");
					return 0;
				}
				*(*(ref <Module>.struct121_0 + 7172) + 258051) = byte.MaxValue;
			}
			else if (<Module>.memcmp((void*)(&struct36), (void*)(&struct13), 16U) == null)
			{
				*(*(ref <Module>.struct121_0 + 7172) + 258048) = 187;
				if (<Module>.memcmp(ref struct36 + 16, (void*)(&struct14), 16U) != null)
				{
					this.textBox6.AppendText("Unknown Hash 1" + "\r\n");
					return 0;
				}
				*(*(ref <Module>.struct121_0 + 7172) + 258049) = 1;
				if (<Module>.memcmp(ref struct36 + 32, (void*)(&struct7), 16U) == null)
				{
					*(*(ref <Module>.struct121_0 + 7172) + 258050) = byte.MaxValue;
					if (<Module>.memcmp(ref struct36 + 48, (void*)(&struct8), 16U) != null)
					{
						this.textBox6.AppendText("Unknown Hash 3" + "\r\n");
						return 0;
					}
					*(*(ref <Module>.struct121_0 + 7172) + 258051) = byte.MaxValue;
				}
				else
				{
					if (<Module>.memcmp(ref struct36 + 32, (void*)(&struct15), 16U) != null)
					{
						this.textBox6.AppendText("Unknown Hash 2" + "\r\n");
						return 0;
					}
					*(*(ref <Module>.struct121_0 + 7172) + 258050) = 187;
					if (<Module>.memcmp(ref struct36 + 48, (void*)(&struct8), 16U) == null)
					{
						*(*(ref <Module>.struct121_0 + 7172) + 258051) = byte.MaxValue;
					}
					else if (<Module>.memcmp(ref struct36 + 48, (void*)(&struct16), 16U) == null)
					{
						*(*(ref <Module>.struct121_0 + 7172) + 258051) = 127;
					}
					else
					{
						if (<Module>.memcmp(ref struct36 + 48, (void*)(&struct17), 16U) != null)
						{
							this.textBox6.AppendText("Unknown Hash 3" + "\r\n");
							return 0;
						}
						*(*(ref <Module>.struct121_0 + 7172) + 258051) = 63;
					}
				}
			}
			else if (<Module>.memcmp((void*)(&struct36), (void*)(&struct22), 16U) == null)
			{
				*(*(ref <Module>.struct121_0 + 7172) + 258048) = 187;
				if (<Module>.memcmp(ref struct36 + 16, (void*)(&struct23), 16U) != null)
				{
					this.textBox6.AppendText("Unknown Hash 1" + "\r\n");
					return 0;
				}
				*(*(ref <Module>.struct121_0 + 7172) + 258049) = 1;
				if (<Module>.memcmp(ref struct36 + 32, (void*)(&struct24), 16U) == null)
				{
					*(*(ref <Module>.struct121_0 + 7172) + 258050) = byte.MaxValue;
					if (<Module>.memcmp(ref struct36 + 48, (void*)(&struct26), 16U) != null)
					{
						this.textBox6.AppendText("Unknown Hash 3" + "\r\n");
						return 0;
					}
					*(*(ref <Module>.struct121_0 + 7172) + 258051) = byte.MaxValue;
				}
				else
				{
					if (<Module>.memcmp(ref struct36 + 32, (void*)(&struct25), 16U) != null)
					{
						this.textBox6.AppendText("Unknown Hash 2" + "\r\n");
						return 0;
					}
					*(*(ref <Module>.struct121_0 + 7172) + 258050) = 187;
					if (<Module>.memcmp(ref struct36 + 48, (void*)(&struct26), 16U) == null)
					{
						*(*(ref <Module>.struct121_0 + 7172) + 258051) = byte.MaxValue;
					}
					else if (<Module>.memcmp(ref struct36 + 48, (void*)(&struct27), 16U) == null)
					{
						*(*(ref <Module>.struct121_0 + 7172) + 258051) = 63;
					}
					else
					{
						if (<Module>.memcmp(ref struct36 + 48, (void*)(&struct28), 16U) != null)
						{
							this.textBox6.AppendText("Unknown Hash 3" + "\r\n");
							return 0;
						}
						*(*(ref <Module>.struct121_0 + 7172) + 258051) = 127;
					}
				}
			}
			else if (<Module>.memcmp((void*)(&struct36), (void*)(&struct18), 16U) == null)
			{
				*(*(ref <Module>.struct121_0 + 7172) + 258048) = byte.MaxValue;
				if (<Module>.memcmp(ref struct36 + 16, (void*)(&struct19), 16U) != null)
				{
					this.textBox6.AppendText("Unknown Hash 1" + "\r\n");
					return 0;
				}
				*(*(ref <Module>.struct121_0 + 7172) + 258049) = byte.MaxValue;
				if (<Module>.memcmp(ref struct36 + 32, (void*)(&struct20), 16U) != null)
				{
					this.textBox6.AppendText("Unknown Hash 2" + "\r\n");
					return 0;
				}
				*(*(ref <Module>.struct121_0 + 7172) + 258050) = byte.MaxValue;
				if (<Module>.memcmp(ref struct36 + 48, (void*)(&struct21), 16U) != null)
				{
					this.textBox6.AppendText("Unknown Hash 3" + "\r\n");
					return 0;
				}
				*(*(ref <Module>.struct121_0 + 7172) + 258051) = byte.MaxValue;
			}
			else
			{
				if (<Module>.memcmp((void*)(&struct36), (void*)(&struct29), 16U) != null)
				{
					this.textBox6.AppendText("Unknown Hash 0" + "\r\n");
					return 0;
				}
				*(*(ref <Module>.struct121_0 + 7172) + 258048) = 187;
				if (<Module>.memcmp(ref struct36 + 16, (void*)(&struct30), 16U) != null)
				{
					this.textBox6.AppendText("Unknown Hash 1" + "\r\n");
					return 0;
				}
				*(*(ref <Module>.struct121_0 + 7172) + 258049) = 1;
				if (<Module>.memcmp(ref struct36 + 32, (void*)(&struct31), 16U) == null)
				{
					*(*(ref <Module>.struct121_0 + 7172) + 258050) = byte.MaxValue;
					if (<Module>.memcmp(ref struct36 + 48, (void*)(&struct33), 16U) != null)
					{
						this.textBox6.AppendText("Unknown Hash 3" + "\r\n");
						return 0;
					}
					*(*(ref <Module>.struct121_0 + 7172) + 258051) = byte.MaxValue;
				}
				else
				{
					if (<Module>.memcmp(ref struct36 + 32, (void*)(&struct32), 16U) != null)
					{
						this.textBox6.AppendText("Unknown Hash 2" + "\r\n");
						return 0;
					}
					*(*(ref <Module>.struct121_0 + 7172) + 258050) = 187;
					if (<Module>.memcmp(ref struct36 + 48, (void*)(&struct33), 16U) == null)
					{
						*(*(ref <Module>.struct121_0 + 7172) + 258051) = byte.MaxValue;
					}
					else if (<Module>.memcmp(ref struct36 + 48, (void*)(&struct34), 16U) == null)
					{
						*(*(ref <Module>.struct121_0 + 7172) + 258051) = 63;
					}
					else
					{
						if (<Module>.memcmp(ref struct36 + 48, (void*)(&struct35), 16U) != null)
						{
							this.textBox6.AppendText("Unknown Hash 3" + "\r\n");
							return 0;
						}
						*(*(ref <Module>.struct121_0 + 7172) + 258051) = 127;
					}
				}
			}
			this.textBox6.AppendText("\r\n");
			return 1;
		}

		// Token: 0x0600024A RID: 586 RVA: 0x00124858 File Offset: 0x00124858
		private void button38_Click(object sender, EventArgs e)
		{
			this.method_18();
			this.method_95();
			this.method_19();
		}

		// Token: 0x0600024B RID: 587 RVA: 0x00124878 File Offset: 0x00124878
		private unsafe void method_95()
		{
			this.label88.Text = "";
			this.label87.Text = "";
			Application.DoEvents();
			this.method_172();
			if (string.Compare(Convert.ToString(this.label72.Text), "No Drive Detected!") == 0)
			{
				this.textBox6.AppendText("\r\n" + "No Drive Detected! DVDkey files extraction aborted! " + "\r\n\r\n");
				<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
				MessageBox.Show("        No Drive Detected!" + "\n" + "PhatKey extraction aborted! ", "PhatKey", MessageBoxButtons.OK, MessageBoxIcon.Hand);
				<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
				this.label88.Text = " ";
				this.label87.Text = " ";
			}
			else if (string.Compare(Convert.ToString(this.label72.Text), "Drive in Vendor Mode!") == 0)
			{
				this.textBox6.AppendText("\r\n" + "Drive in Vendor Mode! DVDkey files extraction aborted! " + "\r\n\r\n");
				<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
				MessageBox.Show("        Drive in Vendor Mode!" + "\n" + "PhatKey extraction aborted! ", "PhatKey", MessageBoxButtons.OK, MessageBoxIcon.Hand);
				<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
				this.label88.Text = " ";
				this.label87.Text = " ";
			}
			else if (this.method_96() == 0U)
			{
				<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
				MessageBox.Show("PhatKey failed!", "PhatKey", MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
				<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
				this.textBox6.AppendText("\r\n" + "PhatKey extraction failed!" + "\r\n\r\n");
				this.label88.Text = " ";
				this.label87.Text = " ";
			}
			else
			{
				if (this.checkBox8.CheckState == CheckState.Unchecked)
				{
					this.method_116();
				}
				if (this.method_63() == 0)
				{
					this.textBox6.AppendText("\r\n" + "PhatKey files extraction aborted! " + "\r\n\r\n");
					this.label88.Text = " ";
					this.label87.Text = " ";
				}
				else if (this.method_65() == 0)
				{
					this.textBox6.AppendText("\r\n" + "PhatKey files extraction aborted! " + "\r\n\r\n");
					this.label88.Text = " ";
					this.label87.Text = " ";
				}
				else if (this.method_66() == 0)
				{
					this.textBox6.AppendText("\r\n" + "PhatKey files extraction aborted! " + "\r\n\r\n");
					this.label88.Text = " ";
					this.label87.Text = " ";
				}
				else if (this.method_67() == 0)
				{
					this.textBox6.AppendText("\r\n" + "PhatKey files extraction aborted! " + "\r\n\r\n");
					this.label88.Text = " ";
					this.label87.Text = " ";
				}
				else
				{
					this.method_117();
					this.Cursor = Cursors.Arrow;
					if (this.bool_2 && this.method_107(*(ref <Module>.struct123_0 + 4) + 280) == 1)
					{
						this.tabControl5.SelectedTab = this.Benq;
						this.pictureBox5.Visible = true;
						this.pictureBox7.Visible = false;
						this.pictureBox2.Visible = true;
						this.pictureBox6.Visible = false;
						this.label133.Text = "Verified";
						this.label131.Text = "Verified";
						this.textBox6.AppendText("Target Key verified, thanks C4eva !" + "\r\n" + "Proceeding with LO-Erase" + "\r\n");
						this.method_14();
						this.method_207();
						this.method_15();
					}
				}
			}
		}

		// Token: 0x0600024C RID: 588 RVA: 0x00124CB4 File Offset: 0x00124CB4
		private unsafe uint method_96()
		{
			Struct28 @struct = 0;
			initblk(ref @struct + 1, 0, 15);
			Struct43 struct2 = 0;
			initblk(ref struct2 + 1, 0, 255);
			Struct55 struct3 = 80;
			*(ref struct3 + 1) = 104;
			*(ref struct3 + 2) = 97;
			*(ref struct3 + 3) = 116;
			*(ref struct3 + 4) = 75;
			*(ref struct3 + 5) = 101;
			*(ref struct3 + 6) = 121;
			*(ref struct3 + 7) = 32;
			*(ref struct3 + 8) = 69;
			*(ref struct3 + 9) = 120;
			*(ref struct3 + 10) = 116;
			*(ref struct3 + 11) = 114;
			*(ref struct3 + 12) = 97;
			*(ref struct3 + 13) = 99;
			*(ref struct3 + 14) = 116;
			*(ref struct3 + 15) = 32;
			*(ref struct3 + 16) = 0;
			*(ref struct3 + 17) = 0;
			*(ref struct3 + 18) = 0;
			*(ref struct3 + 19) = 0;
			*(ref struct3 + 20) = 0;
			*(ref struct3 + 21) = 0;
			*(ref struct3 + 22) = 0;
			*(ref struct3 + 23) = 0;
			*(ref struct3 + 24) = 0;
			*(ref struct3 + 25) = 0;
			*(ref struct3 + 26) = 0;
			*(ref struct3 + 27) = 0;
			*(ref struct3 + 28) = 0;
			*(ref struct3 + 29) = 0;
			*(ref struct3 + 30) = 0;
			*(ref struct3 + 31) = 0;
			uint result;
			if (this.comboBox1.Items.Count == 0)
			{
				result = 0U;
			}
			else
			{
				uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
				byte byte_ = *(ref <Module>.struct38_0 + selectedIndex * 72U + 4);
				ushort num = *(ref <Module>.struct38_0 + selectedIndex * 72U);
				<Module>.smethod_2(num + 6, byte_);
				<Module>.Sleep(250);
				if (this.method_203() == 0)
				{
					result = 0U;
				}
				else
				{
					if (num == 0)
					{
						this.method_268(82, (byte*)(&struct2));
					}
					else
					{
						for (int i = 0; i < 256; i++)
						{
							<Module>.smethod_2(num + 6, byte_);
							<Module>.smethod_2(num + 2, 0);
							<Module>.smethod_2(num + 3, 42);
							<Module>.smethod_2(num + 4, (byte)i);
							<Module>.smethod_2(num + 5, 0);
							<Module>.Sleep(1);
							<Module>.smethod_2(num + 7, 0);
							<Module>.Sleep(2);
							<Module>.smethod_2(num + 6, byte_);
							*(ref struct2 + i) = <Module>.smethod_1(num + 3);
							<Module>.Sleep(1);
						}
					}
					<Module>.memcpy((void*)(&@struct), ref struct2 + 97, 16U);
					if (this.method_130() == 1)
					{
						<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
						MessageBox.Show("Extract complete !\r\n\r\n" + "CK3i has powered off your drive." + "Before you continue, remove Probe 3... then press OK" + "\r\n" + "... CK3i will power on your the drive.  ", "PhatKey", MessageBoxButtons.OK, MessageBoxIcon.Asterisk);
						<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
						this.method_129();
						for (int i = 0; i < 8; i++)
						{
							<Module>.Sleep(250);
							this.textBox6.AppendText(".");
						}
					}
					else
					{
						<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
						MessageBox.Show("Extract complete !\r\n\r\n" + "To continue, you must:\r\n" + "Ensure probe is removed.. Power Off Drive... Wait 5 seconds..." + "\r\n" + "Power On...  then press OK", "PhatKey", MessageBoxButtons.OK, MessageBoxIcon.Asterisk);
						<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
					}
					if (this.method_107((byte*)(&@struct)) != 1)
					{
						<Module>.memcpy((void*)(&@struct), ref struct2 + 98, 16U);
						if (this.method_107((byte*)(&@struct)) != 1)
						{
							this.textBox6.AppendText("\r\n" + "Extracted drive key failed Verification !" + "\r\n\r\n");
							this.Cursor = Cursors.Arrow;
							this.label87.Text = "";
							this.label88.Text = "bad";
							return 0U;
						}
					}
					this.textBox6.AppendText("\r\n" + "Extracted drive key passed Verification !" + "\r\n\r\n");
					this.method_6((byte*)(&@struct), 16U, 0U);
					this.textBox6.AppendText("key returned: " + this.string_0 + "\r\n");
					this.label87.Text = this.string_0;
					this.label88.Text = "Good";
					<Module>.memcpy(*(ref <Module>.struct123_0 + 8) + 280, (void*)(&@struct), 16U);
					<Module>.memcpy(*(ref <Module>.struct123_0 + 8) + 2348, (void*)(&struct3), 32U);
					Application.DoEvents();
					result = 1U;
				}
			}
			return result;
		}

		// Token: 0x0600024D RID: 589 RVA: 0x001250C8 File Offset: 0x001250C8
		private void button39_Click(object sender, EventArgs e)
		{
			this.method_18();
			this.method_97();
			this.method_19();
		}

		// Token: 0x0600024E RID: 590 RVA: 0x001250E8 File Offset: 0x001250E8
		private unsafe void method_97()
		{
			this.label88.Text = "";
			this.label87.Text = "";
			Application.DoEvents();
			this.method_172();
			if (string.Compare(Convert.ToString(this.label72.Text), "No Drive Detected!") == 0)
			{
				this.textBox6.AppendText("\r\n" + "No Drive Detected! DVDkey files extraction aborted! " + "\r\n\r\n");
				<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
				MessageBox.Show("        No Drive Detected!" + "\n" + "SlimKey extraction aborted! ", "SlimKey", MessageBoxButtons.OK, MessageBoxIcon.Hand);
				<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
				this.label88.Text = " ";
				this.label87.Text = " ";
			}
			else if (string.Compare(Convert.ToString(this.label72.Text), "Drive in Vendor Mode!") == 0)
			{
				this.textBox6.AppendText("\r\n" + "Drive in Vendor Mode! DVDkey files extraction aborted! " + "\r\n\r\n");
				<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
				MessageBox.Show("        Drive in Vendor Mode!" + "\n" + "SlimKey extraction aborted! ", "SlimKey", MessageBoxButtons.OK, MessageBoxIcon.Hand);
				<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
				this.label88.Text = " ";
				this.label87.Text = " ";
			}
			else if (this.method_70() == 0)
			{
				<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
				MessageBox.Show("SlimKey failed!", "SlimKey", MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
				<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
				this.textBox6.AppendText("\r\n" + "SlimKey extraction failed!" + "\r\n\r\n");
				this.label88.Text = " ";
				this.label87.Text = " ";
			}
			else
			{
				if (this.checkBox8.CheckState == CheckState.Unchecked)
				{
					this.method_116();
				}
				if (this.method_64() == 0)
				{
					this.textBox6.AppendText("\r\n" + "SlimKey files extraction aborted! " + "\r\n\r\n");
					this.label88.Text = " ";
					this.label87.Text = " ";
				}
				else if (this.method_66() == 0)
				{
					this.textBox6.AppendText("\r\n" + "SlimKey files extraction aborted! " + "\r\n\r\n");
					this.label88.Text = " ";
					this.label87.Text = " ";
				}
				else
				{
					this.method_68();
					this.textBox6.AppendText(string.Concat("Hashing Drive: "));
					Struct43 @struct;
					for (int i = 0; i < 16; i++)
					{
						if (this.method_93(35, 16, (byte)i, ref @struct + i * 16) != 1)
						{
							this.textBox6.AppendText("x");
							break;
						}
						this.textBox6.AppendText(".");
					}
					this.method_94((byte*)(&@struct));
					if (*(*(ref <Module>.struct121_0 + 7172) + 126976) == 96 && *(ref <Module>.struct121_0 + 6815) == 54)
					{
						*(*(ref <Module>.struct121_0 + 7172) + 126976) = 125;
					}
					this.method_118();
					this.Cursor = Cursors.Arrow;
				}
			}
		}

		// Token: 0x0600024F RID: 591 RVA: 0x0012547C File Offset: 0x0012547C
		private void menuItem_14_Click(object sender, EventArgs e)
		{
			RegistryKey registryKey = Registry.CurrentUser.CreateSubKey("JungleFlasher");
			registryKey.SetValue("Delay32", "0");
			registryKey.Close();
			this.menuItem_14.Enabled = false;
			this.menuItem_15.Enabled = true;
			this.menuItem_16.Enabled = true;
			this.menuItem_17.Enabled = true;
			this.menuItem_18.Enabled = true;
		}

		// Token: 0x06000250 RID: 592 RVA: 0x001254F0 File Offset: 0x001254F0
		private void menuItem_15_Click(object sender, EventArgs e)
		{
			RegistryKey registryKey = Registry.CurrentUser.CreateSubKey("JungleFlasher");
			registryKey.SetValue("Delay32", "5");
			registryKey.Close();
			this.menuItem_14.Enabled = true;
			this.menuItem_15.Enabled = false;
			this.menuItem_16.Enabled = true;
			this.menuItem_17.Enabled = true;
			this.menuItem_18.Enabled = true;
		}

		// Token: 0x06000251 RID: 593 RVA: 0x00125564 File Offset: 0x00125564
		private void menuItem_16_Click(object sender, EventArgs e)
		{
			RegistryKey registryKey = Registry.CurrentUser.CreateSubKey("JungleFlasher");
			registryKey.SetValue("Delay32", "10");
			registryKey.Close();
			this.menuItem_14.Enabled = true;
			this.menuItem_15.Enabled = true;
			this.menuItem_16.Enabled = false;
			this.menuItem_17.Enabled = true;
			this.menuItem_18.Enabled = true;
		}

		// Token: 0x06000252 RID: 594 RVA: 0x001255D8 File Offset: 0x001255D8
		private void menuItem_17_Click(object sender, EventArgs e)
		{
			RegistryKey registryKey = Registry.CurrentUser.CreateSubKey("JungleFlasher");
			registryKey.SetValue("Delay32", "15");
			registryKey.Close();
			this.menuItem_14.Enabled = true;
			this.menuItem_15.Enabled = true;
			this.menuItem_16.Enabled = true;
			this.menuItem_17.Enabled = false;
			this.menuItem_18.Enabled = true;
		}

		// Token: 0x06000253 RID: 595 RVA: 0x0012564C File Offset: 0x0012564C
		private void menuItem_18_Click(object sender, EventArgs e)
		{
			RegistryKey registryKey = Registry.CurrentUser.CreateSubKey("JungleFlasher");
			registryKey.SetValue("Delay32", "20");
			registryKey.Close();
			this.menuItem_14.Enabled = true;
			this.menuItem_15.Enabled = true;
			this.menuItem_16.Enabled = true;
			this.menuItem_17.Enabled = true;
			this.menuItem_18.Enabled = false;
		}

		// Token: 0x06000254 RID: 596 RVA: 0x001256C0 File Offset: 0x001256C0
		private void button28_Click(object sender, EventArgs e)
		{
			this.method_18();
			this.method_98();
			this.method_19();
		}

		// Token: 0x06000255 RID: 597 RVA: 0x001256E0 File Offset: 0x001256E0
		private unsafe void method_98()
		{
			this.label88.Text = "";
			this.label87.Text = "";
			Application.DoEvents();
			this.method_172();
			if (string.Compare(Convert.ToString(this.label72.Text), "No Drive Detected!") == 0)
			{
				this.textBox6.AppendText("\r\n" + "No Drive Detected! DVDkey files extraction aborted! " + "\r\n\r\n");
				<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
				MessageBox.Show("        No Drive Detected!" + "\n" + "DVDkey files extraction aborted! ", "Dummy from iXtreme", MessageBoxButtons.OK, MessageBoxIcon.Hand);
				<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
				this.label88.Text = " ";
				this.label87.Text = " ";
			}
			else if (string.Compare(Convert.ToString(this.label72.Text), "Drive in Vendor Mode!") == 0)
			{
				this.textBox6.AppendText("\r\n" + "Drive in Vendor Mode! DVDkey files extraction aborted! " + "\r\n\r\n");
				<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
				MessageBox.Show("        Drive in Vendor Mode!" + "\n" + "DVDkey files extraction aborted! ", "Dummy from iXtreme", MessageBoxButtons.OK, MessageBoxIcon.Hand);
				<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
				this.label88.Text = " ";
				this.label87.Text = " ";
			}
			else if (this.method_99() == 0)
			{
				<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
				MessageBox.Show("iXtreme DVDkey extraction failed!" + "\n" + "Power drive with tray half open. ", "Dummy from iXtreme", MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
				<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
				this.textBox6.AppendText("\r\n" + "iXtreme DVDkey extraction failed!" + "\r\n\r\n");
				this.label88.Text = " ";
				this.label87.Text = " ";
			}
			else
			{
				if (this.checkBox8.CheckState == CheckState.Unchecked)
				{
					this.method_116();
				}
				if (this.method_63() == 0)
				{
					this.textBox6.AppendText("\r\n" + "DVDkey files extraction aborted! " + "\r\n\r\n");
					this.label88.Text = " ";
					this.label87.Text = " ";
				}
				else if (this.method_65() == 0)
				{
					this.textBox6.AppendText("\r\n" + "DVDkey files extraction aborted! " + "\r\n\r\n");
					this.label88.Text = " ";
					this.label87.Text = " ";
				}
				else if (this.method_66() == 0)
				{
					this.textBox6.AppendText("\r\n" + "DVDkey files extraction aborted! " + "\r\n\r\n");
					this.label88.Text = " ";
					this.label87.Text = " ";
				}
				else if (this.method_67() == 0)
				{
					this.textBox6.AppendText("\r\n" + "DVDkey files extraction aborted! " + "\r\n\r\n");
					this.label88.Text = " ";
					this.label87.Text = " ";
				}
				else
				{
					this.method_117();
					if (this.bool_2 && this.method_107(*(ref <Module>.struct123_0 + 4) + 280) == 1)
					{
						this.tabControl5.SelectedTab = this.Benq;
						this.pictureBox5.Visible = true;
						this.pictureBox7.Visible = false;
						this.pictureBox2.Visible = true;
						this.pictureBox6.Visible = false;
						this.label133.Text = "Verified";
						this.label131.Text = "Verified";
						this.textBox6.AppendText("Target Key verified, thanks C4eva !" + "\r\n" + "Proceeding with LO-Erase" + "\r\n");
						this.method_14();
						this.method_207();
						this.method_15();
					}
				}
			}
		}

		// Token: 0x06000256 RID: 598 RVA: 0x00125B20 File Offset: 0x00125B20
		private unsafe int method_99()
		{
			int result;
			if (this.comboBox1.Items.Count == 0)
			{
				result = 0;
			}
			else
			{
				uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
				uint num = (uint)(*(ref <Module>.struct38_0 + selectedIndex * 72U + 4));
				ushort ushort_ = *(ref <Module>.struct38_0 + selectedIndex * 72U);
				int selectedIndex2 = this.comboBox10.SelectedIndex;
				if (this.method_128() == 1)
				{
					<Module>.Sleep(500);
				}
				if (*(ref <Module>.struct38_0 + selectedIndex * 72U + 4) == 160)
				{
					num = 0U;
				}
				else
				{
					num = 16U;
				}
				GStruct3 gstruct;
				<Module>.smethod_21(&gstruct, ushort_, 0, 1, 10000U);
				this.textBox6.AppendText("Sending iXtreme DVDkey request to port " + this.label123.Text + "\r\n");
				Struct52 @struct;
				<Module>.memset((void*)(&@struct), 0, 12U);
				@struct = 18;
				*(ref @struct + 4) = 36;
				*(ref @struct + 9) = 73;
				*(ref @struct + 10) = 88;
				*(ref @struct + 11) = 1;
				Struct34 struct2;
				uint num2;
				if (<Module>.smethod_16((byte*)(&@struct), 12U, (byte)num, 512, (void*)(&struct2), &num2, 48U, 1, &gstruct) != null)
				{
					result = 0;
				}
				else if (struct2 == 5 && *(ref struct2 + 1) == 128 && *(ref struct2 + 2) == 0 && *(ref struct2 + 3) == 50)
				{
					result = 0;
				}
				else
				{
					<Module>.memcpy(*(ref <Module>.struct123_0 + 8) + 280, (void*)(&struct2), 16U);
					<Module>.memset(*(ref <Module>.struct123_0 + 8) + 2348, 0, 32U);
					<Module>.memcpy(*(ref <Module>.struct123_0 + 8) + 2348, ref struct2 + 16, 18U);
					this.method_6((byte*)(&struct2), 16U, 0U);
					this.label88.Text = "Good";
					this.label87.Text = this.string_0;
					this.textBox6.AppendText("\r\n" + "Extracted drive key " + this.string_0 + "\r\n\r\n");
					this.method_9(ref struct2 + 16, 18U);
					this.textBox6.AppendText(this.string_0 + "\r\n\r\n");
					result = 1;
				}
			}
			return result;
		}

		// Token: 0x06000257 RID: 599 RVA: 0x00125D18 File Offset: 0x00125D18
		private void method_100()
		{
			this.label88.Text = "";
			this.label87.Text = "";
			Application.DoEvents();
			this.method_172();
			if (string.Compare(Convert.ToString(this.label72.Text), "No Drive Detected!") == 0)
			{
				this.textBox6.AppendText("\r\n" + "No Drive Detected! DVDkey files extraction aborted! " + "\r\n\r\n");
				<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
				MessageBox.Show("        No Drive Detected!" + "\n" + "DVDkey files extraction aborted! ", "Dummy from iXtreme", MessageBoxButtons.OK, MessageBoxIcon.Hand);
				<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
				this.label88.Text = " ";
				this.label87.Text = " ";
			}
			else if (string.Compare(Convert.ToString(this.label72.Text), "Drive in Vendor Mode!") == 0)
			{
				this.textBox6.AppendText("\r\n" + "Drive in Vendor Mode! DVDkey files extraction aborted! " + "\r\n\r\n");
				<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
				MessageBox.Show("        Drive in Vendor Mode!" + "\n" + "DVDkey files extraction aborted! ", "Dummy from iXtreme", MessageBoxButtons.OK, MessageBoxIcon.Hand);
				<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
				this.label88.Text = " ";
				this.label87.Text = " ";
			}
			else if (this.method_63() == 0)
			{
				this.textBox6.AppendText("\r\n" + "DVDkey files extraction aborted! " + "\r\n\r\n");
				this.label88.Text = " ";
				this.label87.Text = " ";
			}
			else
			{
				this.method_65();
				if (this.method_66() == 0)
				{
					this.textBox6.AppendText("\r\n" + "DVDkey files extraction aborted! " + "\r\n\r\n");
					this.label88.Text = " ";
					this.label87.Text = " ";
				}
				else
				{
					this.method_67();
					this.method_117();
				}
			}
		}

		// Token: 0x06000258 RID: 600 RVA: 0x00125F5C File Offset: 0x00125F5C
		private void button1_Click(object sender, EventArgs e)
		{
			this.method_18();
			this.method_101();
			this.method_19();
		}

		// Token: 0x06000259 RID: 601 RVA: 0x00125F7C File Offset: 0x00125F7C
		private void button4_Click(object sender, EventArgs e)
		{
			this.method_18();
			this.method_119();
			this.method_19();
		}

		// Token: 0x0600025A RID: 602 RVA: 0x003C24C0 File Offset: 0x0030A4C0
		private unsafe void method_101()
		{
			this.label88.Text = "";
			this.label87.Text = "";
			Application.DoEvents();
			this.method_172();
			if (string.Compare(Convert.ToString(this.label72.Text), "No Drive Detected!") == 0)
			{
				this.textBox6.AppendText("\r\n" + "No Drive Detected! LO83info extraction aborted! " + "\r\n\r\n");
				<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
				MessageBox.Show("        No Drive Detected!" + "\n" + "LO83info extraction aborted! ", "LO83info", MessageBoxButtons.OK, MessageBoxIcon.Hand);
				<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
				this.label88.Text = " ";
				this.label87.Text = " ";
			}
			else if (string.Compare(Convert.ToString(this.label72.Text), "Drive in Vendor Mode!") == 0)
			{
				this.textBox6.AppendText("\r\n" + "Drive in Vendor Mode! LO83info extraction aborted! " + "\r\n\r\n");
				<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
				MessageBox.Show("        Drive in Vendor Mode!" + "\n" + "LO83info extraction aborted! ", "LO83info", MessageBoxButtons.OK, MessageBoxIcon.Hand);
				<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
				this.label88.Text = " ";
				this.label87.Text = " ";
			}
			else
			{
				this.method_65();
				if (<Module>.memcmp(*(ref <Module>.struct123_0 + 8) + 684, (void*)(&<Module>.struct29_17), 96U) == null)
				{
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					MessageBox.Show("Drive responds as Lite-On 83 version 2" + "\n\n" + "LO83info is only for Lite-On 83 version 1", "LO83info", MessageBoxButtons.OK, MessageBoxIcon.Hand);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
				}
				else if (<Module>.memcmp(*(ref <Module>.struct123_0 + 8) + 684, (void*)(&<Module>.struct29_32), 96U) == null)
				{
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					MessageBox.Show("LO83info is only for Lite-On 83 version 1" + "\n\n           " + "Drive is not Lite-On 83", "LO83info", MessageBoxButtons.OK, MessageBoxIcon.Hand);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
				}
				else
				{
					RegistryKey registryKey = Registry.CurrentUser.CreateSubKey("JungleFlasher");
					if (registryKey.GetValue("Nforce590") == null)
					{
						if (this.method_103() == 0)
						{
							this.textBox6.AppendText("\r\n" + "LO83info extraction Failed! " + "\r\n\r\n");
							this.label88.Text = " ";
							this.label87.Text = " ";
							return;
						}
					}
					else if (this.method_104() == 0)
					{
						this.textBox6.AppendText("\r\n" + "LO83info extraction Failed! " + "\r\n\r\n");
						this.label88.Text = " ";
						this.label87.Text = " ";
						return;
					}
					registryKey.Close();
					if (this.method_63() == 0)
					{
						this.textBox6.AppendText("\r\n" + "LO83info extraction aborted! " + "\r\n\r\n");
						this.label88.Text = " ";
						this.label87.Text = " ";
					}
					else if (this.method_65() == 0)
					{
						this.textBox6.AppendText("\r\n" + "LO83info extraction aborted! " + "\r\n\r\n");
						this.label88.Text = " ";
						this.label87.Text = " ";
					}
					else if (<Module>.memcmp(*(ref <Module>.struct123_0 + 8) + 600, (void*)(&<Module>.struct10_23), 6U) != null)
					{
						this.textBox6.AppendText("\r\n" + "LO83info extraction Failed! " + "\r\n\r\n");
					}
					else if (this.method_66() == 0)
					{
						this.textBox6.AppendText("\r\n" + "LO83info extraction Failed! " + "\r\n\r\n");
						this.label88.Text = " ";
						this.label87.Text = " ";
					}
					else if (this.method_67() == 0)
					{
						this.textBox6.AppendText("\r\n" + "LO83info extraction Failed! " + "\r\n\r\n");
						this.label88.Text = " ";
						this.label87.Text = " ";
					}
					else if (*(*(ref <Module>.struct123_0 + 8) + 625) != *(*(ref <Module>.struct123_0 + 8) + 2043))
					{
						this.textBox6.AppendText("\r\n" + "LO83info extraction Failed! " + "\r\n\r\n");
					}
					else if (this.method_105() == 0)
					{
						this.textBox6.AppendText("\r\n" + "LO83info extraction Failed! " + "\r\n\r\n");
					}
					else
					{
						if (this.checkBox8.CheckState == CheckState.Unchecked)
						{
							this.method_116();
						}
						this.method_117();
						if (this.bool_2 && this.method_107(*(ref <Module>.struct123_0 + 4) + 280) == 1)
						{
							this.tabControl5.SelectedTab = this.Benq;
							this.pictureBox5.Visible = true;
							this.pictureBox7.Visible = false;
							this.pictureBox2.Visible = true;
							this.pictureBox6.Visible = false;
							this.label133.Text = "Verified";
							this.label131.Text = "Verified";
							this.textBox6.AppendText("Target Key verified, thanks C4eva !" + "\r\n" + "Proceeding with LO-Erase" + "\r\n");
							this.method_14();
							this.method_207();
							this.method_15();
						}
					}
				}
			}
		}

		// Token: 0x0600025B RID: 603 RVA: 0x00126594 File Offset: 0x00126594
		private void button32_Click(object sender, EventArgs e)
		{
			this.method_18();
			this.method_102();
			this.method_19();
		}

		// Token: 0x0600025C RID: 604 RVA: 0x001265B4 File Offset: 0x001265B4
		private unsafe void method_102()
		{
			this.label88.Text = "";
			this.label87.Text = "";
			Application.DoEvents();
			int num = this.method_173();
			if (num == 2)
			{
				this.textBox6.AppendText("\r\n" + "Lite-On barcode found, key verified, thanks C4eva ! " + "\r\n");
			}
			else
			{
				if (num != 1)
				{
					return;
				}
				<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
				int num2 = (int)MessageBox.Show("Lite-On barcode not found in KeyDB !" + "\n" + "Do you wish to try all DB keys for a match." + "\n" + "This could take a while", "Dummy from KeyDB", MessageBoxButtons.YesNo, MessageBoxIcon.Question);
				<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
				if (num2 == 7)
				{
					return;
				}
				if (this.method_115() == 0)
				{
					return;
				}
				this.textBox6.AppendText("\r\n");
			}
			Struct28 @struct;
			for (int i = 0; i < 32; i += 2)
			{
				string s = this.string_14.Substring(i, 2);
				IntPtr intPtr = Marshal.StringToHGlobalAnsi(s);
				IntPtr value = intPtr;
				sbyte* pSbyte_ = (sbyte*)((void*)value);
				byte b;
				this.method_10((void*)(&b), pSbyte_, 2);
				*(ref @struct + i / 2) = b;
			}
			<Module>.memcpy(*(ref <Module>.struct123_0 + 8) + 280, (void*)(&@struct), 16U);
			if (this.method_183() != 0)
			{
				if (this.method_65() == 0)
				{
					this.textBox6.AppendText("\r\n" + "Dummy from KeyDB files extraction aborted! " + "\r\n\r\n");
					this.label88.Text = " ";
					this.label87.Text = " ";
				}
				else
				{
					if (this.checkBox8.CheckState == CheckState.Unchecked)
					{
						this.method_116();
					}
					if (this.method_63() == 0)
					{
						this.textBox6.AppendText("\r\n" + "Dummy from KeyDB files extraction aborted! " + "\r\n\r\n");
						this.label88.Text = " ";
						this.label87.Text = " ";
					}
					else if (this.method_66() == 0)
					{
						this.textBox6.AppendText("\r\n" + "Dummy from KeyDB files extraction aborted! " + "\r\n\r\n");
						this.label88.Text = " ";
						this.label87.Text = " ";
					}
					else if (this.method_67() == 0)
					{
						this.textBox6.AppendText("\r\n" + "Dummy from KeyDB files extraction aborted! " + "\r\n\r\n");
						this.label88.Text = " ";
						this.label87.Text = " ";
					}
					else
					{
						this.method_117();
						if (this.bool_2 && this.method_107(*(ref <Module>.struct123_0 + 4) + 280) == 1)
						{
							this.tabControl5.SelectedTab = this.Benq;
							this.pictureBox5.Visible = true;
							this.pictureBox7.Visible = false;
							this.pictureBox2.Visible = true;
							this.pictureBox6.Visible = false;
							this.label133.Text = "Verified";
							this.label131.Text = "Verified";
							this.textBox6.AppendText("Target Key verified, thanks C4eva !" + "\r\n" + "Proceeding with LO-Erase" + "\r\n");
							this.method_14();
							this.method_207();
							this.method_15();
						}
					}
				}
			}
		}

		// Token: 0x0600025D RID: 605 RVA: 0x003C2AB8 File Offset: 0x0030AAB8
		private unsafe int method_103()
		{
			Struct55 @struct = 76;
			*(ref @struct + 1) = 79;
			*(ref @struct + 2) = 56;
			*(ref @struct + 3) = 51;
			*(ref @struct + 4) = 105;
			*(ref @struct + 5) = 110;
			*(ref @struct + 6) = 102;
			*(ref @struct + 7) = 111;
			*(ref @struct + 8) = 32;
			*(ref @struct + 9) = 69;
			*(ref @struct + 10) = 120;
			*(ref @struct + 11) = 116;
			*(ref @struct + 12) = 114;
			*(ref @struct + 13) = 97;
			*(ref @struct + 14) = 99;
			*(ref @struct + 15) = 116;
			*(ref @struct + 16) = 0;
			*(ref @struct + 17) = 0;
			*(ref @struct + 18) = 0;
			*(ref @struct + 19) = 0;
			*(ref @struct + 20) = 0;
			*(ref @struct + 21) = 0;
			*(ref @struct + 22) = 0;
			*(ref @struct + 23) = 0;
			*(ref @struct + 24) = 0;
			*(ref @struct + 25) = 0;
			*(ref @struct + 26) = 0;
			*(ref @struct + 27) = 0;
			*(ref @struct + 28) = 0;
			*(ref @struct + 29) = 0;
			*(ref @struct + 30) = 0;
			*(ref @struct + 31) = 0;
			Struct52 struct2 = 168;
			*(ref struct2 + 1) = 0;
			*(ref struct2 + 2) = 0;
			*(ref struct2 + 3) = 0;
			*(ref struct2 + 4) = 0;
			*(ref struct2 + 5) = 0;
			*(ref struct2 + 6) = 0;
			*(ref struct2 + 7) = 0;
			*(ref struct2 + 8) = 0;
			*(ref struct2 + 9) = 0;
			*(ref struct2 + 10) = 0;
			*(ref struct2 + 11) = 0;
			int result;
			if (this.comboBox1.Items.Count == 0)
			{
				result = 0;
			}
			else
			{
				uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
				uint num = (uint)(*(ref <Module>.struct38_0 + selectedIndex * 72U + 4));
				ushort ushort_ = *(ref <Module>.struct38_0 + selectedIndex * 72U);
				int selectedIndex2 = this.comboBox10.SelectedIndex;
				Struct91 struct3 = 253;
				*(ref struct3 + 1) = 14;
				*(ref struct3 + 2) = 66;
				*(ref struct3 + 3) = 69;
				*(ref struct3 + 4) = 78;
				*(ref struct3 + 5) = 81;
				*(ref struct3 + 6) = 0;
				*(ref struct3 + 7) = 0;
				*(ref struct3 + 8) = 253;
				*(ref struct3 + 9) = 14;
				*(ref struct3 + 10) = 66;
				*(ref struct3 + 11) = 69;
				*(ref struct3 + 12) = 78;
				*(ref struct3 + 13) = 81;
				*(ref struct3 + 14) = 0;
				*(ref struct3 + 15) = 0;
				*(ref struct3 + 16) = 253;
				*(ref struct3 + 17) = 14;
				*(ref struct3 + 18) = 66;
				*(ref struct3 + 19) = 69;
				*(ref struct3 + 20) = 78;
				*(ref struct3 + 21) = 81;
				*(ref struct3 + 22) = 0;
				*(ref struct3 + 23) = 0;
				*(ref struct3 + 24) = 253;
				*(ref struct3 + 25) = 14;
				*(ref struct3 + 26) = 66;
				*(ref struct3 + 27) = 69;
				*(ref struct3 + 28) = 78;
				*(ref struct3 + 29) = 81;
				*(ref struct3 + 30) = 0;
				*(ref struct3 + 31) = 0;
				*(ref struct3 + 32) = 253;
				*(ref struct3 + 33) = 14;
				*(ref struct3 + 34) = 66;
				*(ref struct3 + 35) = 69;
				*(ref struct3 + 36) = 78;
				*(ref struct3 + 37) = 81;
				*(ref struct3 + 38) = 0;
				*(ref struct3 + 39) = 0;
				*(ref struct3 + 40) = 253;
				*(ref struct3 + 41) = 14;
				*(ref struct3 + 42) = 66;
				*(ref struct3 + 43) = 69;
				*(ref struct3 + 44) = 78;
				*(ref struct3 + 45) = 81;
				*(ref struct3 + 46) = 0;
				*(ref struct3 + 47) = 0;
				*(ref struct3 + 48) = 253;
				*(ref struct3 + 49) = 14;
				*(ref struct3 + 50) = 66;
				*(ref struct3 + 51) = 69;
				*(ref struct3 + 52) = 78;
				*(ref struct3 + 53) = 81;
				*(ref struct3 + 54) = 0;
				*(ref struct3 + 55) = 0;
				*(ref struct3 + 56) = 253;
				*(ref struct3 + 57) = 14;
				*(ref struct3 + 58) = 66;
				*(ref struct3 + 59) = 69;
				*(ref struct3 + 60) = 78;
				*(ref struct3 + 61) = 81;
				*(ref struct3 + 62) = 0;
				*(ref struct3 + 63) = 0;
				*(ref struct3 + 64) = 253;
				*(ref struct3 + 65) = 14;
				*(ref struct3 + 66) = 66;
				*(ref struct3 + 67) = 69;
				*(ref struct3 + 68) = 78;
				*(ref struct3 + 69) = 81;
				*(ref struct3 + 70) = 0;
				*(ref struct3 + 71) = 0;
				*(ref struct3 + 72) = 253;
				*(ref struct3 + 73) = 14;
				*(ref struct3 + 74) = 66;
				*(ref struct3 + 75) = 69;
				*(ref struct3 + 76) = 78;
				*(ref struct3 + 77) = 81;
				*(ref struct3 + 78) = 0;
				*(ref struct3 + 79) = 0;
				*(ref struct3 + 80) = 253;
				*(ref struct3 + 81) = 14;
				*(ref struct3 + 82) = 66;
				*(ref struct3 + 83) = 69;
				*(ref struct3 + 84) = 78;
				*(ref struct3 + 85) = 81;
				*(ref struct3 + 86) = 0;
				*(ref struct3 + 87) = 0;
				*(ref struct3 + 88) = 253;
				*(ref struct3 + 89) = 14;
				*(ref struct3 + 90) = 66;
				*(ref struct3 + 91) = 69;
				*(ref struct3 + 92) = 78;
				*(ref struct3 + 93) = 81;
				*(ref struct3 + 94) = 0;
				*(ref struct3 + 95) = 0;
				*(ref struct3 + 96) = 253;
				*(ref struct3 + 97) = 14;
				*(ref struct3 + 98) = 66;
				*(ref struct3 + 99) = 69;
				*(ref struct3 + 100) = 78;
				*(ref struct3 + 101) = 81;
				*(ref struct3 + 102) = 0;
				*(ref struct3 + 103) = 0;
				*(ref struct3 + 104) = 253;
				*(ref struct3 + 105) = 14;
				*(ref struct3 + 106) = 66;
				*(ref struct3 + 107) = 69;
				*(ref struct3 + 108) = 78;
				*(ref struct3 + 109) = 81;
				*(ref struct3 + 110) = 0;
				*(ref struct3 + 111) = 0;
				this.textBox6.AppendText("Sending LO83info request to I/O port " + this.label123.Text + "\r\n\r\n");
				this.label88.Text = " ";
				this.label87.Text = " ";
				this.Cursor = Cursors.WaitCursor;
				GStruct3 gstruct;
				<Module>.smethod_21(&gstruct, ushort_, 0, 1, 10000U);
				<Module>.smethod_2(*(ref gstruct + 14), (byte)num);
				<Module>.smethod_2(*(ref gstruct + 18), 8);
				while ((<Module>.smethod_0(*(ref gstruct + 16)) & 128) != null)
				{
				}
				if (this.method_128() == 1)
				{
					<Module>.Sleep(500);
				}
				else
				{
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					MessageBox.Show("Power on drive with tray half open.", "LO83info", MessageBoxButtons.OK, MessageBoxIcon.Asterisk);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
				}
				for (uint num2 = 0U; num2 < 768U; num2 += 1U)
				{
					if (gstruct == null)
					{
						this.method_424(9);
					}
					else
					{
						while ((<Module>.smethod_0(*(ref gstruct + 16)) & 128) != null)
						{
						}
						<Module>.smethod_2(*(ref gstruct + 14), (byte)num);
						while ((<Module>.smethod_0(*(ref gstruct + 16)) & 128) != null)
						{
						}
						<Module>.smethod_2(*(ref gstruct + 18), 160);
						while ((<Module>.smethod_0(*(ref gstruct + 16)) & 128) != null)
						{
						}
						<Module>.smethod_3(gstruct, 168);
						<Module>.smethod_3(gstruct, 0);
						<Module>.smethod_3(gstruct, 0);
						<Module>.smethod_3(gstruct, 0);
						<Module>.smethod_3(gstruct, 0);
						<Module>.smethod_3(gstruct, 0);
					}
					if (num2 % 64U == 0U)
					{
						this.textBox6.AppendText(".");
					}
					Application.DoEvents();
				}
				this.textBox6.AppendText("\r\n");
				if (this.method_127() == 1)
				{
					<Module>.Sleep(250);
					this.method_126();
					<Module>.Sleep(500);
				}
				else
				{
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					MessageBox.Show("Move drive tray to the full open position.", "LO83info", MessageBoxButtons.OK, MessageBoxIcon.Asterisk);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
				}
				Struct91 struct4;
				<Module>.memset((void*)(&struct4), 0, 112U);
				Struct91 struct5;
				<Module>.memset((void*)(&struct5), 0, 112U);
				uint num3;
				if (num == 160U)
				{
					num3 = 0U;
				}
				else
				{
					num3 = 16U;
				}
				for (uint num2 = 0U; num2 < 256U; num2 += 1U)
				{
					Struct52 struct6;
					<Module>.memset((void*)(&struct6), 0, 12U);
					struct6 = 253;
					*(ref struct6 + 1) = 14;
					*(ref struct6 + 2) = 66;
					*(ref struct6 + 3) = 69;
					*(ref struct6 + 4) = 78;
					*(ref struct6 + 5) = 81;
					uint num4;
					if (<Module>.smethod_16((byte*)(&struct6), 12U, (byte)num3, 512, (void*)(&struct4), &num4, 112U, 1, &gstruct) == null)
					{
						break;
					}
					if (num2 % 16U == 0U)
					{
						this.textBox6.AppendText(".");
					}
					Application.DoEvents();
				}
				this.method_5((byte*)(&struct4), 112U, 0U);
				this.textBox6.AppendText("\r\n" + this.string_0 + "\r\n");
				if (<Module>.memcmp((void*)(&struct4), (void*)(&struct5), 112U) == null)
				{
					this.Cursor = Cursors.Arrow;
					result = 0;
				}
				else if (<Module>.memcmp((void*)(&struct4), (void*)(&struct3), 112U) == null)
				{
					this.Cursor = Cursors.Arrow;
					result = 0;
				}
				else if (<Module>.memcmp((void*)(&struct4), (void*)(&struct5), 8U) == null)
				{
					this.Cursor = Cursors.Arrow;
					result = 0;
				}
				else
				{
					this.label88.Text = "";
					this.label87.Text = "";
					<Module>.memcpy(*(ref <Module>.struct123_0 + 8) + 964, (void*)(&struct4), 112U);
					<Module>.memcpy(*(ref <Module>.struct123_0 + 8) + 2348, (void*)(&@struct), 32U);
					result = 1;
				}
			}
			return result;
		}

		// Token: 0x0600025E RID: 606 RVA: 0x003C3384 File Offset: 0x0030B384
		private unsafe int method_104()
		{
			Struct55 @struct = 76;
			*(ref @struct + 1) = 79;
			*(ref @struct + 2) = 56;
			*(ref @struct + 3) = 51;
			*(ref @struct + 4) = 105;
			*(ref @struct + 5) = 110;
			*(ref @struct + 6) = 102;
			*(ref @struct + 7) = 111;
			*(ref @struct + 8) = 32;
			*(ref @struct + 9) = 69;
			*(ref @struct + 10) = 120;
			*(ref @struct + 11) = 116;
			*(ref @struct + 12) = 114;
			*(ref @struct + 13) = 97;
			*(ref @struct + 14) = 99;
			*(ref @struct + 15) = 116;
			*(ref @struct + 16) = 0;
			*(ref @struct + 17) = 0;
			*(ref @struct + 18) = 0;
			*(ref @struct + 19) = 0;
			*(ref @struct + 20) = 0;
			*(ref @struct + 21) = 0;
			*(ref @struct + 22) = 0;
			*(ref @struct + 23) = 0;
			*(ref @struct + 24) = 0;
			*(ref @struct + 25) = 0;
			*(ref @struct + 26) = 0;
			*(ref @struct + 27) = 0;
			*(ref @struct + 28) = 0;
			*(ref @struct + 29) = 0;
			*(ref @struct + 30) = 0;
			*(ref @struct + 31) = 0;
			int result;
			if (this.comboBox1.Items.Count == 0)
			{
				result = 0;
			}
			else
			{
				uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
				uint num = (uint)(*(ref <Module>.struct38_0 + selectedIndex * 72U + 4));
				ushort ushort_ = *(ref <Module>.struct38_0 + selectedIndex * 72U);
				int selectedIndex2 = this.comboBox10.SelectedIndex;
				Struct91 struct2 = 253;
				*(ref struct2 + 1) = 14;
				*(ref struct2 + 2) = 66;
				*(ref struct2 + 3) = 69;
				*(ref struct2 + 4) = 78;
				*(ref struct2 + 5) = 81;
				*(ref struct2 + 6) = 0;
				*(ref struct2 + 7) = 0;
				*(ref struct2 + 8) = 253;
				*(ref struct2 + 9) = 14;
				*(ref struct2 + 10) = 66;
				*(ref struct2 + 11) = 69;
				*(ref struct2 + 12) = 78;
				*(ref struct2 + 13) = 81;
				*(ref struct2 + 14) = 0;
				*(ref struct2 + 15) = 0;
				*(ref struct2 + 16) = 253;
				*(ref struct2 + 17) = 14;
				*(ref struct2 + 18) = 66;
				*(ref struct2 + 19) = 69;
				*(ref struct2 + 20) = 78;
				*(ref struct2 + 21) = 81;
				*(ref struct2 + 22) = 0;
				*(ref struct2 + 23) = 0;
				*(ref struct2 + 24) = 253;
				*(ref struct2 + 25) = 14;
				*(ref struct2 + 26) = 66;
				*(ref struct2 + 27) = 69;
				*(ref struct2 + 28) = 78;
				*(ref struct2 + 29) = 81;
				*(ref struct2 + 30) = 0;
				*(ref struct2 + 31) = 0;
				*(ref struct2 + 32) = 253;
				*(ref struct2 + 33) = 14;
				*(ref struct2 + 34) = 66;
				*(ref struct2 + 35) = 69;
				*(ref struct2 + 36) = 78;
				*(ref struct2 + 37) = 81;
				*(ref struct2 + 38) = 0;
				*(ref struct2 + 39) = 0;
				*(ref struct2 + 40) = 253;
				*(ref struct2 + 41) = 14;
				*(ref struct2 + 42) = 66;
				*(ref struct2 + 43) = 69;
				*(ref struct2 + 44) = 78;
				*(ref struct2 + 45) = 81;
				*(ref struct2 + 46) = 0;
				*(ref struct2 + 47) = 0;
				*(ref struct2 + 48) = 253;
				*(ref struct2 + 49) = 14;
				*(ref struct2 + 50) = 66;
				*(ref struct2 + 51) = 69;
				*(ref struct2 + 52) = 78;
				*(ref struct2 + 53) = 81;
				*(ref struct2 + 54) = 0;
				*(ref struct2 + 55) = 0;
				*(ref struct2 + 56) = 253;
				*(ref struct2 + 57) = 14;
				*(ref struct2 + 58) = 66;
				*(ref struct2 + 59) = 69;
				*(ref struct2 + 60) = 78;
				*(ref struct2 + 61) = 81;
				*(ref struct2 + 62) = 0;
				*(ref struct2 + 63) = 0;
				*(ref struct2 + 64) = 253;
				*(ref struct2 + 65) = 14;
				*(ref struct2 + 66) = 66;
				*(ref struct2 + 67) = 69;
				*(ref struct2 + 68) = 78;
				*(ref struct2 + 69) = 81;
				*(ref struct2 + 70) = 0;
				*(ref struct2 + 71) = 0;
				*(ref struct2 + 72) = 253;
				*(ref struct2 + 73) = 14;
				*(ref struct2 + 74) = 66;
				*(ref struct2 + 75) = 69;
				*(ref struct2 + 76) = 78;
				*(ref struct2 + 77) = 81;
				*(ref struct2 + 78) = 0;
				*(ref struct2 + 79) = 0;
				*(ref struct2 + 80) = 253;
				*(ref struct2 + 81) = 14;
				*(ref struct2 + 82) = 66;
				*(ref struct2 + 83) = 69;
				*(ref struct2 + 84) = 78;
				*(ref struct2 + 85) = 81;
				*(ref struct2 + 86) = 0;
				*(ref struct2 + 87) = 0;
				*(ref struct2 + 88) = 253;
				*(ref struct2 + 89) = 14;
				*(ref struct2 + 90) = 66;
				*(ref struct2 + 91) = 69;
				*(ref struct2 + 92) = 78;
				*(ref struct2 + 93) = 81;
				*(ref struct2 + 94) = 0;
				*(ref struct2 + 95) = 0;
				*(ref struct2 + 96) = 253;
				*(ref struct2 + 97) = 14;
				*(ref struct2 + 98) = 66;
				*(ref struct2 + 99) = 69;
				*(ref struct2 + 100) = 78;
				*(ref struct2 + 101) = 81;
				*(ref struct2 + 102) = 0;
				*(ref struct2 + 103) = 0;
				*(ref struct2 + 104) = 253;
				*(ref struct2 + 105) = 14;
				*(ref struct2 + 106) = 66;
				*(ref struct2 + 107) = 69;
				*(ref struct2 + 108) = 78;
				*(ref struct2 + 109) = 81;
				*(ref struct2 + 110) = 0;
				*(ref struct2 + 111) = 0;
				this.textBox6.AppendText("Sending LO83info request to I/O port " + this.label123.Text + "\r\n\r\n");
				this.label88.Text = " ";
				this.label87.Text = " ";
				this.Cursor = Cursors.WaitCursor;
				GStruct3 ushort_2;
				<Module>.smethod_21(&ushort_2, ushort_, 0, 1, 10000U);
				<Module>.smethod_2(*(ref ushort_2 + 14), (byte)num);
				<Module>.smethod_2(*(ref ushort_2 + 18), 8);
				while ((<Module>.smethod_0(*(ref ushort_2 + 16)) & 128) != null)
				{
				}
				if (this.method_128() == 1)
				{
					<Module>.Sleep(500);
				}
				else
				{
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					MessageBox.Show("Power on drive with tray half open.", "LO83info", MessageBoxButtons.OK, MessageBoxIcon.Asterisk);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
				}
				for (uint num2 = 0U; num2 < 768U; num2 += 1U)
				{
					while ((<Module>.smethod_0(*(ref ushort_2 + 16)) & 128) != null)
					{
					}
					<Module>.smethod_2(*(ref ushort_2 + 14), (byte)num);
					while ((<Module>.smethod_0(*(ref ushort_2 + 16)) & 128) != null)
					{
					}
					<Module>.smethod_2(*(ref ushort_2 + 18), 160);
					while ((<Module>.smethod_0(*(ref ushort_2 + 16)) & 128) != null)
					{
					}
					<Module>.smethod_3(ushort_2, 168);
					<Module>.smethod_3(ushort_2, 0);
					<Module>.smethod_3(ushort_2, 0);
					<Module>.smethod_3(ushort_2, 0);
					<Module>.smethod_3(ushort_2, 0);
					<Module>.smethod_3(ushort_2, 0);
					if (num2 % 64U == 0U)
					{
						this.textBox6.AppendText(".");
					}
					Application.DoEvents();
				}
				this.textBox6.AppendText("\r\n");
				if (this.method_127() == 1)
				{
					<Module>.Sleep(250);
					this.method_126();
					<Module>.Sleep(500);
				}
				else
				{
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					MessageBox.Show("Move drive tray to the full open position.", "LO83info", MessageBoxButtons.OK, MessageBoxIcon.Asterisk);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
				}
				Struct92 struct3;
				<Module>.memset((void*)(&struct3), 0, 120U);
				Struct91 struct4;
				<Module>.memset((void*)(&struct4), 0, 112U);
				uint num3;
				if (num == 160U)
				{
					num3 = 0U;
				}
				else
				{
					num3 = 16U;
				}
				for (uint num2 = 0U; num2 < 256U; num2 += 1U)
				{
					Struct28 struct5;
					<Module>.memset((void*)(&struct5), 0, 16U);
					struct5 = 253;
					*(ref struct5 + 1) = 14;
					*(ref struct5 + 2) = 66;
					*(ref struct5 + 3) = 69;
					*(ref struct5 + 4) = 78;
					*(ref struct5 + 5) = 81;
					uint num4;
					if (<Module>.smethod_16((byte*)(&struct5), 16U, (byte)num3, 512, (void*)(&struct3), &num4, 120U, 1, &ushort_2) == null)
					{
						break;
					}
					if (num2 % 16U == 0U)
					{
						this.textBox6.AppendText(".");
					}
					Application.DoEvents();
					<Module>.smethod_1(ushort_2);
					<Module>.smethod_1(ushort_2);
					<Module>.smethod_1(ushort_2);
					<Module>.smethod_1(ushort_2);
				}
				this.method_5(ref struct3 + 8, 112U, 0U);
				this.textBox6.AppendText("\r\n" + this.string_0 + "\r\n");
				if (<Module>.memcmp(ref struct3 + 8, (void*)(&struct4), 112U) == null)
				{
					this.Cursor = Cursors.Arrow;
					result = 0;
				}
				else if (<Module>.memcmp(ref struct3 + 8, (void*)(&struct2), 112U) == null)
				{
					this.Cursor = Cursors.Arrow;
					result = 0;
				}
				else if (<Module>.memcmp(ref struct3 + 8, (void*)(&struct4), 8U) == null)
				{
					this.Cursor = Cursors.Arrow;
					result = 0;
				}
				else if (<Module>.memcmp(ref struct3 + 112, (void*)(&struct4), 8U) == null)
				{
					this.Cursor = Cursors.Arrow;
					result = 0;
				}
				else
				{
					this.label88.Text = "";
					this.label87.Text = "";
					<Module>.memcpy(*(ref <Module>.struct123_0 + 8) + 964, ref struct3 + 8, 112U);
					<Module>.memcpy(*(ref <Module>.struct123_0 + 8) + 2348, (void*)(&@struct), 32U);
					result = 1;
				}
			}
			return result;
		}

		// Token: 0x0600025F RID: 607 RVA: 0x00127A8C File Offset: 0x00127A8C
		private unsafe int method_105()
		{
			Struct28 @struct = 0;
			initblk(ref @struct + 1, 0, 15);
			byte b = *(*(ref <Module>.struct123_0 + 8) + 625) / 2 % 5 * 16;
			Struct28 struct2;
			<Module>.memcpy((void*)(&struct2), *(ref <Module>.struct123_0 + 8) + 1060, 16U);
			Struct28 struct3;
			<Module>.memcpy((void*)(&struct3), *(ref <Module>.struct123_0 + 8) + 964 + (int)b, 16U);
			Struct28 struct4;
			<Module>.memcpy((void*)(&struct4), *(ref <Module>.struct123_0 + 8) + 1044, 16U);
			Struct89 struct5;
			int int_ = <Module>.smethod_143((uint*)(&struct5), (byte*)(&struct3), 128);
			Struct28 struct6;
			<Module>.smethod_145((uint*)(&struct5), int_, (byte*)(&struct2), (byte*)(&struct6));
			for (int i = 0; i < 16; i++)
			{
				*(ref struct6 + i) = (*(ref struct6 + i) ^ *(ref struct4 + i));
			}
			<Module>.memcpy(*(ref <Module>.struct123_0 + 8) + 280, (void*)(&struct6), 16U);
			int result;
			if (this.method_107((byte*)(&struct6)) != 1)
			{
				this.textBox6.AppendText("\r\n" + "Extracted drive key failed Verification !" + "\r\n\r\n");
				result = 0;
			}
			else
			{
				this.method_6((byte*)(&struct6), 16U, 0U);
				this.label88.Text = "Good";
				this.label87.Text = this.string_0;
				this.textBox6.AppendText("\r\n" + "Extracted drive key " + this.string_0 + "\r\n");
				this.textBox6.AppendText("Extracted drive key Passed Verification !" + "\r\n\r\n");
				this.Cursor = Cursors.Arrow;
				result = 1;
			}
			return result;
		}

		// Token: 0x06000260 RID: 608 RVA: 0x00127C04 File Offset: 0x00127C04
		private unsafe int method_106(byte* pByte_0)
		{
			RegistryKey registryKey = Registry.CurrentUser.CreateSubKey("JungleFlasher");
			return (registryKey.GetValue("Nforce590") != null) ? ((this.method_114(pByte_0) != 0) ? 1 : 0) : ((this.method_107(pByte_0) != 0) ? 1 : 0);
		}

		// Token: 0x06000261 RID: 609 RVA: 0x00127C50 File Offset: 0x00127C50
		private unsafe int method_107(byte* pByte_0)
		{
			if (string.Compare(this.label109.Text, 0, "DG-16D5S", 0, 8) == 0)
			{
				if (this.method_109(pByte_0) == 1)
				{
					return 1;
				}
			}
			else if (this.method_108(pByte_0) == 1)
			{
				return 1;
			}
			return 0;
		}

		// Token: 0x06000262 RID: 610 RVA: 0x003C3C40 File Offset: 0x0030BC40
		private unsafe int method_108(byte* pByte_0)
		{
			Struct28 @struct = 67;
			*(ref @struct + 1) = 111;
			*(ref @struct + 2) = 109;
			*(ref @struct + 3) = 109;
			*(ref @struct + 4) = 97;
			*(ref @struct + 5) = 100;
			*(ref @struct + 6) = 111;
			*(ref @struct + 7) = 114;
			*(ref @struct + 8) = 101;
			*(ref @struct + 9) = 32;
			*(ref @struct + 10) = 52;
			*(ref @struct + 11) = 32;
			*(ref @struct + 12) = 101;
			*(ref @struct + 13) = 118;
			*(ref @struct + 14) = 101;
			*(ref @struct + 15) = 114;
			Struct28 struct2 = 74;
			*(ref struct2 + 1) = 117;
			*(ref struct2 + 2) = 110;
			*(ref struct2 + 3) = 103;
			*(ref struct2 + 4) = 108;
			*(ref struct2 + 5) = 101;
			*(ref struct2 + 6) = 32;
			*(ref struct2 + 7) = 70;
			*(ref struct2 + 8) = 108;
			*(ref struct2 + 9) = 97;
			*(ref struct2 + 10) = 115;
			*(ref struct2 + 11) = 104;
			*(ref struct2 + 12) = 101;
			*(ref struct2 + 13) = 114;
			*(ref struct2 + 14) = 32;
			*(ref struct2 + 15) = 0;
			Struct28 struct3 = 0;
			*(ref struct3 + 1) = 1;
			*(ref struct3 + 2) = 2;
			*(ref struct3 + 3) = 3;
			*(ref struct3 + 4) = 4;
			*(ref struct3 + 5) = 5;
			*(ref struct3 + 6) = 6;
			*(ref struct3 + 7) = 7;
			*(ref struct3 + 8) = 8;
			*(ref struct3 + 9) = 9;
			*(ref struct3 + 10) = 10;
			*(ref struct3 + 11) = 11;
			*(ref struct3 + 12) = 12;
			*(ref struct3 + 13) = 13;
			*(ref struct3 + 14) = 14;
			*(ref struct3 + 15) = 15;
			Struct28 struct4 = 0;
			initblk(ref struct4 + 1, 0, 15);
			Struct28 struct5 = 0;
			initblk(ref struct5 + 1, 0, 15);
			Struct90 struct6 = 0;
			initblk(ref struct6 + 1, 0, 57);
			int result;
			if (this.comboBox1.Items.Count == 0)
			{
				result = 0;
			}
			else
			{
				int selectedIndex = this.comboBox1.SelectedIndex;
				ushort ushort_ = *(ref <Module>.struct38_0 + selectedIndex * 72);
				uint num = (uint)(*(ref <Module>.struct38_0 + selectedIndex * 72 + 4));
				uint num2;
				if (num == 160U)
				{
					num2 = 0U;
				}
				else
				{
					num2 = 16U;
				}
				GStruct3 gstruct;
				<Module>.smethod_21(&gstruct, ushort_, 0, 1, 10000U);
				this.Cursor = Cursors.WaitCursor;
				*(ref struct6 + 8) = 59;
				*(ref struct6 + 9) = 48;
				this.method_89(pByte_0, (byte*)(&struct3), (byte*)(&struct2), ref struct6 + 10);
				this.method_89(pByte_0, ref struct6 + 10, (byte*)(&@struct), ref struct6 + 26);
				<Module>.memcpy(ref struct6 + 42, (void*)(&struct3), 16U);
				Struct52 struct7;
				<Module>.memset((void*)(&struct7), 0, 12U);
				struct7 = 85;
				*(ref struct7 + 8) = 58;
				uint num3;
				if (<Module>.smethod_17((byte*)(&struct7), 12U, (byte)num2, 512, (void*)(&struct6), &num3, 58U, 1, &gstruct) != null && <Module>.smethod_17((byte*)(&struct7), 12U, (byte)num2, 512, (void*)(&struct6), &num3, 58U, 1, &gstruct) != null)
				{
					this.textBox6.AppendText("\r\n" + "Stage 1 failed" + "\r\n");
					this.Cursor = Cursors.Arrow;
					result = 0;
				}
				else
				{
					if (*(ref <Module>.struct38_0 + selectedIndex * 72) == 0 && *(ref <Module>.struct38_0 + selectedIndex * 72 + 3) == 1)
					{
						this.method_424(88);
					}
					Struct90 struct8;
					<Module>.memset((void*)(&struct8), 0, 58U);
					<Module>.memset((void*)(&struct7), 0, 12U);
					struct7 = 90;
					*(ref struct7 + 2) = 59;
					*(ref struct7 + 8) = 58;
					if (<Module>.smethod_16((byte*)(&struct7), 12U, (byte)num2, 512, (void*)(&struct8), &num3, 58U, 1, &gstruct) != null && <Module>.smethod_16((byte*)(&struct7), 12U, (byte)num2, 512, (void*)(&struct8), &num3, 58U, 1, &gstruct) != null)
					{
						this.textBox6.AppendText("\r\n" + "Stage 2 failed" + "\r\n");
						this.Cursor = Cursors.Arrow;
						result = 0;
					}
					else
					{
						this.method_90((byte*)(&struct2), (byte*)(&struct3), ref struct8 + 10, (byte*)(&struct4));
						if (<Module>.memcmp((void*)(&struct5), (void*)(&struct4), 16U) != null)
						{
							this.Cursor = Cursors.Arrow;
							result = 0;
						}
						else
						{
							this.method_90((byte*)(&struct2), ref struct8 + 10, ref struct8 + 26, (byte*)(&struct4));
							if (<Module>.memcmp((void*)(&@struct), (void*)(&struct4), 16U) != null)
							{
								this.Cursor = Cursors.Arrow;
								result = 0;
							}
							else
							{
								this.Cursor = Cursors.Arrow;
								result = 1;
							}
						}
					}
				}
			}
			return result;
		}

		// Token: 0x06000263 RID: 611 RVA: 0x003C4018 File Offset: 0x0030C018
		private unsafe int method_109(byte* pByte_0)
		{
			Struct28 @struct = 67;
			*(ref @struct + 1) = 111;
			*(ref @struct + 2) = 109;
			*(ref @struct + 3) = 109;
			*(ref @struct + 4) = 97;
			*(ref @struct + 5) = 100;
			*(ref @struct + 6) = 111;
			*(ref @struct + 7) = 114;
			*(ref @struct + 8) = 101;
			*(ref @struct + 9) = 32;
			*(ref @struct + 10) = 52;
			*(ref @struct + 11) = 32;
			*(ref @struct + 12) = 101;
			*(ref @struct + 13) = 118;
			*(ref @struct + 14) = 101;
			*(ref @struct + 15) = 114;
			Struct28 struct2 = 74;
			*(ref struct2 + 1) = 117;
			*(ref struct2 + 2) = 110;
			*(ref struct2 + 3) = 103;
			*(ref struct2 + 4) = 108;
			*(ref struct2 + 5) = 101;
			*(ref struct2 + 6) = 32;
			*(ref struct2 + 7) = 70;
			*(ref struct2 + 8) = 108;
			*(ref struct2 + 9) = 97;
			*(ref struct2 + 10) = 115;
			*(ref struct2 + 11) = 104;
			*(ref struct2 + 12) = 101;
			*(ref struct2 + 13) = 114;
			*(ref struct2 + 14) = 32;
			*(ref struct2 + 15) = 0;
			Struct28 struct3 = 0;
			*(ref struct3 + 1) = 1;
			*(ref struct3 + 2) = 2;
			*(ref struct3 + 3) = 3;
			*(ref struct3 + 4) = 4;
			*(ref struct3 + 5) = 5;
			*(ref struct3 + 6) = 6;
			*(ref struct3 + 7) = 7;
			*(ref struct3 + 8) = 8;
			*(ref struct3 + 9) = 9;
			*(ref struct3 + 10) = 10;
			*(ref struct3 + 11) = 11;
			*(ref struct3 + 12) = 12;
			*(ref struct3 + 13) = 13;
			*(ref struct3 + 14) = 14;
			*(ref struct3 + 15) = 15;
			Struct28 struct4 = 0;
			initblk(ref struct4 + 1, 0, 15);
			Struct28 struct5 = 0;
			initblk(ref struct5 + 1, 0, 15);
			Struct28 struct6 = 0;
			initblk(ref struct6 + 1, 0, 15);
			Struct28 struct7 = 71;
			*(ref struct7 + 1) = 69;
			*(ref struct7 + 2) = 78;
			*(ref struct7 + 3) = 85;
			*(ref struct7 + 4) = 73;
			*(ref struct7 + 5) = 78;
			*(ref struct7 + 6) = 69;
			*(ref struct7 + 7) = 32;
			*(ref struct7 + 8) = 88;
			*(ref struct7 + 9) = 66;
			*(ref struct7 + 10) = 79;
			*(ref struct7 + 11) = 88;
			*(ref struct7 + 12) = 32;
			*(ref struct7 + 13) = 79;
			*(ref struct7 + 14) = 68;
			*(ref struct7 + 15) = 68;
			Struct28 struct8 = 0;
			initblk(ref struct8 + 1, 0, 15);
			Struct28 struct9 = 0;
			initblk(ref struct9 + 1, 0, 15);
			Struct93 struct10 = 0;
			initblk(ref struct10 + 1, 0, 75);
			int result;
			if (this.comboBox1.Items.Count == 0)
			{
				result = 0;
			}
			else
			{
				int selectedIndex = this.comboBox1.SelectedIndex;
				ushort ushort_ = *(ref <Module>.struct38_0 + selectedIndex * 72);
				uint num = (uint)(*(ref <Module>.struct38_0 + selectedIndex * 72 + 4));
				uint num2;
				if (num == 160U)
				{
					num2 = 0U;
				}
				else
				{
					num2 = 16U;
				}
				GStruct3 gstruct;
				<Module>.smethod_21(&gstruct, ushort_, 0, 1, 10000U);
				this.Cursor = Cursors.WaitCursor;
				*(ref struct10 + 8) = 40;
				*(ref struct10 + 9) = 64;
				<Module>.memcpy((void*)(&struct9), (void*)(&struct3), 16U);
				this.method_110(pByte_0, (byte*)(&struct9), (byte*)(&struct6));
				this.method_89((byte*)(&struct6), (byte*)(&struct3), (byte*)(&struct2), ref struct10 + 10);
				this.method_89((byte*)(&struct6), ref struct10 + 10, (byte*)(&@struct), ref struct10 + 26);
				<Module>.memcpy(ref struct10 + 42, (void*)(&struct3), 16U);
				this.method_112((byte*)(&struct7), ref struct10 + 10, (byte*)(&struct8));
				this.method_110((byte*)(&struct6), (byte*)(&struct8), ref struct10 + 58);
				Struct52 struct11;
				<Module>.memset((void*)(&struct11), 0, 12U);
				struct11 = 85;
				*(ref struct11 + 8) = 74;
				uint num3;
				if (<Module>.smethod_17((byte*)(&struct11), 12U, (byte)num2, 512, (void*)(&struct10), &num3, 74U, 1, &gstruct) != null && <Module>.smethod_17((byte*)(&struct11), 12U, (byte)num2, 512, (void*)(&struct10), &num3, 74U, 1, &gstruct) != null)
				{
					this.textBox6.AppendText("\r\n" + "Stage 1 failed" + "\r\n");
					this.Cursor = Cursors.Arrow;
					result = 0;
				}
				else
				{
					Struct90 struct12;
					<Module>.memset((void*)(&struct12), 0, 58U);
					<Module>.memset((void*)(&struct11), 0, 12U);
					struct11 = 90;
					*(ref struct11 + 2) = 40;
					*(ref struct11 + 8) = 58;
					if (<Module>.smethod_16((byte*)(&struct11), 12U, (byte)num2, 512, (void*)(&struct12), &num3, 58U, 1, &gstruct) != null && <Module>.smethod_16((byte*)(&struct11), 12U, (byte)num2, 512, (void*)(&struct12), &num3, 58U, 1, &gstruct) != null)
					{
						this.textBox6.AppendText("\r\n" + "Stage 2 failed" + "\r\n");
						this.Cursor = Cursors.Arrow;
						result = 0;
					}
					else
					{
						this.method_90((byte*)(&struct2), (byte*)(&struct3), ref struct12 + 10, (byte*)(&struct4));
						if (<Module>.memcmp((void*)(&struct5), (void*)(&struct4), 16U) != null)
						{
							this.Cursor = Cursors.Arrow;
							result = 0;
						}
						else
						{
							this.method_90((byte*)(&struct2), ref struct12 + 10, ref struct12 + 26, (byte*)(&struct4));
							if (<Module>.memcmp((void*)(&@struct), (void*)(&struct4), 16U) != null)
							{
								this.Cursor = Cursors.Arrow;
								result = 0;
							}
							else
							{
								this.Cursor = Cursors.Arrow;
								result = 1;
							}
						}
					}
				}
			}
			return result;
		}

		// Token: 0x06000264 RID: 612 RVA: 0x001284E0 File Offset: 0x001284E0
		private unsafe int method_110(byte* pByte_0, byte* pByte_1, byte* pByte_2)
		{
			Struct28 @struct = 0;
			initblk(ref @struct + 1, 0, 15);
			Struct28 struct2 = 0;
			initblk(ref struct2 + 1, 0, 15);
			Struct28 struct3 = 0;
			initblk(ref struct3 + 1, 0, 15);
			Struct71 struct4 = 0;
			initblk(ref struct4 + 1, 0, 15);
			*(ref @struct + 15) = 1;
			<Module>.memcpy((void*)pByte_2, (void*)pByte_0, 16U);
			for (int i = 128; i > 0; i--)
			{
				this.method_113((byte*)(&@struct));
				byte b = *(ref @struct + 15);
				byte b2 = *pByte_1;
				b2 = (byte)(b2 >> 7);
				b2 |= b;
				*(ref @struct + 15) = (b2 & byte.MaxValue);
				this.method_113(pByte_1);
				this.method_89(pByte_2, (byte*)(&struct2), (byte*)(&@struct), (byte*)(&struct3));
				<Module>.memcpy((void*)pByte_2, (void*)(&struct3), 16U);
			}
			return 1;
		}

		// Token: 0x06000265 RID: 613 RVA: 0x00128590 File Offset: 0x00128590
		private unsafe int method_111(byte* pByte_0, byte* pByte_1)
		{
			Struct28 @struct = 0;
			initblk(ref @struct + 1, 0, 15);
			Struct28 struct2 = 0;
			initblk(ref struct2 + 1, 0, 15);
			Struct28 struct3 = 0;
			initblk(ref struct3 + 1, 0, 15);
			Struct28 struct4 = 0;
			initblk(ref struct4 + 1, 0, 15);
			Struct71 struct5 = 0;
			initblk(ref struct5 + 1, 0, 15);
			*(ref @struct + 15) = 1;
			<Module>.memcpy((void*)(&struct4), (void*)pByte_0, 16U);
			for (int i = 128; i > 0; i--)
			{
				this.method_113((byte*)(&@struct));
				byte b = *(ref @struct + 15);
				byte b2 = *pByte_1;
				b2 = (byte)(b2 >> 7);
				b2 |= b;
				*(ref @struct + 15) = (b2 & byte.MaxValue);
				this.method_113(pByte_1);
				this.method_89((byte*)(&struct4), (byte*)(&struct2), (byte*)(&@struct), (byte*)(&struct3));
				<Module>.memcpy((void*)(&struct4), (void*)(&struct3), 16U);
			}
			string text = "";
			<Module>.sprintf((sbyte*)(&struct5), (sbyte*)(&<Module>.struct19_0));
			for (int i = 0; i < 16; i++)
			{
				<Module>.sprintf((sbyte*)(&struct5), (sbyte*)(&<Module>.struct10_20), ref struct5, *(ref struct4 + i));
			}
			text += new string((sbyte*)(&struct5));
			this.textBox6.AppendText("New drive key is: " + text + "\r\n");
			return 1;
		}

		// Token: 0x06000266 RID: 614 RVA: 0x001286BC File Offset: 0x001286BC
		private unsafe void method_112(byte* pByte_0, byte* pByte_1, byte* pByte_2)
		{
			Struct28 @struct = 0;
			initblk(ref @struct + 1, 0, 15);
			Struct28 struct2 = 0;
			initblk(ref struct2 + 1, 0, 15);
			Struct28 struct3 = 0;
			initblk(ref struct3 + 1, 0, 15);
			<Module>.memcpy((void*)(&@struct), (void*)pByte_0, 16U);
			this.method_89(pByte_1, (byte*)(&struct3), (byte*)(&@struct), (byte*)(&struct2));
			for (int i = 0; i < 16; i++)
			{
				*(ref @struct + i) = (*(ref @struct + i) ^ *(ref struct2 + i));
			}
			this.method_89(pByte_1 + 16, (byte*)(&struct3), (byte*)(&@struct), (byte*)(&struct2));
			for (int i = 0; i < 16; i++)
			{
				*(ref @struct + i) = (*(ref @struct + i) ^ *(ref struct2 + i));
			}
			<Module>.memcpy((void*)pByte_2, (void*)(&@struct), 16U);
		}

		// Token: 0x06000267 RID: 615 RVA: 0x00128764 File Offset: 0x00128764
		private unsafe void method_113(byte* pByte_0)
		{
			Struct28 @struct = 0;
			initblk(ref @struct + 1, 0, 15);
			*(ref @struct + 15) = (byte)((int)pByte_0[15] << 1 & 254);
			*(ref @struct + 14) = (byte)(((int)pByte_0[14] << 1 & 254) | (pByte_0[15] >> 7 & 1));
			*(ref @struct + 13) = (byte)(((int)pByte_0[13] << 1 & 254) | (pByte_0[14] >> 7 & 1));
			*(ref @struct + 12) = (byte)(((int)pByte_0[12] << 1 & 254) | (pByte_0[13] >> 7 & 1));
			*(ref @struct + 11) = (byte)(((int)pByte_0[11] << 1 & 254) | (pByte_0[12] >> 7 & 1));
			*(ref @struct + 10) = (byte)(((int)pByte_0[10] << 1 & 254) | (pByte_0[11] >> 7 & 1));
			*(ref @struct + 9) = (byte)(((int)pByte_0[9] << 1 & 254) | (pByte_0[10] >> 7 & 1));
			*(ref @struct + 8) = (byte)(((int)pByte_0[8] << 1 & 254) | (pByte_0[9] >> 7 & 1));
			*(ref @struct + 7) = (byte)(((int)pByte_0[7] << 1 & 254) | (pByte_0[8] >> 7 & 1));
			*(ref @struct + 6) = (byte)(((int)pByte_0[6] << 1 & 254) | (pByte_0[7] >> 7 & 1));
			*(ref @struct + 5) = (byte)(((int)pByte_0[5] << 1 & 254) | (pByte_0[6] >> 7 & 1));
			*(ref @struct + 4) = (byte)(((int)pByte_0[4] << 1 & 254) | (pByte_0[5] >> 7 & 1));
			*(ref @struct + 3) = (byte)(((int)pByte_0[3] << 1 & 254) | (pByte_0[4] >> 7 & 1));
			*(ref @struct + 2) = (byte)(((int)pByte_0[2] << 1 & 254) | (pByte_0[3] >> 7 & 1));
			*(ref @struct + 1) = (byte)(((int)pByte_0[1] << 1 & 254) | (pByte_0[2] >> 7 & 1));
			@struct = (((int)(*pByte_0) << 1 & 254) | (pByte_0[1] >> 7 & 1));
			<Module>.memcpy((void*)pByte_0, (void*)(&@struct), 16U);
		}

		// Token: 0x06000268 RID: 616 RVA: 0x00128934 File Offset: 0x00128934
		private unsafe int method_114(byte* pByte_0)
		{
			Struct28 @struct = 67;
			*(ref @struct + 1) = 111;
			*(ref @struct + 2) = 109;
			*(ref @struct + 3) = 109;
			*(ref @struct + 4) = 97;
			*(ref @struct + 5) = 100;
			*(ref @struct + 6) = 111;
			*(ref @struct + 7) = 114;
			*(ref @struct + 8) = 101;
			*(ref @struct + 9) = 32;
			*(ref @struct + 10) = 52;
			*(ref @struct + 11) = 32;
			*(ref @struct + 12) = 101;
			*(ref @struct + 13) = 118;
			*(ref @struct + 14) = 101;
			*(ref @struct + 15) = 114;
			Struct28 struct2 = 74;
			*(ref struct2 + 1) = 117;
			*(ref struct2 + 2) = 110;
			*(ref struct2 + 3) = 103;
			*(ref struct2 + 4) = 108;
			*(ref struct2 + 5) = 101;
			*(ref struct2 + 6) = 32;
			*(ref struct2 + 7) = 70;
			*(ref struct2 + 8) = 108;
			*(ref struct2 + 9) = 97;
			*(ref struct2 + 10) = 115;
			*(ref struct2 + 11) = 104;
			*(ref struct2 + 12) = 101;
			*(ref struct2 + 13) = 114;
			*(ref struct2 + 14) = 32;
			*(ref struct2 + 15) = 0;
			Struct28 struct3 = 0;
			*(ref struct3 + 1) = 1;
			*(ref struct3 + 2) = 2;
			*(ref struct3 + 3) = 3;
			*(ref struct3 + 4) = 4;
			*(ref struct3 + 5) = 5;
			*(ref struct3 + 6) = 6;
			*(ref struct3 + 7) = 7;
			*(ref struct3 + 8) = 8;
			*(ref struct3 + 9) = 9;
			*(ref struct3 + 10) = 10;
			*(ref struct3 + 11) = 11;
			*(ref struct3 + 12) = 12;
			*(ref struct3 + 13) = 13;
			*(ref struct3 + 14) = 14;
			*(ref struct3 + 15) = 15;
			Struct28 struct4 = 0;
			initblk(ref struct4 + 1, 0, 15);
			Struct28 struct5 = 0;
			initblk(ref struct5 + 1, 0, 15);
			Struct4 struct6 = 0;
			*(ref struct6 + 1) = 0;
			*(ref struct6 + 2) = 0;
			*(ref struct6 + 3) = 0;
			*(ref struct6 + 4) = 0;
			*(ref struct6 + 5) = 0;
			*(ref struct6 + 6) = 0;
			*(ref struct6 + 7) = 0;
			*(ref struct6 + 8) = 59;
			*(ref struct6 + 9) = 48;
			*(ref struct6 + 10) = 0;
			*(ref struct6 + 11) = 0;
			*(ref struct6 + 12) = 0;
			*(ref struct6 + 13) = 0;
			*(ref struct6 + 14) = 0;
			*(ref struct6 + 15) = 0;
			*(ref struct6 + 16) = 0;
			*(ref struct6 + 17) = 0;
			*(ref struct6 + 18) = 0;
			*(ref struct6 + 19) = 0;
			*(ref struct6 + 20) = 0;
			*(ref struct6 + 21) = 0;
			*(ref struct6 + 22) = 0;
			*(ref struct6 + 23) = 0;
			*(ref struct6 + 24) = 0;
			*(ref struct6 + 25) = 0;
			*(ref struct6 + 26) = 0;
			*(ref struct6 + 27) = 0;
			*(ref struct6 + 28) = 0;
			*(ref struct6 + 29) = 0;
			*(ref struct6 + 30) = 0;
			*(ref struct6 + 31) = 0;
			*(ref struct6 + 32) = 0;
			*(ref struct6 + 33) = 0;
			*(ref struct6 + 34) = 0;
			*(ref struct6 + 35) = 0;
			*(ref struct6 + 36) = 0;
			*(ref struct6 + 37) = 0;
			*(ref struct6 + 38) = 0;
			*(ref struct6 + 39) = 0;
			*(ref struct6 + 40) = 0;
			*(ref struct6 + 41) = 0;
			*(ref struct6 + 42) = 0;
			*(ref struct6 + 43) = 0;
			*(ref struct6 + 44) = 0;
			*(ref struct6 + 45) = 0;
			*(ref struct6 + 46) = 0;
			*(ref struct6 + 47) = 0;
			*(ref struct6 + 48) = 0;
			*(ref struct6 + 49) = 0;
			*(ref struct6 + 50) = 0;
			*(ref struct6 + 51) = 0;
			*(ref struct6 + 52) = 0;
			*(ref struct6 + 53) = 0;
			*(ref struct6 + 54) = 0;
			*(ref struct6 + 55) = 0;
			*(ref struct6 + 56) = 0;
			*(ref struct6 + 57) = 0;
			*(ref struct6 + 58) = 0;
			*(ref struct6 + 59) = 0;
			*(ref struct6 + 60) = 0;
			*(ref struct6 + 61) = 0;
			*(ref struct6 + 62) = 0;
			*(ref struct6 + 63) = 0;
			Struct28 struct7;
			<Module>.memcpy((void*)(&struct7), (void*)pByte_0, 16U);
			int result;
			if (this.comboBox1.Items.Count == 0)
			{
				result = 0;
			}
			else
			{
				int selectedIndex = this.comboBox1.SelectedIndex;
				ushort ushort_ = *(ref <Module>.struct38_0 + selectedIndex * 72);
				uint num = (uint)(*(ref <Module>.struct38_0 + selectedIndex * 72 + 4));
				uint num2;
				if (num == 160U)
				{
					num2 = 0U;
				}
				else
				{
					num2 = 16U;
				}
				GStruct3 gstruct;
				<Module>.smethod_21(&gstruct, ushort_, 0, 1, 10000U);
				this.Cursor = Cursors.WaitCursor;
				this.method_5((byte*)(&struct7), 16U, 0U);
				this.method_5((byte*)(&struct3), 16U, 0U);
				Struct28 struct8;
				<Module>.memcpy((void*)(&struct8), (void*)(&struct2), 16U);
				this.method_5((byte*)(&struct8), 16U, 0U);
				for (int i = 0; i < 16; i++)
				{
					*(ref struct8 + i) = (*(ref struct8 + i) ^ *(ref struct3 + i));
				}
				Struct89 struct9;
				int int_ = <Module>.smethod_142((uint*)(&struct9), (byte*)(&struct7), 128);
				<Module>.smethod_144((uint*)(&struct9), int_, (byte*)(&struct8), (byte*)(&struct4));
				this.method_5((byte*)(&struct4), 16U, 0U);
				Struct4 struct10;
				<Module>.memcpy((void*)(&struct10), (void*)(&struct6), 64U);
				<Module>.memcpy(ref struct10 + 10, (void*)(&struct4), 16U);
				<Module>.memcpy(ref struct10 + 42, (void*)(&struct3), 16U);
				<Module>.memcpy((void*)(&struct3), (void*)(&struct4), 16U);
				<Module>.memcpy((void*)(&struct8), (void*)(&@struct), 16U);
				this.method_5((byte*)(&struct8), 16U, 0U);
				for (int i = 0; i < 16; i++)
				{
					*(ref struct8 + i) = (*(ref struct8 + i) ^ *(ref struct3 + i));
				}
				int_ = <Module>.smethod_142((uint*)(&struct9), (byte*)(&struct7), 128);
				<Module>.smethod_144((uint*)(&struct9), int_, (byte*)(&struct8), (byte*)(&struct4));
				this.method_5((byte*)(&struct4), 16U, 0U);
				<Module>.memcpy(ref struct10 + 26, (void*)(&struct4), 16U);
				Struct28 struct11;
				<Module>.memset((void*)(&struct11), 0, 16U);
				struct11 = 85;
				*(ref struct11 + 8) = 58;
				uint num3;
				if (<Module>.smethod_17((byte*)(&struct11), 16U, (byte)num2, 512, (void*)(&struct10), &num3, 64U, 1, &gstruct) != null && <Module>.smethod_17((byte*)(&struct11), 16U, (byte)num2, 512, (void*)(&struct10), &num3, 64U, 1, &gstruct) != null)
				{
					this.textBox6.AppendText("\r\n" + "Stage 1 failed" + "\r\n");
					this.Cursor = Cursors.Arrow;
					result = 0;
				}
				else
				{
					Struct94 struct12;
					<Module>.memset((void*)(&struct12), 0, 68U);
					<Module>.memset((void*)(&struct11), 0, 16U);
					struct11 = 90;
					*(ref struct11 + 2) = 59;
					*(ref struct11 + 8) = 58;
					if (<Module>.smethod_16((byte*)(&struct11), 16U, (byte)num2, 512, (void*)(&struct12), &num3, 68U, 1, &gstruct) != null && <Module>.smethod_16((byte*)(&struct11), 16U, (byte)num2, 512, (void*)(&struct12), &num3, 68U, 1, &gstruct) != null)
					{
						this.textBox6.AppendText("\r\n" + "Stage 2 failed" + "\r\n");
						this.Cursor = Cursors.Arrow;
						result = 0;
					}
					else
					{
						byte* ptr = ref struct12 + 8;
						this.method_5(ptr, 58U, 0U);
						<Module>.memcpy((void*)(&struct7), (void*)(&struct2), 16U);
						<Module>.memcpy((void*)(&struct3), (void*)(ptr + 42), 16U);
						<Module>.memcpy((void*)(&struct8), (void*)(ptr + 10), 16U);
						int_ = <Module>.smethod_143((uint*)(&struct9), (byte*)(&struct7), 128);
						<Module>.smethod_145((uint*)(&struct9), int_, (byte*)(&struct8), (byte*)(&struct4));
						for (int i = 0; i < 16; i++)
						{
							*(ref struct4 + i) = (*(ref struct4 + i) ^ *(ref struct3 + i));
						}
						this.method_5((byte*)(&struct4), 16U, 0U);
						if (<Module>.memcmp((void*)(&struct5), (void*)(&struct4), 16U) != null)
						{
							this.Cursor = Cursors.Arrow;
							result = 0;
						}
						else
						{
							<Module>.memcpy((void*)(&struct3), (void*)(ptr + 10), 16U);
							<Module>.memcpy((void*)(&struct8), (void*)(ptr + 26), 16U);
							int_ = <Module>.smethod_143((uint*)(&struct9), (byte*)(&struct7), 128);
							<Module>.smethod_145((uint*)(&struct9), int_, (byte*)(&struct8), (byte*)(&struct4));
							for (int i = 0; i < 16; i++)
							{
								*(ref struct4 + i) = (*(ref struct4 + i) ^ *(ref struct3 + i));
							}
							this.method_5((byte*)(&struct4), 16U, 0U);
							this.Cursor = Cursors.Arrow;
							result = ((<Module>.memcmp((void*)(&@struct), (void*)(&struct4), 16U) == null) ? 1 : 0);
						}
					}
				}
			}
			return result;
		}

		// Token: 0x06000269 RID: 617 RVA: 0x00129018 File Offset: 0x00129018
		private unsafe int method_115()
		{
			string text = null;
			string text2 = null;
			RegistryKey registryKey = Registry.CurrentUser.CreateSubKey("JF_KeyDB");
			int result;
			if (registryKey.GetValue("Index") != null)
			{
				string text3 = registryKey.GetValue("Index").ToString();
				int num = (int)Convert.ToInt16(text3);
				num++;
				this.Cursor = Cursors.WaitCursor;
				this.textBox6.AppendText("Scanning KeyDB and testing " + text3 + " keys" + "\r\n");
				this.pictureBox5.Visible = false;
				this.pictureBox7.Visible = true;
				this.pictureBox2.Visible = false;
				this.pictureBox6.Visible = true;
				this.menuItem_21.Enabled = false;
				this.menuItem_22.Enabled = false;
				this.menuItem_23.Enabled = false;
				this.menuItem_24.Enabled = false;
				this.label133.Text = "Not Found";
				this.label131.Text = "Not Found";
				this.string_14 = "";
				this.string_15 = "";
				this.string_16 = "";
				this.string_17 = "";
				this.toolTip_0.SetToolTip(this.pictureBox5, null);
				this.toolTip_0.SetToolTip(this.pictureBox2, null);
				for (int i = 1; i < num; i++)
				{
					if (<Module>.GetAsyncKeyState(27) != null)
					{
						this.textBox6.AppendText("\r\n" + "Aborted by User!" + "\r\n");
						return 0;
					}
					Application.DoEvents();
					registryKey = Registry.CurrentUser.CreateSubKey("JF_KeyDB\\" + Convert.ToString(i));
					this.textBox6.AppendText(".");
					if (registryKey.GetValue("Key") != null)
					{
						text = registryKey.GetValue("Key").ToString();
					}
					if (registryKey.GetValue("JobName") != null)
					{
						text2 = registryKey.GetValue("JobName").ToString();
					}
					string text4;
					if (registryKey.GetValue("WorkingDir") != null)
					{
						text4 = registryKey.GetValue("WorkingDir").ToString();
					}
					else
					{
						text4 = "";
					}
					string strA;
					if (registryKey.GetValue("LastFile") != null)
					{
						strA = registryKey.GetValue("LastFile").ToString();
					}
					else
					{
						strA = "";
					}
					Struct28 @struct;
					for (int j = 0; j < 32; j += 2)
					{
						string s = text.Substring(j, 2);
						IntPtr intPtr = Marshal.StringToHGlobalAnsi(s);
						IntPtr value = intPtr;
						sbyte* pSbyte_ = (sbyte*)((void*)value);
						byte b;
						this.method_10((void*)(&b), pSbyte_, 2);
						*(ref @struct + j / 2) = b;
					}
					if (this.method_107((byte*)(&@struct)) == 1)
					{
						this.toolTip_0.SetToolTip(this.pictureBox5, "Drive Key found in KeyDB (" + Convert.ToString(i) + " - " + text2 + ")" + Environment.NewLine + "Key is: " + text);
						this.toolTip_0.SetToolTip(this.pictureBox2, "Drive Key found in KeyDB (" + Convert.ToString(i) + " - " + text2 + ")" + Environment.NewLine + "Key is: " + text);
						this.pictureBox5.Visible = true;
						this.pictureBox7.Visible = false;
						this.pictureBox2.Visible = true;
						this.pictureBox6.Visible = false;
						if (string.Compare(strA, "") != 0)
						{
							this.menuItem_21.Enabled = true;
						}
						this.menuItem_22.Enabled = true;
						this.menuItem_23.Enabled = true;
						this.menuItem_24.Enabled = true;
						this.string_14 = text;
						this.string_15 = Convert.ToString(i);
						this.string_16 = strA;
						this.string_17 = text4;
						this.label133.Text = "Verified";
						this.label131.Text = "Verified";
						registryKey.Close();
						this.Cursor = Cursors.Arrow;
						this.textBox6.AppendText("\r\n" + "Key found in KeyDB at record (" + Convert.ToString(i) + " - " + text2 + ")" + "\r\n" + "Key is: " + text + "\r\n" + "Key has been tested and verified, thanks C4eva ! " + "\r\n");
						return 1;
					}
				}
				this.textBox6.AppendText("\r\n" + "Key was not found" + "\r\n");
				registryKey.Close();
				this.Cursor = Cursors.Arrow;
				result = 0;
			}
			else
			{
				result = 0;
			}
			return result;
		}

		// Token: 0x0600026A RID: 618 RVA: 0x0012947C File Offset: 0x0012947C
		private void menuItem_21_Click(object sender, EventArgs e)
		{
			if (File.Exists(this.string_16))
			{
				this.method_36(this.string_16, 0);
			}
			else
			{
				<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
				MessageBox.Show("LastFile was not found in the specified location.", "Load Last File", MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
				<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
			}
		}

		// Token: 0x0600026B RID: 619 RVA: 0x001294E8 File Offset: 0x001294E8
		private void menuItem_22_Click(object sender, EventArgs e)
		{
			if (Directory.Exists(Path.GetDirectoryName(this.string_17)))
			{
				OpenFileDialog openFileDialog = new OpenFileDialog();
				openFileDialog.Filter = "Firmware file (*.bin)|*.bin|All Files (*.*)|*.*";
				openFileDialog.FileName = "ix16.bin";
				openFileDialog.DefaultExt = ".bin";
				openFileDialog.CheckFileExists = true;
				openFileDialog.CheckPathExists = true;
				openFileDialog.RestoreDirectory = false;
				openFileDialog.InitialDirectory = this.string_17;
				if (openFileDialog.ShowDialog() == DialogResult.OK)
				{
					string fullPath = Path.GetFullPath(openFileDialog.FileName);
					this.method_36(fullPath, 0);
				}
			}
			else
			{
				<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
				MessageBox.Show("Job Folder was not found.", "Open Job Folder", MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
				<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
			}
		}

		// Token: 0x0600026C RID: 620 RVA: 0x001295B4 File Offset: 0x001295B4
		private void menuItem_23_Click(object sender, EventArgs e)
		{
			int num = this.method_22(this.string_14);
			new Job_history
			{
				int_0 = num
			}.ShowDialog(this);
		}

		// Token: 0x0600026D RID: 621 RVA: 0x001295E8 File Offset: 0x001295E8
		private void menuItem_24_Click(object sender, EventArgs e)
		{
			DataBaseView dataBaseView = new DataBaseView();
			dataBaseView.int_0 = this.method_22(this.string_14);
			if (dataBaseView.ShowDialog(this) == DialogResult.OK)
			{
				this.string_10 = Path.GetDirectoryName(dataBaseView.textBox15.Text);
				this.string_9 = dataBaseView.textBox2.Text;
			}
		}

		// Token: 0x0600026E RID: 622 RVA: 0x00129640 File Offset: 0x00129640
		private unsafe void method_116()
		{
			if (this.bool_2)
			{
				string text = this.string_10 + "\\Key.bin";
				if (!File.Exists(text))
				{
					IntPtr intPtr = Marshal.StringToHGlobalAnsi(text);
					IntPtr value = intPtr;
					sbyte* pSbyte_ = (sbyte*)((void*)value);
					this.string_13 = text;
					GStruct5* ptr = <Module>.fopen((sbyte*)pSbyte_, (sbyte*)(&<Module>.struct18_5));
					if (ptr != null)
					{
						<Module>.fwrite(*(ref <Module>.struct123_0 + 8) + 280, 16U, 1U, ptr);
						<Module>.fclose(ptr);
						this.textBox6.AppendText("\r\n" + "Key data saved to " + text + "\r\n");
						return;
					}
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					MessageBox.Show(text, "Can't open file", MessageBoxButtons.OK);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
				}
			}
			SaveFileDialog saveFileDialog = new SaveFileDialog();
			saveFileDialog.Filter = "Firmware Images (*.bin)|*.bin|All Files (*.*)|*.*";
			saveFileDialog.DefaultExt = ".bin";
			saveFileDialog.FileName = "Key.bin";
			saveFileDialog.RestoreDirectory = false;
			if (this.bool_2)
			{
				saveFileDialog.InitialDirectory = this.string_10;
			}
			if (saveFileDialog.ShowDialog() == DialogResult.OK)
			{
				string fullPath = Path.GetFullPath(saveFileDialog.FileName);
				IntPtr intPtr2 = Marshal.StringToHGlobalAnsi(fullPath);
				IntPtr value2 = intPtr2;
				sbyte* pSbyte_2 = (sbyte*)((void*)value2);
				GStruct5* ptr = <Module>.fopen((sbyte*)pSbyte_2, (sbyte*)(&<Module>.struct18_5));
				if (ptr == null)
				{
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					MessageBox.Show(saveFileDialog.FileName.ToString(), "Can't open file", MessageBoxButtons.OK);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
				}
				else
				{
					this.textBox6.AppendText("Key data saved to " + saveFileDialog.FileName + "\r\n\r\n");
					<Module>.fwrite(*(ref <Module>.struct123_0 + 8) + 280, 16U, 1U, ptr);
					<Module>.fclose(ptr);
				}
			}
		}

		// Token: 0x0600026F RID: 623 RVA: 0x0012982C File Offset: 0x0012982C
		private unsafe void method_117()
		{
			Struct34 @struct = 127;
			*(ref @struct + 1) = byte.MaxValue;
			*(ref @struct + 2) = byte.MaxValue;
			*(ref @struct + 3) = byte.MaxValue;
			*(ref @struct + 4) = byte.MaxValue;
			*(ref @struct + 5) = byte.MaxValue;
			*(ref @struct + 6) = byte.MaxValue;
			*(ref @struct + 7) = byte.MaxValue;
			*(ref @struct + 8) = byte.MaxValue;
			*(ref @struct + 9) = byte.MaxValue;
			*(ref @struct + 10) = byte.MaxValue;
			*(ref @struct + 11) = byte.MaxValue;
			*(ref @struct + 12) = byte.MaxValue;
			*(ref @struct + 13) = byte.MaxValue;
			*(ref @struct + 14) = byte.MaxValue;
			*(ref @struct + 15) = byte.MaxValue;
			*(ref @struct + 16) = byte.MaxValue;
			*(ref @struct + 17) = byte.MaxValue;
			*(ref @struct + 18) = byte.MaxValue;
			*(ref @struct + 19) = byte.MaxValue;
			*(ref @struct + 20) = byte.MaxValue;
			*(ref @struct + 21) = byte.MaxValue;
			*(ref @struct + 22) = byte.MaxValue;
			*(ref @struct + 23) = byte.MaxValue;
			*(ref @struct + 24) = byte.MaxValue;
			*(ref @struct + 25) = byte.MaxValue;
			*(ref @struct + 26) = byte.MaxValue;
			*(ref @struct + 27) = byte.MaxValue;
			*(ref @struct + 28) = byte.MaxValue;
			*(ref @struct + 29) = byte.MaxValue;
			*(ref @struct + 30) = byte.MaxValue;
			*(ref @struct + 31) = byte.MaxValue;
			*(ref @struct + 32) = 0;
			*(ref @struct + 33) = 17;
			*(ref @struct + 34) = 34;
			*(ref @struct + 35) = 51;
			*(ref @struct + 36) = 68;
			*(ref @struct + 37) = 85;
			*(ref @struct + 38) = 102;
			*(ref @struct + 39) = 119;
			*(ref @struct + 40) = 136;
			*(ref @struct + 41) = 153;
			*(ref @struct + 42) = 170;
			*(ref @struct + 43) = 187;
			*(ref @struct + 44) = 204;
			*(ref @struct + 45) = 221;
			*(ref @struct + 46) = 238;
			*(ref @struct + 47) = 250;
			Struct28 struct2 = 68;
			*(ref struct2 + 1) = 86;
			*(ref struct2 + 2) = 68;
			*(ref struct2 + 3) = 75;
			*(ref struct2 + 4) = 101;
			*(ref struct2 + 5) = 121;
			*(ref struct2 + 6) = 51;
			*(ref struct2 + 7) = 50;
			*(ref struct2 + 8) = 32;
			*(ref struct2 + 9) = 101;
			*(ref struct2 + 10) = 120;
			*(ref struct2 + 11) = 116;
			*(ref struct2 + 12) = 114;
			*(ref struct2 + 13) = 97;
			*(ref struct2 + 14) = 99;
			*(ref struct2 + 15) = 116;
			Struct30 struct3;
			<Module>.memset((void*)(&struct3), 0, 512U);
			<Module>.memcpy((void*)(&struct3), *(ref <Module>.struct123_0 + 8) + 780, 180U);
			for (int i = 46; i < 93; i += 2)
			{
				*(ref struct3 + i) = *(*(ref <Module>.struct123_0 + 8) + 780 + (i + 1));
				*(ref struct3 + (i + 1)) = *(*(ref <Module>.struct123_0 + 8) + 780 + i);
			}
			Struct32 struct4;
			<Module>.memset((void*)(&struct4), 0, 262144U);
			Struct33 struct5;
			<Module>.memset((void*)(&struct5), 255, 4096U);
			byte* ptr = ref struct4 + 11264;
			<Module>.memcpy((void*)ptr, (void*)(&struct3), 512U);
			ptr = ref struct4 + 11776;
			<Module>.memcpy((void*)ptr, *(ref <Module>.struct123_0 + 8) + 568, 116U);
			ptr = ref struct4 + 12032;
			<Module>.memcpy((void*)ptr, *(ref <Module>.struct123_0 + 8) + 684, 96U);
			ptr = ref struct4 + 24512;
			<Module>.memcpy((void*)ptr, *(ref <Module>.struct123_0 + 8) + 2348, 32U);
			ptr = ref struct4 + 40960;
			<Module>.memcpy((void*)ptr, (void*)(&struct5), 4096U);
			ptr = ref struct4 + 40960;
			<Module>.memcpy((void*)ptr, (void*)(&@struct), 48U);
			ptr = ref struct4 + 41008;
			<Module>.memcpy((void*)ptr, *(ref <Module>.struct123_0 + 8) + 280, 16U);
			ptr = ref struct4 + 130816;
			<Module>.memcpy((void*)ptr, *(ref <Module>.struct123_0 + 8) + 2028, 80U);
			<Module>.memcpy(*(ref <Module>.struct121_0 + 7172), (void*)(&struct4), 262144U);
			this.method_121();
		}

		// Token: 0x06000270 RID: 624 RVA: 0x00129C24 File Offset: 0x00129C24
		private unsafe void method_118()
		{
			Struct34 @struct = 127;
			*(ref @struct + 1) = byte.MaxValue;
			*(ref @struct + 2) = byte.MaxValue;
			*(ref @struct + 3) = byte.MaxValue;
			*(ref @struct + 4) = byte.MaxValue;
			*(ref @struct + 5) = byte.MaxValue;
			*(ref @struct + 6) = byte.MaxValue;
			*(ref @struct + 7) = byte.MaxValue;
			*(ref @struct + 8) = byte.MaxValue;
			*(ref @struct + 9) = byte.MaxValue;
			*(ref @struct + 10) = byte.MaxValue;
			*(ref @struct + 11) = byte.MaxValue;
			*(ref @struct + 12) = byte.MaxValue;
			*(ref @struct + 13) = byte.MaxValue;
			*(ref @struct + 14) = byte.MaxValue;
			*(ref @struct + 15) = byte.MaxValue;
			*(ref @struct + 16) = byte.MaxValue;
			*(ref @struct + 17) = byte.MaxValue;
			*(ref @struct + 18) = byte.MaxValue;
			*(ref @struct + 19) = byte.MaxValue;
			*(ref @struct + 20) = byte.MaxValue;
			*(ref @struct + 21) = byte.MaxValue;
			*(ref @struct + 22) = byte.MaxValue;
			*(ref @struct + 23) = byte.MaxValue;
			*(ref @struct + 24) = byte.MaxValue;
			*(ref @struct + 25) = byte.MaxValue;
			*(ref @struct + 26) = byte.MaxValue;
			*(ref @struct + 27) = byte.MaxValue;
			*(ref @struct + 28) = byte.MaxValue;
			*(ref @struct + 29) = byte.MaxValue;
			*(ref @struct + 30) = byte.MaxValue;
			*(ref @struct + 31) = byte.MaxValue;
			*(ref @struct + 32) = 0;
			*(ref @struct + 33) = 17;
			*(ref @struct + 34) = 34;
			*(ref @struct + 35) = 51;
			*(ref @struct + 36) = 68;
			*(ref @struct + 37) = 85;
			*(ref @struct + 38) = 102;
			*(ref @struct + 39) = 119;
			*(ref @struct + 40) = 136;
			*(ref @struct + 41) = 153;
			*(ref @struct + 42) = 170;
			*(ref @struct + 43) = 187;
			*(ref @struct + 44) = 204;
			*(ref @struct + 45) = 221;
			*(ref @struct + 46) = 238;
			*(ref @struct + 47) = 250;
			Struct28 struct2 = 68;
			*(ref struct2 + 1) = 86;
			*(ref struct2 + 2) = 68;
			*(ref struct2 + 3) = 75;
			*(ref struct2 + 4) = 101;
			*(ref struct2 + 5) = 121;
			*(ref struct2 + 6) = 51;
			*(ref struct2 + 7) = 50;
			*(ref struct2 + 8) = 32;
			*(ref struct2 + 9) = 101;
			*(ref struct2 + 10) = 120;
			*(ref struct2 + 11) = 116;
			*(ref struct2 + 12) = 114;
			*(ref struct2 + 13) = 97;
			*(ref struct2 + 14) = 99;
			*(ref struct2 + 15) = 116;
			Struct30 struct3;
			<Module>.memset((void*)(&struct3), 0, 512U);
			<Module>.memcpy((void*)(&struct3), *(ref <Module>.struct123_0 + 8) + 780, 180U);
			for (int i = 46; i < 93; i += 2)
			{
				*(ref struct3 + i) = *(*(ref <Module>.struct123_0 + 8) + 780 + (i + 1));
				*(ref struct3 + (i + 1)) = *(*(ref <Module>.struct123_0 + 8) + 780 + i);
			}
			Struct32 struct4;
			<Module>.memset((void*)(&struct4), 0, 262144U);
			<Module>.memcpy(ref struct4 + 172032, *(ref <Module>.struct121_0 + 7172), 4096U);
			*(ref struct4 + 258048) = *(*(ref <Module>.struct121_0 + 7172) + 258048);
			*(ref struct4 + 258049) = *(*(ref <Module>.struct121_0 + 7172) + 258049);
			if (*(ref struct4 + 258050) != 229)
			{
				*(ref struct4 + 258050) = *(*(ref <Module>.struct121_0 + 7172) + 258050);
				*(ref struct4 + 258051) = *(*(ref <Module>.struct121_0 + 7172) + 258051);
			}
			*(ref struct4 + 126976) = *(*(ref <Module>.struct121_0 + 7172) + 126976);
			Struct33 struct5;
			<Module>.memset((void*)(&struct5), 255, 4096U);
			byte* ptr = ref struct4 + 11264;
			<Module>.memcpy((void*)ptr, (void*)(&struct3), 512U);
			ptr = ref struct4 + 11776;
			<Module>.memcpy((void*)ptr, *(ref <Module>.struct123_0 + 8) + 568, 116U);
			ptr = ref struct4 + 12032;
			<Module>.memcpy((void*)ptr, *(ref <Module>.struct123_0 + 8) + 684, 96U);
			ptr = ref struct4 + 24512;
			<Module>.memcpy((void*)ptr, *(ref <Module>.struct123_0 + 8) + 2348, 32U);
			ptr = ref struct4 + 40960;
			<Module>.memcpy((void*)ptr, (void*)(&struct5), 4096U);
			ptr = ref struct4 + 40960;
			<Module>.memcpy((void*)ptr, (void*)(&@struct), 48U);
			ptr = ref struct4 + 41008;
			<Module>.memcpy((void*)ptr, *(ref <Module>.struct123_0 + 8) + 280, 16U);
			ptr = ref struct4 + 130816;
			<Module>.memcpy((void*)ptr, *(ref <Module>.struct123_0 + 8) + 2028, 224U);
			<Module>.memcpy(*(ref <Module>.struct121_0 + 7172), (void*)(&struct4), 262144U);
			this.method_121();
		}

		// Token: 0x06000271 RID: 625 RVA: 0x0012A0D8 File Offset: 0x0012A0D8
		private void textBox11_TextChanged(object sender, EventArgs e)
		{
			if (string.Compare(this.textBox11.Text, "140F0F1011B5223D79587717FFD9EC3A") == 0)
			{
				<Module>.pGstruct14_9 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, null, <Module>.GetCurrentThreadId());
				MessageBox.Show("This key is from a bad LO83info file, try redumping.", "Spoofing iXtreme", MessageBoxButtons.OK, MessageBoxIcon.Hand);
				<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_9);
				this.method_43();
			}
			if (string.Compare(this.textBox11.Text, "A79A2F73EC6B1F204BAECB0E8B763018") == 0)
			{
				<Module>.pGstruct14_9 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, null, <Module>.GetCurrentThreadId());
				MessageBox.Show("This key is from a bad LO83info file, try redumping.", "Spoofing iXtreme", MessageBoxButtons.OK, MessageBoxIcon.Hand);
				<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_9);
				this.method_43();
			}
		}

		// Token: 0x06000272 RID: 626 RVA: 0x0012A188 File Offset: 0x0012A188
		private unsafe void method_119()
		{
			Struct91 @struct;
			<Module>.memset((void*)(&@struct), 0, 112U);
			OpenFileDialog openFileDialog = new OpenFileDialog();
			openFileDialog.Filter = "LO83info file (*.key)|*.key|All Files (*.*)|*.*";
			openFileDialog.FileName = "[barcode].bin.key";
			openFileDialog.DefaultExt = ".key";
			openFileDialog.CheckFileExists = true;
			openFileDialog.CheckPathExists = true;
			openFileDialog.RestoreDirectory = false;
			if (this.bool_2)
			{
				openFileDialog.InitialDirectory = this.string_10;
			}
			if (openFileDialog.ShowDialog() == DialogResult.OK)
			{
				string fullPath = Path.GetFullPath(openFileDialog.FileName);
				IntPtr intPtr = Marshal.StringToHGlobalAnsi(fullPath);
				IntPtr value = intPtr;
				sbyte* pSbyte_ = (sbyte*)((void*)value);
				GStruct5* ptr = <Module>.fopen((sbyte*)pSbyte_, (sbyte*)(&<Module>.struct18_4));
				if (ptr == null)
				{
					<Module>.pGstruct14_9 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, null, <Module>.GetCurrentThreadId());
					MessageBox.Show(openFileDialog.FileName.ToString(), "Can't open file", MessageBoxButtons.OK);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_9);
				}
				else
				{
					<Module>.fseek(ptr, 0, 2);
					int num = <Module>.ftell(ptr);
					<Module>.rewind(ptr);
					Struct95 struct2;
					if (num != 304)
					{
						<Module>.pGstruct14_9 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, null, <Module>.GetCurrentThreadId());
						MessageBox.Show("LO83info file should be 304 bytes", "Loading File", MessageBoxButtons.OK);
						<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_9);
						<Module>.fclose(ptr);
					}
					else if (<Module>.fread((void*)(&struct2), 304U, 1U, ptr) != 1)
					{
						<Module>.pGstruct14_9 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, null, <Module>.GetCurrentThreadId());
						MessageBox.Show("LO83info file should be 304 bytes", "Loading File", MessageBoxButtons.OK);
						<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_9);
						<Module>.fclose(ptr);
					}
					else if (<Module>.memcmp((void*)(&@struct), (void*)(&struct2), 16U) == null)
					{
						<Module>.pGstruct14_9 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, null, <Module>.GetCurrentThreadId());
						MessageBox.Show("LO83info file looks incorrect, try redumping.", "Loading File", MessageBoxButtons.OK);
						<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_9);
					}
					else
					{
						<Module>.memcpy(*(ref <Module>.struct123_0 + 8) + 964, (void*)(&struct2), 304U);
						this.method_120();
					}
				}
			}
		}

		// Token: 0x06000273 RID: 627 RVA: 0x0012A378 File Offset: 0x0012A378
		private unsafe void method_120()
		{
			Struct34 @struct = 127;
			*(ref @struct + 1) = byte.MaxValue;
			*(ref @struct + 2) = byte.MaxValue;
			*(ref @struct + 3) = byte.MaxValue;
			*(ref @struct + 4) = byte.MaxValue;
			*(ref @struct + 5) = byte.MaxValue;
			*(ref @struct + 6) = byte.MaxValue;
			*(ref @struct + 7) = byte.MaxValue;
			*(ref @struct + 8) = byte.MaxValue;
			*(ref @struct + 9) = byte.MaxValue;
			*(ref @struct + 10) = byte.MaxValue;
			*(ref @struct + 11) = byte.MaxValue;
			*(ref @struct + 12) = byte.MaxValue;
			*(ref @struct + 13) = byte.MaxValue;
			*(ref @struct + 14) = byte.MaxValue;
			*(ref @struct + 15) = byte.MaxValue;
			*(ref @struct + 16) = byte.MaxValue;
			*(ref @struct + 17) = byte.MaxValue;
			*(ref @struct + 18) = byte.MaxValue;
			*(ref @struct + 19) = byte.MaxValue;
			*(ref @struct + 20) = byte.MaxValue;
			*(ref @struct + 21) = byte.MaxValue;
			*(ref @struct + 22) = byte.MaxValue;
			*(ref @struct + 23) = byte.MaxValue;
			*(ref @struct + 24) = byte.MaxValue;
			*(ref @struct + 25) = byte.MaxValue;
			*(ref @struct + 26) = byte.MaxValue;
			*(ref @struct + 27) = byte.MaxValue;
			*(ref @struct + 28) = byte.MaxValue;
			*(ref @struct + 29) = byte.MaxValue;
			*(ref @struct + 30) = byte.MaxValue;
			*(ref @struct + 31) = byte.MaxValue;
			*(ref @struct + 32) = 0;
			*(ref @struct + 33) = 17;
			*(ref @struct + 34) = 34;
			*(ref @struct + 35) = 51;
			*(ref @struct + 36) = 68;
			*(ref @struct + 37) = 85;
			*(ref @struct + 38) = 102;
			*(ref @struct + 39) = 119;
			*(ref @struct + 40) = 136;
			*(ref @struct + 41) = 153;
			*(ref @struct + 42) = 170;
			*(ref @struct + 43) = 187;
			*(ref @struct + 44) = 204;
			*(ref @struct + 45) = 221;
			*(ref @struct + 46) = 238;
			*(ref @struct + 47) = 250;
			Struct55 struct2 = 68;
			*(ref struct2 + 1) = 117;
			*(ref struct2 + 2) = 109;
			*(ref struct2 + 3) = 109;
			*(ref struct2 + 4) = 121;
			*(ref struct2 + 5) = 32;
			*(ref struct2 + 6) = 102;
			*(ref struct2 + 7) = 114;
			*(ref struct2 + 8) = 111;
			*(ref struct2 + 9) = 109;
			*(ref struct2 + 10) = 32;
			*(ref struct2 + 11) = 76;
			*(ref struct2 + 12) = 79;
			*(ref struct2 + 13) = 56;
			*(ref struct2 + 14) = 51;
			*(ref struct2 + 15) = 105;
			*(ref struct2 + 16) = 110;
			*(ref struct2 + 17) = 102;
			*(ref struct2 + 18) = 111;
			*(ref struct2 + 19) = 46;
			*(ref struct2 + 20) = 98;
			*(ref struct2 + 21) = 105;
			*(ref struct2 + 22) = 110;
			*(ref struct2 + 23) = 46;
			*(ref struct2 + 24) = 107;
			*(ref struct2 + 25) = 101;
			*(ref struct2 + 26) = 121;
			*(ref struct2 + 27) = 0;
			*(ref struct2 + 28) = 0;
			*(ref struct2 + 29) = 0;
			*(ref struct2 + 30) = 0;
			*(ref struct2 + 31) = 0;
			Struct30 struct3;
			<Module>.memset((void*)(&struct3), 0, 512U);
			<Module>.memcpy((void*)(&struct3), (void*)(&<Module>.struct46_3), 180U);
			<Module>.memcpy(ref struct3 + 20, *(ref <Module>.struct123_0 + 8) + 1172, 20U);
			Struct30 struct4;
			<Module>.memcpy((void*)(&struct4), (void*)(&struct3), 512U);
			for (int i = 46; i < 93; i += 2)
			{
				*(ref struct3 + i) = *(ref struct4 + (i + 1));
				*(ref struct3 + (i + 1)) = *(ref struct4 + i);
			}
			Struct32 struct5;
			<Module>.memset((void*)(&struct5), 0, 262144U);
			Struct33 struct6;
			<Module>.memset((void*)(&struct6), 255, 4096U);
			byte* ptr = ref struct5 + 11264;
			<Module>.memcpy((void*)ptr, (void*)(&struct3), 512U);
			ptr = ref struct5 + 11776;
			<Module>.memcpy((void*)ptr, *(ref <Module>.struct123_0 + 8) + 1076, 96U);
			ptr = ref struct5 + 12032;
			<Module>.memcpy((void*)ptr, (void*)(&<Module>.struct29_26), 96U);
			ptr = ref struct5 + 24512;
			<Module>.memcpy((void*)ptr, (void*)(&struct2), 32U);
			ptr = ref struct5 + 40960;
			<Module>.memcpy((void*)ptr, (void*)(&struct6), 4096U);
			ptr = ref struct5 + 40960;
			<Module>.memcpy((void*)ptr, (void*)(&@struct), 48U);
			ptr = ref struct5 + 41008;
			<Module>.memcpy((void*)ptr, *(ref <Module>.struct123_0 + 8) + 1252, 16U);
			ptr = ref struct5 + 130816;
			<Module>.memcpy((void*)ptr, *(ref <Module>.struct123_0 + 8) + 1172, 80U);
			<Module>.memcpy(*(ref <Module>.struct121_0 + 7172), (void*)(&struct5), 262144U);
			this.method_121();
		}

		// Token: 0x06000274 RID: 628 RVA: 0x0012A7DC File Offset: 0x0012A7DC
		private unsafe void method_121()
		{
			if (this.bool_2)
			{
				string text = this.string_10 + "\\Dummy.bin";
				for (int i = 1; i < 10; i++)
				{
					if (!File.Exists(text))
					{
						IntPtr intPtr = Marshal.StringToHGlobalAnsi(text);
						IntPtr value = intPtr;
						sbyte* pSbyte_ = (sbyte*)((void*)value);
						GStruct5* ptr = <Module>.fopen((sbyte*)pSbyte_, (sbyte*)(&<Module>.struct18_5));
						if (ptr != null)
						{
							<Module>.fwrite(*(ref <Module>.struct121_0 + 7172), 262144U, 1U, ptr);
							<Module>.fclose(ptr);
							this.textBox6.AppendText("\r\n" + "Dummy.bin file saved to " + text + "\r\n");
							this.method_37(text, 0, *(ref <Module>.struct121_0 + 7172));
							return;
						}
					}
					else
					{
						text = this.string_10 + "\\Dummy_" + Convert.ToString(i) + ".bin";
					}
				}
			}
			SaveFileDialog saveFileDialog = new SaveFileDialog();
			saveFileDialog.Filter = "Firmware Images (*.bin)|*.bin|All Files (*.*)|*.*";
			saveFileDialog.DefaultExt = ".bin";
			saveFileDialog.FileName = "Dummy.bin";
			saveFileDialog.RestoreDirectory = false;
			if (this.bool_2)
			{
				saveFileDialog.InitialDirectory = this.string_10;
			}
			if (saveFileDialog.ShowDialog() == DialogResult.OK)
			{
				string fullPath = Path.GetFullPath(saveFileDialog.FileName);
				string fileName = Path.GetFileName(saveFileDialog.FileName);
				IntPtr intPtr2 = Marshal.StringToHGlobalAnsi(fullPath);
				IntPtr value2 = intPtr2;
				sbyte* pSbyte_2 = (sbyte*)((void*)value2);
				GStruct5* ptr = <Module>.fopen((sbyte*)pSbyte_2, (sbyte*)(&<Module>.struct18_5));
				if (ptr == null)
				{
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					MessageBox.Show(fileName, "Can't open file", MessageBoxButtons.OK);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
				}
				else
				{
					<Module>.fwrite(*(ref <Module>.struct121_0 + 7172), 262144U, 1U, ptr);
					<Module>.fclose(ptr);
					this.textBox6.AppendText("\r\n" + "Dummy.bin file saved to " + fileName + "\r\n");
					this.method_37(fullPath, 0, *(ref <Module>.struct121_0 + 7172));
				}
			}
			else
			{
				this.method_37("", 0, *(ref <Module>.struct121_0 + 7172));
			}
		}

		// Token: 0x06000275 RID: 629 RVA: 0x003C449C File Offset: 0x0030C49C
		private unsafe void method_122()
		{
			uint selectedIndex = (uint)this.comboBox10.SelectedIndex;
			Struct84 @struct;
			<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct10_22), Convert.ToString(new string(ref <Module>.struct122_0 + selectedIndex * 324U)));
			this.pVoid_0 = <Module>.CreateFileA((sbyte*)(&@struct), -1073741824, 0, null, 3, 1073741952, null);
			if (this.pVoid_0 == -1)
			{
				this.textBox6.AppendText("Failed to open com port " + Convert.ToString(new string(ref <Module>.struct122_0 + selectedIndex * 324U)) + "\r\n");
			}
			else if (<Module>.SetCommMask(this.pVoid_0, 256) == null)
			{
				this.textBox6.AppendText("SetCommMask failed with error " + Convert.ToString(<Module>.GetLastError()) + "\r\n");
			}
			else
			{
				GStruct95 gstruct;
				*(ref gstruct + 16) = <Module>.CreateEventA(null, 1, 0, null);
				gstruct = 0;
				*(ref gstruct + 4) = 0;
				*(ref gstruct + 8) = 0;
				*(ref gstruct + 12) = 0;
				if (*(ref gstruct + 16) == 0)
				{
					<Module>._assert((sbyte*)(&<Module>.struct24_8), (sbyte*)(&<Module>.struct96_0), 20114U);
				}
				uint num;
				if (<Module>.WaitCommEvent(this.pVoid_0, (uint*)(&num), &gstruct) != null)
				{
					if ((num & 256U) != 0U)
					{
						this.textBox6.AppendText("Switch Detected, Sending DVDKey_32" + "\r\n");
						if (this.pVoid_0 != null)
						{
							<Module>.CloseHandle(this.pVoid_0);
						}
					}
				}
				else
				{
					uint lastError = <Module>.GetLastError();
					if (997U == lastError)
					{
						this.textBox6.AppendText("USB Xtractor switch enabled" + "\r\n");
						Application.DoEvents();
						<Module>.WaitForSingleObject(*(ref gstruct + 16), -1);
						if ((num & 256U) != 0U)
						{
							this.textBox6.AppendText("USB Xtractor switch Detected, Sending DVDKey_32" + "\r\n");
							<Module>.CloseHandle(this.pVoid_0);
							GStruct11* ptr = <Module>.FindWindowExA(this.pGstruct11_0, null, null, (sbyte*)(&<Module>.struct16_1));
							IntPtr intPtr = Marshal.StringToHGlobalAnsi("DoDVDKey");
							IntPtr value = intPtr;
							<Module>.SendMessageA(ptr, 12U, 0U, (void*)value);
						}
						else
						{
							this.textBox6.AppendText("USB Xtractor switch disabled" + "\r\n");
							while (this.pVoid_0 != null)
							{
								<Module>.CloseHandle(this.pVoid_0);
							}
						}
					}
					else
					{
						this.textBox6.AppendText("Wait failed with error " + Convert.ToString(<Module>.GetLastError()) + "\r\n");
					}
				}
			}
		}

		// Token: 0x06000276 RID: 630 RVA: 0x0012AC6C File Offset: 0x0012AC6C
		private void method_123()
		{
			Thread thread = new Thread(new ThreadStart(this.method_122));
			thread.Start();
		}

		// Token: 0x06000277 RID: 631 RVA: 0x0012AC94 File Offset: 0x0012AC94
		private unsafe void method_124()
		{
			int selectedIndex = this.comboBox10.SelectedIndex;
			if (this.pVoid_0 != null)
			{
				<Module>.SetCommMask(this.pVoid_0, 64);
			}
			if (this.checkBox9.CheckState == CheckState.Checked && *(ref <Module>.struct122_0 + selectedIndex * 324 + 8) == 2)
			{
				if (this.method_146() == 1)
				{
					this.textBox6.AppendText("USB Xtractor Found on " + Convert.ToString(new string(ref <Module>.struct122_0 + selectedIndex * 324)) + "\r\n");
					this.method_123();
				}
				else
				{
					this.textBox6.AppendText(Convert.ToString(new string(ref <Module>.struct122_0 + selectedIndex * 324)) + " could not be opened" + "\r\n");
				}
			}
		}

		// Token: 0x06000278 RID: 632 RVA: 0x0012AD5C File Offset: 0x0012AD5C
		private unsafe void tabControl5_SelectedIndexChanged(object sender, EventArgs e)
		{
			uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
			uint count = (uint)this.comboBox1.Items.Count;
			ushort num = *(ref <Module>.struct38_0 + selectedIndex * 72U);
			if (this.tabControl5.SelectedTab != this.DVDKey32 && this.pVoid_0 != null)
			{
				<Module>.SetCommMask(this.pVoid_0, 64);
			}
			if (this.tabControl5.SelectedTab == this.Hitachi && this.radioButton17.Checked && num == 0 && count != 0U && !this.bool_9)
			{
				this.method_424(1);
				this.bool_9 = true;
				<Module>.Sleep(10);
				this.method_424(5);
				<Module>.Sleep(25);
				this.method_424(7);
			}
		}

		// Token: 0x06000279 RID: 633 RVA: 0x0012AE18 File Offset: 0x0012AE18
		private unsafe int method_125(byte byte_0)
		{
			Struct77 @struct = 79;
			*(ref @struct + 1) = 75;
			*(ref @struct + 2) = 0;
			*(ref @struct + 3) = 48;
			*(ref @struct + 4) = 49;
			*(ref @struct + 5) = 0;
			GStruct95 gstruct = 0;
			initblk(ref gstruct + 4, 0, 16);
			GStruct95 gstruct2 = 0;
			initblk(ref gstruct2 + 4, 0, 16);
			GStruct96 gstruct3 = 0;
			initblk(ref gstruct3 + 4, 0, 24);
			gstruct3 = 28;
			uint selectedIndex = (uint)this.comboBox10.SelectedIndex;
			*(ref @struct + 3) = (byte)(((byte_0 & 240) >> 4) + 48);
			*(ref @struct + 4) = (byte_0 & 15) + 48;
			if (byte_0 == 1)
			{
				this.label135.Text = "xt2: Opening";
				Application.DoEvents();
			}
			if (byte_0 == 2)
			{
				this.label135.Text = "xt2: Closing";
				Application.DoEvents();
			}
			if (byte_0 == 3)
			{
				this.label135.Text = "xt2: Half Tray";
				Application.DoEvents();
			}
			if (byte_0 == 10)
			{
				*(ref @struct + 4) = 65;
				this.label135.Text = "xt2: Power Off";
				Application.DoEvents();
			}
			if (byte_0 == 11)
			{
				*(ref @struct + 4) = 66;
				this.label135.Text = "xt2: Power On";
				Application.DoEvents();
			}
			if (byte_0 == 12)
			{
				*(ref @struct + 4) = 67;
				this.label135.Text = "xt2: Power Cycle";
				Application.DoEvents();
			}
			Thread thread = new Thread(new ThreadStart(this.method_165));
			thread.Start();
			Struct84 struct2;
			<Module>.sprintf((sbyte*)(&struct2), (sbyte*)(&<Module>.struct10_22), Convert.ToString(new string(ref <Module>.struct122_0 + selectedIndex * 324U)));
			void* ptr = <Module>.CreateFileA((sbyte*)(&struct2), -1073741824, 0, null, 3, 1073741952, null);
			int result;
			if (ptr == -1)
			{
				this.textBox6.AppendText("Failed to open com port " + Convert.ToString(new string(ref <Module>.struct122_0 + selectedIndex * 324U)) + "\r\n");
				result = 0;
			}
			else
			{
				<Module>.GetCommState(ptr, &gstruct3);
				*(ref gstruct3 + 4) = 19200;
				*(ref gstruct3 + 18) = 8;
				*(ref gstruct3 + 19) = 0;
				*(ref gstruct3 + 20) = 0;
				*(ref gstruct3 + 8) = ((*(ref gstruct3 + 8) & -49) | 16);
				*(ref gstruct3 + 8) = ((*(ref gstruct3 + 8) & -12289) | 4096);
				*(ref gstruct3 + 8) = (*(ref gstruct3 + 8) & -257);
				*(ref gstruct3 + 8) = (*(ref gstruct3 + 8) & -513);
				<Module>.SetCommState(ptr, &gstruct3);
				GStruct94 gstruct4 = 100;
				*(ref gstruct4 + 8) = 10;
				*(ref gstruct4 + 4) = 100;
				*(ref gstruct4 + 16) = 10;
				*(ref gstruct4 + 12) = 100;
				<Module>.SetCommTimeouts(ptr, &gstruct4);
				Struct63 struct3;
				<Module>.memset((void*)(&struct3), 0, 4U);
				Struct77 struct4;
				<Module>.memset((void*)(&struct4), 0, 6U);
				struct3 = 64;
				*(ref struct3 + 1) = 85;
				*(ref struct3 + 2) = byte_0;
				*(ref struct3 + 3) = 64;
				*(ref gstruct + 16) = <Module>.CreateEventA(null, 1, 0, null);
				*(ref gstruct2 + 16) = <Module>.CreateEventA(null, 1, 0, null);
				uint num;
				<Module>.WriteFile(ptr, (void*)(&struct3), 4, (uint*)(&num), &gstruct2);
				<Module>.GetOverlappedResult(ptr, &gstruct2, (uint*)(&num), 1);
				uint num2;
				<Module>.ReadFile(ptr, (void*)(&struct4), 6, (uint*)(&num2), &gstruct);
				<Module>.GetOverlappedResult(ptr, &gstruct, (uint*)(&num2), 1);
				if (<Module>.memcmp((void*)(&struct4), (void*)(&@struct), 6U) == null)
				{
					if (ptr != -1)
					{
						<Module>.CloseHandle(ptr);
					}
					result = 1;
				}
				else if (<Module>.memcmp(ref struct4 + 1, (void*)(&@struct), 5U) == null)
				{
					if (ptr != -1)
					{
						<Module>.CloseHandle(ptr);
					}
					result = 1;
				}
				else
				{
					if (ptr != -1)
					{
						<Module>.CloseHandle(ptr);
					}
					result = 0;
				}
			}
			return result;
		}

		// Token: 0x0600027A RID: 634 RVA: 0x0012B144 File Offset: 0x0012B144
		private void menuItem_25_Click(object sender, EventArgs e)
		{
			this.method_126();
		}

		// Token: 0x0600027B RID: 635 RVA: 0x0012B158 File Offset: 0x0012B158
		private void menuItem_26_Click(object sender, EventArgs e)
		{
			this.method_127();
		}

		// Token: 0x0600027C RID: 636 RVA: 0x0012B16C File Offset: 0x0012B16C
		private void menuItem_27_Click(object sender, EventArgs e)
		{
			this.method_128();
		}

		// Token: 0x0600027D RID: 637 RVA: 0x0012B180 File Offset: 0x0012B180
		private void menuItem_28_Click(object sender, EventArgs e)
		{
			this.method_129();
		}

		// Token: 0x0600027E RID: 638 RVA: 0x0012B194 File Offset: 0x0012B194
		private void menuItem_30_Click(object sender, EventArgs e)
		{
			this.method_130();
		}

		// Token: 0x0600027F RID: 639 RVA: 0x0012B1A8 File Offset: 0x0012B1A8
		private void menuItem_31_Click(object sender, EventArgs e)
		{
			this.method_131();
		}

		// Token: 0x06000280 RID: 640 RVA: 0x0012B1BC File Offset: 0x0012B1BC
		private void button43_Click(object sender, EventArgs e)
		{
			this.method_129();
		}

		// Token: 0x06000281 RID: 641 RVA: 0x0012B1D0 File Offset: 0x0012B1D0
		private void button44_Click(object sender, EventArgs e)
		{
			this.method_130();
		}

		// Token: 0x06000282 RID: 642 RVA: 0x0012B1E4 File Offset: 0x0012B1E4
		private void button45_Click(object sender, EventArgs e)
		{
			this.method_131();
		}

		// Token: 0x06000283 RID: 643 RVA: 0x0012B1F8 File Offset: 0x0012B1F8
		private void button46_Click(object sender, EventArgs e)
		{
			this.method_126();
		}

		// Token: 0x06000284 RID: 644 RVA: 0x0012B20C File Offset: 0x0012B20C
		private void button47_Click(object sender, EventArgs e)
		{
			this.method_127();
		}

		// Token: 0x06000285 RID: 645 RVA: 0x0012B220 File Offset: 0x0012B220
		private void button48_Click(object sender, EventArgs e)
		{
			this.method_128();
		}

		// Token: 0x06000286 RID: 646 RVA: 0x0012B234 File Offset: 0x0012B234
		private void menuItem_35_Click(object sender, EventArgs e)
		{
			string text = null;
			RegistryKey registryKey = Registry.CurrentUser.CreateSubKey("JungleFlasher");
			if (registryKey.GetValue("HalfTrayDelay") != null)
			{
				text = registryKey.GetValue("HalfTrayDelay").ToString();
			}
			else if (registryKey.GetValue("HalfTrayDelay") == null)
			{
				registryKey.SetValue("HalfTrayDelay", "250");
				text = "250";
			}
			text = Convert.ToString(Convert.ToInt32(text) + 50);
			registryKey.SetValue("HalfTrayDelay", text);
			this.menuItem_34.Text = text + "mS";
		}

		// Token: 0x06000287 RID: 647 RVA: 0x0012B2CC File Offset: 0x0012B2CC
		private void menuItem_36_Click(object sender, EventArgs e)
		{
			string text = null;
			RegistryKey registryKey = Registry.CurrentUser.CreateSubKey("JungleFlasher");
			if (registryKey.GetValue("HalfTrayDelay") != null)
			{
				text = registryKey.GetValue("HalfTrayDelay").ToString();
			}
			else if (registryKey.GetValue("HalfTrayDelay") == null)
			{
				registryKey.SetValue("HalfTrayDelay", "250");
				text = "250";
			}
			text = Convert.ToString(Convert.ToInt32(text) - 50);
			registryKey.SetValue("HalfTrayDelay", text);
			this.menuItem_34.Text = text + "mS";
		}

		// Token: 0x06000288 RID: 648 RVA: 0x0012B364 File Offset: 0x0012B364
		private unsafe int method_126()
		{
			int selectedIndex = this.comboBox10.SelectedIndex;
			int result;
			if (*(ref <Module>.struct122_0 + selectedIndex * 324 + 8) == 8 && this.checkBox9.CheckState == CheckState.Checked)
			{
				this.method_125(33);
				this.method_125(1);
				this.method_125(32);
				result = 1;
			}
			else if (*(ref <Module>.struct122_0 + selectedIndex * 324 + 8) == 6 && this.checkBox9.CheckState == CheckState.Checked)
			{
				this.method_164(1U);
				result = 1;
			}
			else if (*(ref <Module>.struct122_0 + selectedIndex * 324 + 8) == 9 && this.checkBox9.CheckState == CheckState.Checked)
			{
				this.method_135();
				this.method_143();
				this.method_138();
				result = 1;
			}
			else
			{
				result = 0;
			}
			return result;
		}

		// Token: 0x06000289 RID: 649 RVA: 0x0012B424 File Offset: 0x0012B424
		private unsafe int method_127()
		{
			int selectedIndex = this.comboBox10.SelectedIndex;
			int result;
			if (*(ref <Module>.struct122_0 + selectedIndex * 324 + 8) == 8 && this.checkBox9.CheckState == CheckState.Checked)
			{
				this.method_125(33);
				this.method_125(2);
				this.method_125(32);
				result = 1;
			}
			else if (*(ref <Module>.struct122_0 + selectedIndex * 324 + 8) == 6 && this.checkBox9.CheckState == CheckState.Checked)
			{
				this.method_164(2U);
				result = 1;
			}
			else if (*(ref <Module>.struct122_0 + selectedIndex * 324 + 8) == 9 && this.checkBox9.CheckState == CheckState.Checked)
			{
				this.method_135();
				this.method_144();
				this.method_138();
				result = 1;
			}
			else
			{
				result = 0;
			}
			return result;
		}

		// Token: 0x0600028A RID: 650 RVA: 0x0012B4E4 File Offset: 0x0012B4E4
		private unsafe int method_128()
		{
			string value = null;
			int selectedIndex = this.comboBox10.SelectedIndex;
			RegistryKey registryKey = Registry.CurrentUser.CreateSubKey("JungleFlasher");
			if (registryKey.GetValue("HalfTrayDelay") != null)
			{
				value = registryKey.GetValue("HalfTrayDelay").ToString();
			}
			else if (registryKey.GetValue("HalfTrayDelay") == null)
			{
				registryKey.SetValue("HalfTrayDelay", "250");
				value = "250";
			}
			int result;
			if (*(ref <Module>.struct122_0 + selectedIndex * 324 + 8) == 8 && this.checkBox9.CheckState == CheckState.Checked)
			{
				this.method_125(33);
				this.method_125(1);
				<Module>.Sleep(Convert.ToInt32(value));
				this.method_125(12);
				this.method_125(32);
				result = 1;
			}
			else if (*(ref <Module>.struct122_0 + selectedIndex * 324 + 8) == 6 && this.checkBox9.CheckState == CheckState.Checked)
			{
				this.method_164(1U);
				<Module>.Sleep(Convert.ToInt32(value));
				this.method_164(10U);
				<Module>.Sleep(250);
				this.method_164(11U);
				result = 1;
			}
			else if (*(ref <Module>.struct122_0 + selectedIndex * 324 + 8) == 9 && this.checkBox9.CheckState == CheckState.Checked)
			{
				this.method_135();
				this.method_143();
				<Module>.Sleep(Convert.ToInt32(value));
				this.method_142();
				<Module>.Sleep(250);
				this.method_141();
				this.method_138();
				result = 1;
			}
			else
			{
				result = 0;
			}
			return result;
		}

		// Token: 0x0600028B RID: 651 RVA: 0x0012B658 File Offset: 0x0012B658
		private unsafe int method_129()
		{
			int selectedIndex = this.comboBox10.SelectedIndex;
			int result;
			if (*(ref <Module>.struct122_0 + selectedIndex * 324 + 8) == 8 && this.checkBox9.CheckState == CheckState.Checked)
			{
				this.method_125(33);
				this.method_125(11);
				this.method_125(32);
				result = 1;
			}
			else if (*(ref <Module>.struct122_0 + selectedIndex * 324 + 8) == 6 && this.checkBox9.CheckState == CheckState.Checked)
			{
				this.method_164(11U);
				result = 1;
			}
			else if (*(ref <Module>.struct122_0 + selectedIndex * 324 + 8) == 9 && this.checkBox9.CheckState == CheckState.Checked)
			{
				this.method_135();
				this.method_141();
				this.method_138();
				result = 1;
			}
			else
			{
				result = 0;
			}
			return result;
		}

		// Token: 0x0600028C RID: 652 RVA: 0x0012B718 File Offset: 0x0012B718
		private unsafe int method_130()
		{
			int selectedIndex = this.comboBox10.SelectedIndex;
			int result;
			if (*(ref <Module>.struct122_0 + selectedIndex * 324 + 8) == 8 && this.checkBox9.CheckState == CheckState.Checked)
			{
				this.method_125(33);
				this.method_125(10);
				this.method_125(32);
				result = 1;
			}
			else if (*(ref <Module>.struct122_0 + selectedIndex * 324 + 8) == 6 && this.checkBox9.CheckState == CheckState.Checked)
			{
				this.method_164(10U);
				result = 1;
			}
			else if (*(ref <Module>.struct122_0 + selectedIndex * 324 + 8) == 9 && this.checkBox9.CheckState == CheckState.Checked)
			{
				this.method_135();
				this.method_142();
				this.method_138();
				result = 1;
			}
			else
			{
				result = 0;
			}
			return result;
		}

		// Token: 0x0600028D RID: 653 RVA: 0x0012B7D8 File Offset: 0x0012B7D8
		private unsafe int method_131()
		{
			int selectedIndex = this.comboBox10.SelectedIndex;
			int result;
			if (*(ref <Module>.struct122_0 + selectedIndex * 324 + 8) == 8 && this.checkBox9.CheckState == CheckState.Checked)
			{
				this.method_125(33);
				this.method_125(12);
				this.method_125(32);
				result = 1;
			}
			else if (*(ref <Module>.struct122_0 + selectedIndex * 324 + 8) == 6 && this.checkBox9.CheckState == CheckState.Checked)
			{
				this.method_164(10U);
				<Module>.Sleep(250);
				this.method_164(11U);
				result = 1;
			}
			else if (*(ref <Module>.struct122_0 + selectedIndex * 324 + 8) == 9 && this.checkBox9.CheckState == CheckState.Checked)
			{
				this.method_135();
				this.method_142();
				<Module>.Sleep(250);
				this.method_141();
				this.method_138();
				result = 1;
			}
			else
			{
				result = 0;
			}
			return result;
		}

		// Token: 0x0600028E RID: 654 RVA: 0x0012B8BC File Offset: 0x0012B8BC
		private unsafe void method_132()
		{
			int selectedIndex = this.comboBox10.SelectedIndex;
			if (*(ref <Module>.struct122_0 + selectedIndex * 324 + 8) == 8 && this.checkBox9.CheckState == CheckState.Checked)
			{
				<Module>.Sleep(250);
				this.method_125(33);
				this.method_125(11);
				this.method_125(32);
			}
			else if (*(ref <Module>.struct122_0 + selectedIndex * 324 + 8) == 6 && this.checkBox9.CheckState == CheckState.Checked)
			{
				<Module>.Sleep(250);
				this.method_164(11U);
			}
			else if (*(ref <Module>.struct122_0 + selectedIndex * 324 + 8) == 9 && this.checkBox9.CheckState == CheckState.Checked)
			{
				this.method_135();
				<Module>.Sleep(250);
				this.method_141();
				this.method_138();
			}
		}

		// Token: 0x0600028F RID: 655 RVA: 0x0012B994 File Offset: 0x0012B994
		private unsafe void method_133()
		{
			int selectedIndex = this.comboBox10.SelectedIndex;
			if (*(ref <Module>.struct122_0 + selectedIndex * 324 + 8) == 8 && this.checkBox9.CheckState == CheckState.Checked)
			{
				<Module>.Sleep(250);
				this.method_125(33);
				this.method_125(10);
				<Module>.Sleep(500);
				this.method_125(11);
				this.method_125(32);
			}
			else if (*(ref <Module>.struct122_0 + selectedIndex * 324 + 8) == 6 && this.checkBox9.CheckState == CheckState.Checked)
			{
				this.method_164(10U);
				<Module>.Sleep(500);
				this.method_164(11U);
			}
			else if (*(ref <Module>.struct122_0 + selectedIndex * 324 + 8) == 9 && this.checkBox9.CheckState == CheckState.Checked)
			{
				<Module>.Sleep(250);
				this.method_135();
				this.method_142();
				<Module>.Sleep(500);
				this.method_141();
				this.method_138();
			}
		}

		// Token: 0x06000290 RID: 656 RVA: 0x0012BA98 File Offset: 0x0012BA98
		private unsafe int method_134()
		{
			int selectedIndex = this.comboBox10.SelectedIndex;
			return (*(ref <Module>.struct122_0 + selectedIndex * 324 + 8) != 8 || this.checkBox9.CheckState != CheckState.Checked) ? ((*(ref <Module>.struct122_0 + selectedIndex * 324 + 8) != 6 || this.checkBox9.CheckState != CheckState.Checked) ? ((*(ref <Module>.struct122_0 + selectedIndex * 324 + 8) != 9 || this.checkBox9.CheckState != CheckState.Checked) ? 0 : 1) : 1) : 1;
		}

		// Token: 0x06000291 RID: 657 RVA: 0x0012BB24 File Offset: 0x0012BB24
		private unsafe int method_135()
		{
			int selectedIndex = this.comboBox10.SelectedIndex;
			if (*(ref <Module>.struct122_0 + selectedIndex * 324 + 8) == 9)
			{
				Struct84 @struct;
				<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct10_22), Convert.ToString(new string(ref <Module>.struct122_0 + selectedIndex * 324)));
				this.pVoid_1 = <Module>.CreateFileA((sbyte*)(&@struct), -1073741824, 0, null, 3, 1073741952, null);
			}
			int result;
			if (this.pVoid_1 == -1)
			{
				this.textBox6.AppendText("Failed to open com port " + Convert.ToString(new string(ref <Module>.struct122_0 + selectedIndex * 324)) + "\r\n");
				result = 0;
			}
			else
			{
				result = 1;
			}
			return result;
		}

		// Token: 0x06000292 RID: 658 RVA: 0x0012BBD0 File Offset: 0x0012BBD0
		private void method_136()
		{
			<Module>.smethod_135(this.pVoid_1, 1);
			this.method_141();
			this.method_139();
		}

		// Token: 0x06000293 RID: 659 RVA: 0x0012BBF8 File Offset: 0x0012BBF8
		private void method_137()
		{
			<Module>.smethod_135(this.pVoid_1, 0);
			this.method_142();
			this.method_140();
		}

		// Token: 0x06000294 RID: 660 RVA: 0x0012BC20 File Offset: 0x0012BC20
		private void method_138()
		{
			if (this.pVoid_1 != null)
			{
				<Module>.CloseHandle(this.pVoid_1);
			}
			this.pVoid_1 = null;
		}

		// Token: 0x06000295 RID: 661 RVA: 0x0012BC48 File Offset: 0x0012BC48
		private unsafe void method_139()
		{
			byte b;
			<Module>.smethod_139(this.pVoid_1, &b);
			if (b == 0)
			{
				b = 0;
			}
			else if (b == 1)
			{
				b = 0;
			}
			else if (b == 2)
			{
				b = 2;
			}
			else if (b == 3)
			{
				b = 2;
			}
			<Module>.smethod_138(this.pVoid_1, b);
		}

		// Token: 0x06000296 RID: 662 RVA: 0x0012BC90 File Offset: 0x0012BC90
		private unsafe void method_140()
		{
			byte b;
			<Module>.smethod_139(this.pVoid_1, &b);
			if (b == 0)
			{
				b = 1;
			}
			else if (b == 1)
			{
				b = 1;
			}
			else if (b == 2)
			{
				b = 3;
			}
			else if (b == 3)
			{
				b = 3;
			}
			<Module>.smethod_138(this.pVoid_1, b);
		}

		// Token: 0x06000297 RID: 663 RVA: 0x0012BCD8 File Offset: 0x0012BCD8
		private unsafe void method_141()
		{
			byte b;
			<Module>.smethod_139(this.pVoid_1, &b);
			if (b == 0)
			{
				b = 0;
			}
			else if (b == 1)
			{
				b = 1;
			}
			else if (b == 2)
			{
				b = 0;
			}
			else if (b == 3)
			{
				b = 1;
			}
			<Module>.smethod_138(this.pVoid_1, b);
		}

		// Token: 0x06000298 RID: 664 RVA: 0x0012BD20 File Offset: 0x0012BD20
		private unsafe void method_142()
		{
			byte b;
			<Module>.smethod_139(this.pVoid_1, &b);
			if (b == 0)
			{
				b = 2;
			}
			else if (b == 1)
			{
				b = 3;
			}
			else if (b == 2)
			{
				b = 2;
			}
			else if (b == 3)
			{
				b = 3;
			}
			<Module>.smethod_138(this.pVoid_1, b);
		}

		// Token: 0x06000299 RID: 665 RVA: 0x0012BD68 File Offset: 0x0012BD68
		private void method_143()
		{
			<Module>.smethod_137(this.pVoid_1, 1);
		}

		// Token: 0x0600029A RID: 666 RVA: 0x0012BD84 File Offset: 0x0012BD84
		private void method_144()
		{
			<Module>.smethod_137(this.pVoid_1, 0);
		}

		// Token: 0x0600029B RID: 667 RVA: 0x0012BDA0 File Offset: 0x0012BDA0
		private unsafe int method_145()
		{
			this.int_0 = 0;
			int num = <Module>.smethod_118((GStruct99*)(&<Module>.struct122_0), 0, 32);
			<Module>.smethod_131();
			this.comboBox10.Items.Clear();
			int result;
			if (num == 0)
			{
				result = 0;
			}
			else
			{
				for (int i = 0; i < num; i++)
				{
					if (*(ref <Module>.struct122_0 + i * 324 + 8) == 7)
					{
						*(ref <Module>.struct122_0 + i * 324 + 8) = 7;
					}
					else if (*(ref <Module>.struct122_0 + i * 324 + 8) == 6)
					{
						*(ref <Module>.struct122_0 + i * 324 + 8) = 6;
					}
					else if (*(ref <Module>.struct122_0 + i * 324 + 8) == 9)
					{
						*(ref <Module>.struct122_0 + i * 324 + 8) = 9;
					}
					else if (*(ref <Module>.struct122_0 + i * 324 + 8) == 4)
					{
						if (*(ref <Module>.struct122_0 + i * 324 + 320) == 2)
						{
							for (int j = 0; j < num; j++)
							{
								if (*(ref <Module>.struct122_0 + j * 324 + 8) == 7 && *(ref <Module>.struct122_0 + i * 324 + 316) == *(ref <Module>.struct122_0 + j * 324 + 316))
								{
									*(ref <Module>.struct122_0 + i * 324 + 8) = 6;
								}
							}
						}
						else if (<Module>.memcmp(ref <Module>.struct122_0 + i * 324 + 193, (void*)(&<Module>.struct66_1), 19U) == null)
						{
							*(ref <Module>.struct122_0 + i * 324 + 8) = 5;
						}
						else if (<Module>.memcmp(ref <Module>.struct122_0 + i * 324 + 193, (void*)(&<Module>.struct13_2), 20U) == null)
						{
							*(ref <Module>.struct122_0 + i * 324 + 8) = 5;
						}
						else
						{
							*(ref <Module>.struct122_0 + i * 324 + 8) = 0;
						}
					}
					else if (<Module>.memcmp(ref <Module>.struct122_0 + i * 324 + 193, (void*)(&<Module>.struct15_6), 12U) == null)
					{
						*(ref <Module>.struct122_0 + i * 324 + 8) = 2;
					}
					else if (<Module>.memcmp(ref <Module>.struct122_0 + i * 324 + 193, (void*)(&<Module>.struct65_9), 14U) == null)
					{
						*(ref <Module>.struct122_0 + i * 324 + 8) = 8;
					}
					else if (<Module>.memcmp(ref <Module>.struct122_0 + i * 324 + 193, (void*)(&<Module>.struct15_7), 12U) == null)
					{
						*(ref <Module>.struct122_0 + i * 324 + 8) = 3;
					}
					else if (<Module>.memcmp(ref <Module>.struct122_0 + i * 324 + 193, (void*)(&<Module>.struct74_4), 10U) == null)
					{
						*(ref <Module>.struct122_0 + i * 324 + 8) = 20;
					}
				}
				for (int i = 0; i < num; i++)
				{
					this.comboBox10.Items.Add(Convert.ToString(new string(ref <Module>.struct122_0 + i * 324)));
				}
				result = num;
			}
			return result;
		}

		// Token: 0x0600029C RID: 668 RVA: 0x0012C090 File Offset: 0x0012C090
		private unsafe int method_146()
		{
			int selectedIndex = this.comboBox10.SelectedIndex;
			string s = Convert.ToString(this.comboBox10.Text);
			IntPtr intPtr = Marshal.StringToHGlobalAnsi(s);
			IntPtr value = intPtr;
			sbyte* ptr = (sbyte*)((void*)value);
			Struct84 @struct;
			<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct10_22), ptr);
			this.label103.Text = "Checking.";
			Application.DoEvents();
			void* ptr2 = <Module>.CreateFileA((sbyte*)(&@struct), -1073741824, 0, null, 3, 1073741952, null);
			int result;
			if (ptr2 == -1)
			{
				this.label103.Text = "Checking..";
				Application.DoEvents();
				this.label103.Text = "Checking...";
				Application.DoEvents();
				*(ref <Module>.struct122_0 + selectedIndex * 324 + 72) = 0;
				<Module>.CloseHandle(ptr2);
				this.label103.Text = "Not available";
				result = 0;
			}
			else
			{
				this.label103.Text = "Checking..";
				Application.DoEvents();
				this.label103.Text = "Checking...";
				Application.DoEvents();
				*(ref <Module>.struct122_0 + selectedIndex * 324 + 72) = 1;
				if (*(ref <Module>.struct122_0 + selectedIndex * 324 + 8) == 10)
				{
					this.label103.Text = "Fax Modem Detected:";
					Application.DoEvents();
					<Module>.Sleep(1000);
					this.label103.Text = "Auto-Dialing 911..";
					Application.DoEvents();
					<Module>.Sleep(500);
					this.label103.Text = "Auto-Dialing 911....";
					Application.DoEvents();
					<Module>.Sleep(500);
					this.label103.Text = "Auto-Dialing 911......";
					Application.DoEvents();
					<Module>.Sleep(500);
				}
				<Module>.CloseHandle(ptr2);
				this.label103.Text = "Ready";
				result = 1;
			}
			return result;
		}

		// Token: 0x0600029D RID: 669 RVA: 0x0012C250 File Offset: 0x0012C250
		private unsafe int method_147()
		{
			int selectedIndex = this.comboBox10.SelectedIndex;
			string s = Convert.ToString(this.comboBox10.Text);
			IntPtr intPtr = Marshal.StringToHGlobalAnsi(s);
			IntPtr value = intPtr;
			sbyte* ptr = (sbyte*)((void*)value);
			Struct84 @struct;
			<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct10_22), ptr);
			void* ptr2 = <Module>.CreateFileA((sbyte*)(&@struct), -1073741824, 0, null, 3, 1073741952, null);
			int result;
			if (ptr2 == -1)
			{
				<Module>.CloseHandle(ptr2);
				*(ref <Module>.struct122_0 + selectedIndex * 324 + 72) = 0;
				result = 0;
			}
			else
			{
				<Module>.CloseHandle(ptr2);
				*(ref <Module>.struct122_0 + selectedIndex * 324 + 72) = 1;
				result = 1;
			}
			return result;
		}

		// Token: 0x0600029E RID: 670 RVA: 0x0012C2F0 File Offset: 0x0012C2F0
		private void comboBox10_SelectedIndexChanged(object sender, EventArgs e)
		{
			this.label135.Text = "";
			this.method_148();
		}

		// Token: 0x0600029F RID: 671 RVA: 0x0012C314 File Offset: 0x0012C314
		private unsafe void method_148()
		{
			string strA = null;
			if (this.comboBox10.Items.Count == 0)
			{
				this.label102.Text = new string((sbyte*)(&<Module>.struct19_0));
				this.label103.Text = new string((sbyte*)(&<Module>.struct19_0));
				this.label104.Text = new string((sbyte*)(&<Module>.struct19_0));
				this.label105.Text = new string((sbyte*)(&<Module>.struct19_0));
				this.checkBox9.Enabled = false;
			}
			else
			{
				int selectedIndex = this.comboBox10.SelectedIndex;
				if (this.pVoid_0 != null)
				{
					<Module>.SetCommMask(this.pVoid_0, 64);
				}
				RegistryKey registryKey = Registry.CurrentUser.CreateSubKey("JungleFlasher");
				if (registryKey.GetValue(Convert.ToString(new string(ref <Module>.struct122_0 + selectedIndex * 324))) != null)
				{
					strA = registryKey.GetValue(Convert.ToString(new string(ref <Module>.struct122_0 + selectedIndex * 324))).ToString();
				}
				registryKey.Close();
				if (string.Compare(strA, "XT2") == 0)
				{
					*(ref <Module>.struct122_0 + selectedIndex * 324 + 8) = 8;
				}
				else if (string.Compare(strA, "CK3CP") == 0)
				{
					*(ref <Module>.struct122_0 + selectedIndex * 324 + 8) = 6;
				}
				this.label102.Text = Convert.ToString(new string(ref <Module>.struct122_0 + selectedIndex * 324));
				if (*(ref <Module>.struct122_0 + selectedIndex * 324 + 8) == 0)
				{
					this.label104.Text = new string((sbyte*)(&<Module>.struct25_10));
					this.checkBox9.Enabled = false;
				}
				else if (*(ref <Module>.struct122_0 + selectedIndex * 324 + 8) == 1)
				{
					this.label104.Text = new string((sbyte*)(&<Module>.struct24_9));
					this.checkBox9.Enabled = false;
				}
				else if (*(ref <Module>.struct122_0 + selectedIndex * 324 + 8) == 2)
				{
					this.label104.Text = new string((sbyte*)(&<Module>.struct97_0));
					this.checkBox9.Enabled = true;
				}
				else if (*(ref <Module>.struct122_0 + selectedIndex * 324 + 8) == 3)
				{
					this.label104.Text = new string((sbyte*)(&<Module>.struct97_1));
					this.checkBox9.Enabled = false;
				}
				else if (*(ref <Module>.struct122_0 + selectedIndex * 324 + 8) == 4)
				{
					this.label104.Text = new string((sbyte*)(&<Module>.struct98_0));
					this.checkBox9.Enabled = false;
				}
				else if (*(ref <Module>.struct122_0 + selectedIndex * 324 + 8) == 5)
				{
					this.label104.Text = new string((sbyte*)(&<Module>.struct1_4));
					this.checkBox9.Enabled = false;
				}
				else if (*(ref <Module>.struct122_0 + selectedIndex * 324 + 8) == 6)
				{
					this.label104.Text = new string((sbyte*)(&<Module>.struct66_2));
					this.checkBox9.Enabled = true;
				}
				else if (*(ref <Module>.struct122_0 + selectedIndex * 324 + 8) == 7)
				{
					this.label104.Text = new string((sbyte*)(&<Module>.struct66_3));
					this.checkBox9.Enabled = false;
				}
				else if (*(ref <Module>.struct122_0 + selectedIndex * 324 + 8) == 8)
				{
					this.label104.Text = new string((sbyte*)(&<Module>.struct99_0));
					this.checkBox9.Enabled = true;
				}
				else if (*(ref <Module>.struct122_0 + selectedIndex * 324 + 8) == 9)
				{
					this.label104.Text = new string((sbyte*)(&<Module>.struct15_8));
					this.checkBox9.Enabled = true;
				}
				this.label105.Text = Convert.ToString(new string(ref <Module>.struct122_0 + selectedIndex * 324 + 12));
				if (this.tabControl5.SelectedTab == this.DVDKey32)
				{
					this.method_146();
					if (this.checkBox9.CheckState == CheckState.Checked)
					{
						if (*(ref <Module>.struct122_0 + selectedIndex * 324 + 8) == 2)
						{
							this.textBox6.AppendText("USB Xtractor Found on " + Convert.ToString(new string(ref <Module>.struct122_0 + selectedIndex * 324)) + "\r\n");
							this.method_123();
						}
						if (*(ref <Module>.struct122_0 + selectedIndex * 324 + 8) == 6)
						{
							this.method_166(17U);
						}
						if (*(ref <Module>.struct122_0 + selectedIndex * 324 + 8) == 9)
						{
							this.method_150();
							this.label135.Text = "CK3i: Enabled";
							Thread thread = new Thread(new ThreadStart(this.method_165));
							thread.Start();
							if (this.method_135() == 1)
							{
								this.method_136();
								this.method_138();
							}
						}
						if (*(ref <Module>.struct122_0 + selectedIndex * 324 + 8) == 8)
						{
							this.label135.Text = "xt2: Enabled";
							Thread thread2 = new Thread(new ThreadStart(this.method_165));
							thread2.Start();
						}
					}
				}
			}
		}

		// Token: 0x060002A0 RID: 672 RVA: 0x003C4700 File Offset: 0x0030C700
		private unsafe void button8_Click(object sender, EventArgs e)
		{
			if (this.method_145() != 0)
			{
				this.textBox6.AppendText("Found " + Convert.ToString(this.comboBox10.Items.Count) + " Com Ports.");
				this.textBox6.AppendText("\r\n");
				if (Convert.ToInt16(this.string_12) == -1 && this.comboBox10.Items.Count > 0)
				{
					this.comboBox10.SelectedIndex = 0;
					this.method_148();
				}
				else if ((int)Convert.ToInt16(this.string_12) > this.comboBox10.Items.Count - 1)
				{
					this.comboBox10.SelectedIndex = 0;
					this.method_148();
				}
				else
				{
					this.comboBox10.SelectedIndex = 0;
					this.comboBox10.SelectedIndex = (int)Convert.ToInt16(this.string_12);
				}
			}
			else
			{
				this.comboBox10.Text = new string((sbyte*)(&<Module>.struct19_0));
				this.label102.Text = new string((sbyte*)(&<Module>.struct19_0));
				this.label103.Text = new string((sbyte*)(&<Module>.struct19_0));
				this.label104.Text = new string((sbyte*)(&<Module>.struct19_0));
				this.label105.Text = new string((sbyte*)(&<Module>.struct19_0));
				this.checkBox9.Enabled = false;
				<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
				MessageBox.Show("No comports were found during enumeration!", "JungleFlasher", MessageBoxButtons.OK);
				<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
				this.textBox6.AppendText("Found 0 Com Ports." + "\r\n");
			}
		}

		// Token: 0x060002A1 RID: 673 RVA: 0x003C48BC File Offset: 0x0030C8BC
		private unsafe void method_149(object sender, EventArgs e)
		{
			if (this.method_145() != 0)
			{
				this.textBox6.AppendText("Found " + Convert.ToString(this.comboBox10.Items.Count) + " Com Ports.");
				this.textBox6.AppendText("\r\n");
				if (Convert.ToInt16(this.string_12) == -1 && this.comboBox10.Items.Count > 0)
				{
					this.comboBox10.SelectedIndex = 0;
					this.method_148();
				}
				else if ((int)Convert.ToInt16(this.string_12) > this.comboBox10.Items.Count - 1)
				{
					this.comboBox10.SelectedIndex = 0;
					this.method_148();
				}
				else
				{
					this.comboBox10.SelectedIndex = 0;
					this.comboBox10.SelectedIndex = (int)Convert.ToInt16(this.string_12);
				}
			}
			else
			{
				this.comboBox10.Text = new string((sbyte*)(&<Module>.struct19_0));
				this.label102.Text = new string((sbyte*)(&<Module>.struct19_0));
				this.label103.Text = new string((sbyte*)(&<Module>.struct19_0));
				this.label104.Text = new string((sbyte*)(&<Module>.struct19_0));
				this.label105.Text = new string((sbyte*)(&<Module>.struct19_0));
				this.checkBox9.Enabled = false;
				this.textBox6.AppendText("Found 0 Com Ports." + "\r\n");
			}
		}

		// Token: 0x060002A2 RID: 674 RVA: 0x003C4A38 File Offset: 0x0030CA38
		private unsafe void checkBox9_CheckedChanged(object sender, EventArgs e)
		{
			int selectedIndex = this.comboBox10.SelectedIndex;
			if (this.pVoid_0 != null)
			{
				<Module>.SetCommMask(this.pVoid_0, 64);
			}
			if (this.checkBox9.CheckState == CheckState.Checked)
			{
				if (*(ref <Module>.struct122_0 + selectedIndex * 324 + 8) == 2)
				{
					if (this.method_146() == 1)
					{
						this.label135.Text = "X-USB: Enabled";
						this.method_123();
					}
					else
					{
						this.textBox6.AppendText(Convert.ToString(new string(ref <Module>.struct122_0 + selectedIndex * 324)) + " could not be opened" + "\r\n");
					}
				}
				else
				{
					this.menuItem_25.Enabled = true;
					this.menuItem_26.Enabled = true;
					this.menuItem_27.Enabled = true;
					this.menuItem_28.Enabled = true;
					this.menuItem_30.Enabled = true;
					this.menuItem_31.Enabled = true;
					this.method_150();
					if (*(ref <Module>.struct122_0 + selectedIndex * 324 + 8) == 6)
					{
						this.method_166(17U);
					}
					if (*(ref <Module>.struct122_0 + selectedIndex * 324 + 8) == 8)
					{
						this.label135.Text = "xt2: Enabled";
						Thread thread = new Thread(new ThreadStart(this.method_165));
						thread.Start();
					}
					if (*(ref <Module>.struct122_0 + selectedIndex * 324 + 8) == 9)
					{
						this.label135.Text = "CK3i: Enabled";
						this.method_135();
						this.method_136();
						this.method_138();
						Thread thread2 = new Thread(new ThreadStart(this.method_165));
						thread2.Start();
					}
				}
			}
			else
			{
				this.menuItem_25.Enabled = false;
				this.menuItem_26.Enabled = false;
				this.menuItem_27.Enabled = false;
				this.menuItem_28.Enabled = false;
				this.menuItem_30.Enabled = false;
				this.menuItem_31.Enabled = false;
				this.groupBox18.Visible = false;
				if (*(ref <Module>.struct122_0 + selectedIndex * 324 + 8) == 6)
				{
					this.method_166(18U);
				}
				if (*(ref <Module>.struct122_0 + selectedIndex * 324 + 8) == 8)
				{
					this.label135.Text = "xt2: Disabled";
					Thread thread3 = new Thread(new ThreadStart(this.method_165));
					thread3.Start();
				}
				if (*(ref <Module>.struct122_0 + selectedIndex * 324 + 8) == 9)
				{
					this.label135.Text = "CK3i: Disabled";
					this.method_135();
					this.method_137();
					this.method_138();
					Thread thread4 = new Thread(new ThreadStart(this.method_165));
					thread4.Start();
				}
			}
		}

		// Token: 0x060002A3 RID: 675 RVA: 0x0012CDCC File Offset: 0x0012CDCC
		private void checkBox9_EnabledChanged(object sender, EventArgs e)
		{
			if (this.checkBox9.Enabled)
			{
				this.menuItem_25.Visible = true;
				this.menuItem_26.Visible = true;
				this.menuItem_27.Visible = true;
				this.menuItem_28.Visible = true;
				this.menuItem_29.Visible = true;
				this.menuItem_30.Visible = true;
				this.menuItem_31.Visible = true;
			}
			else if (!this.checkBox9.Enabled)
			{
				this.menuItem_25.Visible = false;
				this.menuItem_26.Visible = false;
				this.menuItem_27.Visible = false;
				this.menuItem_28.Visible = false;
				this.menuItem_29.Visible = false;
				this.menuItem_30.Visible = false;
				this.menuItem_31.Visible = false;
			}
		}

		// Token: 0x060002A4 RID: 676 RVA: 0x0012CEA0 File Offset: 0x0012CEA0
		private void method_150()
		{
			string str = null;
			RegistryKey registryKey = Registry.CurrentUser.CreateSubKey("JungleFlasher");
			this.groupBox18.Visible = true;
			if (this.method_135() == 1)
			{
				this.method_136();
				this.method_138();
			}
			if (registryKey.GetValue("HalfTrayDelay") != null)
			{
				str = registryKey.GetValue("HalfTrayDelay").ToString();
			}
			else if (registryKey.GetValue("HalfTrayDelay") == null)
			{
				registryKey.SetValue("HalfTrayDelay", "250");
				str = "250";
			}
			this.menuItem_34.Text = str + "mS";
			registryKey.Close();
		}

		// Token: 0x060002A5 RID: 677 RVA: 0x0012CF44 File Offset: 0x0012CF44
		private unsafe void method_151()
		{
			this.int_1 = 0;
			this.int_2 = 1;
			this.int_3 = 1;
			this.int_7 = 0;
			this.int_8 = 0;
			GStruct96 gstruct = 0;
			initblk(ref gstruct + 4, 0, 24);
			IntPtr intPtr = Marshal.StringToHGlobalAnsi(this.string_1);
			IntPtr value = intPtr;
			sbyte* ptr = (sbyte*)((void*)value);
			Struct84 @struct;
			<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct10_22), ptr);
			this.pVoid_2 = <Module>.CreateFileA((sbyte*)(&@struct), -1073741824, 0, null, 3, 1073741952, null);
			if (this.pVoid_2 == -1)
			{
				this.textBox6.AppendText(this.string_1 + ": Not Available" + "\r\n");
			}
			else
			{
				gstruct = 28;
				<Module>.GetCommState(this.pVoid_2, &gstruct);
				*(ref gstruct + 4) = 9600;
				*(ref gstruct + 18) = 8;
				*(ref gstruct + 19) = 0;
				*(ref gstruct + 20) = 0;
				<Module>.SetCommState(this.pVoid_2, &gstruct);
				GStruct94 gstruct2 = 20;
				*(ref gstruct2 + 8) = 20;
				*(ref gstruct2 + 4) = 20;
				*(ref gstruct2 + 16) = 20;
				*(ref gstruct2 + 12) = 20;
				<Module>.SetCommTimeouts(this.pVoid_2, &gstruct2);
				RegistryKey registryKey = Registry.CurrentUser.CreateSubKey("JungleFlasher");
				if (registryKey.GetValue("CK3CP_Cont") != null)
				{
					this.string_6 = registryKey.GetValue("CK3CP_Cont").ToString();
				}
				else if (registryKey.GetValue("CK3CP_Cont") == null)
				{
					registryKey.SetValue("CK3CP_Cont", "0");
					this.string_6 = "0";
				}
				if (registryKey.GetValue("CK3CP_Back") != null)
				{
					this.string_7 = registryKey.GetValue("CK3CP_Back").ToString();
				}
				else if (registryKey.GetValue("CK3CP_Back") == null)
				{
					registryKey.SetValue("CK3CP_Back", "75");
					this.string_7 = "75";
				}
				registryKey.Close();
				this.method_159((uint)Convert.ToInt16(this.string_7));
				this.method_160((uint)Convert.ToInt16(this.string_6));
				this.string_2 = "Jungle Flasher";
				this.string_3 = "Ver 0.1.96 (323)";
				this.thread_0 = new Thread(new ThreadStart(this.method_161));
				this.thread_0.Start();
				this.thread_1 = new Thread(new ThreadStart(this.method_163));
				this.thread_1.Start();
			}
		}

		// Token: 0x060002A6 RID: 678 RVA: 0x0012D18C File Offset: 0x0012D18C
		private void method_152()
		{
			this.method_166(18U);
			RegistryKey registryKey = Registry.CurrentUser.CreateSubKey("JungleFlasher");
			registryKey.SetValue("CK3CP_Cont", this.string_6);
			registryKey.SetValue("CK3CP_Back", this.string_7);
			registryKey.Close();
			this.string_2 = "";
			this.string_3 = "";
			this.string_2 = " XECUTER CK3-CP ";
			<Module>.Sleep(400);
			while (this.int_7 == 1)
			{
			}
			while (this.int_8 == 1)
			{
				<Module>.SetCommMask(this.pVoid_2, 64);
			}
			<Module>.Sleep(400);
			try
			{
				this.thread_0.Abort();
			}
			catch (Exception ex)
			{
				string message = ex.Message;
			}
			try
			{
				this.thread_1.Abort();
			}
			catch (Exception ex2)
			{
				string message2 = ex2.Message;
			}
			if (this.pVoid_2 != null)
			{
				try
				{
					<Module>.CloseHandle(this.pVoid_2);
				}
				catch (Exception ex3)
				{
					string message3 = ex3.Message;
					MessageBox.Show(message3, "Closing Com Handle", MessageBoxButtons.OK, MessageBoxIcon.Asterisk);
				}
			}
		}

		// Token: 0x060002A7 RID: 679 RVA: 0x0012D2F0 File Offset: 0x0012D2F0
		private unsafe void method_153()
		{
			if (this.pVoid_2 != null)
			{
				GStruct95 gstruct = 0;
				initblk(ref gstruct + 4, 0, 16);
				Struct100 @struct;
				<Module>.memset((void*)(&@struct), 32, 36U);
				@struct = 254;
				*(ref @struct + 1) = 0;
				*(ref @struct + 18) = byte.MaxValue;
				*(ref @struct + 19) = 192;
				IntPtr intPtr = Marshal.StringToHGlobalAnsi(this.string_2);
				IntPtr value = intPtr;
				sbyte* pSbyte_ = (sbyte*)((void*)value);
				IntPtr intPtr2 = Marshal.StringToHGlobalAnsi(this.string_3);
				IntPtr value2 = intPtr2;
				sbyte* pSbyte_2 = (sbyte*)((void*)value2);
				<Module>.memcpy(ref @struct + 2, (void*)pSbyte_, <Module>.strlen((sbyte*)pSbyte_));
				<Module>.memcpy(ref @struct + 20, (void*)pSbyte_2, <Module>.strlen((sbyte*)pSbyte_2));
				*(ref gstruct + 16) = <Module>.CreateEventA(null, 1, 0, null);
				uint num;
				<Module>.WriteFile(this.pVoid_2, (void*)(&@struct), 36, (uint*)(&num), &gstruct);
				<Module>.GetOverlappedResult(this.pVoid_2, &gstruct, (uint*)(&num), 1);
			}
		}

		// Token: 0x060002A8 RID: 680 RVA: 0x0012D3CC File Offset: 0x0012D3CC
		private unsafe int method_154()
		{
			Struct60 @struct = 254;
			*(ref @struct + 1) = 10;
			GStruct95 gstruct = 0;
			initblk(ref gstruct + 4, 0, 16);
			*(ref gstruct + 16) = <Module>.CreateEventA(null, 1, 0, null);
			Struct101 struct2;
			uint num;
			<Module>.ReadFile(this.pVoid_2, (void*)(&struct2), 10, (uint*)(&num), &gstruct);
			<Module>.GetOverlappedResult(this.pVoid_2, &gstruct, (uint*)(&num), 1);
			int result;
			if ((struct2 & 1) != null)
			{
				this.method_167(3U);
				result = 1;
			}
			else if ((struct2 & 2) != null)
			{
				this.method_167(4U);
				result = 1;
			}
			else if ((struct2 & 4) != null)
			{
				this.method_167(1U);
				result = 1;
			}
			else if ((struct2 & 8) != null)
			{
				this.method_167(2U);
				result = 1;
			}
			else
			{
				result = 0;
			}
			return result;
		}

		// Token: 0x060002A9 RID: 681 RVA: 0x0012D470 File Offset: 0x0012D470
		private unsafe void method_155()
		{
			Struct60 @struct = 254;
			*(ref @struct + 1) = 10;
			GStruct95 gstruct = 0;
			initblk(ref gstruct + 4, 0, 16);
			*(ref gstruct + 16) = <Module>.CreateEventA(null, 1, 0, null);
			uint num;
			<Module>.WriteFile(this.pVoid_2, (void*)(&@struct), 2, (uint*)(&num), &gstruct);
			<Module>.GetOverlappedResult(this.pVoid_2, &gstruct, (uint*)(&num), 1);
		}

		// Token: 0x060002AA RID: 682 RVA: 0x0012D4CC File Offset: 0x0012D4CC
		private unsafe void method_156()
		{
			Struct60 @struct = 254;
			*(ref @struct + 1) = 5;
			GStruct95 gstruct = 0;
			initblk(ref gstruct + 4, 0, 16);
			GStruct95 gstruct2 = 0;
			initblk(ref gstruct2 + 4, 0, 16);
			*(ref gstruct + 16) = <Module>.CreateEventA(null, 1, 0, null);
			*(ref gstruct2 + 16) = <Module>.CreateEventA(null, 1, 0, null);
			Struct101 struct2;
			uint num;
			<Module>.ReadFile(this.pVoid_2, (void*)(&struct2), 10, (uint*)(&num), &gstruct);
			uint num2;
			<Module>.WriteFile(this.pVoid_2, (void*)(&@struct), 2, (uint*)(&num2), &gstruct2);
			<Module>.GetOverlappedResult(this.pVoid_2, &gstruct, (uint*)(&num), 1);
			this.string_2 = "" + new string((sbyte*)(&struct2));
			this.string_3 = "";
		}

		// Token: 0x060002AB RID: 683 RVA: 0x0012D57C File Offset: 0x0012D57C
		private unsafe void method_157()
		{
			Struct60 @struct = 254;
			*(ref @struct + 1) = 4;
			GStruct95 gstruct = 0;
			initblk(ref gstruct + 4, 0, 16);
			GStruct95 gstruct2 = 0;
			initblk(ref gstruct2 + 4, 0, 16);
			*(ref gstruct + 16) = <Module>.CreateEventA(null, 1, 0, null);
			*(ref gstruct2 + 16) = <Module>.CreateEventA(null, 1, 0, null);
			Struct101 value;
			uint num;
			<Module>.ReadFile(this.pVoid_2, (void*)(&value), 10, (uint*)(&num), &gstruct);
			uint num2;
			<Module>.WriteFile(this.pVoid_2, (void*)(&@struct), 2, (uint*)(&num2), &gstruct2);
			<Module>.GetOverlappedResult(this.pVoid_2, &gstruct, (uint*)(&num), 1);
			this.string_7 = "" + Convert.ToString(value);
		}

		// Token: 0x060002AC RID: 684 RVA: 0x0012D620 File Offset: 0x0012D620
		private unsafe void method_158()
		{
			Struct60 @struct = 254;
			*(ref @struct + 1) = 3;
			GStruct95 gstruct = 0;
			initblk(ref gstruct + 4, 0, 16);
			GStruct95 gstruct2 = 0;
			initblk(ref gstruct2 + 4, 0, 16);
			*(ref gstruct + 16) = <Module>.CreateEventA(null, 1, 0, null);
			*(ref gstruct2 + 16) = <Module>.CreateEventA(null, 1, 0, null);
			Struct101 value;
			uint num;
			<Module>.ReadFile(this.pVoid_2, (void*)(&value), 10, (uint*)(&num), &gstruct);
			uint num2;
			<Module>.WriteFile(this.pVoid_2, (void*)(&@struct), 2, (uint*)(&num2), &gstruct2);
			<Module>.GetOverlappedResult(this.pVoid_2, &gstruct, (uint*)(&num), 1);
			this.string_6 = "" + Convert.ToString(value);
		}

		// Token: 0x060002AD RID: 685 RVA: 0x0012D6C4 File Offset: 0x0012D6C4
		private unsafe void method_159(uint uint_0)
		{
			Struct102 @struct = 254;
			*(ref @struct + 1) = 2;
			*(ref @struct + 2) = 0;
			GStruct95 gstruct = 0;
			initblk(ref gstruct + 4, 0, 16);
			*(ref @struct + 2) = (byte)uint_0;
			*(ref gstruct + 16) = <Module>.CreateEventA(null, 1, 0, null);
			uint num;
			<Module>.WriteFile(this.pVoid_2, (void*)(&@struct), 3, (uint*)(&num), &gstruct);
			<Module>.GetOverlappedResult(this.pVoid_2, &gstruct, (uint*)(&num), 1);
		}

		// Token: 0x060002AE RID: 686 RVA: 0x0012D72C File Offset: 0x0012D72C
		private unsafe void method_160(uint uint_0)
		{
			Struct102 @struct = 254;
			*(ref @struct + 1) = 1;
			*(ref @struct + 2) = 0;
			GStruct95 gstruct = 0;
			initblk(ref gstruct + 4, 0, 16);
			*(ref @struct + 2) = (byte)uint_0;
			*(ref gstruct + 16) = <Module>.CreateEventA(null, 1, 0, null);
			uint num;
			<Module>.WriteFile(this.pVoid_2, (void*)(&@struct), 3, (uint*)(&num), &gstruct);
			<Module>.GetOverlappedResult(this.pVoid_2, &gstruct, (uint*)(&num), 1);
		}

		// Token: 0x060002AF RID: 687 RVA: 0x0012D794 File Offset: 0x0012D794
		private unsafe void method_161()
		{
			if (<Module>.SetCommMask(this.pVoid_2, 1) == null)
			{
				this.textBox6.AppendText("SetCommMask failed with error: " + Convert.ToString(<Module>.GetLastError()) + "\r\n");
			}
			else
			{
				GStruct95 gstruct;
				*(ref gstruct + 16) = <Module>.CreateEventA(null, 1, 0, null);
				if (*(ref gstruct + 16) == 0)
				{
					<Module>._assert((sbyte*)(&<Module>.struct72_5), (sbyte*)(&<Module>.struct96_0), 21557U);
				}
				for (;;)
				{
					uint num;
					if (<Module>.WaitCommEvent(this.pVoid_2, (uint*)(&num), &gstruct) == null)
					{
						uint lastError = <Module>.GetLastError();
						if (997U == lastError)
						{
							<Module>.WaitForSingleObject(*(ref gstruct + 16), -1);
							uint num2;
							<Module>.GetOverlappedResult(this.pVoid_2, &gstruct, (uint*)(&num2), 1);
							if ((num & 64U) != 0U)
							{
								break;
							}
							if ((num & 1U) != 0U)
							{
								while (this.method_154() == 1)
								{
									<Module>.Sleep(200);
									this.method_155();
								}
							}
						}
					}
					<Module>.Sleep(200);
				}
				this.int_8 = 0;
			}
		}

		// Token: 0x060002B0 RID: 688 RVA: 0x0012D888 File Offset: 0x0012D888
		private void method_162()
		{
			string strA = this.string_2;
			<Module>.Sleep(1500);
			if (string.Compare(strA, this.string_2) == 0)
			{
				this.string_2 = "Jungle Flasher";
				this.string_3 = "Ver 0.1.96 (323)";
			}
		}

		// Token: 0x060002B1 RID: 689 RVA: 0x0012D8CC File Offset: 0x0012D8CC
		private void method_163()
		{
			this.int_7 = 1;
			for (;;)
			{
				<Module>.Sleep(200);
				if (string.Compare(" XECUTER CK3-CP ", this.string_2) == 0)
				{
					break;
				}
				if (string.Compare(this.string_2, this.string_4) != 0 || string.Compare(this.string_3, this.string_5) != 0)
				{
					this.method_153();
					this.string_4 = this.string_2;
					this.string_5 = this.string_3;
				}
			}
			this.method_153();
			<Module>.Sleep(200);
			this.int_7 = 0;
		}

		// Token: 0x060002B2 RID: 690 RVA: 0x0012D964 File Offset: 0x0012D964
		private unsafe void method_164(uint uint_0)
		{
			Struct102 @struct = 254;
			*(ref @struct + 1) = 0;
			*(ref @struct + 2) = 0;
			this.method_155();
			if (uint_0 == 1U)
			{
				this.label135.Text = "CK3-CP: Opening";
				Application.DoEvents();
				*(ref @struct + 1) = 7;
				*(ref @struct + 2) = 4;
			}
			else if (uint_0 == 2U)
			{
				this.label135.Text = "CK3-CP: Closing";
				Application.DoEvents();
				*(ref @struct + 1) = 6;
				*(ref @struct + 2) = 4;
			}
			else if (uint_0 == 10U)
			{
				this.label135.Text = "CK3-CP: Power Off";
				Application.DoEvents();
				*(ref @struct + 1) = 6;
				*(ref @struct + 2) = 3;
			}
			else
			{
				if (uint_0 != 11U)
				{
					return;
				}
				this.label135.Text = "CK3-CP: Power On";
				Application.DoEvents();
				*(ref @struct + 1) = 7;
				*(ref @struct + 2) = 3;
			}
			GStruct95 gstruct = 0;
			initblk(ref gstruct + 4, 0, 16);
			*(ref gstruct + 16) = <Module>.CreateEventA(null, 1, 0, null);
			uint num;
			<Module>.WriteFile(this.pVoid_2, (void*)(&@struct), 3, (uint*)(&num), &gstruct);
			<Module>.GetOverlappedResult(this.pVoid_2, &gstruct, (uint*)(&num), 1);
			Thread thread = new Thread(new ThreadStart(this.method_165));
			thread.Start();
		}

		// Token: 0x060002B3 RID: 691 RVA: 0x0012DA88 File Offset: 0x0012DA88
		private void method_165()
		{
			string text = this.label135.Text;
			<Module>.Sleep(1500);
			if (string.Compare(text, this.label135.Text) == 0)
			{
				this.label135.Text = "";
			}
		}

		// Token: 0x060002B4 RID: 692 RVA: 0x0012DAD0 File Offset: 0x0012DAD0
		private unsafe void method_166(uint uint_0)
		{
			Struct60 @struct = 254;
			*(ref @struct + 1) = 11;
			if (uint_0 == 17U)
			{
				*(ref @struct + 1) = 11;
				this.label135.Text = "CK3-CP: Software Mode";
				Application.DoEvents();
			}
			else
			{
				if (uint_0 != 18U)
				{
					return;
				}
				*(ref @struct + 1) = 12;
				this.label135.Text = "CK3-CP: Manual mode";
				Application.DoEvents();
			}
			GStruct95 gstruct = 0;
			initblk(ref gstruct + 4, 0, 16);
			*(ref gstruct + 16) = <Module>.CreateEventA(null, 1, 0, null);
			uint num;
			<Module>.WriteFile(this.pVoid_2, (void*)(&@struct), 2, (uint*)(&num), &gstruct);
			<Module>.GetOverlappedResult(this.pVoid_2, &gstruct, (uint*)(&num), 1);
			Thread thread = new Thread(new ThreadStart(this.method_165));
			thread.Start();
		}

		// Token: 0x060002B5 RID: 693 RVA: 0x003C4CE4 File Offset: 0x0030CCE4
		private unsafe void method_167(uint uint_0)
		{
			string value = null;
			string str = "MTK-Flash";
			string str2 = "Benq-UnLock";
			string str3 = "Sammy-UnLock";
			string str4 = "LiteOn-Erase";
			string str5 = "Intro-DevID";
			string str6 = "Bad-Flash";
			string str7 = "Outro";
			string str8 = "DVD-Key32";
			string str9 = "DVD-Key";
			string str10 = "LO83info";
			string str11 = "dummy <- iX";
			string str12 = "dummy <- DB";
			string str13 = "Hitachi";
			string str14 = "Mode-B";
			string str15 = "79 Unlock";
			string str16 = "Restore";
			string str17 = "Flash-IX";
			string str18 = "CK3-CP";
			string str19 = "Backlight";
			string str20 = "Contrast";
			string str21 = "F/w Ver";
			string str22 = "Open Tray";
			string str23 = "Close Tray";
			string str24 = "Half Tray";
			string str25 = "Power On";
			string str26 = "Power Off";
			string str27 = "Power Cycle";
			if (uint_0 == 1U)
			{
				this.int_1--;
			}
			else if (uint_0 == 2U)
			{
				this.int_1++;
			}
			else if (uint_0 == 3U)
			{
				if (this.int_1 == 1)
				{
					this.int_2--;
				}
				else if (this.int_1 == 2)
				{
					this.int_3--;
				}
				else if (this.int_1 == 3 && this.int_2 == 4 && this.int_3 == 1)
				{
					int num = (int)Convert.ToInt16(this.string_7);
					num--;
					if (num < 0)
					{
						num = 0;
					}
					this.string_7 = Convert.ToString(num);
					this.method_159((uint)num);
				}
				else if (this.int_1 == 3 && this.int_2 == 4 && this.int_3 == 2)
				{
					int num = Convert.ToInt32(this.string_6);
					num--;
					if (num < 0)
					{
						num = 0;
					}
					this.string_6 = Convert.ToString(num);
					this.method_160((uint)num);
				}
			}
			else if (uint_0 == 4U)
			{
				if (this.int_1 == 1)
				{
					this.int_2++;
				}
				else if (this.int_1 == 2)
				{
					this.int_3++;
				}
				else
				{
					if (this.int_1 == 3 && this.int_2 == 1 && this.int_3 == 1)
					{
						this.method_186();
						this.int_1 = 0;
						this.int_2 = 1;
						this.int_3 = 1;
						this.method_162();
						return;
					}
					if (this.int_1 == 3 && this.int_2 == 1 && this.int_3 == 2)
					{
						this.method_191();
						this.int_1 = 0;
						this.int_2 = 1;
						this.int_3 = 1;
						this.method_162();
						return;
					}
					if (this.int_1 == 3 && this.int_2 == 1 && this.int_3 == 3)
					{
						this.method_207();
						this.int_1 = 0;
						this.int_2 = 1;
						this.int_3 = 1;
						this.method_162();
						return;
					}
					if (this.int_1 == 3 && this.int_2 == 1 && this.int_3 == 4)
					{
						this.method_202();
						this.int_1 = 0;
						this.int_2 = 1;
						this.int_3 = 1;
						this.method_162();
						return;
					}
					if (this.int_1 == 3 && this.int_2 == 1 && this.int_3 == 5)
					{
						this.int_1 = 0;
						this.int_2 = 1;
						this.int_3 = 1;
						GStruct11* ptr = <Module>.FindWindowExA(this.pGstruct11_0, null, null, (sbyte*)(&<Module>.struct16_1));
						IntPtr intPtr = Marshal.StringToHGlobalAnsi("DoBadFlash");
						IntPtr value2 = intPtr;
						<Module>.SendMessageA(ptr, 12U, 0U, (void*)value2);
						this.method_162();
						return;
					}
					if (this.int_1 == 3 && this.int_2 == 1 && this.int_3 == 6)
					{
						this.method_209();
						this.int_1 = 0;
						this.int_2 = 1;
						this.int_3 = 1;
						this.string_2 = this.label110.Text + " " + this.label106.Text;
						this.string_3 = this.label109.Text;
						this.method_162();
						return;
					}
					if (this.int_1 == 3 && this.int_2 == 2 && this.int_3 == 1)
					{
						this.method_61();
						this.int_1 = 0;
						this.int_2 = 1;
						this.int_3 = 1;
						this.method_162();
						return;
					}
					if (this.int_1 == 3 && this.int_2 == 2 && this.int_3 == 2)
					{
						this.method_101();
						this.int_1 = 0;
						this.int_2 = 1;
						this.int_3 = 1;
						this.method_162();
						return;
					}
					if (this.int_1 == 3 && this.int_2 == 2 && this.int_3 == 3)
					{
						this.method_98();
						this.int_1 = 0;
						this.int_2 = 1;
						this.int_3 = 1;
						this.method_162();
						return;
					}
					if (this.int_1 == 3 && this.int_2 == 2 && this.int_3 == 4)
					{
						this.method_102();
						this.int_1 = 0;
						this.int_2 = 1;
						this.int_3 = 1;
						this.method_162();
						return;
					}
					if (this.int_1 == 3 && this.int_2 == 3 && this.int_3 == 1)
					{
						this.method_336();
						this.int_1 = 0;
						this.int_2 = 1;
						this.int_3 = 1;
						this.method_162();
						return;
					}
					if (this.int_1 == 3 && this.int_2 == 3 && this.int_3 == 2)
					{
						this.method_379();
						this.int_1 = 0;
						this.int_2 = 1;
						this.int_3 = 1;
						this.method_162();
						return;
					}
					if (this.int_1 == 3 && this.int_2 == 3 && this.int_3 == 3)
					{
						this.radioButton9.Checked = true;
						this.method_364();
						this.int_1 = 0;
						this.int_2 = 1;
						this.int_3 = 1;
						this.method_162();
						return;
					}
					if (this.int_1 == 3 && this.int_2 == 3 && this.int_3 == 4)
					{
						this.radioButton8.Checked = true;
						this.method_364();
						this.int_1 = 0;
						this.int_2 = 1;
						this.int_3 = 1;
						this.method_162();
						return;
					}
					if (this.int_1 == 3 && this.int_2 == 4 && this.int_3 == 1)
					{
						int num = (int)Convert.ToInt16(this.string_7);
						num++;
						if (num > 100)
						{
							num = 100;
						}
						this.string_7 = Convert.ToString(num);
						this.method_159((uint)num);
					}
					else if (this.int_1 == 3 && this.int_2 == 4 && this.int_3 == 2)
					{
						int num = Convert.ToInt32(this.string_6);
						num++;
						if (num > 100)
						{
							num = 100;
						}
						this.string_6 = Convert.ToString(num);
						this.method_160((uint)num);
					}
				}
			}
			if (this.int_1 < 1)
			{
				this.int_1 = 0;
				this.int_2 = 1;
				this.int_3 = 1;
			}
			if (this.int_1 > 3)
			{
				this.int_1 = 3;
			}
			if (this.int_1 == 1)
			{
				if (this.int_2 < 1)
				{
					this.int_2 = 4;
				}
				else if (this.int_2 > 4)
				{
					this.int_2 = 1;
				}
				this.int_3 = 1;
			}
			if (this.int_1 == 2)
			{
				if (this.int_2 == 1)
				{
					if (this.int_3 < 1)
					{
						this.int_3 = 6;
					}
					else if (this.int_3 > 6)
					{
						this.int_3 = 1;
					}
				}
				if (this.int_2 == 2)
				{
					if (this.int_3 < 1)
					{
						this.int_3 = 4;
					}
					else if (this.int_3 > 4)
					{
						this.int_3 = 1;
					}
				}
				if (this.int_2 == 3)
				{
					if (this.int_3 < 1)
					{
						this.int_3 = 4;
					}
					else if (this.int_3 > 4)
					{
						this.int_3 = 1;
					}
				}
				if (this.int_2 == 4)
				{
					if (this.int_3 < 1)
					{
						this.int_3 = 9;
					}
					else if (this.int_3 > 9)
					{
						this.int_3 = 1;
					}
				}
			}
			if (this.int_1 == 0)
			{
				this.string_2 = "Jungle Flasher";
				this.string_3 = "Ver 0.1.96 (323)";
			}
			else if (this.int_1 == 1)
			{
				if (this.int_2 == 1)
				{
					this.string_2 = "1." + str;
					this.string_3 = "";
				}
				else if (this.int_2 == 2)
				{
					this.string_2 = "2." + str8;
					this.string_3 = "";
				}
				else if (this.int_2 == 3)
				{
					this.string_2 = "3." + str13;
					this.string_3 = "";
				}
				else if (this.int_2 == 4)
				{
					this.string_2 = "4." + str18;
					this.string_3 = "";
				}
			}
			else if (this.int_1 == 2)
			{
				if (this.int_2 == 1)
				{
					if (this.int_3 == 1)
					{
						this.string_2 = "1." + str;
						this.string_3 = " 1." + str2;
					}
					if (this.int_3 == 2)
					{
						this.string_2 = "1." + str;
						this.string_3 = " 2." + str3;
					}
					if (this.int_3 == 3)
					{
						this.string_2 = "1." + str;
						this.string_3 = " 3." + str4;
					}
					if (this.int_3 == 4)
					{
						this.string_2 = "1." + str;
						this.string_3 = " 4." + str5;
					}
					if (this.int_3 == 5)
					{
						this.string_2 = "1." + str;
						this.string_3 = " 5." + str6;
					}
					if (this.int_3 == 6)
					{
						this.string_2 = "1." + str;
						this.string_3 = " 6." + str7;
					}
					this.tabControl5.SelectedTab = this.Benq;
				}
				else if (this.int_2 == 2)
				{
					if (this.int_3 == 1)
					{
						this.string_2 = "2." + str8;
						this.string_3 = " 1." + str9;
					}
					if (this.int_3 == 2)
					{
						this.string_2 = "2." + str8;
						this.string_3 = " 2." + str10;
					}
					if (this.int_3 == 3)
					{
						this.string_2 = "2." + str8;
						this.string_3 = " 3." + str11;
					}
					if (this.int_3 == 4)
					{
						this.string_2 = "2." + str8;
						this.string_3 = " 4." + str12;
					}
					this.tabControl5.SelectedTab = this.DVDKey32;
				}
				else if (this.int_2 == 3)
				{
					if (this.int_3 == 1)
					{
						this.string_2 = "3." + str13;
						this.string_3 = " 1." + str14;
					}
					if (this.int_3 == 2)
					{
						this.string_2 = "3." + str13;
						this.string_3 = " 2." + str15;
					}
					if (this.int_3 == 3)
					{
						this.string_2 = "3." + str13;
						this.string_3 = " 3." + str16;
					}
					if (this.int_3 == 4)
					{
						this.string_2 = "3." + str13;
						this.string_3 = " 4." + str17;
					}
					this.tabControl5.SelectedTab = this.Hitachi;
				}
				else if (this.int_2 == 4)
				{
					if (this.int_3 == 1)
					{
						this.string_2 = "4." + str18;
						this.string_3 = " 1." + str19;
					}
					if (this.int_3 == 2)
					{
						this.string_2 = "4." + str18;
						this.string_3 = " 2." + str20;
					}
					if (this.int_3 == 3)
					{
						this.string_2 = "4." + str18;
						this.string_3 = " 3." + str21;
					}
					if (this.int_3 == 4)
					{
						this.string_2 = "4." + str18;
						this.string_3 = " 4." + str22;
					}
					if (this.int_3 == 5)
					{
						this.string_2 = "4." + str18;
						this.string_3 = " 5." + str23;
					}
					if (this.int_3 == 6)
					{
						this.string_2 = "4." + str18;
						this.string_3 = " 6." + str24;
					}
					if (this.int_3 == 7)
					{
						this.string_2 = "4." + str18;
						this.string_3 = " 7." + str25;
					}
					if (this.int_3 == 8)
					{
						this.string_2 = "4." + str18;
						this.string_3 = " 8." + str26;
					}
					if (this.int_3 == 9)
					{
						this.string_2 = "4." + str18;
						this.string_3 = " 9." + str27;
					}
					this.tabControl5.SelectedTab = this.Firmtools;
				}
			}
			else if (this.int_1 == 3)
			{
				if (this.int_2 == 1)
				{
					if (this.int_3 == 1)
					{
						this.string_2 = " 1." + str2;
						this.string_3 = " ^ Quit    OK > ";
					}
					if (this.int_3 == 2)
					{
						this.string_2 = " 2." + str3;
						this.string_3 = " ^ Quit    OK > ";
					}
					if (this.int_3 == 3)
					{
						this.string_2 = " 3." + str4;
						this.string_3 = " ^ Quit    OK > ";
					}
					if (this.int_3 == 4)
					{
						this.string_2 = " 4." + str5;
						this.string_3 = " ^ Quit    OK > ";
					}
					if (this.int_3 == 5)
					{
						this.string_2 = " 5." + str6;
						this.string_3 = " ^ Quit    OK > ";
					}
					if (this.int_3 == 6)
					{
						this.string_2 = " 6." + str7;
						this.string_3 = " ^ Quit    OK > ";
					}
				}
				else if (this.int_2 == 2)
				{
					if (this.int_3 == 1)
					{
						this.string_2 = " 1." + str9;
						this.string_3 = " ^ Quit    OK > ";
					}
					if (this.int_3 == 2)
					{
						this.string_2 = " 2." + str10;
						this.string_3 = " ^ Quit    OK > ";
					}
					if (this.int_3 == 3)
					{
						this.string_2 = " 3." + str11;
						this.string_3 = " ^ Quit    OK > ";
					}
					if (this.int_3 == 4)
					{
						this.string_2 = " 4." + str12;
						this.string_3 = " ^ Quit    OK > ";
					}
				}
				else if (this.int_2 == 3)
				{
					if (this.int_3 == 1)
					{
						this.string_2 = " 1." + str14;
						this.string_3 = " ^ Quit    OK > ";
					}
					if (this.int_3 == 2)
					{
						this.string_2 = " 2." + str15;
						this.string_3 = " ^ Quit    OK > ";
					}
					if (this.int_3 == 3)
					{
						this.string_2 = " 3." + str16;
						this.string_3 = " ^ Quit    OK > ";
					}
					if (this.int_3 == 4)
					{
						this.string_2 = " 4." + str17;
						this.string_3 = " ^ Quit    OK > ";
					}
				}
				else if (this.int_2 == 4)
				{
					if (this.int_3 == 1)
					{
						this.string_2 = " 1." + str19;
						if (Convert.ToInt16(this.string_7) == 100)
						{
							this.string_3 = string.Concat("<<<   100    >>>");
						}
						else if (Convert.ToInt16(this.string_7) < 10)
						{
							this.string_3 = "<<<     " + this.string_7 + "    >>>";
						}
						else
						{
							this.string_3 = "<<<    " + this.string_7 + "    >>>";
						}
					}
					if (this.int_3 == 2)
					{
						this.string_2 = " 2." + str20;
						if (Convert.ToInt16(this.string_6) == 100)
						{
							this.string_3 = string.Concat("<<<   100    >>>");
						}
						else if (Convert.ToInt16(this.string_6) < 10)
						{
							this.string_3 = "<<<     " + this.string_6 + "    >>>";
						}
						else
						{
							this.string_3 = "<<<    " + this.string_6 + "    >>>";
						}
					}
					if (this.int_3 == 3)
					{
						this.method_156();
					}
					if (this.int_3 == 4)
					{
						this.string_2 = " 4." + str22;
						this.string_3 = string.Concat("  Opening");
						this.method_164(1U);
					}
					if (this.int_3 == 5)
					{
						this.string_2 = " 5." + str23;
						this.string_3 = string.Concat("  Closing");
						this.method_164(2U);
					}
					if (this.int_3 == 6)
					{
						this.string_2 = " 5." + str24;
						RegistryKey registryKey = Registry.CurrentUser.CreateSubKey("JungleFlasher");
						if (registryKey.GetValue("HalfTrayDelay") != null)
						{
							value = registryKey.GetValue("HalfTrayDelay").ToString();
						}
						else if (registryKey.GetValue("HalfTrayDelay") == null)
						{
							registryKey.SetValue("HalfTrayDelay", "250");
							value = "250";
						}
						this.string_3 = string.Concat("  Opening");
						this.method_164(1U);
						<Module>.Sleep(Convert.ToInt32(value));
						this.string_3 = string.Concat("  Power Off");
						this.method_164(10U);
						<Module>.Sleep(250);
						this.string_3 = string.Concat("  Power On");
						this.method_164(11U);
					}
					if (this.int_3 == 7)
					{
						this.string_2 = " 5." + str25;
						this.string_3 = string.Concat("  Power On");
						this.method_164(11U);
					}
					if (this.int_3 == 8)
					{
						this.string_2 = " 5." + str26;
						this.string_3 = string.Concat("  Power Off");
						this.method_164(10U);
					}
					if (this.int_3 == 9)
					{
						this.string_2 = " 5." + str27;
						this.string_3 = string.Concat("  Power Off");
						this.method_164(10U);
						<Module>.Sleep(250);
						this.string_3 = string.Concat("  Power On");
						this.method_164(11U);
					}
				}
			}
		}

		// Token: 0x060002B6 RID: 694 RVA: 0x0012EE6C File Offset: 0x0012EE6C
		private void checkBox2_CheckedChanged(object sender, EventArgs e)
		{
			if (this.bool_1)
			{
				this.checkBox11.CheckState = this.checkBox2.CheckState;
				Application.DoEvents();
				this.Cursor = Cursors.WaitCursor;
				if (<Module>.struct38_0 == null && <Module>.gstruct10_0 != null)
				{
					this.method_422();
				}
				this.method_170();
				this.Cursor = Cursors.Arrow;
			}
		}

		// Token: 0x060002B7 RID: 695 RVA: 0x0012EED4 File Offset: 0x0012EED4
		private void checkBox4_CheckedChanged(object sender, EventArgs e)
		{
			if (this.bool_1)
			{
				this.checkBox10.CheckState = this.checkBox4.CheckState;
				if (this.checkBox4.CheckState == CheckState.Checked)
				{
					this.checkBox10.CheckState = CheckState.Checked;
					this.checkBox2.Enabled = false;
					this.checkBox11.Enabled = false;
					this.checkBox15.Enabled = false;
					this.checkBox16.Enabled = false;
					this.radioButton14.Checked = true;
				}
				else
				{
					this.checkBox10.CheckState = CheckState.Unchecked;
					this.checkBox2.Enabled = true;
					this.checkBox11.Enabled = true;
					if (this.bool_5)
					{
						this.checkBox15.Enabled = true;
						this.checkBox16.Enabled = true;
					}
					this.radioButton18.Enabled = false;
					this.radioButton17.Checked = true;
				}
				Application.DoEvents();
				this.Cursor = Cursors.WaitCursor;
				if (<Module>.struct38_0 == null && <Module>.gstruct10_0 != null)
				{
					this.method_422();
				}
				this.method_170();
				if (this.checkBox4.CheckState == CheckState.Checked)
				{
					this.method_168();
				}
				this.Cursor = Cursors.Arrow;
			}
		}

		// Token: 0x060002B8 RID: 696 RVA: 0x0012F008 File Offset: 0x0012F008
		private unsafe void checkBox15_CheckedChanged(object sender, EventArgs e)
		{
			if (this.bool_1)
			{
				this.checkBox16.CheckState = this.checkBox15.CheckState;
				if (this.checkBox15.CheckState == CheckState.Checked)
				{
					this.checkBox16.CheckState = CheckState.Checked;
					this.checkBox2.Enabled = false;
					this.checkBox11.Enabled = false;
					this.checkBox4.Enabled = false;
					this.checkBox10.Enabled = false;
					this.string_18 = "1";
					<Module>.smethod_150(*(ref <Module>.gstruct101_0 + 4));
					<Module>.smethod_148((sbyte*)(&<Module>.struct24_5));
					this.textBox6.AppendText("PortIO unloaded." + "\r\n");
					this.radioButton18.Enabled = true;
					this.radioButton17.Checked = true;
				}
				else
				{
					this.checkBox16.CheckState = CheckState.Unchecked;
					this.checkBox2.Enabled = true;
					this.checkBox11.Enabled = true;
					this.checkBox4.Enabled = true;
					this.checkBox10.Enabled = true;
					this.string_18 = "0";
					this.method_2();
					this.radioButton18.Enabled = false;
					this.radioButton17.Checked = true;
				}
				Application.DoEvents();
				this.Cursor = Cursors.WaitCursor;
				if (<Module>.gstruct10_0 != null)
				{
					this.method_422();
				}
				this.method_170();
				this.Cursor = Cursors.Arrow;
			}
		}

		// Token: 0x060002B9 RID: 697 RVA: 0x0012F174 File Offset: 0x0012F174
		private void checkBox16_CheckedChanged(object sender, EventArgs e)
		{
			this.checkBox15.CheckState = this.checkBox16.CheckState;
		}

		// Token: 0x060002BA RID: 698 RVA: 0x0012F198 File Offset: 0x0012F198
		private void checkBox10_CheckedChanged(object sender, EventArgs e)
		{
			this.checkBox4.CheckState = this.checkBox10.CheckState;
		}

		// Token: 0x060002BB RID: 699 RVA: 0x0012F1BC File Offset: 0x0012F1BC
		private void checkBox11_CheckedChanged(object sender, EventArgs e)
		{
			this.checkBox2.CheckState = this.checkBox11.CheckState;
		}

		// Token: 0x060002BC RID: 700 RVA: 0x0012F1E0 File Offset: 0x0012F1E0
		private unsafe void method_168()
		{
			uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
			if (*(ref <Module>.struct38_0 + selectedIndex * 72U + 68) == 0)
			{
				this.radioButton18.Enabled = false;
				this.radioButton17.Checked = true;
			}
			if (*(ref <Module>.struct38_0 + selectedIndex * 72U + 68) == 39)
			{
				if (this.textBox6.TextLength > 0)
				{
					this.textBox6.AppendText("Via Card with status (Code 39), Hitachi Port IO enabled!" + "\r\n");
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					MessageBox.Show("Via Card with status (Code 39), Hitachi Port IO enabled!", "Via Port Enumeration", MessageBoxButtons.OK, MessageBoxIcon.Asterisk);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
				}
				this.radioButton18.Enabled = true;
			}
		}

		// Token: 0x060002BD RID: 701 RVA: 0x0012F2AC File Offset: 0x0012F2AC
		private unsafe void method_169()
		{
			uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
			if (*(ref <Module>.struct38_0 + selectedIndex * 72U + 68) == 0)
			{
				this.radioButton18.Enabled = false;
				this.radioButton17.Checked = true;
			}
			if (*(ref <Module>.struct38_0 + selectedIndex * 72U + 68) == 39)
			{
				this.radioButton18.Enabled = true;
			}
		}

		// Token: 0x060002BE RID: 702 RVA: 0x0012F30C File Offset: 0x0012F30C
		private unsafe int method_170()
		{
			int num = 0;
			for (int i = 0; i < 32; i++)
			{
				<Module>.memset(ref <Module>.struct38_0 + i * 72, 0, 72U);
			}
			int num2;
			for (;;)
			{
				this.comboBox1.Items.Clear();
				this.comboBox7.Items.Clear();
				this.comboBox13.Items.Clear();
				if (*(ref <Module>.gstruct10_0 + 4) != 0)
				{
					this.method_422();
				}
				if (*(ref <Module>.gstruct10_0 + 8) != 0)
				{
					this.method_423();
				}
				this.method_410();
				this.method_411();
				if (*(ref <Module>.gstruct10_0 + 12) == 1)
				{
					*(ref <Module>.struct38_0 + num * 72) = 0;
					*(ref <Module>.struct38_0 + num * 72 + 2) = 2;
					*(ref <Module>.struct38_0 + num * 72 + 3) = 0;
					*(ref <Module>.struct38_0 + num * 72 + 4) = 160;
					<Module>.memcpy(ref <Module>.struct38_0 + num * 72 + 5, (void*)(&<Module>.struct67_2), 13U);
					num++;
				}
				if (*(ref <Module>.gstruct10_0 + 13) == 1)
				{
					*(ref <Module>.struct38_0 + num * 72) = 0;
					*(ref <Module>.struct38_0 + num * 72 + 2) = 2;
					*(ref <Module>.struct38_0 + num * 72 + 3) = 1;
					*(ref <Module>.struct38_0 + num * 72 + 4) = 160;
					<Module>.memcpy(ref <Module>.struct38_0 + num * 72 + 5, (void*)(&<Module>.struct0_3), 17U);
					num++;
				}
				if (*(ref <Module>.gstruct10_0 + 12) == 1)
				{
					*(ref <Module>.gstruct10_0 + 14) = 0;
					this.checkBox16.Enabled = true;
					this.checkBox15.Enabled = true;
				}
				else if (*(ref <Module>.gstruct10_0 + 13) == 1)
				{
					*(ref <Module>.gstruct10_0 + 14) = 1;
					this.checkBox16.Enabled = true;
					this.checkBox15.Enabled = true;
				}
				else
				{
					this.checkBox16.Enabled = false;
					this.checkBox15.Enabled = false;
				}
				if (string.Compare(this.string_18, "1") == 0)
				{
					if (num == 1)
					{
						this.comboBox1.Items.Add("0x0000");
						this.comboBox7.Items.Add("0x0000");
						this.comboBox13.Items.Add("0x0000");
					}
					if (num == 2)
					{
						this.comboBox1.Items.Add("0x0000");
						this.comboBox7.Items.Add("0x0000");
						this.comboBox13.Items.Add("0x0000");
						this.comboBox1.Items.Add("0x0000");
						this.comboBox7.Items.Add("0x0000");
						this.comboBox13.Items.Add("0x0000");
					}
					if (num != 0)
					{
						break;
					}
					this.checkBox2.Enabled = true;
					this.checkBox11.Enabled = true;
					this.checkBox4.Enabled = true;
					this.checkBox10.Enabled = true;
				}
				if (this.checkBox4.CheckState == CheckState.Checked)
				{
					num2 = <Module>.smethod_86((GStruct86*)(&<Module>.struct38_0), 0, 32);
				}
				else
				{
					num2 = <Module>.smethod_85((GStruct86*)(&<Module>.struct38_0), num, 32);
				}
				if (num2 != 0)
				{
					goto IL_469;
				}
				if (this.checkBox4.CheckState == CheckState.Checked)
				{
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					MessageBox.Show("No VIA ports were found!", "JungleFlasher", MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
					this.checkBox4.CheckState = CheckState.Unchecked;
					this.checkBox10.CheckState = CheckState.Unchecked;
				}
				else
				{
					if (this.checkBox2.CheckState != CheckState.Unchecked)
					{
						goto IL_463;
					}
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					MessageBox.Show("No VIA or SATA Class ports were found!", "JungleFlasher", MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
					this.checkBox2.CheckState = CheckState.Checked;
					this.checkBox11.CheckState = CheckState.Checked;
				}
			}
			this.comboBox1.SelectedIndex = 0;
			this.comboBox7.SelectedIndex = 0;
			this.comboBox13.SelectedIndex = 0;
			this.checkBox2.Enabled = false;
			this.checkBox11.Enabled = false;
			this.checkBox4.Enabled = false;
			this.checkBox10.Enabled = false;
			this.radioButton18.Enabled = true;
			this.radioButton17.Checked = true;
			return 1;
			IL_463:
			return 0;
			IL_469:
			for (int j = 0; j < num2; j++)
			{
				Struct60 @struct;
				*(ref @struct + 1) = (byte)(*(ref <Module>.struct38_0 + j * 72) & 255);
				@struct = (*(ref <Module>.struct38_0 + j * 72) & 65280) >> 8;
				this.comboBox1.Items.Add(this.method_171((byte*)(&@struct), 2U, 0U));
				this.comboBox7.Items.Add(this.method_171((byte*)(&@struct), 2U, 0U));
				this.comboBox13.Items.Add(this.method_171((byte*)(&@struct), 2U, 0U));
				this.comboBox1.SelectedIndex = 0;
				this.comboBox7.SelectedIndex = 0;
				this.comboBox13.SelectedIndex = 0;
			}
			return num2;
		}

		// Token: 0x060002BF RID: 703 RVA: 0x0012F83C File Offset: 0x0012F83C
		private unsafe string method_171(byte* pByte_0, uint uint_0, uint uint_1)
		{
			string text = null;
			for (uint num = 0U; num < uint_0; num += 1U)
			{
				Struct62 @struct;
				<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct35_121), pByte_0[num]);
				string text2 = new string((sbyte*)(&<Module>.struct19_0));
				text2 += new string((sbyte*)(&@struct));
				text += text2;
			}
			return new string((sbyte*)(&<Module>.struct18_10)) + text;
		}

		// Token: 0x060002C0 RID: 704 RVA: 0x0012F8A4 File Offset: 0x0012F8A4
		private unsafe int method_172()
		{
			string text = null;
			string text2 = null;
			int result;
			if (this.comboBox1.Items.Count == 0)
			{
				result = 0;
			}
			else
			{
				uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
				uint num = (uint)(*(ref <Module>.struct38_0 + selectedIndex * 72U + 4));
				ushort num2 = *(ref <Module>.struct38_0 + selectedIndex * 72U);
				this.Cursor = Cursors.WaitCursor;
				<Module>.Sleep(100);
				uint num3 = 0U;
				if (*(ref <Module>.struct38_0 + selectedIndex * 72U) == 0 && *(ref <Module>.struct38_0 + selectedIndex * 72U + 3) == 1)
				{
					this.method_175();
				}
				GStruct3 gstruct;
				<Module>.smethod_21(&gstruct, num2, 0, 1, 1000U);
				<Module>.smethod_2(*(ref gstruct + 18), (byte)num3);
				<Module>.Sleep(1);
				<Module>.smethod_2(*(ref gstruct + 14), (byte)num);
				<Module>.Sleep(500);
				num3 = (uint)<Module>.smethod_1(*(ref gstruct + 18));
				if (num3 == 112U | num3 == 114U | num3 == 115U)
				{
					this.label110.Text = "Drive in Vendor Mode!";
					this.label109.Text = "";
					this.label106.Text = "";
					this.label92.Text = "";
					this.label72.Text = "Drive in Vendor Mode!";
					this.label68.Text = "";
					this.label61.Text = "";
					this.label58.Text = "";
					this.label100.Text = "Drive in Vendor Mode!";
					this.label99.Text = "";
					this.label98.Text = "";
					this.label97.Text = "";
					if (this.checkBox5.CheckState == CheckState.Checked)
					{
						this.method_205();
					}
					this.Cursor = Cursors.Arrow;
					result = 0;
				}
				else
				{
					if (num2 == 0)
					{
						<Module>.smethod_2(*(ref gstruct + 4), 3);
						<Module>.Sleep(1);
						<Module>.smethod_2(*(ref gstruct + 6), 1);
						<Module>.Sleep(1);
						<Module>.smethod_2(*(ref gstruct + 18), 239);
						<Module>.Sleep(50);
						num3 = (uint)<Module>.smethod_1(*(ref gstruct + 18));
					}
					this.toolTip_0.SetToolTip(this.button42, "Lock/UnLock Slim Lite-On Spi ");
					this.button42.Enabled = false;
					this.button42.Text = "";
					if (this.method_174() == 1)
					{
						this.Cursor = Cursors.Arrow;
						result = 0;
					}
					else
					{
						uint num4;
						if (*(ref <Module>.struct38_0 + selectedIndex * 72U + 4) == 160)
						{
							num4 = 0U;
						}
						else
						{
							num4 = 16U;
						}
						Struct52 @struct;
						<Module>.memset((void*)(&@struct), 0, 12U);
						@struct = 18;
						*(ref @struct + 1) = 0;
						*(ref @struct + 2) = 0;
						*(ref @struct + 3) = 0;
						*(ref @struct + 4) = 96;
						*(ref @struct + 5) = 192;
						Struct85 struct2;
						uint num5;
						if (<Module>.smethod_16((byte*)(&@struct), 12U, (byte)num4, 512, (void*)(&struct2), &num5, 96U, 1, &gstruct) != null)
						{
							this.label110.Text = "No Drive Detected!";
							this.label109.Text = "";
							this.label106.Text = "";
							this.label92.Text = "";
							this.label72.Text = "No Drive Detected!";
							this.label68.Text = "";
							this.label61.Text = "";
							this.label58.Text = "";
							this.label100.Text = "No Drive Detected!";
							this.label99.Text = "";
							this.label98.Text = "";
							this.label97.Text = "";
							this.Cursor = Cursors.Arrow;
							result = 0;
						}
						else
						{
							this.label110.Text = "";
							this.label72.Text = "";
							byte* pByte_ = ref struct2 + 8;
							this.label110.Text = this.method_176(pByte_, 8U);
							this.label72.Text = this.label110.Text;
							this.label100.Text = this.label110.Text;
							this.label109.Text = "";
							this.label68.Text = "";
							pByte_ = ref struct2 + 16;
							this.label109.Text = this.method_176(pByte_, 16U);
							this.label68.Text = this.label109.Text;
							this.label99.Text = this.label109.Text;
							this.label106.Text = "";
							this.label61.Text = "";
							pByte_ = ref struct2 + 32;
							this.label106.Text = this.method_176(pByte_, 4U);
							this.label61.Text = this.label106.Text;
							this.label98.Text = this.label106.Text;
							this.label92.Text = new string((sbyte*)(&<Module>.struct19_0));
							this.label58.Text = new string((sbyte*)(&<Module>.struct19_0));
							pByte_ = ref struct2 + 36;
							this.label92.Text = this.method_176(pByte_, 20U);
							this.label58.Text = this.label92.Text;
							this.label97.Text = this.label92.Text;
							Application.DoEvents();
							if (*(ref struct2 + 8) == 0 | *(ref struct2 + 8) == 255)
							{
								this.label110.Text = "No Drive Detected!";
								this.label109.Text = "";
								this.label106.Text = "";
								this.label92.Text = "";
								this.label72.Text = "No Drive Detected!";
								this.label68.Text = "";
								this.label61.Text = "";
								this.label58.Text = "";
								this.label100.Text = "No Drive Detected!";
								this.label99.Text = "";
								this.label98.Text = "";
								this.label97.Text = "";
							}
							if (*(ref struct2 + 8) == *(ref struct2 + 10) | *(ref struct2 + 8) == *(ref struct2 + 12) | *(ref struct2 + 8) == *(ref struct2 + 14) | *(ref struct2 + 8) == *(ref struct2 + 16))
							{
								this.label110.Text = "No Drive Detected!";
								this.label109.Text = "";
								this.label106.Text = "";
								this.label92.Text = "";
								this.label72.Text = "No Drive Detected!";
								this.label68.Text = "";
								this.label61.Text = "";
								this.label58.Text = "";
								this.label100.Text = "No Drive Detected!";
								this.label99.Text = "";
								this.label98.Text = "";
								this.label97.Text = "";
							}
							if (*(ref struct2 + 32) == 48 & *(ref struct2 + 33) == 48)
							{
								if (*(ref struct2 + 34) == 53)
								{
									this.radioButton4.Checked = true;
								}
								else if (*(ref struct2 + 34) == 55)
								{
									this.radioButton5.Checked = true;
								}
								else if (*(ref struct2 + 34) == 52 & *(ref struct2 + 35) != 48)
								{
									this.radioButton3.Checked = true;
								}
								else if (*(ref struct2 + 34) == 51 & *(ref struct2 + 35) == 54)
								{
									this.radioButton2.Checked = true;
								}
								else
								{
									this.radioButton1.Checked = true;
								}
							}
							this.pictureBox5.Visible = false;
							this.pictureBox7.Visible = true;
							this.pictureBox2.Visible = false;
							this.pictureBox6.Visible = true;
							this.menuItem_21.Enabled = false;
							this.menuItem_22.Enabled = false;
							this.menuItem_23.Enabled = false;
							this.menuItem_24.Enabled = false;
							this.toolTip_0.SetToolTip(this.pictureBox5, null);
							this.toolTip_0.SetToolTip(this.pictureBox2, null);
							this.label133.Text = "Not Found";
							this.label131.Text = "Not Found";
							this.string_14 = "";
							this.string_15 = "";
							this.string_16 = "";
							this.string_17 = "";
							if (*(ref struct2 + 24) != 68 && *(ref struct2 + 25) != 76 && *(ref struct2 + 26) != 49 && *(ref struct2 + 27) != 48)
							{
								this.method_178();
							}
							string text3;
							if (*(ref struct2 + 42) == 68 && *(ref struct2 + 43) == 54 && *(ref struct2 + 46) == 67 && *(ref struct2 + 47) == 71)
							{
								pByte_ = ref struct2 + 42;
								text3 = this.method_176(pByte_, 17U);
							}
							else
							{
								if ((*(ref struct2 + 32) != 57 || *(ref struct2 + 33) != 53 || *(ref struct2 + 34) != 48 || *(ref struct2 + 35) != 52) && (*(ref struct2 + 32) != 48 || *(ref struct2 + 33) != 50 || *(ref struct2 + 34) != 50 || *(ref struct2 + 35) != 53) && (*(ref struct2 + 32) != 48 || *(ref struct2 + 33) != 50 || *(ref struct2 + 34) != 55 || *(ref struct2 + 35) != 50) && (*(ref struct2 + 32) != 48 || *(ref struct2 + 33) != 52 || *(ref struct2 + 34) != 48 || *(ref struct2 + 35) != 49) && (*(ref struct2 + 32) != 49 || *(ref struct2 + 33) != 48 || *(ref struct2 + 34) != 55 || *(ref struct2 + 35) != 49) && (*(ref struct2 + 32) != 49 || *(ref struct2 + 33) != 49 || *(ref struct2 + 34) != 55 || *(ref struct2 + 35) != 53) && (*(ref struct2 + 32) != 49 || *(ref struct2 + 33) != 53 || *(ref struct2 + 34) != 51 || *(ref struct2 + 35) != 50))
								{
									this.Cursor = Cursors.Arrow;
									return 1;
								}
								<Module>.memset((void*)(&@struct), 0, 12U);
								@struct = 18;
								*(ref @struct + 1) = 0;
								*(ref @struct + 2) = 0;
								*(ref @struct + 3) = 0;
								*(ref @struct + 4) = 116;
								*(ref @struct + 5) = 192;
								if (<Module>.smethod_16((byte*)(&@struct), 12U, (byte)num4, 512, (void*)(&struct2), &num5, 116U, 1, &gstruct) != null)
								{
									this.Cursor = Cursors.Arrow;
									return 0;
								}
								if (*(ref struct2 + 96) == 255 && *(ref struct2 + 97) == 255)
								{
									return 0;
								}
								pByte_ = ref struct2 + 96;
								text3 = this.method_176(pByte_, 17U);
							}
							RegistryKey registryKey = Registry.CurrentUser.CreateSubKey("JF_KeyDB\\SerList");
							if (registryKey.GetValue(text3) != null)
							{
								string text4 = registryKey.GetValue(text3).ToString();
								registryKey.Close();
								registryKey = Registry.CurrentUser.CreateSubKey("JF_KeyDB\\" + text4);
								if (registryKey.GetValue("Key") != null)
								{
									text = registryKey.GetValue("Key").ToString();
									this.string_14 = text;
								}
								if (registryKey.GetValue("JobName") != null)
								{
									text2 = registryKey.GetValue("JobName").ToString();
								}
								string text5;
								if (registryKey.GetValue("WorkingDir") != null)
								{
									text5 = registryKey.GetValue("WorkingDir").ToString();
								}
								else
								{
									text5 = "";
								}
								string strA;
								if (registryKey.GetValue("LastFile") != null)
								{
									strA = registryKey.GetValue("LastFile").ToString();
								}
								else
								{
									strA = "";
								}
								Struct28 struct3;
								for (int i = 0; i < 32; i += 2)
								{
									string s = text.Substring(i, 2);
									IntPtr intPtr = Marshal.StringToHGlobalAnsi(s);
									IntPtr value = intPtr;
									sbyte* pSbyte_ = (sbyte*)((void*)value);
									this.method_10((void*)(&num5), pSbyte_, 2);
									*(ref struct3 + i / 2) = (byte)num5;
								}
								if (this.method_107((byte*)(&struct3)) == 1)
								{
									this.toolTip_0.SetToolTip(this.pictureBox5, "Drive Barcode found in KeyDB (" + text4 + " - " + text2 + ")" + Environment.NewLine + "Barcode is: " + text3 + Environment.NewLine + "Key is: " + text);
									this.toolTip_0.SetToolTip(this.pictureBox2, "Drive Barcode found in KeyDB (" + text4 + " - " + text2 + ")" + Environment.NewLine + "Barcode is: " + text3 + Environment.NewLine + "Key is: " + text);
									this.pictureBox5.Visible = true;
									this.pictureBox7.Visible = false;
									this.pictureBox2.Visible = true;
									this.pictureBox6.Visible = false;
									if (string.Compare(strA, "") != 0)
									{
										this.menuItem_21.Enabled = true;
									}
									this.menuItem_22.Enabled = true;
									this.menuItem_23.Enabled = true;
									this.menuItem_24.Enabled = true;
									this.label133.Text = "Verified";
									this.label131.Text = "Verified";
									this.string_14 = text;
									this.string_15 = text4;
									this.string_16 = strA;
									this.string_17 = text5;
									registryKey.Close();
									this.Cursor = Cursors.Arrow;
									if (this.bool_1)
									{
										this.textBox6.AppendText("\r\n" + "Key found in KeyDB at record (" + text4 + " - " + text2 + ")" + "\r\n" + "Key is: " + text + "\r\n" + "Key has been tested and verified, thanks C4eva ! " + "\r\n");
									}
									result = 2;
								}
								else
								{
									result = 1;
								}
							}
							else
							{
								this.pictureBox5.Visible = false;
								this.pictureBox7.Visible = true;
								this.pictureBox2.Visible = false;
								this.pictureBox6.Visible = true;
								this.menuItem_21.Enabled = false;
								this.menuItem_22.Enabled = false;
								this.menuItem_23.Enabled = false;
								this.menuItem_24.Enabled = false;
								this.toolTip_0.SetToolTip(this.pictureBox5, null);
								this.toolTip_0.SetToolTip(this.pictureBox2, null);
								this.label133.Text = "Not Found";
								this.label131.Text = "Not Found";
								this.Cursor = Cursors.Arrow;
								registryKey.Close();
								result = 1;
							}
						}
					}
				}
			}
			return result;
		}

		// Token: 0x060002C1 RID: 705 RVA: 0x00130714 File Offset: 0x00130714
		private unsafe int method_173()
		{
			string text = null;
			string text2 = null;
			int result;
			if (this.comboBox1.Items.Count == 0)
			{
				result = 0;
			}
			else
			{
				uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
				uint num = (uint)(*(ref <Module>.struct38_0 + selectedIndex * 72U + 4));
				ushort ushort_ = *(ref <Module>.struct38_0 + selectedIndex * 72U);
				this.Cursor = Cursors.WaitCursor;
				<Module>.Sleep(100);
				uint num2 = 0U;
				if (*(ref <Module>.struct38_0 + selectedIndex * 72U) == 0 && *(ref <Module>.struct38_0 + selectedIndex * 72U + 3) == 1)
				{
					this.method_175();
				}
				GStruct3 gstruct;
				<Module>.smethod_21(&gstruct, ushort_, 0, 1, 1000U);
				<Module>.smethod_2(*(ref gstruct + 18), (byte)num2);
				<Module>.Sleep(1);
				<Module>.smethod_2(*(ref gstruct + 14), (byte)num);
				<Module>.Sleep(500);
				num2 = (uint)<Module>.smethod_1(*(ref gstruct + 18));
				if (num2 == 112U | num2 == 114U | num2 == 115U)
				{
					this.label110.Text = "Drive in Vendor Mode!";
					this.label109.Text = "";
					this.label106.Text = "";
					this.label92.Text = "";
					this.label72.Text = "Drive in Vendor Mode!";
					this.label68.Text = "";
					this.label61.Text = "";
					this.label58.Text = "";
					this.label100.Text = "Drive in Vendor Mode!";
					this.label99.Text = "";
					this.label98.Text = "";
					this.label97.Text = "";
					if (this.checkBox5.CheckState == CheckState.Checked)
					{
						this.method_205();
					}
					this.Cursor = Cursors.Arrow;
					result = 0;
				}
				else
				{
					this.toolTip_0.SetToolTip(this.button42, "Lock/UnLock Slim Lite-On Spi ");
					this.button42.Enabled = false;
					this.button42.Text = "";
					if (this.method_174() == 1)
					{
						this.Cursor = Cursors.Arrow;
						result = 0;
					}
					else
					{
						uint num3;
						if (*(ref <Module>.struct38_0 + selectedIndex * 72U + 4) == 160)
						{
							num3 = 0U;
						}
						else
						{
							num3 = 16U;
						}
						Struct52 @struct;
						<Module>.memset((void*)(&@struct), 0, 12U);
						@struct = 18;
						*(ref @struct + 1) = 0;
						*(ref @struct + 2) = 0;
						*(ref @struct + 3) = 0;
						*(ref @struct + 4) = 96;
						*(ref @struct + 5) = 192;
						Struct85 struct2;
						uint num4;
						if (<Module>.smethod_16((byte*)(&@struct), 12U, (byte)num3, 512, (void*)(&struct2), &num4, 96U, 1, &gstruct) != null)
						{
							this.label110.Text = "No Drive Detected!";
							this.label109.Text = "";
							this.label106.Text = "";
							this.label92.Text = "";
							this.label72.Text = "No Drive Detected!";
							this.label68.Text = "";
							this.label61.Text = "";
							this.label58.Text = "";
							this.label100.Text = "No Drive Detected!";
							this.label99.Text = "";
							this.label98.Text = "";
							this.label97.Text = "";
							this.Cursor = Cursors.Arrow;
							result = 0;
						}
						else
						{
							this.label110.Text = "";
							this.label72.Text = "";
							byte* pByte_ = ref struct2 + 8;
							this.label110.Text = this.method_176(pByte_, 8U);
							this.label72.Text = this.label110.Text;
							this.label100.Text = this.label110.Text;
							this.label109.Text = "";
							this.label68.Text = "";
							pByte_ = ref struct2 + 16;
							this.label109.Text = this.method_176(pByte_, 16U);
							this.label68.Text = this.label109.Text;
							this.label99.Text = this.label109.Text;
							this.label106.Text = "";
							this.label61.Text = "";
							pByte_ = ref struct2 + 32;
							this.label106.Text = this.method_176(pByte_, 4U);
							this.label61.Text = this.label106.Text;
							this.label98.Text = this.label106.Text;
							this.label92.Text = new string((sbyte*)(&<Module>.struct19_0));
							this.label58.Text = new string((sbyte*)(&<Module>.struct19_0));
							pByte_ = ref struct2 + 36;
							this.label92.Text = this.method_176(pByte_, 20U);
							this.label58.Text = this.label92.Text;
							this.label97.Text = this.label92.Text;
							Application.DoEvents();
							if (*(ref struct2 + 8) == 0 | *(ref struct2 + 8) == 255)
							{
								this.label110.Text = "No Drive Detected!";
								this.label109.Text = "";
								this.label106.Text = "";
								this.label92.Text = "";
								this.label72.Text = "No Drive Detected!";
								this.label68.Text = "";
								this.label61.Text = "";
								this.label58.Text = "";
								this.label100.Text = "No Drive Detected!";
								this.label99.Text = "";
								this.label98.Text = "";
								this.label97.Text = "";
							}
							if (*(ref struct2 + 8) == *(ref struct2 + 10) | *(ref struct2 + 8) == *(ref struct2 + 12) | *(ref struct2 + 8) == *(ref struct2 + 14) | *(ref struct2 + 8) == *(ref struct2 + 16))
							{
								this.label110.Text = "No Drive Detected!";
								this.label109.Text = "";
								this.label106.Text = "";
								this.label92.Text = "";
								this.label72.Text = "No Drive Detected!";
								this.label68.Text = "";
								this.label61.Text = "";
								this.label58.Text = "";
								this.label100.Text = "No Drive Detected!";
								this.label99.Text = "";
								this.label98.Text = "";
								this.label97.Text = "";
							}
							if (*(ref struct2 + 32) == 48 & *(ref struct2 + 33) == 48)
							{
								if (*(ref struct2 + 34) == 53)
								{
									this.radioButton4.Checked = true;
								}
								else if (*(ref struct2 + 34) == 55)
								{
									this.radioButton5.Checked = true;
								}
								else if (*(ref struct2 + 34) == 52 & *(ref struct2 + 35) != 48)
								{
									this.radioButton3.Checked = true;
								}
								else if (*(ref struct2 + 34) == 51 & *(ref struct2 + 35) == 54)
								{
									this.radioButton2.Checked = true;
								}
								else
								{
									this.radioButton1.Checked = true;
								}
							}
							this.pictureBox5.Visible = false;
							this.pictureBox7.Visible = true;
							this.pictureBox2.Visible = false;
							this.pictureBox6.Visible = true;
							this.menuItem_21.Enabled = false;
							this.menuItem_22.Enabled = false;
							this.menuItem_23.Enabled = false;
							this.menuItem_24.Enabled = false;
							this.toolTip_0.SetToolTip(this.pictureBox5, null);
							this.toolTip_0.SetToolTip(this.pictureBox2, null);
							this.label133.Text = "Not Found";
							this.label131.Text = "Not Found";
							this.string_14 = "";
							this.string_15 = "";
							this.string_16 = "";
							this.string_17 = "";
							if (*(ref <Module>.struct38_0 + selectedIndex * 72U) == 0 && *(ref <Module>.struct38_0 + selectedIndex * 72U + 3) == 1)
							{
								this.Cursor = Cursors.Arrow;
								result = 1;
							}
							else
							{
								this.method_178();
								string text3;
								if (*(ref struct2 + 42) == 68 && *(ref struct2 + 43) == 54 && *(ref struct2 + 46) == 67 && *(ref struct2 + 47) == 71)
								{
									pByte_ = ref struct2 + 42;
									text3 = this.method_176(pByte_, 17U);
								}
								else
								{
									if ((*(ref struct2 + 32) != 57 || *(ref struct2 + 33) != 53 || *(ref struct2 + 34) != 48 || *(ref struct2 + 35) != 52) && (*(ref struct2 + 32) != 48 || *(ref struct2 + 33) != 50 || *(ref struct2 + 34) != 50 || *(ref struct2 + 35) != 53) && (*(ref struct2 + 32) != 48 || *(ref struct2 + 33) != 50 || *(ref struct2 + 34) != 55 || *(ref struct2 + 35) != 50) && (*(ref struct2 + 32) != 48 || *(ref struct2 + 33) != 52 || *(ref struct2 + 34) != 48 || *(ref struct2 + 35) != 49) && (*(ref struct2 + 32) != 49 || *(ref struct2 + 33) != 48 || *(ref struct2 + 34) != 55 || *(ref struct2 + 35) != 49))
									{
										this.Cursor = Cursors.Arrow;
										return 1;
									}
									<Module>.memset((void*)(&@struct), 0, 12U);
									@struct = 18;
									*(ref @struct + 1) = 0;
									*(ref @struct + 2) = 0;
									*(ref @struct + 3) = 0;
									*(ref @struct + 4) = 116;
									*(ref @struct + 5) = 192;
									if (<Module>.smethod_16((byte*)(&@struct), 12U, (byte)num3, 512, (void*)(&struct2), &num4, 116U, 1, &gstruct) != null)
									{
										this.Cursor = Cursors.Arrow;
										return 0;
									}
									if (*(ref struct2 + 96) == 255 && *(ref struct2 + 97) == 255)
									{
										return 0;
									}
									pByte_ = ref struct2 + 96;
									text3 = this.method_176(pByte_, 17U);
								}
								RegistryKey registryKey = Registry.CurrentUser.CreateSubKey("JF_KeyDB\\SerList");
								if (registryKey.GetValue(text3) != null)
								{
									string text4 = registryKey.GetValue(text3).ToString();
									registryKey.Close();
									registryKey = Registry.CurrentUser.CreateSubKey("JF_KeyDB\\" + text4);
									if (registryKey.GetValue("Key") != null)
									{
										text = registryKey.GetValue("Key").ToString();
										this.string_14 = text;
									}
									if (registryKey.GetValue("JobName") != null)
									{
										text2 = registryKey.GetValue("JobName").ToString();
									}
									string text5;
									if (registryKey.GetValue("WorkingDir") != null)
									{
										text5 = registryKey.GetValue("WorkingDir").ToString();
									}
									else
									{
										text5 = "";
									}
									string strA;
									if (registryKey.GetValue("LastFile") != null)
									{
										strA = registryKey.GetValue("LastFile").ToString();
									}
									else
									{
										strA = "";
									}
									Struct28 struct3;
									for (int i = 0; i < 32; i += 2)
									{
										string s = text.Substring(i, 2);
										IntPtr intPtr = Marshal.StringToHGlobalAnsi(s);
										IntPtr value = intPtr;
										sbyte* pSbyte_ = (sbyte*)((void*)value);
										this.method_10((void*)(&num4), pSbyte_, 2);
										*(ref struct3 + i / 2) = (byte)num4;
									}
									if (this.method_107((byte*)(&struct3)) == 1)
									{
										this.toolTip_0.SetToolTip(this.pictureBox5, "Drive Barcode found in KeyDB (" + text4 + " - " + text2 + ")" + Environment.NewLine + "Barcode is: " + text3 + Environment.NewLine + "Key is: " + text);
										this.toolTip_0.SetToolTip(this.pictureBox2, "Drive Barcode found in KeyDB (" + text4 + " - " + text2 + ")" + Environment.NewLine + "Barcode is: " + text3 + Environment.NewLine + "Key is: " + text);
										this.pictureBox5.Visible = true;
										this.pictureBox7.Visible = false;
										this.pictureBox2.Visible = true;
										this.pictureBox6.Visible = false;
										if (string.Compare(strA, "") != 0)
										{
											this.menuItem_21.Enabled = true;
										}
										this.menuItem_22.Enabled = true;
										this.menuItem_23.Enabled = true;
										this.menuItem_24.Enabled = true;
										this.label133.Text = "Verified";
										this.label131.Text = "Verified";
										this.string_14 = text;
										this.string_15 = text4;
										this.string_16 = strA;
										this.string_17 = text5;
										registryKey.Close();
										this.Cursor = Cursors.Arrow;
										if (this.bool_1)
										{
											this.textBox6.AppendText("\r\n" + "Key found in KeyDB at record (" + text4 + " - " + text2 + ")" + "\r\n" + "Key is: " + text + "\r\n" + "Key has been tested and verified, thanks C4eva ! " + "\r\n");
										}
										result = 2;
									}
									else
									{
										if (string.Compare(text3, "D608CG73880800348") == 0 && this.bool_1)
										{
											<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
											uint num5 = (uint)MessageBox.Show("Barcode is common to all Lite-On DG-16D2S following the 13146 System update" + "\n" + "Key DB entrys from before update may exist and match" + "\n" + "Click YES to manually enter and search for the Case Barcode.", "Dummy-From-KeyDB", MessageBoxButtons.YesNo, MessageBoxIcon.Question, MessageBoxDefaultButton.Button1);
											<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
											if (num5 == 6U)
											{
												Common_Barcode common_Barcode = new Common_Barcode();
												if (common_Barcode.ShowDialog(this) == DialogResult.OK)
												{
													text3 = common_Barcode.textBox3.Text;
													text3 = text3.Substring(0, 17);
													registryKey = Registry.CurrentUser.CreateSubKey("JF_KeyDB\\SerList");
													if (registryKey.GetValue(text3) == null)
													{
														this.pictureBox5.Visible = false;
														this.pictureBox7.Visible = true;
														this.pictureBox2.Visible = false;
														this.pictureBox6.Visible = true;
														this.menuItem_21.Enabled = false;
														this.menuItem_22.Enabled = false;
														this.menuItem_23.Enabled = false;
														this.menuItem_24.Enabled = false;
														this.toolTip_0.SetToolTip(this.pictureBox5, null);
														this.toolTip_0.SetToolTip(this.pictureBox2, null);
														this.label133.Text = "Not Found";
														this.label131.Text = "Not Found";
														this.Cursor = Cursors.Arrow;
														registryKey.Close();
														return 1;
													}
													text4 = registryKey.GetValue(text3).ToString();
													registryKey.Close();
												}
											}
										}
										registryKey = Registry.CurrentUser.CreateSubKey("JF_KeyDB\\" + text4);
										if (registryKey.GetValue("Key") != null)
										{
											text = registryKey.GetValue("Key").ToString();
											this.string_14 = text;
										}
										if (registryKey.GetValue("JobName") != null)
										{
											text2 = registryKey.GetValue("JobName").ToString();
										}
										if (registryKey.GetValue("WorkingDir") != null)
										{
											text5 = registryKey.GetValue("WorkingDir").ToString();
										}
										else
										{
											text5 = "";
										}
										if (registryKey.GetValue("LastFile") != null)
										{
											strA = registryKey.GetValue("LastFile").ToString();
										}
										else
										{
											strA = "";
										}
										for (int i = 0; i < 32; i += 2)
										{
											string s = text.Substring(i, 2);
											IntPtr intPtr2 = Marshal.StringToHGlobalAnsi(s);
											IntPtr value2 = intPtr2;
											sbyte* pSbyte_ = (sbyte*)((void*)value2);
											this.method_10((void*)(&num4), pSbyte_, 2);
											*(ref struct3 + i / 2) = (byte)num4;
										}
										if (this.method_107((byte*)(&struct3)) == 1)
										{
											this.toolTip_0.SetToolTip(this.pictureBox5, "Drive Barcode found in KeyDB (" + text4 + " - " + text2 + ")" + Environment.NewLine + "Barcode is: " + text3 + Environment.NewLine + "Key is: " + text);
											this.toolTip_0.SetToolTip(this.pictureBox2, "Drive Barcode found in KeyDB (" + text4 + " - " + text2 + ")" + Environment.NewLine + "Barcode is: " + text3 + Environment.NewLine + "Key is: " + text);
											this.pictureBox5.Visible = true;
											this.pictureBox7.Visible = false;
											this.pictureBox2.Visible = true;
											this.pictureBox6.Visible = false;
											if (string.Compare(strA, "") != 0)
											{
												this.menuItem_21.Enabled = true;
											}
											this.menuItem_22.Enabled = true;
											this.menuItem_23.Enabled = true;
											this.menuItem_24.Enabled = true;
											this.label133.Text = "Verified";
											this.label131.Text = "Verified";
											this.string_14 = text;
											this.string_15 = text4;
											this.string_16 = strA;
											this.string_17 = text5;
											registryKey.Close();
											this.Cursor = Cursors.Arrow;
											if (this.bool_1)
											{
												this.textBox6.AppendText("\r\n" + "Key found in KeyDB at record (" + text4 + " - " + text2 + ")" + "\r\n" + "Key is: " + text + "\r\n" + "Key has been tested and verified, thanks C4eva ! " + "\r\n");
											}
											result = 2;
										}
										else
										{
											result = 1;
										}
									}
								}
								else
								{
									this.pictureBox5.Visible = false;
									this.pictureBox7.Visible = true;
									this.pictureBox2.Visible = false;
									this.pictureBox6.Visible = true;
									this.menuItem_21.Enabled = false;
									this.menuItem_22.Enabled = false;
									this.menuItem_23.Enabled = false;
									this.menuItem_24.Enabled = false;
									this.toolTip_0.SetToolTip(this.pictureBox5, null);
									this.toolTip_0.SetToolTip(this.pictureBox2, null);
									this.label133.Text = "Not Found";
									this.label131.Text = "Not Found";
									this.Cursor = Cursors.Arrow;
									registryKey.Close();
									result = 1;
								}
							}
						}
					}
				}
			}
			return result;
		}

		// Token: 0x060002C2 RID: 706 RVA: 0x0013191C File Offset: 0x0013191C
		private unsafe int method_174()
		{
			int result;
			if (this.comboBox1.Items.Count == 0)
			{
				result = 0;
			}
			else
			{
				ushort selectedIndex = (ushort)this.comboBox1.SelectedIndex;
				ushort ushort_ = *(ref <Module>.struct38_0 + selectedIndex * 72);
				uint num;
				if (*(ref <Module>.struct38_0 + selectedIndex * 72 + 4) == 160)
				{
					num = 0U;
				}
				else
				{
					num = 16U;
				}
				GStruct3 gstruct;
				<Module>.smethod_21(&gstruct, ushort_, 0, 1, 1000U);
				Struct30 @struct;
				uint num2;
				if (<Module>.smethod_12(236, (byte)num, null, null, 64, (void*)(&@struct), &num2, 512U, 512U, 1, &gstruct) != null)
				{
					this.label110.Text = "No Drive Detected!";
					this.label109.Text = "";
					this.label106.Text = "";
					this.label92.Text = "";
					this.label72.Text = "No Drive Detected!";
					this.label68.Text = "";
					this.label61.Text = "";
					this.label58.Text = "";
					this.label100.Text = "No Drive Detected!";
					this.label99.Text = "";
					this.label98.Text = "";
					this.label97.Text = "";
					result = 0;
				}
				else
				{
					Struct30 struct2;
					for (uint num3 = 0U; num3 < 512U; num3 += 2U)
					{
						*(ref struct2 + num3) = *(ref @struct + (num3 + 1U));
						*(ref struct2 + (num3 + 1U)) = *(ref @struct + num3);
					}
					byte* ptr = ref struct2 + 54;
					Struct37 struct3;
					<Module>.memset((void*)(&struct3), 0, 40U);
					Struct37 struct4;
					<Module>.memset((void*)(&struct4), 0, 40U);
					Struct42 struct5;
					<Module>.memset((void*)(&struct5), 0, 20U);
					uint num4;
					for (num4 = 0U; num4 < 40U; num4 += 1U)
					{
						if (ptr[num4] == 32)
						{
							break;
						}
						*(ref struct3 + num4) = ptr[num4];
					}
					uint num5;
					for (num5 = 0U; num5 < 40U - num4; num5 += 1U)
					{
						*(ref struct4 + num5) = ptr[num5 + num4 + 1U];
					}
					ptr = ref struct2 + 20;
					for (num4 = 0U; num4 < 20U; num4 += 1U)
					{
						if (ptr[num4] != 32)
						{
							break;
						}
					}
					for (num5 = 0U; num5 < 20U - num4; num5 += 1U)
					{
						*(ref struct5 + num5) = ptr[num5 + num4];
					}
					this.label110.Text = "";
					this.label72.Text = "";
					this.label100.Text = "";
					this.label110.Text = this.method_176((byte*)(&struct3), num4);
					this.label72.Text = this.label110.Text;
					this.label100.Text = this.label110.Text;
					this.label109.Text = "";
					this.label68.Text = "";
					this.label99.Text = "";
					this.label109.Text = this.method_176((byte*)(&struct4), num5);
					this.label68.Text = this.label109.Text;
					this.label99.Text = this.label109.Text;
					this.label106.Text = "";
					this.label61.Text = "";
					this.label98.Text = "";
					this.label106.Text = this.method_176(ref struct2 + 46, 8U);
					this.label61.Text = this.label106.Text;
					this.label98.Text = this.label106.Text;
					this.label92.Text = "";
					this.label58.Text = "";
					this.label97.Text = "";
					this.label92.Text = this.method_176((byte*)(&struct5), 20U);
					this.label58.Text = this.label92.Text;
					this.label97.Text = this.label92.Text;
					this.method_14();
					this.method_18();
					this.method_17();
					this.checkBox6.CheckState = CheckState.Unchecked;
					result = 1;
				}
			}
			return result;
		}

		// Token: 0x060002C3 RID: 707 RVA: 0x00131D28 File Offset: 0x00131D28
		private unsafe int method_175()
		{
			int result;
			if (this.comboBox1.Items.Count == 0)
			{
				result = 0;
			}
			else
			{
				ushort selectedIndex = (ushort)this.comboBox1.SelectedIndex;
				ushort ushort_ = *(ref <Module>.struct38_0 + selectedIndex * 72);
				uint num;
				if (*(ref <Module>.struct38_0 + selectedIndex * 72 + 4) == 160)
				{
					num = 0U;
				}
				else
				{
					num = 16U;
				}
				GStruct3 gstruct;
				<Module>.smethod_21(&gstruct, ushort_, 0, 1, 1000U);
				result = ((<Module>.smethod_11(8, (byte)num, null, null, 64, 1, &gstruct) == null) ? 1 : 0);
			}
			return result;
		}

		// Token: 0x060002C4 RID: 708 RVA: 0x00131DA4 File Offset: 0x00131DA4
		private unsafe string method_176(byte* pByte_0, uint uint_0)
		{
			string text = null;
			for (uint num = 0U; num < uint_0; num += 1U)
			{
				if (pByte_0[num] >= 32 && pByte_0[num] <= 126)
				{
					Struct20 @struct;
					<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct18_0), pByte_0[num]);
					string text2 = new string((sbyte*)(&<Module>.struct19_0));
					text2 += new string((sbyte*)(&@struct));
					text += text2;
				}
				else
				{
					text += " ";
				}
			}
			return text;
		}

		// Token: 0x060002C5 RID: 709 RVA: 0x00131E18 File Offset: 0x00131E18
		private void comboBox1_SelectedIndexChanged(object sender, EventArgs e)
		{
			int selectedIndex = this.comboBox1.SelectedIndex;
			if (this.bool_1)
			{
				if (this.bool_1)
				{
					this.method_177();
				}
				this.int_9 = this.comboBox1.SelectedIndex;
			}
		}

		// Token: 0x060002C6 RID: 710 RVA: 0x00131E5C File Offset: 0x00131E5C
		private void comboBox7_SelectedIndexChanged(object sender, EventArgs e)
		{
			uint selectedIndex = (uint)this.comboBox7.SelectedIndex;
			this.comboBox1.SelectedIndex = (int)selectedIndex;
			this.comboBox13.SelectedIndex = (int)selectedIndex;
		}

		// Token: 0x060002C7 RID: 711 RVA: 0x00131E90 File Offset: 0x00131E90
		private void comboBox13_SelectedIndexChanged(object sender, EventArgs e)
		{
			uint selectedIndex = (uint)this.comboBox13.SelectedIndex;
			this.comboBox1.SelectedIndex = (int)selectedIndex;
			this.comboBox7.SelectedIndex = (int)selectedIndex;
		}

		// Token: 0x060002C8 RID: 712 RVA: 0x003C5FD8 File Offset: 0x0030DFD8
		private unsafe void method_177()
		{
			uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
			if (selectedIndex != 4294967295U)
			{
				this.comboBox7.SelectedIndex = (int)selectedIndex;
				this.comboBox13.SelectedIndex = (int)selectedIndex;
				this.label118.Text = "";
				this.label119.Text = "";
				this.label120.Text = "";
				this.label121.Text = "";
				this.label122.Text = "";
				this.label133.Text = "";
				this.label131.Text = "";
				if (*(ref <Module>.gstruct10_0 + 4) != 0)
				{
					this.method_422();
				}
				if (*(ref <Module>.gstruct10_0 + 8) != 0)
				{
					this.method_423();
				}
				if (*(ref <Module>.struct38_0 + selectedIndex * 72U) == 0)
				{
					if (*(ref <Module>.struct38_0 + selectedIndex * 72U + 3) == 0)
					{
						*(ref <Module>.gstruct10_0 + 14) = 0;
						if (*(ref <Module>.gstruct10_0 + 4) != 0)
						{
							this.method_422();
						}
						if (this.method_420() == 1)
						{
							this.label135.Text = "X360USB PRO: Opened";
							Application.DoEvents();
							Thread thread = new Thread(new ThreadStart(this.method_165));
							thread.Start();
						}
					}
					else
					{
						*(ref <Module>.gstruct10_0 + 14) = 1;
						if (*(ref <Module>.gstruct10_0 + 8) != 0)
						{
							this.method_423();
						}
						if (this.method_421() == 1)
						{
							this.label135.Text = "X360USB BADASS: Opened";
							Application.DoEvents();
							Thread thread2 = new Thread(new ThreadStart(this.method_165));
							thread2.Start();
						}
					}
				}
				else
				{
					if (*(ref <Module>.gstruct10_0 + 4) != 0)
					{
						this.method_424(1);
						this.bool_9 = true;
						this.method_422();
						this.label135.Text = "X360USB PRO: Closed";
						Application.DoEvents();
						Thread thread3 = new Thread(new ThreadStart(this.method_165));
						thread3.Start();
					}
					if (*(ref <Module>.gstruct10_0 + 8) != 0)
					{
						this.method_423();
						this.label135.Text = "X360USB BADASS: Closed";
						Application.DoEvents();
						Thread thread4 = new Thread(new ThreadStart(this.method_165));
						thread4.Start();
					}
				}
				if (*(ref <Module>.struct38_0 + selectedIndex * 72U + 2) == 1)
				{
					this.label117.Text = new string((sbyte*)(&<Module>.struct35_126));
					this.label83.Text = new string((sbyte*)(&<Module>.struct35_126));
				}
				else if (*(ref <Module>.struct38_0 + selectedIndex * 72U + 2) == 2)
				{
					this.label117.Text = new string((sbyte*)(&<Module>.struct35_127));
					this.label83.Text = new string((sbyte*)(&<Module>.struct35_127));
				}
				else
				{
					this.label117.Text = new string((sbyte*)(&<Module>.struct35_128));
					this.label83.Text = new string((sbyte*)(&<Module>.struct35_128));
				}
				if (*(ref <Module>.struct38_0 + selectedIndex * 72U + 3) != 0)
				{
					this.label116.Text = new string((sbyte*)(&<Module>.struct7_5));
					this.label81.Text = new string((sbyte*)(&<Module>.struct7_5));
				}
				else
				{
					this.label116.Text = new string((sbyte*)(&<Module>.struct7_6));
					this.label81.Text = new string((sbyte*)(&<Module>.struct7_6));
				}
				if (*(ref <Module>.struct38_0 + selectedIndex * 72U + 4) == 160)
				{
					this.label115.Text = new string((sbyte*)(&<Module>.struct10_24));
					this.label76.Text = new string((sbyte*)(&<Module>.struct10_24));
				}
				else
				{
					this.label115.Text = new string((sbyte*)(&<Module>.struct10_25));
					this.label76.Text = new string((sbyte*)(&<Module>.struct10_25));
				}
				if (*(ref <Module>.struct38_0 + selectedIndex * 72U) == 0)
				{
					if (*(ref <Module>.struct38_0 + selectedIndex * 72U + 3) == 0)
					{
						this.label113.Text = "XECUTER X360USB PRO" + Environment.NewLine + "( Ver " + this.string_23 + " )";
						this.label75.Text = "XECUTER X360USB PRO" + Environment.NewLine + "( Ver " + this.string_23 + " )";
					}
					else
					{
						this.label113.Text = "XECUTER X360USB BAD ASS" + Environment.NewLine + "( Ver " + this.string_24 + " )";
						this.label75.Text = "XECUTER X360USB BAD ASS" + Environment.NewLine + "( Ver " + this.string_24 + " )";
					}
				}
				else
				{
					this.label113.Text = new string(ref <Module>.struct38_0 + selectedIndex * 72U + 5);
					this.label75.Text = new string(ref <Module>.struct38_0 + selectedIndex * 72U + 5);
				}
				Struct60 @struct;
				*(ref @struct + 1) = (byte)(*(ref <Module>.struct38_0 + selectedIndex * 72U) & 255);
				@struct = (*(ref <Module>.struct38_0 + selectedIndex * 72U) & 65280) >> 8;
				this.label123.Text = this.method_171((byte*)(&@struct), 2U, 0U);
				this.label84.Text = this.method_171((byte*)(&@struct), 2U, 0U);
				this.method_15();
				this.method_19();
				this.method_16();
				this.pictureBox2.Visible = false;
				this.pictureBox5.Visible = false;
				this.menuItem_21.Enabled = false;
				this.menuItem_22.Enabled = false;
				this.menuItem_23.Enabled = false;
				this.menuItem_24.Enabled = false;
				Application.DoEvents();
				this.method_172();
			}
		}

		// Token: 0x060002C9 RID: 713 RVA: 0x00132420 File Offset: 0x00132420
		private void button9_Click(object sender, EventArgs e)
		{
			this.method_177();
		}

		// Token: 0x060002CA RID: 714 RVA: 0x00132434 File Offset: 0x00132434
		private void button10_Click(object sender, EventArgs e)
		{
			this.method_177();
		}

		// Token: 0x060002CB RID: 715 RVA: 0x00132448 File Offset: 0x00132448
		private unsafe void button25_Click(object sender, EventArgs e)
		{
			uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
			uint count = (uint)this.comboBox1.Items.Count;
			ushort num = *(ref <Module>.struct38_0 + selectedIndex * 72U);
			this.method_177();
			if (this.radioButton17.Checked && num == 0 && count != 0U)
			{
				this.method_424(1);
				this.bool_9 = true;
				<Module>.Sleep(10);
				this.method_424(5);
				<Module>.Sleep(25);
				this.method_424(7);
			}
		}

		// Token: 0x060002CC RID: 716 RVA: 0x003C6540 File Offset: 0x0030E540
		private void method_178()
		{
			if (this.method_179() == 1)
			{
				if (this.bool_1)
				{
					this.textBox6.AppendText("Drive is Hitachi.. " + "\r\n");
				}
			}
			else if (this.method_180() == 1)
			{
				if (this.bool_1)
				{
					this.textBox6.AppendText("Drive is Hitachi.. 78/79 " + "\r\n");
				}
			}
			else if (this.method_181() == 1)
			{
				if (this.bool_1)
				{
					this.textBox6.AppendText("Drive is Samsung.. " + "\r\n");
				}
				this.radioButton20.Checked = true;
			}
			else if (this.method_182() == 1)
			{
				if (this.bool_1)
				{
					this.textBox6.AppendText("Drive is Benq.. " + "\r\n");
				}
				this.radioButton20.Checked = true;
			}
			else if (this.method_184() == 1)
			{
				if (this.bool_1)
				{
					this.textBox6.AppendText("Drive is Slim Lite-On.. " + "\r\n");
				}
				if (this.radioButton21.Checked)
				{
					this.radioButton19.Checked = true;
				}
			}
			else if (this.method_185() == 1)
			{
				if (this.bool_1)
				{
					this.textBox6.AppendText("Drive is Slim Lite-On.. " + "\r\n");
				}
				if (this.radioButton21.Visible)
				{
					this.radioButton21.Checked = true;
				}
			}
			else if (this.method_183() == 1)
			{
				if (this.bool_1)
				{
					this.textBox6.AppendText("Drive is Lite-On.. " + "\r\n");
				}
				this.radioButton20.Checked = true;
			}
			else
			{
				this.textBox6.AppendText("Drive type Un-determined" + "\r\n");
			}
		}

		// Token: 0x060002CD RID: 717 RVA: 0x003C671C File Offset: 0x0030E71C
		private unsafe int method_179()
		{
			string text = null;
			string text2 = null;
			int result;
			if (this.comboBox1.Items.Count == 0)
			{
				result = 0;
			}
			else
			{
				uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
				ushort ushort_ = *(ref <Module>.struct38_0 + selectedIndex * 72U);
				uint num;
				if (*(ref <Module>.struct38_0 + selectedIndex * 72U + 4) == 160)
				{
					num = 0U;
				}
				else
				{
					num = 16U;
				}
				GStruct3 gstruct;
				<Module>.smethod_21(&gstruct, ushort_, 0, 1, 500U);
				Struct28 @struct;
				<Module>.memset((void*)(&@struct), 0, 16U);
				Struct52 struct2;
				<Module>.memset((void*)(&struct2), 0, 12U);
				struct2 = 231;
				*(ref struct2 + 1) = 72;
				*(ref struct2 + 2) = 73;
				*(ref struct2 + 3) = 84;
				*(ref struct2 + 4) = 1;
				*(ref struct2 + 6) = 145;
				*(ref struct2 + 7) = 0;
				*(ref struct2 + 8) = 79;
				*(ref struct2 + 9) = 0;
				*(ref struct2 + 10) = 0;
				*(ref struct2 + 11) = 16;
				uint num2;
				if (<Module>.smethod_16((byte*)(&struct2), 12U, (byte)num, 512, (void*)(&@struct), &num2, 16U, 1, &gstruct) != null)
				{
					result = 0;
				}
				else
				{
					this.method_6((byte*)(&@struct), 16U, 0U);
					if (this.method_107((byte*)(&@struct)) == 1)
					{
						this.method_6((byte*)(&@struct), 16U, 0U);
						if (this.bool_1)
						{
							this.textBox6.AppendText("Drive key " + this.string_0 + "\r\n");
						}
						RegistryKey registryKey = Registry.CurrentUser.CreateSubKey("JF_KeyDB\\KeyList");
						if (registryKey.GetValue(this.string_0) == null)
						{
							this.toolTip_0.SetToolTip(this.pictureBox5, "Drive Key NOT in KeyDB " + Environment.NewLine + "Key is: " + this.string_0);
							this.toolTip_0.SetToolTip(this.pictureBox2, "Drive Key NOT in KeyDB " + Environment.NewLine + "Key is: " + this.string_0);
							this.pictureBox5.Visible = true;
							this.pictureBox7.Visible = false;
							this.pictureBox2.Visible = true;
							this.pictureBox6.Visible = false;
							this.string_14 = text;
							this.label133.Text = "Verified";
							this.label131.Text = "Verified";
							registryKey.Close();
							this.Cursor = Cursors.Arrow;
							if (this.bool_1)
							{
								this.textBox6.AppendText("\r\n" + "Key NOT in KeyDB " + "\r\n" + "Key is: " + this.string_0 + "\r\n" + "Key has been tested and verified, thanks C4eva ! " + "\r\n");
							}
							return 1;
						}
						string text3 = registryKey.GetValue(this.string_0).ToString();
						registryKey.Close();
						registryKey = Registry.CurrentUser.CreateSubKey("JF_KeyDB\\" + text3);
						if (registryKey.GetValue("JobName") != null)
						{
							text2 = registryKey.GetValue("JobName").ToString();
						}
						string text4;
						if (registryKey.GetValue("WorkingDir") != null)
						{
							text4 = registryKey.GetValue("WorkingDir").ToString();
						}
						else
						{
							text4 = "";
						}
						string strA;
						if (registryKey.GetValue("LastFile") != null)
						{
							strA = registryKey.GetValue("LastFile").ToString();
						}
						else
						{
							strA = "";
						}
						if (registryKey.GetValue("Index") != null)
						{
							text3 = registryKey.GetValue("Index").ToString();
						}
						this.toolTip_0.SetToolTip(this.pictureBox5, "Drive Key found in KeyDB (" + text3 + " - " + text2 + ")" + Environment.NewLine + "Key is: " + this.string_0);
						this.toolTip_0.SetToolTip(this.pictureBox2, "Drive Key found in KeyDB (" + text3 + " - " + text2 + ")" + Environment.NewLine + "Key is: " + this.string_0);
						this.pictureBox5.Visible = true;
						this.pictureBox7.Visible = false;
						this.pictureBox2.Visible = true;
						this.pictureBox6.Visible = false;
						if (string.Compare(strA, "") != 0)
						{
							this.menuItem_21.Enabled = true;
						}
						this.menuItem_22.Enabled = true;
						this.menuItem_23.Enabled = true;
						this.menuItem_24.Enabled = true;
						this.string_14 = text;
						this.string_15 = text3;
						this.string_16 = strA;
						this.string_17 = text4;
						this.label133.Text = "Verified";
						this.label131.Text = "Verified";
						registryKey.Close();
						this.Cursor = Cursors.Arrow;
						if (this.bool_1)
						{
							this.textBox6.AppendText("\r\n" + "Key found in KeyDB at record (" + text3 + " - " + text2 + ")" + "\r\n" + "Key is: " + this.string_0 + "\r\n" + "Key has been tested and verified, thanks C4eva ! " + "\r\n");
						}
					}
					result = 1;
				}
			}
			return result;
		}

		// Token: 0x060002CE RID: 718 RVA: 0x00132B48 File Offset: 0x00132B48
		private unsafe int method_180()
		{
			int result;
			if (this.comboBox1.Items.Count == 0)
			{
				result = 0;
			}
			else
			{
				uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
				ushort ushort_ = *(ref <Module>.struct38_0 + selectedIndex * 72U);
				uint num;
				if (*(ref <Module>.struct38_0 + selectedIndex * 72U + 4) == 160)
				{
					num = 0U;
				}
				else
				{
					num = 16U;
				}
				GStruct3 gstruct;
				<Module>.smethod_21(&gstruct, ushort_, 0, 1, 250U);
				Struct52 @struct;
				<Module>.memset((void*)(&@struct), 0, 12U);
				@struct = 231;
				*(ref @struct + 1) = 72;
				*(ref @struct + 2) = 73;
				*(ref @struct + 3) = 84;
				*(ref @struct + 4) = 48;
				*(ref @struct + 5) = 144;
				*(ref @struct + 6) = 144;
				*(ref @struct + 7) = 208;
				*(ref @struct + 8) = 1;
				result = ((<Module>.smethod_15((byte*)(&@struct), 12U, (byte)num, 1, &gstruct) == null) ? 1 : 0);
			}
			return result;
		}

		// Token: 0x060002CF RID: 719 RVA: 0x003C6BCC File Offset: 0x0030EBCC
		private unsafe int method_181()
		{
			string text = null;
			string text2 = null;
			Struct28 @struct = 255;
			*(ref @struct + 1) = byte.MaxValue;
			*(ref @struct + 2) = byte.MaxValue;
			*(ref @struct + 3) = byte.MaxValue;
			*(ref @struct + 4) = byte.MaxValue;
			*(ref @struct + 5) = byte.MaxValue;
			*(ref @struct + 6) = byte.MaxValue;
			*(ref @struct + 7) = byte.MaxValue;
			*(ref @struct + 8) = byte.MaxValue;
			*(ref @struct + 9) = byte.MaxValue;
			*(ref @struct + 10) = byte.MaxValue;
			*(ref @struct + 11) = byte.MaxValue;
			*(ref @struct + 12) = byte.MaxValue;
			*(ref @struct + 13) = byte.MaxValue;
			*(ref @struct + 14) = byte.MaxValue;
			*(ref @struct + 15) = byte.MaxValue;
			uint uint_ = 12U;
			uint uint_2 = 16U;
			int result;
			if (this.comboBox1.Items.Count == 0)
			{
				result = 0;
			}
			else
			{
				uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
				ushort ushort_ = *(ref <Module>.struct38_0 + selectedIndex * 72U);
				uint num;
				if (*(ref <Module>.struct38_0 + selectedIndex * 72U + 4) == 160)
				{
					num = 0U;
				}
				else
				{
					num = 16U;
				}
				GStruct3 gstruct;
				<Module>.smethod_21(&gstruct, ushort_, 0, 1, 250U);
				Struct52 struct2;
				<Module>.memset((void*)(&struct2), 0, 12U);
				Struct28 struct3;
				<Module>.memset((void*)(&struct3), 0, 16U);
				struct2 = 255;
				*(ref struct2 + 1) = 8;
				*(ref struct2 + 2) = 5;
				*(ref struct2 + 4) = 5;
				*(ref struct2 + 5) = 1;
				*(ref struct2 + 6) = 3;
				*(ref struct2 + 8) = 4;
				*(ref struct2 + 9) = 7;
				uint num2;
				if (<Module>.smethod_16((byte*)(&struct2), uint_, (byte)num, 512, (void*)(&struct3), &num2, uint_2, 1, &gstruct) != null)
				{
					result = 0;
				}
				else
				{
					if (this.method_107((byte*)(&struct3)) == 1)
					{
						this.method_6((byte*)(&struct3), 16U, 0U);
						RegistryKey registryKey = Registry.CurrentUser.CreateSubKey("JF_KeyDB\\KeyList");
						if (registryKey.GetValue(this.string_0) == null)
						{
							this.toolTip_0.SetToolTip(this.pictureBox5, "Drive Key NOT in KeyDB " + Environment.NewLine + "Key is: " + this.string_0);
							this.toolTip_0.SetToolTip(this.pictureBox2, "Drive Key NOT in KeyDB " + Environment.NewLine + "Key is: " + this.string_0);
							this.pictureBox5.Visible = true;
							this.pictureBox7.Visible = false;
							this.pictureBox2.Visible = true;
							this.pictureBox6.Visible = false;
							this.string_14 = text;
							this.label133.Text = "Verified";
							this.label131.Text = "Verified";
							registryKey.Close();
							this.Cursor = Cursors.Arrow;
							if (this.bool_1)
							{
								this.textBox6.AppendText("\r\n" + "Key NOT in KeyDB " + "\r\n" + "Key is: " + this.string_0 + "\r\n" + "Key has been tested and verified, thanks C4eva ! " + "\r\n");
							}
							return 1;
						}
						string text3 = registryKey.GetValue(this.string_0).ToString();
						registryKey.Close();
						registryKey = Registry.CurrentUser.CreateSubKey("JF_KeyDB\\" + text3);
						if (registryKey.GetValue("JobName") != null)
						{
							text2 = registryKey.GetValue("JobName").ToString();
						}
						string text4;
						if (registryKey.GetValue("WorkingDir") != null)
						{
							text4 = registryKey.GetValue("WorkingDir").ToString();
						}
						else
						{
							text4 = "";
						}
						string strA;
						if (registryKey.GetValue("LastFile") != null)
						{
							strA = registryKey.GetValue("LastFile").ToString();
						}
						else
						{
							strA = "";
						}
						if (registryKey.GetValue("Index") != null)
						{
							text3 = registryKey.GetValue("Index").ToString();
						}
						this.toolTip_0.SetToolTip(this.pictureBox5, "Drive Key found in KeyDB (" + text3 + " - " + text2 + ")" + Environment.NewLine + "Key is: " + this.string_0);
						this.toolTip_0.SetToolTip(this.pictureBox2, "Drive Key found in KeyDB (" + text3 + " - " + text2 + ")" + Environment.NewLine + "Key is: " + this.string_0);
						this.pictureBox5.Visible = true;
						this.pictureBox7.Visible = false;
						this.pictureBox2.Visible = true;
						this.pictureBox6.Visible = false;
						if (string.Compare(strA, "") != 0)
						{
							this.menuItem_21.Enabled = true;
						}
						this.menuItem_22.Enabled = true;
						this.menuItem_23.Enabled = true;
						this.menuItem_24.Enabled = true;
						this.string_14 = text;
						this.string_15 = text3;
						this.string_16 = strA;
						this.string_17 = text4;
						this.label133.Text = "Verified";
						this.label131.Text = "Verified";
						registryKey.Close();
						this.Cursor = Cursors.Arrow;
						if (this.bool_1)
						{
							this.textBox6.AppendText("\r\n" + "Key found in KeyDB at record (" + text3 + " - " + text2 + ")" + "\r\n" + "Key is: " + this.string_0 + "\r\n" + "Key has been tested and verified, thanks C4eva ! " + "\r\n");
						}
					}
					result = 1;
				}
			}
			return result;
		}

		// Token: 0x060002D0 RID: 720 RVA: 0x00133124 File Offset: 0x00133124
		private unsafe int method_182()
		{
			Struct28 @struct = 0;
			*(ref @struct + 1) = 1;
			*(ref @struct + 2) = 2;
			*(ref @struct + 3) = 3;
			*(ref @struct + 4) = 4;
			*(ref @struct + 5) = 5;
			*(ref @struct + 6) = 6;
			*(ref @struct + 7) = 7;
			*(ref @struct + 8) = 8;
			*(ref @struct + 9) = 9;
			*(ref @struct + 10) = 10;
			*(ref @struct + 11) = 11;
			*(ref @struct + 12) = 12;
			*(ref @struct + 13) = 13;
			*(ref @struct + 14) = 14;
			*(ref @struct + 15) = 15;
			int result;
			if (this.comboBox1.Items.Count == 0)
			{
				result = 0;
			}
			else
			{
				uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
				ushort ushort_ = *(ref <Module>.struct38_0 + selectedIndex * 72U);
				if (*(ref <Module>.struct38_0 + selectedIndex * 72U) == 0 && *(ref <Module>.struct38_0 + selectedIndex * 72U + 3) == 1)
				{
					result = 0;
				}
				else
				{
					uint num;
					if (*(ref <Module>.struct38_0 + selectedIndex * 72U + 4) == 160)
					{
						num = 0U;
					}
					else
					{
						num = 16U;
					}
					GStruct3 gstruct;
					<Module>.smethod_21(&gstruct, ushort_, 0, 1, 5000U);
					Struct52 struct2;
					<Module>.memset((void*)(&struct2), 0, 12U);
					struct2 = 253;
					*(ref struct2 + 1) = 15;
					*(ref struct2 + 2) = 66;
					*(ref struct2 + 3) = 69;
					*(ref struct2 + 4) = 78;
					*(ref struct2 + 5) = 81;
					*(ref struct2 + 6) = 0;
					*(ref struct2 + 7) = 0;
					*(ref struct2 + 8) = 16;
					uint num2;
					result = ((<Module>.smethod_17((byte*)(&struct2), 12U, (byte)num, 512, (void*)(&@struct), &num2, 16U, 1, &gstruct) == null) ? 1 : 0);
				}
			}
			return result;
		}

		// Token: 0x060002D1 RID: 721 RVA: 0x0013328C File Offset: 0x0013328C
		private unsafe int method_183()
		{
			int result;
			if (this.comboBox1.Items.Count == 0)
			{
				result = 0;
			}
			else
			{
				uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
				ushort ushort_ = *(ref <Module>.struct38_0 + selectedIndex * 72U);
				uint num;
				if (*(ref <Module>.struct38_0 + selectedIndex * 72U + 4) == 160)
				{
					num = 0U;
				}
				else
				{
					num = 16U;
				}
				GStruct3 gstruct;
				<Module>.smethod_21(&gstruct, ushort_, 0, 1, 250U);
				Struct52 @struct;
				<Module>.memset((void*)(&@struct), 0, 12U);
				@struct = 18;
				*(ref @struct + 1) = 0;
				*(ref @struct + 2) = 0;
				*(ref @struct + 3) = 0;
				*(ref @struct + 4) = 96;
				*(ref @struct + 5) = 192;
				*(ref @struct + 6) = 0;
				*(ref @struct + 7) = 0;
				*(ref @struct + 8) = 80;
				*(ref @struct + 9) = 76;
				*(ref @struct + 10) = 68;
				*(ref @struct + 11) = 83;
				Struct29 struct2;
				uint num2;
				if (<Module>.smethod_16((byte*)(&@struct), 12U, (byte)num, 512, (void*)(&struct2), &num2, 96U, 1, &gstruct) != null)
				{
					result = 0;
				}
				else
				{
					if (*(ref struct2 + 8) == 80 && *(ref struct2 + 9) == 76 && *(ref struct2 + 10) == 68)
					{
						if (*(ref struct2 + 11) == 83)
						{
							return 1;
						}
					}
					result = 0;
				}
			}
			return result;
		}

		// Token: 0x060002D2 RID: 722 RVA: 0x0013339C File Offset: 0x0013339C
		private unsafe int method_184()
		{
			Struct103 @struct = 68;
			*(ref @struct + 1) = 71;
			*(ref @struct + 2) = 45;
			*(ref @struct + 3) = 49;
			*(ref @struct + 4) = 54;
			*(ref @struct + 5) = 68;
			*(ref @struct + 6) = 52;
			*(ref @struct + 7) = 83;
			int result;
			if (this.comboBox1.Items.Count == 0)
			{
				result = 0;
			}
			else
			{
				uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
				ushort ushort_ = *(ref <Module>.struct38_0 + selectedIndex * 72U);
				uint num;
				if (*(ref <Module>.struct38_0 + selectedIndex * 72U + 4) == 160)
				{
					num = 0U;
				}
				else
				{
					num = 16U;
				}
				GStruct3 gstruct;
				<Module>.smethod_21(&gstruct, ushort_, 0, 1, 250U);
				Struct52 struct2;
				<Module>.memset((void*)(&struct2), 0, 12U);
				struct2 = 18;
				*(ref struct2 + 1) = 0;
				*(ref struct2 + 2) = 0;
				*(ref struct2 + 3) = 0;
				*(ref struct2 + 4) = 116;
				*(ref struct2 + 5) = 192;
				Struct85 struct3;
				uint num2;
				result = ((<Module>.smethod_16((byte*)(&struct2), 12U, (byte)num, 512, (void*)(&struct3), &num2, 116U, 1, &gstruct) == null) ? ((<Module>.memcmp(ref struct3 + 16, (void*)(&@struct), 8U) != null) ? 0 : 1) : 0);
			}
			return result;
		}

		// Token: 0x060002D3 RID: 723 RVA: 0x001334A0 File Offset: 0x001334A0
		private unsafe int method_185()
		{
			Struct103 @struct = 68;
			*(ref @struct + 1) = 71;
			*(ref @struct + 2) = 45;
			*(ref @struct + 3) = 49;
			*(ref @struct + 4) = 54;
			*(ref @struct + 5) = 68;
			*(ref @struct + 6) = 53;
			*(ref @struct + 7) = 83;
			int result;
			if (this.comboBox1.Items.Count == 0)
			{
				result = 0;
			}
			else
			{
				uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
				ushort ushort_ = *(ref <Module>.struct38_0 + selectedIndex * 72U);
				uint num;
				if (*(ref <Module>.struct38_0 + selectedIndex * 72U + 4) == 160)
				{
					num = 0U;
				}
				else
				{
					num = 16U;
				}
				GStruct3 gstruct;
				<Module>.smethod_21(&gstruct, ushort_, 0, 1, 250U);
				Struct52 struct2;
				<Module>.memset((void*)(&struct2), 0, 12U);
				struct2 = 18;
				*(ref struct2 + 1) = 0;
				*(ref struct2 + 2) = 0;
				*(ref struct2 + 3) = 0;
				*(ref struct2 + 4) = 116;
				*(ref struct2 + 5) = 192;
				Struct85 struct3;
				uint num2;
				result = ((<Module>.smethod_16((byte*)(&struct2), 12U, (byte)num, 512, (void*)(&struct3), &num2, 116U, 1, &gstruct) == null) ? ((<Module>.memcmp(ref struct3 + 16, (void*)(&@struct), 8U) != null) ? 0 : 1) : 0);
			}
			return result;
		}

		// Token: 0x060002D4 RID: 724 RVA: 0x001335A4 File Offset: 0x001335A4
		private void button18_Click(object sender, EventArgs e)
		{
			this.method_14();
			this.radioButton20.Checked = true;
			this.method_197();
			this.method_186();
			this.method_15();
		}

		// Token: 0x060002D5 RID: 725 RVA: 0x001335D8 File Offset: 0x001335D8
		private unsafe void method_186()
		{
			string str = null;
			this.method_172();
			if (string.Compare(Convert.ToString(this.label72.Text), "No Drive Detected!") == 0)
			{
				<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
				MessageBox.Show("No Drive Detected!" + "\n" + "Benq Un Lock aborted! ", "Benq Un Lock", MessageBoxButtons.OK, MessageBoxIcon.Hand);
				<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
				this.label88.Text = " ";
				this.label87.Text = " ";
			}
			else if (string.Compare(Convert.ToString(this.label72.Text), "Drive in Vendor Mode!") == 0)
			{
				<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
				MessageBox.Show("Drive in Vendor Mode!" + "\n" + "Benq Un Lock aborted!", "Benq Un Lock", MessageBoxButtons.OK, MessageBoxIcon.Hand);
				<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
				this.label88.Text = " ";
				this.label87.Text = " ";
			}
			else if (this.comboBox1.Items.Count != 0)
			{
				uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
				ushort ushort_ = *(ref <Module>.struct38_0 + selectedIndex * 72U);
				uint num;
				if (*(ref <Module>.struct38_0 + selectedIndex * 72U + 4) == 160)
				{
					num = 0U;
				}
				else
				{
					num = 16U;
				}
				GStruct3 gstruct;
				<Module>.smethod_21(&gstruct, ushort_, 0, 1, 1000U);
				Struct28 @struct;
				<Module>.memset((void*)(&@struct), 0, 16U);
				Struct52 struct2;
				<Module>.memset((void*)(&struct2), 0, 12U);
				struct2 = 253;
				*(ref struct2 + 1) = 15;
				*(ref struct2 + 2) = 66;
				*(ref struct2 + 3) = 69;
				*(ref struct2 + 4) = 78;
				*(ref struct2 + 5) = 81;
				*(ref struct2 + 6) = 0;
				*(ref struct2 + 7) = 0;
				*(ref struct2 + 8) = 16;
				this.textBox6.AppendText("\r\n" + "Sending Magic Keys to Drive on port " + this.label123.Text + "\r\n");
				for (uint num2 = 0U; num2 < 784U; num2 += 16U)
				{
					Struct28 struct3;
					<Module>.memcpy((void*)(&struct3), ref <Module>.struct51_0 + num2, 16U);
					this.method_391((byte*)(&struct3), (byte*)(&@struct), 16);
					uint num3;
					if (<Module>.smethod_17((byte*)(&struct2), 12U, (byte)num, 512, (void*)(&@struct), &num3, 16U, 1, &gstruct) != null)
					{
						<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
						MessageBox.Show("Benq-Un-Lock command returned an Error", "Warning", MessageBoxButtons.OK, MessageBoxIcon.Hand);
						<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
						return;
					}
					selectedIndex = (uint)this.comboBox1.SelectedIndex;
					if (*(ref <Module>.struct38_0 + selectedIndex * 72U) == 0 && *(ref <Module>.struct38_0 + selectedIndex * 72U + 3) == 1)
					{
						this.method_424(88);
					}
					this.textBox6.AppendText(new string((sbyte*)(&<Module>.struct6_9)));
				}
				this.textBox6.AppendText("\r\n" + "Done!" + "\r\n");
				this.textBox6.AppendText("Sending Vendor Intro" + str + "\r\n");
				if (this.method_252() != 115U)
				{
					<Module>.Sleep(250);
					if (this.method_252() != 115U)
					{
						<Module>.Sleep(250);
						if (this.method_252() != 115U)
						{
							<Module>.Sleep(250);
							if (this.method_252() != 115U)
							{
								this.textBox6.AppendText("Vendor Intro Failed" + str + "\r\n");
								return;
							}
						}
					}
				}
				else
				{
					this.label122.Text = "Serial flash with status 0x73";
				}
				this.textBox6.AppendText("Requesting Device ID" + str + "\r\n");
				uint uint_ = (uint)this.method_297();
				if (this.method_206(uint_) == 0 && this.bool_2)
				{
					this.method_187();
				}
			}
		}

		// Token: 0x060002D6 RID: 726 RVA: 0x003C70D8 File Offset: 0x0030F0D8
		private unsafe void method_187()
		{
			this.Cursor = Cursors.WaitCursor;
			if (this.method_298() != 0)
			{
				this.Cursor = Cursors.Arrow;
			}
			else
			{
				this.Cursor = Cursors.Arrow;
				this.method_263();
				this.tabControl5.SelectedTab = this.Firmtools;
				if (*(*(ref <Module>.struct123_0 + 4)) == 0)
				{
					this.textBox6.AppendText("Load Failed" + "\r\n");
				}
				else
				{
					string text = "Drive has been unlocked, put in vendor mode and dumped." + "\n";
					text = text + "iXtreme has auto-loaded and been spoofed from source." + "\n\n";
					text = text + "Do You wish to proceed with erase and Flash" + "\n";
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					int num = (int)MessageBox.Show(text, "Auto Flash", MessageBoxButtons.YesNo, MessageBoxIcon.Asterisk, MessageBoxDefaultButton.Button2);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
					if (num == 7)
					{
						this.textBox6.AppendText("Auto-Flashing was aborted!" + "\r\n");
					}
					else
					{
						this.Cursor = Cursors.WaitCursor;
						this.method_299();
						this.textBox6.AppendText("Writing target buffer to flash" + "\r\n");
						if (this.method_302() == 1)
						{
							this.Cursor = Cursors.Arrow;
						}
						else
						{
							this.Cursor = Cursors.Arrow;
							<Module>.Sleep(500);
							this.Cursor = Cursors.WaitCursor;
							this.textBox6.AppendText("\r\n" + "Flash Verification Test !");
							this.method_298();
							this.Cursor = Cursors.Arrow;
							for (int i = 0; i < 262144; i++)
							{
								if (*(*(ref <Module>.struct121_0 + 7172) + i) != *(*(ref <Module>.struct121_0 + 4780) + i))
								{
									this.textBox6.AppendText("Write Verify Failed !" + "\r\n");
									return;
								}
							}
							this.textBox6.AppendText("Write verified OK !" + "\r\n\r\n");
							this.string_2 = "Write verified !";
							this.string_3 = "OK";
						}
					}
				}
			}
		}

		// Token: 0x060002D7 RID: 727 RVA: 0x00133BD4 File Offset: 0x00133BD4
		private unsafe void method_188()
		{
			this.Cursor = Cursors.WaitCursor;
			Application.DoEvents();
			this.textBox6.AppendText("\r\n");
			for (int i = 0; i < 12; i++)
			{
				<Module>.Sleep(250);
				this.textBox6.AppendText(".");
			}
			this.textBox6.AppendText("\r\n");
			if (this.method_307() != 0)
			{
				this.Cursor = Cursors.Arrow;
			}
			else if (<Module>.memcmp(*(ref <Module>.struct121_0 + 7172) + 82176, (void*)(&<Module>.struct43_16), 6U) != null)
			{
				this.Cursor = Cursors.Arrow;
			}
			else
			{
				this.Cursor = Cursors.Arrow;
				this.method_264();
				this.textBox6.AppendText("\r\n" + "Loading MTK_Flash source file " + "\r\n");
				if (*(*(ref <Module>.struct123_0 + 4)) == 0)
				{
					this.textBox6.AppendText("Load Failed" + "\r\n");
				}
				else
				{
					string text = "Drive has been unlocked, put in vendor mode and dumped." + "\n";
					text = text + "iXtreme has auto-loaded and been spoofed from source." + "\n\n";
					text = text + "Do You wish to proceed with erase and Flash" + "\n";
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					int num = (int)MessageBox.Show(text, "Auto Flash", MessageBoxButtons.YesNo, MessageBoxIcon.Asterisk, MessageBoxDefaultButton.Button2);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
					if (num == 7)
					{
						this.textBox6.AppendText("Auto-Flashing was aborted!" + "\r\n");
					}
					else
					{
						this.Cursor = Cursors.WaitCursor;
						this.method_311();
						this.textBox6.AppendText("Writing target buffer to flash" + "\r\n");
						if (this.method_326() == 1)
						{
							this.Cursor = Cursors.Arrow;
						}
						else
						{
							this.Cursor = Cursors.Arrow;
							<Module>.Sleep(500);
							this.Cursor = Cursors.WaitCursor;
							this.textBox6.AppendText("\r\n" + "Flash Verification Test !");
							this.method_307();
							this.Cursor = Cursors.Arrow;
							for (int i = 0; i < 262144; i++)
							{
								if (*(*(ref <Module>.struct121_0 + 7172) + i) != *(*(ref <Module>.struct121_0 + 4780) + i))
								{
									this.textBox6.AppendText("Write Verify Failed !" + "\r\n");
									return;
								}
							}
							this.textBox6.AppendText("Write verified OK !" + "\r\n\r\n");
							this.string_2 = "Write verified !";
							this.string_3 = "OK";
						}
					}
				}
			}
		}

		// Token: 0x060002D8 RID: 728 RVA: 0x00133E84 File Offset: 0x00133E84
		private void button40_Click(object sender, EventArgs e)
		{
			this.method_14();
			this.method_197();
			if (string.Compare(this.label109.Text, 0, "DG-16D5S", 0, 8) == 0)
			{
				this.method_190();
			}
			else
			{
				this.method_189();
			}
			this.method_15();
		}

		// Token: 0x060002D9 RID: 729 RVA: 0x00133ED0 File Offset: 0x00133ED0
		private unsafe int method_189()
		{
			Struct68 @struct = 0;
			initblk(ref @struct + 1, 0, 259);
			<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct19_0));
			this.Cursor = Cursors.WaitCursor;
			this.method_172();
			this.radioButton19.Checked = true;
			int result;
			if (string.Compare(Convert.ToString(this.label72.Text), "No Drive Detected!") == 0)
			{
				<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
				MessageBox.Show("No Drive Detected!" + "\n" + "Slim Un Lock aborted! ", "Slim Un Lock", MessageBoxButtons.OK, MessageBoxIcon.Hand);
				<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
				this.label88.Text = " ";
				this.label87.Text = " ";
				result = 0;
			}
			else if (string.Compare(Convert.ToString(this.label72.Text), "Drive in Vendor Mode!") == 0)
			{
				<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
				MessageBox.Show("Drive in Vendor Mode!" + "\n" + "Slim Un Lock aborted!", "Slim Un Lock", MessageBoxButtons.OK, MessageBoxIcon.Hand);
				<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
				this.label88.Text = " ";
				this.label87.Text = " ";
				result = 0;
			}
			else
			{
				this.method_82();
				Struct28 struct2;
				this.method_85((byte*)(&struct2));
				if (this.method_87((byte*)(&struct2)) == 0)
				{
					this.Cursor = Cursors.Arrow;
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					MessageBox.Show("Unlock failed !", "Slim Un Lock", MessageBoxButtons.OK, MessageBoxIcon.Asterisk);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
					result = 0;
				}
				else if (this.method_200() == 0)
				{
					this.Cursor = Cursors.Arrow;
					result = 0;
				}
				else
				{
					this.Cursor = Cursors.Arrow;
					result = 1;
				}
			}
			return result;
		}

		// Token: 0x060002DA RID: 730 RVA: 0x001340D0 File Offset: 0x001340D0
		private unsafe int method_190()
		{
			Struct68 @struct = 0;
			initblk(ref @struct + 1, 0, 259);
			<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct19_0));
			this.Cursor = Cursors.WaitCursor;
			this.method_172();
			this.radioButton19.Checked = true;
			int result;
			if (string.Compare(Convert.ToString(this.label72.Text), "No Drive Detected!") == 0)
			{
				<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
				MessageBox.Show("No Drive Detected!" + "\n" + "Slim Un Lock aborted! ", "Slim Un Lock", MessageBoxButtons.OK, MessageBoxIcon.Hand);
				<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
				this.label88.Text = " ";
				this.label87.Text = " ";
				result = 0;
			}
			else if (string.Compare(Convert.ToString(this.label72.Text), "Drive in Vendor Mode!") == 0)
			{
				<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
				MessageBox.Show("Drive in Vendor Mode!" + "\n" + "Slim Un Lock aborted!", "Slim Un Lock", MessageBoxButtons.OK, MessageBoxIcon.Hand);
				<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
				this.label88.Text = " ";
				this.label87.Text = " ";
				result = 0;
			}
			else
			{
				this.method_82();
				Struct28 struct2;
				this.method_86((byte*)(&struct2));
				if (this.method_88((byte*)(&struct2)) == 0)
				{
					this.Cursor = Cursors.Arrow;
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					MessageBox.Show("Unlock failed !", "Slim Un Lock", MessageBoxButtons.OK, MessageBoxIcon.Asterisk);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
					result = 0;
				}
				else if (this.method_201() == 0)
				{
					this.Cursor = Cursors.Arrow;
					result = 0;
				}
				else
				{
					this.Cursor = Cursors.Arrow;
					result = 1;
				}
			}
			return result;
		}

		// Token: 0x060002DB RID: 731 RVA: 0x001342D0 File Offset: 0x001342D0
		private void button21_Click(object sender, EventArgs e)
		{
			this.method_14();
			this.radioButton20.Checked = true;
			this.method_191();
			this.method_15();
		}

		// Token: 0x060002DC RID: 732 RVA: 0x001342FC File Offset: 0x001342FC
		private unsafe void method_191()
		{
			string str = null;
			Struct4 @struct = 0;
			*(ref @struct + 1) = 0;
			*(ref @struct + 2) = 0;
			*(ref @struct + 3) = 0;
			*(ref @struct + 4) = 0;
			*(ref @struct + 5) = 0;
			*(ref @struct + 6) = 0;
			*(ref @struct + 7) = 0;
			*(ref @struct + 8) = 251;
			*(ref @struct + 9) = 48;
			*(ref @struct + 10) = byte.MaxValue;
			*(ref @struct + 11) = byte.MaxValue;
			*(ref @struct + 12) = byte.MaxValue;
			*(ref @struct + 13) = byte.MaxValue;
			*(ref @struct + 14) = byte.MaxValue;
			*(ref @struct + 15) = byte.MaxValue;
			*(ref @struct + 16) = byte.MaxValue;
			*(ref @struct + 17) = byte.MaxValue;
			*(ref @struct + 18) = byte.MaxValue;
			*(ref @struct + 19) = byte.MaxValue;
			*(ref @struct + 20) = byte.MaxValue;
			*(ref @struct + 21) = byte.MaxValue;
			*(ref @struct + 22) = byte.MaxValue;
			*(ref @struct + 23) = byte.MaxValue;
			*(ref @struct + 24) = byte.MaxValue;
			*(ref @struct + 25) = byte.MaxValue;
			*(ref @struct + 26) = byte.MaxValue;
			*(ref @struct + 27) = byte.MaxValue;
			*(ref @struct + 28) = byte.MaxValue;
			*(ref @struct + 29) = byte.MaxValue;
			*(ref @struct + 30) = byte.MaxValue;
			*(ref @struct + 31) = byte.MaxValue;
			*(ref @struct + 32) = byte.MaxValue;
			*(ref @struct + 33) = byte.MaxValue;
			*(ref @struct + 34) = byte.MaxValue;
			*(ref @struct + 35) = byte.MaxValue;
			*(ref @struct + 36) = byte.MaxValue;
			*(ref @struct + 37) = byte.MaxValue;
			*(ref @struct + 38) = byte.MaxValue;
			*(ref @struct + 39) = byte.MaxValue;
			*(ref @struct + 40) = byte.MaxValue;
			*(ref @struct + 41) = byte.MaxValue;
			*(ref @struct + 42) = byte.MaxValue;
			*(ref @struct + 43) = byte.MaxValue;
			*(ref @struct + 44) = byte.MaxValue;
			*(ref @struct + 45) = byte.MaxValue;
			*(ref @struct + 46) = byte.MaxValue;
			*(ref @struct + 47) = byte.MaxValue;
			*(ref @struct + 48) = byte.MaxValue;
			*(ref @struct + 49) = byte.MaxValue;
			*(ref @struct + 50) = byte.MaxValue;
			*(ref @struct + 51) = byte.MaxValue;
			*(ref @struct + 52) = byte.MaxValue;
			*(ref @struct + 53) = byte.MaxValue;
			*(ref @struct + 54) = byte.MaxValue;
			*(ref @struct + 55) = byte.MaxValue;
			*(ref @struct + 56) = byte.MaxValue;
			*(ref @struct + 57) = byte.MaxValue;
			*(ref @struct + 58) = byte.MaxValue;
			*(ref @struct + 59) = byte.MaxValue;
			*(ref @struct + 60) = byte.MaxValue;
			*(ref @struct + 61) = byte.MaxValue;
			*(ref @struct + 62) = byte.MaxValue;
			*(ref @struct + 63) = byte.MaxValue;
			Struct28 struct2 = 255;
			*(ref struct2 + 1) = byte.MaxValue;
			*(ref struct2 + 2) = byte.MaxValue;
			*(ref struct2 + 3) = byte.MaxValue;
			*(ref struct2 + 4) = byte.MaxValue;
			*(ref struct2 + 5) = byte.MaxValue;
			*(ref struct2 + 6) = byte.MaxValue;
			*(ref struct2 + 7) = byte.MaxValue;
			*(ref struct2 + 8) = byte.MaxValue;
			*(ref struct2 + 9) = byte.MaxValue;
			*(ref struct2 + 10) = byte.MaxValue;
			*(ref struct2 + 11) = byte.MaxValue;
			*(ref struct2 + 12) = byte.MaxValue;
			*(ref struct2 + 13) = byte.MaxValue;
			*(ref struct2 + 14) = byte.MaxValue;
			*(ref struct2 + 15) = byte.MaxValue;
			if (this.comboBox1.Items.Count != 0)
			{
				uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
				ushort ushort_ = *(ref <Module>.struct38_0 + selectedIndex * 72U);
				uint num;
				if (*(ref <Module>.struct38_0 + selectedIndex * 72U + 4) == 160)
				{
					num = 0U;
				}
				else
				{
					num = 16U;
				}
				if (!this.bool_2)
				{
					string text = "Sammy_Un_Lock will unlock a Samsung MS28 with stock f/w and LT " + "\n";
					text = text + "and LT+ flashed drives. " + "\n";
					text = text + "For iXtreme ver 1.4 and before, unlock using 0800 DVD. " + "\n";
					text = text + "For iXtreme 1.5, unlock drive by powering up with tray half open." + "\n";
					text = text + "Do you wish to proceed anyway ?" + "\n";
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					int num2 = (int)MessageBox.Show(text, "Sammy-Un-Lock", MessageBoxButtons.YesNo, MessageBoxIcon.Asterisk, MessageBoxDefaultButton.Button2);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
					if (num2 == 7)
					{
						this.textBox6.AppendText("Sammy-Un-Lock NOT sent " + "\r\n");
						return;
					}
				}
				Application.DoEvents();
				GStruct3 gstruct;
				<Module>.smethod_21(&gstruct, ushort_, 0, 1, 10000U);
				Struct52 struct3;
				<Module>.memset((void*)(&struct3), 0, 12U);
				struct3 = 255;
				*(ref struct3 + 1) = 8;
				*(ref struct3 + 2) = 5;
				*(ref struct3 + 4) = 5;
				*(ref struct3 + 5) = 1;
				*(ref struct3 + 6) = 3;
				*(ref struct3 + 8) = 4;
				*(ref struct3 + 9) = 7;
				this.textBox6.AppendText("\r\n" + "Sending Sammy_Un_Lock to Drive on port " + this.label123.Text + "\r\n");
				Struct28 struct4;
				uint num3;
				if (<Module>.smethod_16((byte*)(&struct3), 12U, (byte)num, 512, (void*)(&struct4), &num3, 16U, 1, &gstruct) != null)
				{
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					MessageBox.Show("Failed at Stage 1", "Sammy_Un_Lock", MessageBoxButtons.OK, MessageBoxIcon.Hand);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
				}
				else
				{
					this.textBox6.AppendText("Stage 1, Complete!" + "\r\n");
					if (struct4 == struct2)
					{
						<Module>.memset((void*)(&struct4), 0, 16U);
					}
					Struct4 struct5;
					<Module>.memcpy((void*)(&struct5), (void*)(&@struct), 64U);
					<Module>.memset((void*)(&struct3), 0, 12U);
					struct3 = 85;
					*(ref struct3 + 8) = 58;
					if (<Module>.smethod_17((byte*)(&struct3), 12U, (byte)num, 512, (void*)(&struct5), &num3, 64U, 1, &gstruct) != null)
					{
						<Module>.Sleep(2000);
						if (<Module>.smethod_17((byte*)(&struct3), 12U, (byte)num, 512, (void*)(&struct5), &num3, 64U, 1, &gstruct) != null)
						{
							<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
							MessageBox.Show("Failed at Stage 2", "Sammy_Un_Lock", MessageBoxButtons.OK, MessageBoxIcon.Hand);
							<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
							return;
						}
					}
					this.textBox6.AppendText("Stage 2, Complete!" + "\r\n");
					if (*(ref <Module>.struct38_0 + selectedIndex * 72U) == 0 && *(ref <Module>.struct38_0 + selectedIndex * 72U + 3) == 1)
					{
						this.method_424(88);
					}
					<Module>.Sleep(2000);
					byte* ptr = ref struct5 + 10;
					<Module>.memcpy((void*)ptr, (void*)(&struct4), 16U);
					if (<Module>.smethod_17((byte*)(&struct3), 12U, (byte)num, 512, (void*)(&struct5), &num3, 64U, 1, &gstruct) != null)
					{
						<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
						MessageBox.Show("Failed at Stage 3", "Sammy_Un_Lock", MessageBoxButtons.OK, MessageBoxIcon.Hand);
						<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
					}
					else
					{
						this.textBox6.AppendText("Stage 3, Complete!" + "\r\n" + "Done!" + "\r\n");
						if (*(ref <Module>.struct38_0 + selectedIndex * 72U) == 0 && *(ref <Module>.struct38_0 + selectedIndex * 72U + 3) == 1)
						{
							this.method_424(88);
						}
						Application.DoEvents();
						this.textBox6.AppendText("Sending Vendor Intro" + str + "\r\n");
						Application.DoEvents();
						if (this.method_252() != 112U)
						{
							<Module>.Sleep(250);
							if (this.method_252() != 112U)
							{
								<Module>.Sleep(250);
								if (this.method_252() != 112U)
								{
									<Module>.Sleep(250);
									if (this.method_252() != 112U)
									{
										this.textBox6.AppendText("Vendor Intro Failed" + str + "\r\n");
										return;
									}
								}
							}
						}
						else
						{
							this.label122.Text = "Parallel flash with Status 0x70";
						}
						this.textBox6.AppendText("Requesting Device ID" + str + "\r\n");
						uint uint_ = (uint)this.method_290();
						if (this.method_206(uint_) == 0 && this.bool_2)
						{
							this.method_193();
						}
					}
				}
			}
		}

		// Token: 0x060002DD RID: 733 RVA: 0x00134AE4 File Offset: 0x00134AE4
		private unsafe void method_192()
		{
			Struct28 @struct = 255;
			*(ref @struct + 1) = byte.MaxValue;
			*(ref @struct + 2) = byte.MaxValue;
			*(ref @struct + 3) = byte.MaxValue;
			*(ref @struct + 4) = byte.MaxValue;
			*(ref @struct + 5) = byte.MaxValue;
			*(ref @struct + 6) = byte.MaxValue;
			*(ref @struct + 7) = byte.MaxValue;
			*(ref @struct + 8) = byte.MaxValue;
			*(ref @struct + 9) = byte.MaxValue;
			*(ref @struct + 10) = byte.MaxValue;
			*(ref @struct + 11) = byte.MaxValue;
			*(ref @struct + 12) = byte.MaxValue;
			*(ref @struct + 13) = byte.MaxValue;
			*(ref @struct + 14) = byte.MaxValue;
			*(ref @struct + 15) = byte.MaxValue;
			if (this.comboBox1.Items.Count != 0)
			{
				uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
				ushort ushort_ = *(ref <Module>.struct38_0 + selectedIndex * 72U);
				uint num;
				if (*(ref <Module>.struct38_0 + selectedIndex * 72U + 4) == 160)
				{
					num = 0U;
				}
				else
				{
					num = 16U;
				}
				GStruct3 gstruct;
				<Module>.smethod_21(&gstruct, ushort_, 0, 1, 10000U);
				Struct52 struct2;
				<Module>.memset((void*)(&struct2), 0, 12U);
				struct2 = 255;
				*(ref struct2 + 1) = 8;
				*(ref struct2 + 2) = 5;
				*(ref struct2 + 4) = 5;
				*(ref struct2 + 5) = 1;
				*(ref struct2 + 6) = 3;
				*(ref struct2 + 8) = 4;
				*(ref struct2 + 9) = 7;
				this.textBox6.AppendText("\r\n" + "Retrieving Key from Samsung Drive on port " + this.label123.Text + "\r\n");
				Struct28 struct3;
				uint num2;
				if (<Module>.smethod_16((byte*)(&struct2), 12U, (byte)num, 512, (void*)(&struct3), &num2, 16U, 1, &gstruct) != null)
				{
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					MessageBox.Show(new string((sbyte*)(&<Module>.struct97_2)), "Sammy_Key", MessageBoxButtons.OK, MessageBoxIcon.Hand);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
				}
				else
				{
					if (struct3 == @struct)
					{
						<Module>.memset((void*)(&struct3), 0, 16U);
					}
					this.method_6((byte*)(&struct3), 16U, 0U);
					this.textBox6.AppendText("Extracted drive key " + this.string_0 + "\r\n");
					string text;
					if (this.bool_2)
					{
						text = this.string_10 + "\\" + this.string_0 + ".bin";
					}
					else
					{
						SaveFileDialog saveFileDialog = new SaveFileDialog();
						saveFileDialog.Filter = "Firmware Images (*.bin)|*.bin|All Files (*.*)|*.*";
						saveFileDialog.DefaultExt = ".bin";
						saveFileDialog.FileName = this.string_0 + ".bin";
						saveFileDialog.RestoreDirectory = false;
						if (this.bool_2)
						{
							saveFileDialog.InitialDirectory = this.string_10;
						}
						if (saveFileDialog.ShowDialog() != DialogResult.OK)
						{
							return;
						}
						text = Path.GetFullPath(saveFileDialog.FileName);
					}
					IntPtr intPtr = Marshal.StringToHGlobalAnsi(text);
					IntPtr value = intPtr;
					sbyte* pSbyte_ = (sbyte*)((void*)value);
					GStruct5* ptr = <Module>.fopen((sbyte*)pSbyte_, (sbyte*)(&<Module>.struct18_5));
					if (ptr == null)
					{
						<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
						MessageBox.Show(text, "Can't open file", MessageBoxButtons.OK);
						<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
					}
					else
					{
						<Module>.fwrite((void*)(&struct3), 16U, 1U, ptr);
						<Module>.fclose(ptr);
						this.textBox6.AppendText("Sammy key saved to " + text + "\r\n");
					}
				}
			}
		}

		// Token: 0x060002DE RID: 734 RVA: 0x003C7300 File Offset: 0x0030F300
		private unsafe void method_193()
		{
			this.Cursor = Cursors.WaitCursor;
			if (this.method_291() != 0)
			{
				this.Cursor = Cursors.Arrow;
			}
			else
			{
				this.Cursor = Cursors.Arrow;
				this.method_262();
				this.textBox6.AppendText("\r\n" + "Loading MTK_Flash source file " + "\r\n");
				if (*(*(ref <Module>.struct123_0 + 4)) == 0)
				{
					this.textBox6.AppendText("Load Failed" + "\r\n");
				}
				else
				{
					string text = "Drive has been unlocked, put in vendor mode and dumped." + "\n";
					text = text + "iXtreme has auto-loaded and been spoofed from source." + "\n\n";
					text = text + "Do You wish to proceed with erase and Flash" + "\n";
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					int num = (int)MessageBox.Show(text, "Auto Flash", MessageBoxButtons.YesNo, MessageBoxIcon.Asterisk, MessageBoxDefaultButton.Button2);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
					if (num == 7)
					{
						this.textBox6.AppendText("Auto-Flashing was aborted!" + "\r\n");
					}
					else
					{
						this.textBox6.AppendText("Writing target buffer to flash" + "\r\n");
						this.Cursor = Cursors.WaitCursor;
						this.method_292();
						if (this.method_296() == 1)
						{
							this.Cursor = Cursors.Arrow;
						}
						else
						{
							this.Cursor = Cursors.Arrow;
							<Module>.Sleep(500);
							this.Cursor = Cursors.WaitCursor;
							this.textBox6.AppendText("\r\n" + "Flash Verification Test !");
							this.method_291();
							this.Cursor = Cursors.Arrow;
							for (int i = 0; i < 262144; i++)
							{
								if (*(*(ref <Module>.struct121_0 + 7172) + i) != *(*(ref <Module>.struct121_0 + 4780) + i))
								{
									this.textBox6.AppendText("Write Verify Failed !" + "\r\n");
									return;
								}
							}
							this.textBox6.AppendText("Write verified OK !" + "\r\n\r\n");
							this.string_2 = "Write verified !";
							this.string_3 = "OK";
						}
					}
				}
			}
		}

		// Token: 0x060002DF RID: 735 RVA: 0x00135054 File Offset: 0x00135054
		private void method_194()
		{
			if (string.Compare(this.label109.Text, 0, "DG-16D5S", 0, 8) == 0)
			{
				this.method_196();
			}
			else
			{
				this.method_195();
			}
		}

		// Token: 0x060002E0 RID: 736 RVA: 0x0013508C File Offset: 0x0013508C
		private unsafe void method_195()
		{
			Struct4 @struct = 0;
			*(ref @struct + 1) = 0;
			*(ref @struct + 2) = 0;
			*(ref @struct + 3) = 0;
			*(ref @struct + 4) = 0;
			*(ref @struct + 5) = 0;
			*(ref @struct + 6) = 0;
			*(ref @struct + 7) = 0;
			*(ref @struct + 8) = 251;
			*(ref @struct + 9) = 48;
			*(ref @struct + 10) = byte.MaxValue;
			*(ref @struct + 11) = byte.MaxValue;
			*(ref @struct + 12) = byte.MaxValue;
			*(ref @struct + 13) = byte.MaxValue;
			*(ref @struct + 14) = byte.MaxValue;
			*(ref @struct + 15) = byte.MaxValue;
			*(ref @struct + 16) = byte.MaxValue;
			*(ref @struct + 17) = byte.MaxValue;
			*(ref @struct + 18) = byte.MaxValue;
			*(ref @struct + 19) = byte.MaxValue;
			*(ref @struct + 20) = byte.MaxValue;
			*(ref @struct + 21) = byte.MaxValue;
			*(ref @struct + 22) = byte.MaxValue;
			*(ref @struct + 23) = byte.MaxValue;
			*(ref @struct + 24) = byte.MaxValue;
			*(ref @struct + 25) = byte.MaxValue;
			*(ref @struct + 26) = byte.MaxValue;
			*(ref @struct + 27) = byte.MaxValue;
			*(ref @struct + 28) = byte.MaxValue;
			*(ref @struct + 29) = byte.MaxValue;
			*(ref @struct + 30) = byte.MaxValue;
			*(ref @struct + 31) = byte.MaxValue;
			*(ref @struct + 32) = byte.MaxValue;
			*(ref @struct + 33) = byte.MaxValue;
			*(ref @struct + 34) = byte.MaxValue;
			*(ref @struct + 35) = byte.MaxValue;
			*(ref @struct + 36) = byte.MaxValue;
			*(ref @struct + 37) = byte.MaxValue;
			*(ref @struct + 38) = byte.MaxValue;
			*(ref @struct + 39) = byte.MaxValue;
			*(ref @struct + 40) = byte.MaxValue;
			*(ref @struct + 41) = byte.MaxValue;
			*(ref @struct + 42) = byte.MaxValue;
			*(ref @struct + 43) = byte.MaxValue;
			*(ref @struct + 44) = byte.MaxValue;
			*(ref @struct + 45) = byte.MaxValue;
			*(ref @struct + 46) = byte.MaxValue;
			*(ref @struct + 47) = byte.MaxValue;
			*(ref @struct + 48) = byte.MaxValue;
			*(ref @struct + 49) = byte.MaxValue;
			*(ref @struct + 50) = byte.MaxValue;
			*(ref @struct + 51) = byte.MaxValue;
			*(ref @struct + 52) = byte.MaxValue;
			*(ref @struct + 53) = byte.MaxValue;
			*(ref @struct + 54) = byte.MaxValue;
			*(ref @struct + 55) = byte.MaxValue;
			*(ref @struct + 56) = byte.MaxValue;
			*(ref @struct + 57) = byte.MaxValue;
			*(ref @struct + 58) = byte.MaxValue;
			*(ref @struct + 59) = byte.MaxValue;
			*(ref @struct + 60) = byte.MaxValue;
			*(ref @struct + 61) = byte.MaxValue;
			*(ref @struct + 62) = byte.MaxValue;
			*(ref @struct + 63) = byte.MaxValue;
			Struct28 struct2 = 255;
			*(ref struct2 + 1) = byte.MaxValue;
			*(ref struct2 + 2) = byte.MaxValue;
			*(ref struct2 + 3) = byte.MaxValue;
			*(ref struct2 + 4) = byte.MaxValue;
			*(ref struct2 + 5) = byte.MaxValue;
			*(ref struct2 + 6) = byte.MaxValue;
			*(ref struct2 + 7) = byte.MaxValue;
			*(ref struct2 + 8) = byte.MaxValue;
			*(ref struct2 + 9) = byte.MaxValue;
			*(ref struct2 + 10) = byte.MaxValue;
			*(ref struct2 + 11) = byte.MaxValue;
			*(ref struct2 + 12) = byte.MaxValue;
			*(ref struct2 + 13) = byte.MaxValue;
			*(ref struct2 + 14) = byte.MaxValue;
			*(ref struct2 + 15) = byte.MaxValue;
			if (this.comboBox1.Items.Count != 0)
			{
				uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
				ushort ushort_ = *(ref <Module>.struct38_0 + selectedIndex * 72U);
				uint num;
				if (*(ref <Module>.struct38_0 + selectedIndex * 72U + 4) == 160)
				{
					num = 0U;
				}
				else
				{
					num = 16U;
				}
				GStruct3 gstruct;
				<Module>.smethod_21(&gstruct, ushort_, 0, 1, 1000U);
				Struct4 struct3;
				<Module>.memcpy((void*)(&struct3), (void*)(&@struct), 64U);
				Struct52 struct4;
				<Module>.memset((void*)(&struct4), 0, 12U);
				struct4 = 85;
				*(ref struct4 + 8) = 58;
				uint num2;
				if (<Module>.smethod_17((byte*)(&struct4), 12U, (byte)num, 512, (void*)(&struct3), &num2, 64U, 1, &gstruct) != null)
				{
					<Module>.Sleep(2000);
					if (<Module>.smethod_17((byte*)(&struct4), 12U, (byte)num, 512, (void*)(&struct3), &num2, 64U, 1, &gstruct) != null)
					{
						<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
						MessageBox.Show("Failed at Stage 1", "Set Drive Key", MessageBoxButtons.OK, MessageBoxIcon.Hand);
						<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
						return;
					}
				}
				this.textBox6.AppendText("Stage 1, Complete!" + "\r\n");
				if (*(ref <Module>.struct38_0 + selectedIndex * 72U) == 0 && *(ref <Module>.struct38_0 + selectedIndex * 72U + 3) == 1)
				{
					this.method_424(88);
				}
				<Module>.Sleep(2000);
				byte* ptr = ref struct3 + 10;
				<Module>.memcpy((void*)ptr, *(ref <Module>.struct123_0 + 4) + 280, 16U);
				if (<Module>.smethod_17((byte*)(&struct4), 12U, (byte)num, 512, (void*)(&struct3), &num2, 64U, 1, &gstruct) != null)
				{
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					MessageBox.Show("Failed at Stage 2", "Set Drive Key", MessageBoxButtons.OK, MessageBoxIcon.Hand);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
				}
				else
				{
					if (*(ref <Module>.struct38_0 + selectedIndex * 72U) == 0 && *(ref <Module>.struct38_0 + selectedIndex * 72U + 3) == 1)
					{
						this.method_424(88);
					}
					this.textBox6.AppendText("Stage 2, Complete!" + "\r\n" + "Done!" + "\r\n");
				}
			}
		}

		// Token: 0x060002E1 RID: 737 RVA: 0x001355E0 File Offset: 0x001355E0
		private unsafe void method_196()
		{
			Struct80 @struct = 0;
			*(ref @struct + 1) = 0;
			*(ref @struct + 2) = 0;
			*(ref @struct + 3) = 0;
			*(ref @struct + 4) = 0;
			*(ref @struct + 5) = 0;
			*(ref @struct + 6) = 0;
			*(ref @struct + 7) = 0;
			*(ref @struct + 8) = 171;
			*(ref @struct + 9) = 16;
			*(ref @struct + 10) = byte.MaxValue;
			*(ref @struct + 11) = byte.MaxValue;
			*(ref @struct + 12) = byte.MaxValue;
			*(ref @struct + 13) = byte.MaxValue;
			*(ref @struct + 14) = byte.MaxValue;
			*(ref @struct + 15) = byte.MaxValue;
			*(ref @struct + 16) = byte.MaxValue;
			*(ref @struct + 17) = byte.MaxValue;
			*(ref @struct + 18) = byte.MaxValue;
			*(ref @struct + 19) = byte.MaxValue;
			*(ref @struct + 20) = byte.MaxValue;
			*(ref @struct + 21) = byte.MaxValue;
			*(ref @struct + 22) = byte.MaxValue;
			*(ref @struct + 23) = byte.MaxValue;
			*(ref @struct + 24) = byte.MaxValue;
			*(ref @struct + 25) = byte.MaxValue;
			if (this.comboBox1.Items.Count != 0)
			{
				uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
				ushort ushort_ = *(ref <Module>.struct38_0 + selectedIndex * 72U);
				uint num;
				if (*(ref <Module>.struct38_0 + selectedIndex * 72U + 4) == 160)
				{
					num = 0U;
				}
				else
				{
					num = 16U;
				}
				GStruct3 gstruct;
				<Module>.smethod_21(&gstruct, ushort_, 0, 1, 1000U);
				Struct80 struct2;
				<Module>.memcpy((void*)(&struct2), (void*)(&@struct), 26U);
				Struct52 struct3;
				<Module>.memset((void*)(&struct3), 0, 12U);
				struct3 = 85;
				*(ref struct3 + 8) = 26;
				<Module>.memcpy(ref struct2 + 10, *(ref <Module>.struct123_0 + 4) + 280, 16U);
				uint num2;
				if (<Module>.smethod_17((byte*)(&struct3), 12U, (byte)num, 512, (void*)(&struct2), &num2, 26U, 1, &gstruct) != null)
				{
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					MessageBox.Show("Failed at Stage 1", "Set Drive Key", MessageBoxButtons.OK, MessageBoxIcon.Hand);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
				}
				else
				{
					if (*(ref <Module>.struct38_0 + selectedIndex * 72U) == 0 && *(ref <Module>.struct38_0 + selectedIndex * 72U + 3) == 1)
					{
						this.method_424(88);
					}
					this.textBox6.AppendText("Stage 1, Complete!" + "\r\n" + "Done!" + "\r\n");
				}
			}
		}

		// Token: 0x060002E2 RID: 738 RVA: 0x0013581C File Offset: 0x0013581C
		private void button17_Click(object sender, EventArgs e)
		{
			this.method_14();
			this.bool_1 = false;
			this.method_197();
			this.method_197();
			this.method_198();
			this.bool_1 = true;
			this.method_15();
		}

		// Token: 0x060002E3 RID: 739 RVA: 0x00135858 File Offset: 0x00135858
		private void method_197()
		{
			this.method_360();
			this.method_172();
			string strA = this.label72.Text + this.label68.Text + this.label61.Text;
			int count = this.comboBox16.Items.Count;
			int i = 0;
			while (i < count)
			{
				string text = Convert.ToString(this.comboBox16.Items[i]);
				string text2 = text.Substring(0, 3);
				text = text.Substring(5, 28);
				if (string.Compare(strA, text) != 0)
				{
					i++;
				}
				else
				{
					string text3 = "" + "The drive on I/O port " + this.label84.Text + " has windows drive letter " + text2 + "\n";
					text3 = text3 + "assigned to it. This may cause read back issues." + "\n\n";
					text3 = text3 + "Do you wish to disable " + text2 + " ?";
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					int num = (int)MessageBox.Show(text3, "Warning", MessageBoxButtons.YesNo, MessageBoxIcon.Hand, MessageBoxDefaultButton.Button1);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
					if (num == 7)
					{
						break;
					}
					this.method_335(text2);
					break;
				}
			}
		}

		// Token: 0x060002E4 RID: 740 RVA: 0x003C7534 File Offset: 0x0030F534
		private unsafe void method_198()
		{
			string text = null;
			bool flag = false;
			int selectedIndex = this.comboBox10.SelectedIndex;
			if (this.comboBox1.Items.Count != 0)
			{
				uint selectedIndex2 = (uint)this.comboBox1.SelectedIndex;
				this.label118.Text = "";
				this.label119.Text = "";
				this.label120.Text = "";
				this.label121.Text = "";
				this.label122.Text = "";
				this.textBox6.AppendText("Sending Vendor Intro to port " + this.label123.Text + "\r\n");
				byte b;
				if (this.radioButton19.Checked)
				{
					b = (byte)this.method_253();
				}
				else if (this.radioButton21.Checked)
				{
					b = (byte)this.method_254();
				}
				else
				{
					b = (byte)this.method_252();
				}
				this.bool_0 = false;
				uint num;
				if (b == 115)
				{
					this.textBox6.AppendText("\r\n" + "Serial flash found with Status 0x73" + "\r\n");
					this.label122.Text = "Serial flash with status 0x73";
					this.textBox6.AppendText("\r\n" + "Sending Device ID request to port " + this.label123.Text + "\r\n");
					num = (uint)this.method_297();
				}
				else if (b == 112)
				{
					this.textBox6.AppendText("\r\n" + "Parallel flash found with Status 0x70" + "\r\n");
					this.label122.Text = "Parallel flash with Status 0x70";
					this.textBox6.AppendText("\r\n" + "Sending Device ID request to port " + this.label123.Text + "\r\n");
					num = (uint)this.method_290();
				}
				else if (b == 114)
				{
					this.textBox6.AppendText("\r\n" + "Serial flash found with Status 0x72" + "\r\n");
					this.label122.Text = "Serial flash with status 0x72";
					this.textBox6.AppendText("\r\n" + "Sending Device ID request to port " + this.label123.Text + "\r\n");
					<Module>.Sleep(1000);
					num = (uint)this.method_303();
					if (this.radioButton19.Checked)
					{
						this.method_239();
					}
					if (this.radioButton21.Checked)
					{
						this.method_240();
					}
					if (this.radioButton20.Checked)
					{
						this.method_241();
					}
					if (num == 0U)
					{
						<Module>.Sleep(1000);
						num = (uint)this.method_303();
					}
					if (num == 65535U)
					{
						<Module>.Sleep(1000);
						num = (uint)this.method_303();
						if (num == 65535U)
						{
							<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
							int num2 = (int)MessageBox.Show("Please return MRA Hack device to the Normal position !" + "\r\n\r\n" + "Then, press OK to continue.", "Device ID Failed !", MessageBoxButtons.OKCancel, MessageBoxIcon.Exclamation);
							<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
							if (num2 != 1)
							{
								return;
							}
							num = (uint)this.method_303();
						}
					}
				}
				else
				{
					Struct20 @struct;
					<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct35_129), b);
					string text2 = new string((sbyte*)(&<Module>.struct19_0));
					text2 += new string((sbyte*)(&@struct));
					text += text2;
					this.textBox6.AppendText("Status 0x" + text + "\r\n");
					int num2;
					if (this.method_130() == 1)
					{
						num2 = 6;
						Thread thread = new Thread(new ThreadStart(this.method_132));
						thread.Start();
					}
					else
					{
						<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
						num2 = (int)MessageBox.Show("If you wish to resend the command you should click Yes." + "\n" + "Power off the drive and then back on (within 1 second)." + "\n\n" + "Press Escape to cancel.", "MTK Vendor Intro failed", MessageBoxButtons.YesNo, MessageBoxIcon.Question);
						<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
					}
					if (num2 != 6)
					{
						num = 0U;
						return;
					}
					this.textBox6.AppendText("Re-sending Vendor Intro: " + "\r\n");
					uint num3 = <Module>.smethod_6();
					while (b != 112 & b != 114 & b != 115)
					{
						uint num4 = <Module>.smethod_6();
						if (num4 - num3 >= 200000U)
						{
							this.textBox6.AppendText("\r\n" + "Device Intro failed!" + "\r\n");
							return;
						}
						if (<Module>.GetAsyncKeyState(27) != null)
						{
							this.textBox6.AppendText("\r\n" + "Aborted by User!" + "\r\n");
							return;
						}
						if (flag)
						{
							<Module>.Sleep(500);
							b = (byte)this.method_252();
						}
						else
						{
							b = (byte)this.method_250();
						}
						<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct35_129), b);
						text2 = new string((sbyte*)(&<Module>.struct19_0));
						text2 += new string((sbyte*)(&@struct));
						this.label122.Text = "Status 0x" + text2;
						Application.DoEvents();
						this.textBox6.AppendText(new string((sbyte*)(&<Module>.struct6_9)));
						if (b == 115)
						{
							this.textBox6.AppendText("\r\n" + "Serial flash found with Status 0x73" + "\r\n");
							this.label122.Text = "Serial flash with status 0x73";
							this.textBox6.AppendText("\r\n" + "Sending Device ID request to port " + this.label123.Text + "\r\n");
							num = (uint)this.method_297();
							break;
						}
						if (b == 112)
						{
							this.textBox6.AppendText("\r\n" + "Parallel flash found with Status 0x70" + "\r\n");
							this.label122.Text = "Parallel flash with Status 0x70";
							this.textBox6.AppendText("\r\n" + "Sending Device ID request to port " + this.label123.Text + "\r\n");
							num = (uint)this.method_290();
							break;
						}
						if (b == 114)
						{
							this.textBox6.AppendText("\r\n" + "Serial flash found with Status 0x72" + "\r\n");
							this.label122.Text = "Serial flash with status 0x72";
							this.textBox6.AppendText("\r\n" + "Sending Device ID request to port " + this.label123.Text + "\r\n");
							<Module>.Sleep(1500);
							num = (uint)this.method_303();
							if (this.radioButton19.Checked)
							{
								this.method_239();
							}
							if (this.radioButton20.Checked)
							{
								this.method_241();
							}
							if (this.radioButton21.Checked)
							{
								this.method_240();
							}
							if (num == 0U)
							{
								<Module>.Sleep(1000);
								num = (uint)this.method_303();
							}
							if (num != 65535U)
							{
								break;
							}
							<Module>.Sleep(1000);
							num = (uint)this.method_303();
							if (num != 65535U)
							{
								break;
							}
							<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
							num2 = (int)MessageBox.Show("Please return MRA Hack Device to the Normal position !" + "\r\n\r\n" + "Then, press OK to continue.", "Device ID Failed !", MessageBoxButtons.OKCancel, MessageBoxIcon.Exclamation);
							<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
							if (num2 == 1)
							{
								num = (uint)this.method_303();
								break;
							}
							return;
						}
						else
						{
							if (b == 209 && !flag)
							{
								flag = true;
								if (this.method_130() == 1)
								{
									new Thread(new ThreadStart(this.method_132));
								}
							}
							if (*(ref <Module>.struct38_0 + selectedIndex2 * 72U) == 0 && *(ref <Module>.struct38_0 + selectedIndex2 * 72U + 3) == 1)
							{
								<Module>.Sleep(50);
							}
							else
							{
								<Module>.Sleep(250);
							}
						}
					}
				}
				if (this.method_206(num) == 0)
				{
					<Module>.Sleep(1000);
					if (this.bool_2 & b == 115)
					{
						this.method_187();
					}
					if (this.bool_2 & b == 112)
					{
						this.method_193();
					}
					if (this.bool_2 & b == 114 & this.radioButton20.Checked)
					{
						this.method_188();
					}
				}
			}
		}

		// Token: 0x060002E5 RID: 741 RVA: 0x003C7D50 File Offset: 0x0030FD50
		private unsafe void method_199()
		{
			byte b = 0;
			int selectedIndex = this.comboBox10.SelectedIndex;
			if (this.comboBox1.Items.Count != 0)
			{
				int selectedIndex2 = this.comboBox1.SelectedIndex;
				this.label118.Text = "";
				this.label119.Text = "";
				this.label120.Text = "";
				this.label121.Text = "";
				this.label122.Text = "";
				this.textBox6.AppendText("Sending Vendor Intro to port " + this.label123.Text + "\r\n");
				this.bool_0 = false;
				for (uint num = 137U; num < 256U; num += 1U)
				{
					for (uint num2 = 0U; num2 < 256U; num2 += 1U)
					{
						Struct20 @struct;
						<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct35_121), (byte)num);
						string text = new string((sbyte*)(&<Module>.struct19_0));
						text += new string((sbyte*)(&@struct));
						this.label118.Text = "0x" + text;
						<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct35_121), (byte)num2);
						text = new string((sbyte*)(&<Module>.struct19_0));
						text += new string((sbyte*)(&@struct));
						this.label119.Text = "0x" + text;
						int num3;
						if (this.method_130() == 1)
						{
							num3 = 6;
							Thread thread = new Thread(new ThreadStart(this.method_132));
							thread.Start();
						}
						else
						{
							<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
							num3 = (int)MessageBox.Show("If you wish to resend the command you should click Yes." + "\n" + "Power off the drive and then back on (within 1 second)." + "\n\n" + "Press Escape to cancel.", "MTK Vendor Intro failed", MessageBoxButtons.YesNo, MessageBoxIcon.Question);
							<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
						}
						if (num3 == 6)
						{
							uint num4 = <Module>.smethod_6();
							while (b != 112 & b != 114 & b != 115 & b != 112 & b != 82)
							{
								uint num5 = <Module>.smethod_6();
								if (num5 - num4 >= 3000U)
								{
									break;
								}
								if (<Module>.GetAsyncKeyState(27) != null)
								{
									this.textBox6.AppendText("\r\n" + "Aborted by User!" + "\r\n");
									return;
								}
								b = (byte)this.method_255((byte)num2, (byte)num);
								<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct35_129), b);
								string text2 = new string((sbyte*)(&<Module>.struct19_0));
								text2 += new string((sbyte*)(&@struct));
								this.label122.Text = "Status 0x" + text2;
								Application.DoEvents();
								if (b == 115)
								{
									this.textBox6.AppendText("\r\n" + "Serial flash found with Status 0x73" + "\r\n");
									this.label122.Text = "Serial flash with status 0x73";
									return;
								}
								if (b == 112)
								{
									this.textBox6.AppendText("\r\n" + "Parallel flash found with Status 0x70" + "\r\n");
									this.label122.Text = "Parallel flash with Status 0x70";
									return;
								}
								if (b == 114)
								{
									this.textBox6.AppendText("\r\n" + "Serial flash found with Status 0x72" + "\r\n");
									this.label122.Text = "Serial flash with status 0x72";
									return;
								}
								<Module>.Sleep(250);
							}
						}
					}
				}
			}
		}

		// Token: 0x060002E6 RID: 742 RVA: 0x003C80E8 File Offset: 0x003100E8
		private unsafe int method_200()
		{
			string text = null;
			int selectedIndex = this.comboBox10.SelectedIndex;
			this.label118.Text = "";
			this.label119.Text = "";
			this.label120.Text = "";
			this.label121.Text = "";
			this.label122.Text = "";
			this.textBox6.AppendText("Sending Vendor Intro to port " + this.label123.Text + "\r\n");
			byte b = (byte)this.method_253();
			this.bool_0 = false;
			uint uint_;
			if (b == 114)
			{
				this.textBox6.AppendText("\r\n" + "Serial flash found with Status 0x72" + "\r\n");
				this.label122.Text = "Serial flash with status 0x72";
				this.textBox6.AppendText("\r\n" + "Sending Device ID request to port " + this.label123.Text + "\r\n");
				<Module>.Sleep(100);
				this.radioButton19.Checked = true;
				uint_ = (uint)this.method_305();
			}
			else
			{
				Struct20 @struct;
				<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct35_121), b);
				string text2 = new string((sbyte*)(&<Module>.struct19_0));
				text2 += new string((sbyte*)(&@struct));
				text += text2;
				this.textBox6.AppendText("Status 0x" + text + "\r\n");
				int num;
				if (this.method_130() == 1)
				{
					num = 6;
					Thread thread = new Thread(new ThreadStart(this.method_132));
					thread.Start();
				}
				else
				{
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					num = (int)MessageBox.Show("If you wish to resend the command you should click Yes." + "\n" + "Power off the drive and then back on (within 1 second)." + "\n\n" + "Press Escape to cancel.", "MTK Vendor Intro failed", MessageBoxButtons.YesNo, MessageBoxIcon.Question);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
				}
				if (num != 6)
				{
					uint_ = 0U;
					return 0;
				}
				this.textBox6.AppendText("Re-sending Vendor Intro: " + "\r\n");
				uint num2 = <Module>.smethod_6();
				while (b != 114)
				{
					uint num3 = <Module>.smethod_6();
					if (num3 - num2 >= 10000U)
					{
						this.textBox6.AppendText("\r\n" + "Device Intro failed!" + "\r\n");
						return 0;
					}
					if (<Module>.GetAsyncKeyState(27) != null)
					{
						this.textBox6.AppendText("\r\n" + "Aborted by User!" + "\r\n");
						return 0;
					}
					b = (byte)this.method_253();
					<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct35_129), b);
					text2 = new string((sbyte*)(&<Module>.struct19_0));
					text2 += new string((sbyte*)(&@struct));
					this.label122.Text = "Status 0x" + text2;
					Application.DoEvents();
					this.textBox6.AppendText(new string((sbyte*)(&<Module>.struct6_9)));
					if (b == 114)
					{
						this.textBox6.AppendText("\r\n" + "Serial flash found with Status 0x72" + "\r\n");
						this.label122.Text = "Serial flash with status 0x72";
						this.textBox6.AppendText("\r\n" + "Sending Device ID request to port " + this.label123.Text + "\r\n");
						<Module>.Sleep(100);
						uint_ = (uint)this.method_305();
						break;
					}
					<Module>.Sleep(250);
				}
			}
			return (this.method_206(uint_) == 0) ? 1 : 0;
		}

		// Token: 0x060002E7 RID: 743 RVA: 0x003C8464 File Offset: 0x00310464
		private unsafe int method_201()
		{
			string text = null;
			int selectedIndex = this.comboBox10.SelectedIndex;
			this.label118.Text = "";
			this.label119.Text = "";
			this.label120.Text = "";
			this.label121.Text = "";
			this.label122.Text = "";
			this.textBox6.AppendText("Sending Vendor Intro to port " + this.label123.Text + "\r\n");
			byte b = (byte)this.method_253();
			this.bool_0 = false;
			uint uint_;
			if (b == 114)
			{
				this.textBox6.AppendText("\r\n" + "Serial flash found with Status 0x72" + "\r\n");
				this.label122.Text = "Serial flash with status 0x72";
				this.textBox6.AppendText("\r\n" + "Sending Device ID request to port " + this.label123.Text + "\r\n");
				<Module>.Sleep(100);
				if (this.radioButton21.Visible)
				{
					this.radioButton21.Checked = true;
				}
				uint_ = (uint)this.method_306();
			}
			else
			{
				Struct20 @struct;
				<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct35_121), b);
				string text2 = new string((sbyte*)(&<Module>.struct19_0));
				text2 += new string((sbyte*)(&@struct));
				text += text2;
				this.textBox6.AppendText("Status 0x" + text + "\r\n");
				int num;
				if (this.method_130() == 1)
				{
					num = 6;
					Thread thread = new Thread(new ThreadStart(this.method_132));
					thread.Start();
				}
				else
				{
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					num = (int)MessageBox.Show("If you wish to resend the command you should click Yes." + "\n" + "Power off the drive and then back on (within 1 second)." + "\n\n" + "Press Escape to cancel.", "MTK Vendor Intro failed", MessageBoxButtons.YesNo, MessageBoxIcon.Question);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
				}
				if (num != 6)
				{
					uint_ = 0U;
					return 0;
				}
				this.textBox6.AppendText("Re-sending Vendor Intro: " + "\r\n");
				uint num2 = <Module>.smethod_6();
				while (b != 114)
				{
					uint num3 = <Module>.smethod_6();
					if (num3 - num2 >= 10000U)
					{
						this.textBox6.AppendText("\r\n" + "Device Intro failed!" + "\r\n");
						return 0;
					}
					if (<Module>.GetAsyncKeyState(27) != null)
					{
						this.textBox6.AppendText("\r\n" + "Aborted by User!" + "\r\n");
						return 0;
					}
					b = (byte)this.method_254();
					<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct35_129), b);
					text2 = new string((sbyte*)(&<Module>.struct19_0));
					text2 += new string((sbyte*)(&@struct));
					this.label122.Text = "Status 0x" + text2;
					Application.DoEvents();
					this.textBox6.AppendText(new string((sbyte*)(&<Module>.struct6_9)));
					if (b == 114)
					{
						this.textBox6.AppendText("\r\n" + "Serial flash found with Status 0x72" + "\r\n");
						this.label122.Text = "Serial flash with status 0x72";
						this.textBox6.AppendText("\r\n" + "Sending Device ID request to port " + this.label123.Text + "\r\n");
						<Module>.Sleep(100);
						uint_ = (uint)this.method_306();
						break;
					}
					<Module>.Sleep(250);
				}
			}
			return (this.method_206(uint_) == 0) ? 1 : 0;
		}

		// Token: 0x060002E8 RID: 744 RVA: 0x003C87F0 File Offset: 0x003107F0
		private unsafe void method_202()
		{
			string text = null;
			this.label118.Text = "";
			this.label119.Text = "";
			this.label120.Text = "";
			this.label121.Text = "";
			this.label122.Text = "";
			this.textBox6.AppendText("Sending Vendor Intro to port " + this.label123.Text + "\r\n");
			sbyte b = (sbyte)this.method_250();
			this.bool_0 = false;
			uint uint_;
			if (b == 115)
			{
				this.textBox6.AppendText("\r\n" + "Serial flash found with Status 0x73" + "\r\n");
				this.label122.Text = "Serial flash with status 0x73";
				this.textBox6.AppendText("\r\n" + "Sending Device ID request to port " + this.label123.Text + "\r\n");
				uint_ = (uint)this.method_297();
			}
			else if (b == 112)
			{
				this.textBox6.AppendText("\r\n" + "Parallel flash found with Status 0x70" + "\r\n");
				this.label122.Text = "Parallel flash with Status 0x70";
				this.textBox6.AppendText("\r\n" + "Sending Device ID request to port " + this.label123.Text + "\r\n");
				uint_ = (uint)this.method_290();
			}
			else if (b == 114)
			{
				this.textBox6.AppendText("\r\n" + "Serial flash found with Status 0x72" + "\r\n");
				this.label122.Text = "Serial flash with status 0x72";
				this.textBox6.AppendText("\r\n" + "Sending Device ID request to port " + this.label123.Text + "\r\n");
				uint_ = (uint)this.method_303();
			}
			else
			{
				Struct20 @struct;
				<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct35_129), (byte)b);
				string text2 = new string((sbyte*)(&<Module>.struct19_0));
				text2 += new string((sbyte*)(&@struct));
				text += text2;
				this.textBox6.AppendText("Status 0x" + text + "\r\n");
				<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
				int num = (int)MessageBox.Show("If you wish to resend the command you should click Yes." + "\n" + "Power off the drive and then back on (within 1 second)." + "\n\n" + "Press Escape to cancel.", "MTK Vendor Intro failed", MessageBoxButtons.YesNo, MessageBoxIcon.Question);
				<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
				if (num != 6)
				{
					uint_ = 0U;
					return;
				}
				this.textBox6.AppendText("Re-sending Vendor Intro: " + "\r\n");
				uint num2 = <Module>.smethod_6();
				while (b != 112 & b != 114 & b != 115)
				{
					uint num3 = <Module>.smethod_6();
					if (num3 - num2 >= 20000U)
					{
						this.textBox6.AppendText("\r\n" + "Device Intro failed!" + "\r\n");
						return;
					}
					if (<Module>.GetAsyncKeyState(27) != null)
					{
						this.textBox6.AppendText("\r\n" + "Aborted by User!" + "\r\n");
						return;
					}
					b = (sbyte)this.method_250();
					<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct35_129), (byte)b);
					text2 = new string((sbyte*)(&<Module>.struct19_0));
					text2 += new string((sbyte*)(&@struct));
					this.label122.Text = "Status 0x" + text2;
					Application.DoEvents();
					this.textBox6.AppendText(new string((sbyte*)(&<Module>.struct6_9)));
					if (b == 115)
					{
						this.textBox6.AppendText("\r\n" + "Serial flash found with Status 0x73" + "\r\n");
						this.label122.Text = "Serial flash with status 0x73";
						this.textBox6.AppendText("\r\n" + "Sending Device ID request to port " + this.label123.Text + "\r\n");
						uint_ = (uint)this.method_297();
						break;
					}
					if (b == 112)
					{
						this.textBox6.AppendText("\r\n" + "Parallel flash found with Status 0x70" + "\r\n");
						this.label122.Text = "Parallel flash with Status 0x70";
						this.textBox6.AppendText("\r\n" + "Sending Device ID request to port " + this.label123.Text + "\r\n");
						uint_ = (uint)this.method_290();
						break;
					}
					if (b == 114)
					{
						this.textBox6.AppendText("\r\n" + "Serial flash found with Status 0x72" + "\r\n");
						this.label122.Text = "Serial flash with status 0x72";
						this.textBox6.AppendText("\r\n" + "Sending Device ID request to port " + this.label123.Text + "\r\n");
						uint_ = (uint)this.method_303();
						break;
					}
					<Module>.Sleep(250);
				}
			}
			this.method_206(uint_);
		}

		// Token: 0x060002E9 RID: 745 RVA: 0x003C8CE4 File Offset: 0x00310CE4
		private unsafe int method_203()
		{
			string text = null;
			this.label118.Text = "";
			this.label119.Text = "";
			this.label120.Text = "";
			this.label121.Text = "";
			this.label122.Text = "";
			this.textBox6.AppendText("Sending Vendor Intro to port " + this.label123.Text + "\r\n");
			sbyte b = (sbyte)this.method_252();
			this.bool_0 = false;
			int result;
			if (b == 114)
			{
				this.textBox6.AppendText("\r\n" + "Serial flash found with Status 0x72" + "\r\n");
				this.label122.Text = "Serial flash with status 0x72";
				this.textBox6.AppendText("\r\n" + "Sending Device ID request to port " + this.label123.Text + "\r\n");
				uint uint_ = (uint)this.method_303();
				result = 0;
			}
			else if (b == 82)
			{
				this.textBox6.AppendText("\r\n" + "Serial flash found with Status 0x52" + "\r\n");
				this.label122.Text = "Serial flash with status 0x52";
				result = 1;
			}
			else
			{
				Struct20 @struct;
				<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct35_129), (byte)b);
				string text2 = new string((sbyte*)(&<Module>.struct19_0));
				text2 += new string((sbyte*)(&@struct));
				text += text2;
				this.textBox6.AppendText("Status 0x" + text + "\r\n");
				<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
				int num = (int)MessageBox.Show("To resend the command you should click Yes." + "\n" + "Press and hold Probe 3 cable button... Probe MPX01... Then release cable button." + "\n\n" + "Press Escape to cancel.", "MTK Vendor Intro failed", MessageBoxButtons.YesNo, MessageBoxIcon.Question);
				<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
				if (num == 6)
				{
					this.textBox6.AppendText("Re-sending Vendor Intro: " + "\r\n");
					uint num2 = <Module>.smethod_6();
					while (b != 82 & b != 114)
					{
						uint num3 = <Module>.smethod_6();
						if (num3 - num2 >= 20000U)
						{
							this.textBox6.AppendText("\r\n" + "Device Intro failed!" + "\r\n");
							return 0;
						}
						if (<Module>.GetAsyncKeyState(27) != null)
						{
							this.textBox6.AppendText("\r\n" + "Aborted by User!" + "\r\n");
							return 0;
						}
						b = (sbyte)this.method_252();
						<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct35_129), (byte)b);
						text2 = new string((sbyte*)(&<Module>.struct19_0));
						text2 += new string((sbyte*)(&@struct));
						this.label122.Text = "Status 0x" + text2;
						Application.DoEvents();
						this.textBox6.AppendText(new string((sbyte*)(&<Module>.struct6_9)));
						if (b == 114)
						{
							this.textBox6.AppendText("\r\n" + "Serial flash found with Status 0x72" + "\r\n");
							this.label122.Text = "Serial flash with status 0x72";
							this.textBox6.AppendText("\r\n" + "Sending Device ID request to port " + this.label123.Text + "\r\n");
							uint uint_ = (uint)this.method_303();
							if (this.method_206(uint_) != 0)
							{
								return 0;
							}
						}
						else if (b == 82)
						{
							this.textBox6.AppendText("\r\n" + "Serial flash found with Status 0x52" + "\r\n");
							this.label122.Text = "Serial flash with status 0x52";
							return 1;
						}
						<Module>.Sleep(250);
					}
				}
				result = 0;
			}
			return result;
		}

		// Token: 0x060002EA RID: 746 RVA: 0x00137494 File Offset: 0x00137494
		private int method_204()
		{
			this.label118.Text = "";
			this.label119.Text = "";
			this.label120.Text = "";
			this.label121.Text = "";
			this.label122.Text = "";
			sbyte b = (sbyte)this.method_250();
			this.bool_0 = false;
			int result;
			if (b == 82)
			{
				this.textBox6.AppendText("\r\n" + "Serial flash found with Status 0x52" + "\r\n");
				this.label122.Text = "Serial flash with status 0x52";
				this.method_96();
				result = 1;
			}
			else
			{
				result = 0;
			}
			return result;
		}

		// Token: 0x060002EB RID: 747 RVA: 0x00137544 File Offset: 0x00137544
		private void method_205()
		{
			this.label118.Text = "";
			this.label119.Text = "";
			this.label120.Text = "";
			this.label121.Text = "";
			this.label122.Text = "";
			sbyte b = (sbyte)this.method_250();
			uint uint_;
			if (b == 115)
			{
				this.label122.Text = "Serial flash with status 0x73";
				uint_ = (uint)this.method_297();
			}
			else if (b == 112)
			{
				this.label122.Text = "Parallel flash with Status 0x70";
				uint_ = (uint)this.method_290();
			}
			else if (b == 114)
			{
				this.label122.Text = "Serial flash with status 0x72";
				uint_ = (uint)this.method_303();
			}
			else if (b != 112 & b != 114 & b != 115)
			{
				return;
			}
			this.method_206(uint_);
		}

		// Token: 0x060002EC RID: 748 RVA: 0x0013762C File Offset: 0x0013762C
		private unsafe int method_206(uint uint_0)
		{
			uint num = (uint_0 & 65280U) >> 8;
			Struct20 @struct;
			<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct35_129), num);
			string text = new string((sbyte*)(&<Module>.struct19_0));
			string text2 = new string((sbyte*)(&<Module>.struct19_0));
			text += new string((sbyte*)(&@struct));
			text2 += text;
			this.label118.Text = "0x" + text2;
			this.textBox6.AppendText("Manufacturer ID: 0x" + text2 + "\r\n");
			uint num2 = uint_0 & 255U;
			<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct35_129), num2);
			text = new string((sbyte*)(&<Module>.struct19_0));
			text2 = new string((sbyte*)(&<Module>.struct19_0));
			text += new string((sbyte*)(&@struct));
			text2 += text;
			this.label119.Text = "0x" + text2;
			this.textBox6.AppendText("Device ID: 0x" + text2 + "\r\n");
			string text3;
			int result;
			if (num == 191U && num2 == 182U)
			{
				text2 = "SST(SST39SF020)";
				text3 = "262144 bytes";
				result = 0;
				this.string_2 = "DevID: 0xBF 0xB6";
				this.string_3 = "SST(SST39SF020)";
			}
			else if (num == 191U && num2 == 67U)
			{
				text2 = "SST(25LF020/25VF020)";
				text3 = "262144 bytes";
				result = 0;
				this.string_2 = "DevID: 0xBF 0x43";
				this.string_3 = "SST(25LF020/25VF020)";
			}
			else if (num == 239U && num2 == 17U)
			{
				text2 = "Winbond/NEX(W25P20/NX25P20)";
				text3 = "262144 bytes";
				result = 0;
				this.string_2 = "DevID: 0xEF 0x11";
				this.string_3 = "Winbond(W25P20)";
			}
			else if (num == 157U && num2 == 125U)
			{
				text2 = "PMC(PM25LV020)";
				text3 = "262144 bytes";
				result = 0;
				this.string_2 = "DevID: 0x9D 0x7D";
				this.string_3 = "PMC(PM25LV020)";
			}
			else if (num == 239U && num2 == 49U)
			{
				text2 = "Winbond/NEX(W25B20/NX25B20)";
				text3 = "262144 bytes";
				result = 0;
				this.string_2 = "DevID: 0xEF 0x31";
				this.string_3 = "Winbond(W25B20)";
			}
			else if (num == 55U && num2 == 17U)
			{
				text2 = "AMIC(A25L20P)";
				text3 = "262144 bytes";
				result = 0;
				this.string_2 = "DevID: 0x37 0x11";
				this.string_3 = "AMIC(A25L20P)";
			}
			else if (num == 194U && num2 == 17U)
			{
				text2 = "MXIC(MX25L2005)";
				text3 = "262144 bytes";
				result = 0;
				this.string_2 = "DevID: 0xC2 0x11";
				this.string_3 = "MXIC(MX25L2005)";
			}
			else if (num == 16U && num2 == 0U)
			{
				text2 = "Spansion(S25FL002D)";
				text3 = "262144 bytes";
				result = 0;
				this.string_2 = "DevID: 0x10 0x00";
				this.string_3 = "SPANSION(S25FL002D)";
			}
			else if (num == 28U && num2 == 20U)
			{
				text2 = "EON(EN25P16)";
				text3 = "2097152 bytes";
				result = 0;
				this.string_2 = "DevID: 0x1C 0x14";
				this.string_3 = "EON(EN25P16)";
			}
			else if (num == 239U && num2 == 20U)
			{
				text2 = "Winbond/NEX(W25P16/NX25P16)";
				text3 = "2097152 bytes";
				result = 0;
				this.string_2 = "DevID: 0xEF 0x14";
				this.string_3 = "Winbond(W25P16)";
			}
			else if (num == 194U && num2 == 20U)
			{
				text2 = "MXIC(MX25L1605D)";
				text3 = "2097152 bytes";
				result = 0;
				this.string_2 = "DevID: 0xC2 0x14";
				this.string_3 = "MXIC(MX25L1605D)";
			}
			else if (num == 28U && num2 == 19U)
			{
				text2 = "EON(EN25P80)";
				text3 = "1048576 bytes";
				result = 0;
				this.string_2 = "DevID: 0x1C 0x13";
				this.string_3 = "EON(EN25P80)";
			}
			else if (num == 239U && num2 == 19U)
			{
				text2 = "Winbond/NEX(W25P80/NX25P80)";
				text3 = "1048576 bytes";
				result = 0;
				this.string_2 = "DevID: 0xEF 0x13";
				this.string_3 = "Winbond(W25P80)";
			}
			else if (num == 194U && num2 == 19U)
			{
				text2 = "MXIC(MX25L8005)";
				text3 = "1048576 bytes";
				result = 0;
				this.string_2 = "DevID: 0xC2 0x13";
				this.string_3 = "MXIC(MX25L8005)";
			}
			else
			{
				text2 = "Unknown type";
				text3 = "n/a";
				result = 1;
			}
			this.label120.Text = text2;
			this.label121.Text = text3;
			this.textBox6.AppendText("Flash Name:  " + text2 + "\r\n");
			this.textBox6.AppendText("Flash Size:  " + text3 + "\r\n");
			this.label110.Text = "Drive in Vendor Mode!";
			this.label109.Text = "";
			this.label106.Text = "";
			this.label92.Text = "";
			this.label72.Text = "Drive in Vendor Mode!";
			this.label68.Text = "";
			this.label61.Text = "";
			this.label58.Text = "";
			this.label100.Text = "Drive in Vendor Mode!";
			this.label99.Text = "";
			this.label98.Text = "";
			this.label97.Text = "";
			return result;
		}

		// Token: 0x060002ED RID: 749 RVA: 0x00137B44 File Offset: 0x00137B44
		private void button7_Click(object sender, EventArgs e)
		{
			this.method_14();
			this.radioButton20.Checked = true;
			this.method_207();
			this.method_15();
		}

		// Token: 0x060002EE RID: 750 RVA: 0x003C9094 File Offset: 0x00311094
		private unsafe void method_207()
		{
			int selectedIndex = this.comboBox10.SelectedIndex;
			if (this.comboBox1.Items.Count != 0)
			{
				uint selectedIndex2 = (uint)this.comboBox1.SelectedIndex;
				uint num = (uint)(*(ref <Module>.struct38_0 + selectedIndex2 * 72U + 4));
				ushort ushort_ = *(ref <Module>.struct38_0 + selectedIndex2 * 72U);
				if (*(*(ref <Module>.struct123_0 + 4)) == 0)
				{
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					int num2 = (int)MessageBox.Show("No Firmware is loaded to Target buffer," + "\n" + "Are you sure you wish to proceed ?", "Lite-On Erase", MessageBoxButtons.YesNo, MessageBoxIcon.Hand, MessageBoxDefaultButton.Button2);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
					if (num2 == 7)
					{
						this.textBox6.AppendText("Lite-On-Erase NOT sent " + "\r\n");
						return;
					}
				}
				if (*(*(ref <Module>.struct123_0 + 4)) != 4 && *(*(ref <Module>.struct123_0 + 4)) != 0)
				{
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					int num2 = (int)MessageBox.Show("Firmware in Target buffer is not Lite-On," + "\n" + "Are you sure you wish to proceed ?", "Lite-On Erase", MessageBoxButtons.YesNo, MessageBoxIcon.Hand, MessageBoxDefaultButton.Button2);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
					if (num2 == 7)
					{
						this.textBox6.AppendText("Lite-On-Erase NOT sent " + "\r\n");
						return;
					}
				}
				if (this.method_69() == 1 && this.method_107(*(ref <Module>.struct123_0 + 4) + 280) != 1)
				{
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					int num2 = (int)MessageBox.Show("Target DVDKey Can't be verified to drive !" + "\n" + "Are you sure you wish to proceed ?", "Lite-On Erase", MessageBoxButtons.YesNo, MessageBoxIcon.Hand, MessageBoxDefaultButton.Button2);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
					if (num2 == 7)
					{
						this.textBox6.AppendText("Lite-On-Erase NOT sent " + "\r\n");
						return;
					}
				}
				if (this.method_69() == 1 && *(*(ref <Module>.struct123_0 + 4)) == 4)
				{
					byte* ptr = *(ref <Module>.struct121_0 + 4780) + 130816;
					if (<Module>.memcmp((void*)ptr, *(ref <Module>.struct123_0 + 8) + 2028, 20U) != null)
					{
						<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
						int num2 = (int)MessageBox.Show("The Target f/w in does not appear to match the attached drive !" + "\n" + "This is based on a comparison of the drive barcode." + "\n" + "Please make sure you have done DVDKey32." + "\n\n" + "Are you sure you wish to proceed ?", "Lite-On Erase", MessageBoxButtons.YesNo, MessageBoxIcon.Hand, MessageBoxDefaultButton.Button2);
						<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
						if (num2 == 7)
						{
							this.textBox6.AppendText("Lite-On-Erase NOT sent " + "\r\n");
							return;
						}
					}
				}
				if (!this.bool_2)
				{
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					int num2 = (int)MessageBox.Show("Are you 100% sure you have the Correct Drive Key" + "\n\n" + "This Command will Completely Erase your Drive f/w!" + "\n\n" + "                Do you Wish to Proceed ?", "Lite-On-Erase", MessageBoxButtons.YesNo, MessageBoxIcon.Hand, MessageBoxDefaultButton.Button2);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
					if (num2 == 7)
					{
						this.textBox6.AppendText("Lite-On-Erase NOT sent " + "\r\n");
						return;
					}
				}
				if (this.method_134() == 0)
				{
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					int num2 = (int)MessageBox.Show("When Erase is complete, Vendor Intro will be sent." + "\n\n" + "Power drive Off then On in quick succession, Once!" + "\n\n" + "Drive should return Status 0x72 and a good Device ID." + "\n\n" + "                Do you Wish to Proceed ?", "Lite-On-Erase", MessageBoxButtons.YesNo, MessageBoxIcon.Hand, MessageBoxDefaultButton.Button2);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
					if (num2 == 7)
					{
						this.textBox6.AppendText("Lite-On-Erase NOT sent " + "\r\n");
						return;
					}
				}
				GStruct3 gstruct;
				<Module>.smethod_21(&gstruct, ushort_, 0, 1, 10000U);
				this.textBox6.AppendText("\r\n" + "Sending Lite-On-Erase request to port " + this.label123.Text + "\r\n");
				<Module>.smethod_2(*(ref gstruct + 14), (byte)num);
				<Module>.Sleep(250);
				this.textBox6.AppendText(".");
				<Module>.Sleep(250);
				this.textBox6.AppendText(".");
				<Module>.smethod_2(*(ref gstruct + 14), (byte)num);
				<Module>.smethod_2(*(ref gstruct + 8), 46);
				<Module>.smethod_2(*(ref gstruct + 18), 128);
				if (this.method_134() == 1)
				{
					Thread thread = new Thread(new ThreadStart(this.method_133));
					thread.Start();
				}
				else
				{
					for (int i = 0; i < 12; i++)
					{
						<Module>.Sleep(250);
						this.textBox6.AppendText(".");
					}
				}
				ushort num3 = (ushort)<Module>.smethod_1(*(ref gstruct + 18));
				Struct20 @struct;
				<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct35_129), (byte)num3);
				string text = new string((sbyte*)(&<Module>.struct19_0));
				text += new string((sbyte*)(&@struct));
				this.textBox6.AppendText("\r\n" + "Drive returned Status 0x" + text + "\r\n");
				uint num4 = <Module>.smethod_6();
				uint uint_;
				while (num3 != 114)
				{
					uint num5 = <Module>.smethod_6();
					if (num5 - num4 >= 10000U)
					{
						this.textBox6.AppendText("\r\n" + "Device Intro failed!" + "\r\n");
						return;
					}
					if (<Module>.GetAsyncKeyState(27) != null)
					{
						this.textBox6.AppendText("\r\n" + "Aborted by User!" + "\r\n");
						return;
					}
					<Module>.smethod_2(*(ref gstruct + 14), (byte)num);
					<Module>.Sleep(500);
					<Module>.smethod_2(*(ref gstruct + 8), 46);
					<Module>.smethod_2(*(ref gstruct + 18), 128);
					num3 = (ushort)<Module>.smethod_1(*(ref gstruct + 18));
					<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct35_129), (byte)num3);
					text = new string((sbyte*)(&<Module>.struct19_0));
					text += new string((sbyte*)(&@struct));
					this.label122.Text = "Status 0x" + text;
					Application.DoEvents();
					this.textBox6.AppendText(new string((sbyte*)(&<Module>.struct6_9)));
					Application.DoEvents();
					if (num3 == 242)
					{
						this.textBox6.AppendText("\r\n" + "Serial flash found with Status 0x72" + "\r\n");
						this.label122.Text = "Serial flash with status 0x72";
						<Module>.Sleep(250);
						this.method_258();
						<Module>.Sleep(250);
						this.method_252();
						uint_ = (uint)this.method_304();
						break;
					}
					if (num3 == 114)
					{
						this.textBox6.AppendText("\r\n" + "Serial flash found with Status 0x72" + "\r\n");
						this.label122.Text = "Serial flash with status 0x72";
						<Module>.Sleep(250);
						this.method_258();
						<Module>.Sleep(250);
						this.method_252();
						uint_ = (uint)this.method_304();
						break;
					}
				}
				if (this.method_206(uint_) == 0)
				{
					Application.DoEvents();
					if (this.bool_2)
					{
						this.method_208();
					}
				}
			}
		}

		// Token: 0x060002EF RID: 751 RVA: 0x003C97F4 File Offset: 0x003117F4
		private unsafe void method_208()
		{
			if (*(*(ref <Module>.struct123_0 + 4)) == 0)
			{
				<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
				MessageBox.Show("No Firmware is loaded to Target buffer", "F/W Write", MessageBoxButtons.OK, MessageBoxIcon.Hand);
				<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
			}
			else if (*(*(ref <Module>.struct123_0 + 4)) != 4)
			{
				<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
				MessageBox.Show("Firmware in Target buffer is not Lite-On, write aborted", "F/W Write", MessageBoxButtons.OK, MessageBoxIcon.Hand);
				<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
			}
			else
			{
				this.Cursor = Cursors.WaitCursor;
				this.method_311();
				this.textBox6.AppendText("Writing target buffer to flash" + "\r\n");
				if (this.method_326() == 1)
				{
					this.Cursor = Cursors.Arrow;
				}
				else
				{
					this.Cursor = Cursors.Arrow;
					<Module>.Sleep(500);
					this.Cursor = Cursors.WaitCursor;
					this.textBox6.AppendText("\r\n" + "Flash Verification Test !");
					this.method_307();
					this.Cursor = Cursors.Arrow;
					for (int i = 0; i < 262144; i++)
					{
						if (*(*(ref <Module>.struct121_0 + 7172) + i) != *(*(ref <Module>.struct121_0 + 4780) + i))
						{
							this.textBox6.AppendText("Write Verify Failed !" + "\r\n");
							return;
						}
					}
					this.textBox6.AppendText("Write verified OK !" + "\r\n\r\n");
					Thread thread = new Thread(new ThreadStart(this.method_162));
					thread.Start();
				}
			}
		}

		// Token: 0x060002F0 RID: 752 RVA: 0x00138488 File Offset: 0x00138488
		private void button16_Click(object sender, EventArgs e)
		{
			this.method_14();
			this.method_209();
			this.method_15();
		}

		// Token: 0x060002F1 RID: 753 RVA: 0x001384A8 File Offset: 0x001384A8
		private void method_209()
		{
			this.textBox6.AppendText("Sending Vendor Outro to port " + this.label123.Text + "\r\n");
			this.method_251();
			this.toolTip_0.SetToolTip(this.button42, "Lock/UnLock Slim Lite-On Spi ");
			this.button42.Enabled = false;
			this.button42.Text = "";
			this.label118.Text = "";
			this.label119.Text = "";
			this.label120.Text = "";
			this.label121.Text = "";
			this.label122.Text = "";
			<Module>.Sleep(1500);
			this.method_172();
		}

		// Token: 0x060002F2 RID: 754 RVA: 0x00138574 File Offset: 0x00138574
		private void button15_Click(object sender, EventArgs e)
		{
			this.method_14();
			this.method_210();
			this.method_15();
		}

		// Token: 0x060002F3 RID: 755 RVA: 0x00138594 File Offset: 0x00138594
		private void method_210()
		{
			if (this.radioButton19.Checked)
			{
				this.method_212();
			}
			else
			{
				this.method_211();
			}
		}

		// Token: 0x060002F4 RID: 756 RVA: 0x001385C0 File Offset: 0x001385C0
		private unsafe void method_211()
		{
			if (string.Compare(Convert.ToString(this.label120.Text), "Unknown type") == 0)
			{
				this.textBox6.AppendText("Unknown flash type Read aborted !" + "\r\n");
			}
			else
			{
				uint num = (uint)this.method_261();
				Struct20 @struct;
				<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct35_129), num);
				string text = new string((sbyte*)(&<Module>.struct19_0));
				text += new string((sbyte*)(&@struct));
				text = "0x" + text;
				int num2 = <Module>.clock();
				if (num == 112U)
				{
					this.textBox6.AppendText("Parallel flash found with Status 0x70" + "\r\n");
					this.Cursor = Cursors.WaitCursor;
					this.method_291();
					int num3 = <Module>.clock();
					int value = num3 - num2;
					this.textBox6.AppendText("\r\n" + "Dumped in " + Convert.ToString(value) + "mS" + "\r\n");
					this.Cursor = Cursors.Arrow;
					this.method_262();
					this.textBox6.AppendText("\r\n" + "Loading MTK_Flash source file " + "\r\n");
				}
				else if (num == 115U)
				{
					this.textBox6.AppendText("Serial flash found with Status 0x73" + "\r\n");
					this.Cursor = Cursors.WaitCursor;
					this.method_298();
					int num3 = <Module>.clock();
					int value = num3 - num2;
					this.textBox6.AppendText("\r\n" + "Dumped in " + Convert.ToString(value) + "mS" + "\r\n");
					this.Cursor = Cursors.Arrow;
					this.method_263();
					this.textBox6.AppendText("\r\n" + "Loading MTK_Flash source file " + "\r\n");
				}
				else if (num == 114U)
				{
					this.textBox6.AppendText("Serial flash found with Status 0x72" + "\r\n");
					this.Cursor = Cursors.WaitCursor;
					this.method_307();
					int num3 = <Module>.clock();
					int value = num3 - num2;
					this.textBox6.AppendText("\r\n" + "Dumped in " + Convert.ToString(value) + "mS" + "\r\n");
					this.Cursor = Cursors.Arrow;
					this.method_264();
					this.textBox6.AppendText("\r\n" + "Loading MTK_Flash source file " + "\r\n");
				}
				else
				{
					this.textBox6.AppendText("Invalid Status " + text + "\r\n");
				}
			}
		}

		// Token: 0x060002F5 RID: 757 RVA: 0x00138844 File Offset: 0x00138844
		private unsafe void method_212()
		{
			string strA = null;
			int num = 0;
			Struct28 @struct = 239;
			*(ref @struct + 1) = 180;
			*(ref @struct + 2) = 134;
			*(ref @struct + 3) = 14;
			*(ref @struct + 4) = 51;
			*(ref @struct + 5) = 186;
			*(ref @struct + 6) = 40;
			*(ref @struct + 7) = 88;
			*(ref @struct + 8) = 99;
			*(ref @struct + 9) = 52;
			*(ref @struct + 10) = 85;
			*(ref @struct + 11) = 115;
			*(ref @struct + 12) = 79;
			*(ref @struct + 13) = 173;
			*(ref @struct + 14) = 24;
			*(ref @struct + 15) = 147;
			Struct28 struct2 = 36;
			*(ref struct2 + 1) = 213;
			*(ref struct2 + 2) = 165;
			*(ref struct2 + 3) = 239;
			*(ref struct2 + 4) = 251;
			*(ref struct2 + 5) = 64;
			*(ref struct2 + 6) = 87;
			*(ref struct2 + 7) = 131;
			*(ref struct2 + 8) = 252;
			*(ref struct2 + 9) = 60;
			*(ref struct2 + 10) = 35;
			*(ref struct2 + 11) = 73;
			*(ref struct2 + 12) = 167;
			*(ref struct2 + 13) = 178;
			*(ref struct2 + 14) = 185;
			*(ref struct2 + 15) = 12;
			Struct28 struct3 = 52;
			*(ref struct3 + 1) = 69;
			*(ref struct3 + 2) = 177;
			*(ref struct3 + 3) = 214;
			*(ref struct3 + 4) = 227;
			*(ref struct3 + 5) = 148;
			*(ref struct3 + 6) = 233;
			*(ref struct3 + 7) = 64;
			*(ref struct3 + 8) = 198;
			*(ref struct3 + 9) = 228;
			*(ref struct3 + 10) = 212;
			*(ref struct3 + 11) = 253;
			*(ref struct3 + 12) = 219;
			*(ref struct3 + 13) = 73;
			*(ref struct3 + 14) = 84;
			*(ref struct3 + 15) = 20;
			Struct28 struct4 = 26;
			*(ref struct4 + 1) = 194;
			*(ref struct4 + 2) = 56;
			*(ref struct4 + 3) = 208;
			*(ref struct4 + 4) = 231;
			*(ref struct4 + 5) = 48;
			*(ref struct4 + 6) = 102;
			*(ref struct4 + 7) = 115;
			*(ref struct4 + 8) = 147;
			*(ref struct4 + 9) = 121;
			*(ref struct4 + 10) = 237;
			*(ref struct4 + 11) = 217;
			*(ref struct4 + 12) = 109;
			*(ref struct4 + 13) = 141;
			*(ref struct4 + 14) = 64;
			*(ref struct4 + 15) = 46;
			Struct28 struct5 = 64;
			*(ref struct5 + 1) = 116;
			*(ref struct5 + 2) = 220;
			*(ref struct5 + 3) = 208;
			*(ref struct5 + 4) = 84;
			*(ref struct5 + 5) = 22;
			*(ref struct5 + 6) = 95;
			*(ref struct5 + 7) = 210;
			*(ref struct5 + 8) = 63;
			*(ref struct5 + 9) = 201;
			*(ref struct5 + 10) = 208;
			*(ref struct5 + 11) = 33;
			*(ref struct5 + 12) = 129;
			*(ref struct5 + 13) = 190;
			*(ref struct5 + 14) = 153;
			*(ref struct5 + 15) = 53;
			Struct28 struct6 = 123;
			*(ref struct6 + 1) = 0;
			*(ref struct6 + 2) = 74;
			*(ref struct6 + 3) = 89;
			*(ref struct6 + 4) = 0;
			*(ref struct6 + 5) = 11;
			*(ref struct6 + 6) = 221;
			*(ref struct6 + 7) = 131;
			*(ref struct6 + 8) = 180;
			*(ref struct6 + 9) = 196;
			*(ref struct6 + 10) = 36;
			*(ref struct6 + 11) = 121;
			*(ref struct6 + 12) = 111;
			*(ref struct6 + 13) = 65;
			*(ref struct6 + 14) = 168;
			*(ref struct6 + 15) = 106;
			GStruct93 gstruct;
			<Module>.smethod_111(ref gstruct);
			GStruct19 gstruct2;
			try
			{
				<Module>.smethod_90(ref gstruct2);
				try
				{
					if (string.Compare(Convert.ToString(this.label120.Text), "Unknown type") != 0)
					{
						goto IL_3C4;
					}
					this.textBox6.AppendText("Unknown flash type Read aborted !" + "\r\n");
				}
				catch
				{
					<Module>.__CxxCallUnwindDtor(<Module>.ppInt_14, (void*)(&gstruct2));
					throw;
				}
				<Module>.smethod_92(ref gstruct2);
			}
			catch
			{
				<Module>.__CxxCallUnwindDtor(<Module>.ppInt_13, (void*)(&gstruct));
				throw;
			}
			<Module>.smethod_112(ref gstruct);
			return;
			try
			{
				try
				{
					IL_3C4:
					uint num2 = (uint)this.method_261();
					Struct20 struct7;
					<Module>.sprintf((sbyte*)(&struct7), (sbyte*)(&<Module>.struct35_129), num2);
					string text = new string((sbyte*)(&<Module>.struct19_0));
					text += new string((sbyte*)(&struct7));
					text = "0x" + text;
					if (num2 == 114U)
					{
						goto IL_45A;
					}
					this.textBox6.AppendText("Invalid Status " + text + "\r\n");
				}
				catch
				{
					<Module>.__CxxCallUnwindDtor(<Module>.ppInt_14, (void*)(&gstruct2));
					throw;
				}
				<Module>.smethod_92(ref gstruct2);
			}
			catch
			{
				<Module>.__CxxCallUnwindDtor(<Module>.ppInt_13, (void*)(&gstruct));
				throw;
			}
			<Module>.smethod_112(ref gstruct);
			return;
			try
			{
				try
				{
					IL_45A:
					this.textBox6.AppendText("Serial flash found with Status 0x72" + "\r\n");
					int num3 = this.method_323();
					if (num3 != 140)
					{
						goto IL_4D2;
					}
					this.textBox6.AppendText("Spi is locked, Aborting!" + "\r\n");
				}
				catch
				{
					<Module>.__CxxCallUnwindDtor(<Module>.ppInt_14, (void*)(&gstruct2));
					throw;
				}
				<Module>.smethod_92(ref gstruct2);
			}
			catch
			{
				<Module>.__CxxCallUnwindDtor(<Module>.ppInt_13, (void*)(&gstruct));
				throw;
			}
			<Module>.smethod_112(ref gstruct);
			return;
			try
			{
				try
				{
					IL_4D2:
					int num3;
					if (num3 != 142)
					{
						goto IL_528;
					}
					this.textBox6.AppendText("Spi is locked, Aborting!" + "\r\n");
				}
				catch
				{
					<Module>.__CxxCallUnwindDtor(<Module>.ppInt_14, (void*)(&gstruct2));
					throw;
				}
				<Module>.smethod_92(ref gstruct2);
			}
			catch
			{
				<Module>.__CxxCallUnwindDtor(<Module>.ppInt_13, (void*)(&gstruct));
				throw;
			}
			<Module>.smethod_112(ref gstruct);
			return;
			try
			{
				try
				{
					IL_528:
					this.Cursor = Cursors.WaitCursor;
					this.textBox6.AppendText("Reading Drive Key." + "\r\n");
					this.method_256();
					Struct28 struct8;
					<Module>.memcpy((void*)(&struct8), *(ref <Module>.struct123_0 + 8) + 280, 16U);
					this.method_259();
					for (int i = 0; i < 12; i++)
					{
						<Module>.Sleep(250);
						this.textBox6.AppendText(".");
					}
					if (this.method_107((byte*)(&struct8)) == 1)
					{
						this.Cursor = Cursors.WaitCursor;
						this.textBox6.AppendText("\r\n" + "Authorised !" + "\r\n");
						goto IL_621;
					}
					this.textBox6.AppendText("\r\n" + "Authorisation Failed!" + "\r\n");
				}
				catch
				{
					<Module>.__CxxCallUnwindDtor(<Module>.ppInt_14, (void*)(&gstruct2));
					throw;
				}
				<Module>.smethod_92(ref gstruct2);
			}
			catch
			{
				<Module>.__CxxCallUnwindDtor(<Module>.ppInt_13, (void*)(&gstruct));
				throw;
			}
			<Module>.smethod_112(ref gstruct);
			return;
			Struct28 struct9;
			int num4;
			try
			{
				try
				{
					IL_621:
					this.textBox6.AppendText("Grabbing sector 0x3E000." + "\r\n");
					this.method_92(0, 0, 0, (byte*)(&struct9));
					num4 = 16;
				}
				catch
				{
					<Module>.__CxxCallUnwindDtor(<Module>.ppInt_14, (void*)(&gstruct2));
					throw;
				}
			}
			catch
			{
				<Module>.__CxxCallUnwindDtor(<Module>.ppInt_13, (void*)(&gstruct));
				throw;
			}
			int j;
			Struct33 struct10;
			for (;;)
			{
				try
				{
					try
					{
						if (num4 >= 32)
						{
							goto IL_7AD;
						}
						j = 0;
					}
					catch
					{
						<Module>.__CxxCallUnwindDtor(<Module>.ppInt_14, (void*)(&gstruct2));
						throw;
					}
				}
				catch
				{
					<Module>.__CxxCallUnwindDtor(<Module>.ppInt_13, (void*)(&gstruct));
					throw;
				}
				for (;;)
				{
					try
					{
						try
						{
							if (j >= 256)
							{
								break;
							}
							if (this.method_91(0, (byte)num4, (byte)j, (byte*)(&struct9)) != 0)
							{
								goto IL_6F3;
							}
							this.textBox6.AppendText("\r\n" + "Read Failed !" + "\r\n");
						}
						catch
						{
							<Module>.__CxxCallUnwindDtor(<Module>.ppInt_14, (void*)(&gstruct2));
							throw;
						}
						<Module>.smethod_92(ref gstruct2);
						goto IL_7A1;
					}
					catch
					{
						<Module>.__CxxCallUnwindDtor(<Module>.ppInt_13, (void*)(&gstruct));
						throw;
					}
					try
					{
						try
						{
							IL_6F3:
							<Module>.memcpy(ref struct10 + num, (void*)(&struct9), 16U);
						}
						catch
						{
							<Module>.__CxxCallUnwindDtor(<Module>.ppInt_14, (void*)(&gstruct2));
							throw;
						}
					}
					catch
					{
						<Module>.__CxxCallUnwindDtor(<Module>.ppInt_13, (void*)(&gstruct));
						throw;
					}
					try
					{
						try
						{
							j += 16;
							num += 16;
						}
						catch
						{
							<Module>.__CxxCallUnwindDtor(<Module>.ppInt_14, (void*)(&gstruct2));
							throw;
						}
						continue;
					}
					catch
					{
						<Module>.__CxxCallUnwindDtor(<Module>.ppInt_13, (void*)(&gstruct));
						throw;
					}
					break;
				}
				try
				{
					try
					{
						this.textBox6.AppendText(".");
						Application.DoEvents();
					}
					catch
					{
						<Module>.__CxxCallUnwindDtor(<Module>.ppInt_14, (void*)(&gstruct2));
						throw;
					}
				}
				catch
				{
					<Module>.__CxxCallUnwindDtor(<Module>.ppInt_13, (void*)(&gstruct));
					throw;
				}
				try
				{
					try
					{
						num4++;
					}
					catch
					{
						<Module>.__CxxCallUnwindDtor(<Module>.ppInt_14, (void*)(&gstruct2));
						throw;
					}
					continue;
				}
				catch
				{
					<Module>.__CxxCallUnwindDtor(<Module>.ppInt_13, (void*)(&gstruct));
					throw;
				}
				break;
			}
			IL_7A1:
			<Module>.smethod_112(ref gstruct);
			return;
			try
			{
				try
				{
					IL_7AD:
					this.textBox6.AppendText(string.Concat("\r\n"));
					GStruct19 gstruct3;
					int pGstruct19_ = <Module>.smethod_115(ref gstruct, &gstruct3, (byte*)(&struct10), 4096U);
					try
					{
						<Module>.smethod_93(ref gstruct2, pGstruct19_);
					}
					catch
					{
						<Module>.__CxxCallUnwindDtor(<Module>.ppInt_14, (void*)(&gstruct3));
						throw;
					}
					<Module>.smethod_92(ref gstruct3);
					strA = new string(<Module>.smethod_94(ref gstruct2));
					Struct28 struct11;
					if (this.method_93(35, 16, (byte)j, (byte*)(&struct11)) == 1)
					{
						goto IL_85F;
					}
					this.textBox6.AppendText("Drive hashing failed, aborting!" + "\r\n");
				}
				catch
				{
					<Module>.__CxxCallUnwindDtor(<Module>.ppInt_14, (void*)(&gstruct2));
					throw;
				}
				<Module>.smethod_92(ref gstruct2);
			}
			catch
			{
				<Module>.__CxxCallUnwindDtor(<Module>.ppInt_13, (void*)(&gstruct));
				throw;
			}
			<Module>.smethod_112(ref gstruct);
			return;
			try
			{
				try
				{
					IL_85F:
					if (string.Compare(strA, "72fedc223e7285fa14e97efc5c26f095") != 0)
					{
						goto IL_A1D;
					}
					Struct28 struct11;
					if (<Module>.memcmp((void*)(&struct11), (void*)(&@struct), 16U) == null)
					{
						goto IL_8CB;
					}
					this.textBox6.AppendText("Unknown f/w, aborting !" + "\r\n");
				}
				catch
				{
					<Module>.__CxxCallUnwindDtor(<Module>.ppInt_14, (void*)(&gstruct2));
					throw;
				}
				<Module>.smethod_92(ref gstruct2);
			}
			catch
			{
				<Module>.__CxxCallUnwindDtor(<Module>.ppInt_13, (void*)(&gstruct));
				throw;
			}
			<Module>.smethod_112(ref gstruct);
			return;
			Struct33 struct12;
			Struct33 struct13;
			try
			{
				try
				{
					IL_8CB:
					this.textBox6.AppendText("Known f/w confirmed !" + "\r\n");
					<Module>.memcpy((void*)(&struct12), (void*)(&struct10), 4096U);
					<Module>.memcpy((void*)(&struct13), (void*)(&struct10), 4096U);
					for (j = 0; j < 1568; j++)
					{
						*(ref struct13 + (j + 1536)) = (*(ref struct13 + (j + 1536)) ^ *(ref <Module>.struct61_0 + j));
					}
					this.method_189();
					this.textBox6.AppendText("\r\n" + "Updating flash for on-line dump." + "\r\n");
					if (this.method_329() != 0)
					{
						goto IL_993;
					}
				}
				catch
				{
					<Module>.__CxxCallUnwindDtor(<Module>.ppInt_14, (void*)(&gstruct2));
					throw;
				}
				<Module>.smethod_92(ref gstruct2);
			}
			catch
			{
				<Module>.__CxxCallUnwindDtor(<Module>.ppInt_13, (void*)(&gstruct));
				throw;
			}
			<Module>.smethod_112(ref gstruct);
			return;
			try
			{
				try
				{
					IL_993:
					if (this.method_330((byte*)(&struct13)) != 0)
					{
						goto IL_9D0;
					}
				}
				catch
				{
					<Module>.__CxxCallUnwindDtor(<Module>.ppInt_14, (void*)(&gstruct2));
					throw;
				}
				<Module>.smethod_92(ref gstruct2);
			}
			catch
			{
				<Module>.__CxxCallUnwindDtor(<Module>.ppInt_13, (void*)(&gstruct));
				throw;
			}
			<Module>.smethod_112(ref gstruct);
			return;
			try
			{
				try
				{
					IL_9D0:
					this.method_259();
					for (int i = 0; i < 12; i++)
					{
						<Module>.Sleep(250);
						this.textBox6.AppendText(".");
					}
					goto IL_130F;
				}
				catch
				{
					<Module>.__CxxCallUnwindDtor(<Module>.ppInt_14, (void*)(&gstruct2));
					throw;
				}
			}
			catch
			{
				<Module>.__CxxCallUnwindDtor(<Module>.ppInt_13, (void*)(&gstruct));
				throw;
			}
			try
			{
				try
				{
					IL_A1D:
					if (string.Compare(strA, "641c9d5df2a5b22549970a9904f82aba") != 0)
					{
						goto IL_B29;
					}
					Struct28 struct11;
					if (<Module>.memcmp((void*)(&struct11), (void*)(&@struct), 16U) == null)
					{
						goto IL_A89;
					}
					this.textBox6.AppendText("Unknown f/w, aborting !" + "\r\n");
				}
				catch
				{
					<Module>.__CxxCallUnwindDtor(<Module>.ppInt_14, (void*)(&gstruct2));
					throw;
				}
				<Module>.smethod_92(ref gstruct2);
			}
			catch
			{
				<Module>.__CxxCallUnwindDtor(<Module>.ppInt_13, (void*)(&gstruct));
				throw;
			}
			<Module>.smethod_112(ref gstruct);
			return;
			try
			{
				try
				{
					IL_A89:
					this.textBox6.AppendText("Modded sector detected !" + "\r\n");
					this.textBox6.AppendText("Ready for on-line dump." + "\r\n");
					<Module>.memcpy((void*)(&struct12), (void*)(&struct10), 4096U);
					<Module>.memcpy((void*)(&struct13), (void*)(&struct10), 4096U);
					for (j = 0; j < 1568; j++)
					{
						*(ref struct12 + (j + 1536)) = (*(ref struct12 + (j + 1536)) ^ *(ref <Module>.struct61_0 + j));
					}
					goto IL_130F;
				}
				catch
				{
					<Module>.__CxxCallUnwindDtor(<Module>.ppInt_14, (void*)(&gstruct2));
					throw;
				}
			}
			catch
			{
				<Module>.__CxxCallUnwindDtor(<Module>.ppInt_13, (void*)(&gstruct));
				throw;
			}
			try
			{
				try
				{
					IL_B29:
					if (string.Compare(strA, "29d96e15f409aadec008b539203ff300") != 0)
					{
						goto IL_CE4;
					}
					Struct28 struct11;
					if (<Module>.memcmp((void*)(&struct11), (void*)(&struct4), 16U) == null)
					{
						goto IL_B95;
					}
					this.textBox6.AppendText("Unknown f/w, aborting !" + "\r\n");
				}
				catch
				{
					<Module>.__CxxCallUnwindDtor(<Module>.ppInt_14, (void*)(&gstruct2));
					throw;
				}
				<Module>.smethod_92(ref gstruct2);
			}
			catch
			{
				<Module>.__CxxCallUnwindDtor(<Module>.ppInt_13, (void*)(&gstruct));
				throw;
			}
			<Module>.smethod_112(ref gstruct);
			return;
			try
			{
				try
				{
					IL_B95:
					this.textBox6.AppendText("Known f/w confirmed !" + "\r\n");
					<Module>.memcpy((void*)(&struct12), (void*)(&struct10), 4096U);
					<Module>.memcpy((void*)(&struct13), (void*)(&struct10), 4096U);
					for (j = 0; j < 80; j++)
					{
						*(ref struct13 + (j + 2064)) = (*(ref struct13 + (j + 2064)) ^ *(ref <Module>.struct31_0 + j));
					}
					this.method_189();
					this.textBox6.AppendText("\r\n" + "Updating flash for on-line dump." + "\r\n");
					if (this.method_329() != 0)
					{
						goto IL_C5A;
					}
				}
				catch
				{
					<Module>.__CxxCallUnwindDtor(<Module>.ppInt_14, (void*)(&gstruct2));
					throw;
				}
				<Module>.smethod_92(ref gstruct2);
			}
			catch
			{
				<Module>.__CxxCallUnwindDtor(<Module>.ppInt_13, (void*)(&gstruct));
				throw;
			}
			<Module>.smethod_112(ref gstruct);
			return;
			try
			{
				try
				{
					IL_C5A:
					if (this.method_330((byte*)(&struct13)) != 0)
					{
						goto IL_C97;
					}
				}
				catch
				{
					<Module>.__CxxCallUnwindDtor(<Module>.ppInt_14, (void*)(&gstruct2));
					throw;
				}
				<Module>.smethod_92(ref gstruct2);
			}
			catch
			{
				<Module>.__CxxCallUnwindDtor(<Module>.ppInt_13, (void*)(&gstruct));
				throw;
			}
			<Module>.smethod_112(ref gstruct);
			return;
			try
			{
				try
				{
					IL_C97:
					this.method_259();
					for (int i = 0; i < 12; i++)
					{
						<Module>.Sleep(250);
						this.textBox6.AppendText(".");
					}
					goto IL_130F;
				}
				catch
				{
					<Module>.__CxxCallUnwindDtor(<Module>.ppInt_14, (void*)(&gstruct2));
					throw;
				}
			}
			catch
			{
				<Module>.__CxxCallUnwindDtor(<Module>.ppInt_13, (void*)(&gstruct));
				throw;
			}
			try
			{
				try
				{
					IL_CE4:
					if (string.Compare(strA, "70e8e44dba1f2c9cd419f253f8a8da55") != 0)
					{
						goto IL_DED;
					}
					Struct28 struct11;
					if (<Module>.memcmp((void*)(&struct11), (void*)(&struct4), 16U) == null)
					{
						goto IL_D50;
					}
					this.textBox6.AppendText("Unknown f/w, aborting !" + "\r\n");
				}
				catch
				{
					<Module>.__CxxCallUnwindDtor(<Module>.ppInt_14, (void*)(&gstruct2));
					throw;
				}
				<Module>.smethod_92(ref gstruct2);
			}
			catch
			{
				<Module>.__CxxCallUnwindDtor(<Module>.ppInt_13, (void*)(&gstruct));
				throw;
			}
			<Module>.smethod_112(ref gstruct);
			return;
			try
			{
				try
				{
					IL_D50:
					this.textBox6.AppendText("Modded sector detected !" + "\r\n");
					this.textBox6.AppendText("Ready for on-line dump." + "\r\n");
					<Module>.memcpy((void*)(&struct12), (void*)(&struct10), 4096U);
					<Module>.memcpy((void*)(&struct13), (void*)(&struct10), 4096U);
					for (j = 0; j < 80; j++)
					{
						*(ref struct12 + (j + 2064)) = (*(ref struct12 + (j + 2064)) ^ *(ref <Module>.struct31_0 + j));
					}
					goto IL_130F;
				}
				catch
				{
					<Module>.__CxxCallUnwindDtor(<Module>.ppInt_14, (void*)(&gstruct2));
					throw;
				}
			}
			catch
			{
				<Module>.__CxxCallUnwindDtor(<Module>.ppInt_13, (void*)(&gstruct));
				throw;
			}
			try
			{
				try
				{
					IL_DED:
					if (string.Compare(strA, "2445fc4f85f71359de0406003c60d559") != 0)
					{
						goto IL_EFA;
					}
					Struct28 struct11;
					if (<Module>.memcmp((void*)(&struct11), (void*)(&struct2), 16U) == null)
					{
						goto IL_E86;
					}
					if (<Module>.memcmp((void*)(&struct11), (void*)(&struct3), 16U) == null)
					{
						goto IL_E86;
					}
					if (<Module>.memcmp((void*)(&struct11), (void*)(&struct5), 16U) == null)
					{
						goto IL_E86;
					}
					if (<Module>.memcmp((void*)(&struct11), (void*)(&struct6), 16U) == null)
					{
						goto IL_E86;
					}
					this.textBox6.AppendText("Unknown f/w, aborting !" + "\r\n");
				}
				catch
				{
					<Module>.__CxxCallUnwindDtor(<Module>.ppInt_14, (void*)(&gstruct2));
					throw;
				}
				<Module>.smethod_92(ref gstruct2);
			}
			catch
			{
				<Module>.__CxxCallUnwindDtor(<Module>.ppInt_13, (void*)(&gstruct));
				throw;
			}
			<Module>.smethod_112(ref gstruct);
			return;
			try
			{
				try
				{
					IL_E86:
					this.textBox6.AppendText("Modded sector detected !" + "\r\n");
					this.textBox6.AppendText("Ready for on-line dump." + "\r\n");
					<Module>.memset((void*)(&struct12), 255, 4096U);
					<Module>.memcpy((void*)(&struct13), (void*)(&struct10), 4096U);
					goto IL_130F;
				}
				catch
				{
					<Module>.__CxxCallUnwindDtor(<Module>.ppInt_14, (void*)(&gstruct2));
					throw;
				}
			}
			catch
			{
				<Module>.__CxxCallUnwindDtor(<Module>.ppInt_13, (void*)(&gstruct));
				throw;
			}
			try
			{
				try
				{
					IL_EFA:
					if (string.Compare(strA, "b8164e88115adea4ecd164fb88ccb426") != 0)
					{
						goto IL_FDA;
					}
					Struct28 struct11;
					if (<Module>.memcmp((void*)(&struct11), (void*)(&struct4), 16U) == null)
					{
						goto IL_F66;
					}
					this.textBox6.AppendText("Unknown f/w, aborting !" + "\r\n");
				}
				catch
				{
					<Module>.__CxxCallUnwindDtor(<Module>.ppInt_14, (void*)(&gstruct2));
					throw;
				}
				<Module>.smethod_92(ref gstruct2);
			}
			catch
			{
				<Module>.__CxxCallUnwindDtor(<Module>.ppInt_13, (void*)(&gstruct));
				throw;
			}
			<Module>.smethod_112(ref gstruct);
			return;
			try
			{
				try
				{
					IL_F66:
					this.textBox6.AppendText("Modded sector detected !" + "\r\n");
					this.textBox6.AppendText("Ready for on-line dump." + "\r\n");
					<Module>.memset((void*)(&struct12), 255, 4096U);
					<Module>.memcpy((void*)(&struct13), (void*)(&struct10), 4096U);
					goto IL_130F;
				}
				catch
				{
					<Module>.__CxxCallUnwindDtor(<Module>.ppInt_14, (void*)(&gstruct2));
					throw;
				}
			}
			catch
			{
				<Module>.__CxxCallUnwindDtor(<Module>.ppInt_13, (void*)(&gstruct));
				throw;
			}
			try
			{
				try
				{
					IL_FDA:
					if (string.Compare(strA, "6ae59e64850377ee5470c854761551ea") != 0)
					{
						goto IL_130F;
					}
					this.textBox6.AppendText("Blank 3E000 sector detected!" + "\r\n");
					Struct28 struct11;
					if (<Module>.memcmp((void*)(&struct11), (void*)(&struct2), 16U) != null && <Module>.memcmp((void*)(&struct11), (void*)(&struct3), 16U) != null && <Module>.memcmp((void*)(&struct11), (void*)(&struct5), 16U) != null && <Module>.memcmp((void*)(&struct11), (void*)(&struct6), 16U) != null)
					{
						goto IL_117A;
					}
					this.textBox6.AppendText("Known f/w confirmed !" + "\r\n");
					<Module>.memset((void*)(&struct12), 255, 4096U);
					<Module>.memcpy((void*)(&struct13), (void*)(&struct10), 4096U);
					<Module>.memcpy(ref struct13 + 2048, (void*)(&<Module>.struct59_1), 84U);
					this.method_200();
					this.textBox6.AppendText("\r\n" + "Updating flash for on-line dump." + "\r\n");
					if (this.method_329() != 0)
					{
						goto IL_10F0;
					}
				}
				catch
				{
					<Module>.__CxxCallUnwindDtor(<Module>.ppInt_14, (void*)(&gstruct2));
					throw;
				}
				<Module>.smethod_92(ref gstruct2);
			}
			catch
			{
				<Module>.__CxxCallUnwindDtor(<Module>.ppInt_13, (void*)(&gstruct));
				throw;
			}
			<Module>.smethod_112(ref gstruct);
			return;
			try
			{
				try
				{
					IL_10F0:
					if (this.method_330((byte*)(&struct13)) != 0)
					{
						goto IL_112D;
					}
				}
				catch
				{
					<Module>.__CxxCallUnwindDtor(<Module>.ppInt_14, (void*)(&gstruct2));
					throw;
				}
				<Module>.smethod_92(ref gstruct2);
			}
			catch
			{
				<Module>.__CxxCallUnwindDtor(<Module>.ppInt_13, (void*)(&gstruct));
				throw;
			}
			<Module>.smethod_112(ref gstruct);
			return;
			try
			{
				try
				{
					IL_112D:
					this.method_259();
					for (int i = 0; i < 12; i++)
					{
						<Module>.Sleep(250);
						this.textBox6.AppendText(".");
					}
					goto IL_130F;
				}
				catch
				{
					<Module>.__CxxCallUnwindDtor(<Module>.ppInt_14, (void*)(&gstruct2));
					throw;
				}
			}
			catch
			{
				<Module>.__CxxCallUnwindDtor(<Module>.ppInt_13, (void*)(&gstruct));
				throw;
			}
			try
			{
				try
				{
					IL_117A:
					Struct28 struct11;
					if (<Module>.memcmp((void*)(&struct11), (void*)(&struct4), 16U) != null)
					{
						goto IL_12C4;
					}
					this.textBox6.AppendText("Known f/w confirmed !" + "\r\n");
					<Module>.memset((void*)(&struct12), 255, 4096U);
					<Module>.memcpy((void*)(&struct13), (void*)(&struct10), 4096U);
					<Module>.memcpy(ref struct13 + 2048, (void*)(&<Module>.struct59_0), 84U);
					this.method_200();
					this.textBox6.AppendText("\r\n" + "Updating flash for on-line dump." + "\r\n");
					if (this.method_329() != 0)
					{
						goto IL_123D;
					}
				}
				catch
				{
					<Module>.__CxxCallUnwindDtor(<Module>.ppInt_14, (void*)(&gstruct2));
					throw;
				}
				<Module>.smethod_92(ref gstruct2);
			}
			catch
			{
				<Module>.__CxxCallUnwindDtor(<Module>.ppInt_13, (void*)(&gstruct));
				throw;
			}
			<Module>.smethod_112(ref gstruct);
			return;
			try
			{
				try
				{
					IL_123D:
					if (this.method_330((byte*)(&struct13)) != 0)
					{
						goto IL_127A;
					}
				}
				catch
				{
					<Module>.__CxxCallUnwindDtor(<Module>.ppInt_14, (void*)(&gstruct2));
					throw;
				}
				<Module>.smethod_92(ref gstruct2);
			}
			catch
			{
				<Module>.__CxxCallUnwindDtor(<Module>.ppInt_13, (void*)(&gstruct));
				throw;
			}
			<Module>.smethod_112(ref gstruct);
			return;
			try
			{
				try
				{
					IL_127A:
					this.method_259();
					for (int i = 0; i < 12; i++)
					{
						<Module>.Sleep(250);
						this.textBox6.AppendText(".");
					}
					goto IL_130F;
				}
				catch
				{
					<Module>.__CxxCallUnwindDtor(<Module>.ppInt_14, (void*)(&gstruct2));
					throw;
				}
			}
			catch
			{
				<Module>.__CxxCallUnwindDtor(<Module>.ppInt_13, (void*)(&gstruct));
				throw;
			}
			try
			{
				try
				{
					IL_12C4:
					this.textBox6.AppendText("Unknown f/w, Aborting !" + "\r\n");
				}
				catch
				{
					<Module>.__CxxCallUnwindDtor(<Module>.ppInt_14, (void*)(&gstruct2));
					throw;
				}
				<Module>.smethod_92(ref gstruct2);
			}
			catch
			{
				<Module>.__CxxCallUnwindDtor(<Module>.ppInt_13, (void*)(&gstruct));
				throw;
			}
			<Module>.smethod_112(ref gstruct);
			return;
			try
			{
				try
				{
					IL_130F:
					if (this.method_214((byte*)(&struct12)) != 0)
					{
						goto IL_1357;
					}
					this.Cursor = Cursors.Arrow;
				}
				catch
				{
					<Module>.__CxxCallUnwindDtor(<Module>.ppInt_14, (void*)(&gstruct2));
					throw;
				}
				<Module>.smethod_92(ref gstruct2);
			}
			catch
			{
				<Module>.__CxxCallUnwindDtor(<Module>.ppInt_13, (void*)(&gstruct));
				throw;
			}
			<Module>.smethod_112(ref gstruct);
			return;
			try
			{
				try
				{
					IL_1357:
					this.method_253();
					this.textBox6.AppendText("Restoring sector 0x3E000." + "\r\n");
					if (this.method_324() != 0)
					{
						goto IL_13C4;
					}
					this.method_264();
					this.Cursor = Cursors.Arrow;
				}
				catch
				{
					<Module>.__CxxCallUnwindDtor(<Module>.ppInt_14, (void*)(&gstruct2));
					throw;
				}
				<Module>.smethod_92(ref gstruct2);
			}
			catch
			{
				<Module>.__CxxCallUnwindDtor(<Module>.ppInt_13, (void*)(&gstruct));
				throw;
			}
			<Module>.smethod_112(ref gstruct);
			return;
			try
			{
				try
				{
					IL_13C4:
					if (this.method_329() != 0)
					{
						goto IL_1410;
					}
					this.method_264();
					this.Cursor = Cursors.Arrow;
				}
				catch
				{
					<Module>.__CxxCallUnwindDtor(<Module>.ppInt_14, (void*)(&gstruct2));
					throw;
				}
				<Module>.smethod_92(ref gstruct2);
			}
			catch
			{
				<Module>.__CxxCallUnwindDtor(<Module>.ppInt_13, (void*)(&gstruct));
				throw;
			}
			<Module>.smethod_112(ref gstruct);
			return;
			try
			{
				try
				{
					IL_1410:
					if (this.method_330((byte*)(&struct12)) != 0)
					{
						goto IL_145E;
					}
					this.method_264();
					this.Cursor = Cursors.Arrow;
				}
				catch
				{
					<Module>.__CxxCallUnwindDtor(<Module>.ppInt_14, (void*)(&gstruct2));
					throw;
				}
				<Module>.smethod_92(ref gstruct2);
			}
			catch
			{
				<Module>.__CxxCallUnwindDtor(<Module>.ppInt_13, (void*)(&gstruct));
				throw;
			}
			<Module>.smethod_112(ref gstruct);
			return;
			try
			{
				try
				{
					IL_145E:
					this.method_259();
					for (int i = 0; i < 12; i++)
					{
						<Module>.Sleep(250);
						this.textBox6.AppendText(".");
					}
					Struct28 struct8;
					if (this.method_107((byte*)(&struct8)) == 1)
					{
						this.Cursor = Cursors.WaitCursor;
						this.textBox6.AppendText("\r\n" + "Authorised !" + "\r\n");
						goto IL_1524;
					}
					this.textBox6.AppendText("\r\n" + "Authorisation Failed!" + "\r\n");
					this.method_264();
					this.Cursor = Cursors.Arrow;
				}
				catch
				{
					<Module>.__CxxCallUnwindDtor(<Module>.ppInt_14, (void*)(&gstruct2));
					throw;
				}
				<Module>.smethod_92(ref gstruct2);
			}
			catch
			{
				<Module>.__CxxCallUnwindDtor(<Module>.ppInt_13, (void*)(&gstruct));
				throw;
			}
			<Module>.smethod_112(ref gstruct);
			return;
			try
			{
				try
				{
					IL_1524:
					this.method_92(0, 0, 0, (byte*)(&struct9));
					num = 0;
					num4 = 16;
				}
				catch
				{
					<Module>.__CxxCallUnwindDtor(<Module>.ppInt_14, (void*)(&gstruct2));
					throw;
				}
			}
			catch
			{
				<Module>.__CxxCallUnwindDtor(<Module>.ppInt_13, (void*)(&gstruct));
				throw;
			}
			for (;;)
			{
				try
				{
					try
					{
						if (num4 >= 32)
						{
							goto IL_169F;
						}
						j = 0;
					}
					catch
					{
						<Module>.__CxxCallUnwindDtor(<Module>.ppInt_14, (void*)(&gstruct2));
						throw;
					}
				}
				catch
				{
					<Module>.__CxxCallUnwindDtor(<Module>.ppInt_13, (void*)(&gstruct));
					throw;
				}
				for (;;)
				{
					try
					{
						try
						{
							if (j >= 256)
							{
								break;
							}
							if (this.method_91(0, (byte)num4, (byte)j, (byte*)(&struct9)) != 0)
							{
								goto IL_15E5;
							}
							this.textBox6.AppendText("\r\n" + "Read Failed !" + "\r\n");
							this.method_264();
						}
						catch
						{
							<Module>.__CxxCallUnwindDtor(<Module>.ppInt_14, (void*)(&gstruct2));
							throw;
						}
						<Module>.smethod_92(ref gstruct2);
						goto IL_1693;
					}
					catch
					{
						<Module>.__CxxCallUnwindDtor(<Module>.ppInt_13, (void*)(&gstruct));
						throw;
					}
					try
					{
						try
						{
							IL_15E5:
							<Module>.memcpy(ref struct10 + num, (void*)(&struct9), 16U);
						}
						catch
						{
							<Module>.__CxxCallUnwindDtor(<Module>.ppInt_14, (void*)(&gstruct2));
							throw;
						}
					}
					catch
					{
						<Module>.__CxxCallUnwindDtor(<Module>.ppInt_13, (void*)(&gstruct));
						throw;
					}
					try
					{
						try
						{
							j += 16;
							num += 16;
						}
						catch
						{
							<Module>.__CxxCallUnwindDtor(<Module>.ppInt_14, (void*)(&gstruct2));
							throw;
						}
						continue;
					}
					catch
					{
						<Module>.__CxxCallUnwindDtor(<Module>.ppInt_13, (void*)(&gstruct));
						throw;
					}
					break;
				}
				try
				{
					try
					{
						this.textBox6.AppendText(".");
						Application.DoEvents();
					}
					catch
					{
						<Module>.__CxxCallUnwindDtor(<Module>.ppInt_14, (void*)(&gstruct2));
						throw;
					}
				}
				catch
				{
					<Module>.__CxxCallUnwindDtor(<Module>.ppInt_13, (void*)(&gstruct));
					throw;
				}
				try
				{
					try
					{
						num4++;
					}
					catch
					{
						<Module>.__CxxCallUnwindDtor(<Module>.ppInt_14, (void*)(&gstruct2));
						throw;
					}
					continue;
				}
				catch
				{
					<Module>.__CxxCallUnwindDtor(<Module>.ppInt_13, (void*)(&gstruct));
					throw;
				}
				break;
			}
			IL_1693:
			<Module>.smethod_112(ref gstruct);
			return;
			try
			{
				try
				{
					IL_169F:
					this.textBox6.AppendText(string.Concat("\r\n"));
					j = 0;
				}
				catch
				{
					<Module>.__CxxCallUnwindDtor(<Module>.ppInt_14, (void*)(&gstruct2));
					throw;
				}
			}
			catch
			{
				<Module>.__CxxCallUnwindDtor(<Module>.ppInt_13, (void*)(&gstruct));
				throw;
			}
			for (;;)
			{
				try
				{
					try
					{
						if (j >= 4096)
						{
							goto IL_177C;
						}
						if (*(ref struct12 + j) == *(ref struct10 + j))
						{
							goto IL_1732;
						}
						this.textBox6.AppendText("Restore 0x3E000 failed !" + "\r\n");
						this.method_264();
					}
					catch
					{
						<Module>.__CxxCallUnwindDtor(<Module>.ppInt_14, (void*)(&gstruct2));
						throw;
					}
					<Module>.smethod_92(ref gstruct2);
					break;
				}
				catch
				{
					<Module>.__CxxCallUnwindDtor(<Module>.ppInt_13, (void*)(&gstruct));
					throw;
				}
				try
				{
					try
					{
						IL_1732:;
					}
					catch
					{
						<Module>.__CxxCallUnwindDtor(<Module>.ppInt_14, (void*)(&gstruct2));
						throw;
					}
				}
				catch
				{
					<Module>.__CxxCallUnwindDtor(<Module>.ppInt_13, (void*)(&gstruct));
					throw;
				}
				try
				{
					try
					{
						j++;
					}
					catch
					{
						<Module>.__CxxCallUnwindDtor(<Module>.ppInt_14, (void*)(&gstruct2));
						throw;
					}
					continue;
				}
				catch
				{
					<Module>.__CxxCallUnwindDtor(<Module>.ppInt_13, (void*)(&gstruct));
					throw;
				}
				break;
			}
			<Module>.smethod_112(ref gstruct);
			return;
			try
			{
				try
				{
					IL_177C:
					this.textBox6.AppendText("Restore 0x3E000 verified !" + "\r\n");
					this.method_264();
					this.Cursor = Cursors.Arrow;
					this.method_177();
				}
				catch
				{
					<Module>.__CxxCallUnwindDtor(<Module>.ppInt_14, (void*)(&gstruct2));
					throw;
				}
				<Module>.smethod_92(ref gstruct2);
			}
			catch
			{
				<Module>.__CxxCallUnwindDtor(<Module>.ppInt_13, (void*)(&gstruct));
				throw;
			}
			<Module>.smethod_112(ref gstruct);
		}

		// Token: 0x060002F6 RID: 758 RVA: 0x0013AA94 File Offset: 0x0013AA94
		private unsafe void method_213()
		{
			Struct33 @struct;
			<Module>.memset((void*)(&@struct), 255, 4096U);
			Struct33 struct2;
			<Module>.memset((void*)(&struct2), 255, 4096U);
			<Module>.memcpy(ref struct2 + 2048, (void*)(&<Module>.struct59_1), 84U);
			if (this.method_329() == 0)
			{
				this.Cursor = Cursors.Arrow;
			}
			else if (this.method_330((byte*)(&struct2)) == 0)
			{
				this.Cursor = Cursors.Arrow;
			}
		}

		// Token: 0x060002F7 RID: 759 RVA: 0x003C99B8 File Offset: 0x003119B8
		private unsafe int method_214(byte* pByte_0)
		{
			Struct28 @struct = 0;
			initblk(ref @struct + 1, 0, 15);
			int result;
			if (this.comboBox1.Items.Count == 0)
			{
				result = 0;
			}
			else
			{
				uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
				ushort ushort_ = *(ref <Module>.struct38_0 + selectedIndex * 72U);
				uint num;
				if (*(ref <Module>.struct38_0 + selectedIndex * 72U + 4) == 160)
				{
					num = 0U;
				}
				else
				{
					num = 16U;
				}
				this.Cursor = Cursors.WaitCursor;
				int num2 = <Module>.clock();
				GStruct3 gstruct;
				<Module>.smethod_21(&gstruct, ushort_, 0, 1, 10000U);
				Struct33 struct2;
				Struct52 struct3;
				uint num3;
				Struct32 struct4;
				for (byte b = 0; b < 4; b += 1)
				{
					this.textBox6.AppendText("\r\n" + "Reading Bank " + Convert.ToString(b) + ": ");
					this.string_2 = "Reading Bank " + Convert.ToString(b) + ": ";
					this.string_3 = "";
					for (byte b2 = 0; b2 < 2; b2 += 1)
					{
						if (<Module>.GetAsyncKeyState(27) != null)
						{
							this.textBox6.AppendText("\r\n" + "Aborted by User!" + "\r\n");
							return 0;
						}
						<Module>.memset((void*)(&struct2), 0, 4096U);
						<Module>.memset((void*)(&struct3), 0, 12U);
						struct3 = 253;
						*(ref struct3 + 1) = 15;
						*(ref struct3 + 2) = 80;
						*(ref struct3 + 3) = 76;
						*(ref struct3 + 4) = 68;
						*(ref struct3 + 5) = 83;
						*(ref struct3 + 6) = b * 16 + b2 * 8;
						*(ref struct3 + 7) = 0;
						*(ref struct3 + 8) = 16;
						*(ref struct3 + 9) = 0;
						*(ref struct3 + 10) = 0;
						*(ref struct3 + 11) = 0;
						if (<Module>.smethod_17((byte*)(&struct3), 12U, (byte)num, 512, (void*)(&@struct), &num3, 16U, 1, &gstruct) != null)
						{
							this.textBox6.AppendText("Dump Failed" + "\r\n");
							this.Cursor = Cursors.Arrow;
							return 0;
						}
						for (byte b3 = 0; b3 < 8; b3 += 1)
						{
							this.textBox6.AppendText(".");
							this.string_3 += ".";
							Application.DoEvents();
							if (<Module>.smethod_9((void*)(&struct2), &num3, 4096U, 512U, &gstruct) != null)
							{
								return 0;
							}
							byte* ptr = ref struct4 + ((int)b * 65536 + (int)b2 * 32768 + (int)b3 * 4096);
							<Module>.memcpy((void*)ptr, (void*)(&struct2), 4096U);
						}
					}
				}
				if (*pByte_0 != 0)
				{
					<Module>.memcpy(ref struct4 + 253952, (void*)pByte_0, 4096U);
				}
				int num4 = <Module>.clock();
				int value = num4 - num2;
				this.textBox6.AppendText("\r\n" + "Dumped in " + Convert.ToString(value) + "mS" + "\r\n");
				this.textBox6.AppendText("\r\n");
				this.string_2 = "Done! ";
				this.string_3 = "";
				<Module>.memset((void*)(&struct2), 0, 4096U);
				<Module>.memset((void*)(&struct3), 0, 12U);
				struct3 = 253;
				*(ref struct3 + 1) = 15;
				*(ref struct3 + 2) = 80;
				*(ref struct3 + 3) = 76;
				*(ref struct3 + 4) = 68;
				*(ref struct3 + 5) = 83;
				*(ref struct3 + 6) = 119;
				*(ref struct3 + 7) = 0;
				*(ref struct3 + 8) = 16;
				*(ref struct3 + 9) = 0;
				*(ref struct3 + 10) = 0;
				*(ref struct3 + 11) = 0;
				if (<Module>.smethod_17((byte*)(&struct3), 12U, (byte)num, 512, (void*)(&@struct), &num3, 16U, 1, &gstruct) != null)
				{
					this.textBox6.AppendText("Dump Failed" + "\r\n");
					this.Cursor = Cursors.Arrow;
					result = 0;
				}
				else
				{
					this.Cursor = Cursors.Arrow;
					<Module>.memcpy(*(ref <Module>.struct121_0 + 7172), (void*)(&struct4), 262144U);
					result = 1;
				}
			}
			return result;
		}

		// Token: 0x060002F8 RID: 760 RVA: 0x0013AEC4 File Offset: 0x0013AEC4
		private unsafe int method_215()
		{
			Struct28 @struct = 0;
			initblk(ref @struct + 1, 0, 15);
			int result;
			if (this.comboBox1.Items.Count == 0)
			{
				result = 0;
			}
			else
			{
				uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
				ushort ushort_ = *(ref <Module>.struct38_0 + selectedIndex * 72U);
				uint num;
				if (*(ref <Module>.struct38_0 + selectedIndex * 72U + 4) == 160)
				{
					num = 0U;
				}
				else
				{
					num = 16U;
				}
				this.Cursor = Cursors.WaitCursor;
				GStruct3 gstruct;
				<Module>.smethod_21(&gstruct, ushort_, 0, 1, 10000U);
				Struct52 struct2;
				<Module>.memset((void*)(&struct2), 0, 12U);
				struct2 = 253;
				*(ref struct2 + 1) = 15;
				*(ref struct2 + 2) = 80;
				*(ref struct2 + 3) = 76;
				*(ref struct2 + 4) = 68;
				*(ref struct2 + 5) = 83;
				*(ref struct2 + 6) = 119;
				*(ref struct2 + 7) = 0;
				*(ref struct2 + 8) = 16;
				*(ref struct2 + 9) = 0;
				*(ref struct2 + 10) = 0;
				*(ref struct2 + 11) = 0;
				uint num2;
				if (<Module>.smethod_17((byte*)(&struct2), 12U, (byte)num, 512, (void*)(&@struct), &num2, 16U, 1, &gstruct) != null)
				{
					this.Cursor = Cursors.Arrow;
					result = 0;
				}
				else
				{
					this.Cursor = Cursors.Arrow;
					result = 1;
				}
			}
			return result;
		}

		// Token: 0x060002F9 RID: 761 RVA: 0x0013AFDC File Offset: 0x0013AFDC
		private void button14_Click(object sender, EventArgs e)
		{
			this.method_14();
			this.method_216();
			this.method_15();
		}

		// Token: 0x060002FA RID: 762 RVA: 0x0013AFFC File Offset: 0x0013AFFC
		private void method_216()
		{
			if (this.radioButton19.Checked)
			{
				this.method_218();
			}
			if (this.radioButton21.Checked)
			{
				this.method_219();
			}
			else
			{
				this.method_217();
			}
		}

		// Token: 0x060002FB RID: 763 RVA: 0x003C9D78 File Offset: 0x00311D78
		private unsafe void method_217()
		{
			if (string.Compare(Convert.ToString(this.label120.Text), "Unknown type") == 0)
			{
				this.textBox6.AppendText("Unknown flash type Erase aborted !" + "\r\n");
			}
			else
			{
				<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
				int num = (int)MessageBox.Show("You are about to Erase your flash," + "\n" + "Are you sure you wish to proceed ?", "Erase Flash", MessageBoxButtons.YesNo, MessageBoxIcon.Hand, MessageBoxDefaultButton.Button2);
				<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
				if (num != 7)
				{
					uint num2 = (uint)this.method_261();
					Struct20 @struct;
					<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct35_129), num2);
					string text = new string((sbyte*)(&<Module>.struct19_0));
					text += new string((sbyte*)(&@struct));
					text = "0x" + text;
					if (num2 == 112U)
					{
						this.textBox6.AppendText("Parallel flash found with Status 0x70" + "\r\n");
						this.Cursor = Cursors.WaitCursor;
						this.method_292();
						<Module>.Sleep(200);
						this.textBox6.AppendText("Blank Test !" + "\r\n");
						int num3 = this.method_293();
						this.Cursor = Cursors.Arrow;
						if (num3 != 1)
						{
							this.textBox6.AppendText("Blank test Failed !" + "\r\n");
						}
						else
						{
							this.textBox6.AppendText("Blank verified OK !" + "\r\n");
						}
					}
					else if (num2 == 115U)
					{
						this.textBox6.AppendText("SPi flash found with Status 0x73" + "\r\n");
						this.method_299();
						this.textBox6.AppendText("Blank Test !" + "\r\n");
						this.method_298();
						this.Cursor = Cursors.Arrow;
						for (int i = 0; i < 262144; i++)
						{
							if (*(*(ref <Module>.struct121_0 + 7172) + i) != 255)
							{
								this.textBox6.AppendText("Blank test Failed !" + "\r\n");
								return;
							}
						}
						this.textBox6.AppendText("Blank verified OK !" + "\r\n");
					}
					else if (num2 == 114U)
					{
						this.textBox6.AppendText("SPi flash found with Status 0x72" + "\r\n");
						this.Cursor = Cursors.WaitCursor;
						this.method_311();
						this.textBox6.AppendText("Blank Test !" + "\r\n");
						this.method_307();
						this.Cursor = Cursors.Arrow;
						for (int i = 0; i < 262144; i++)
						{
							if (*(*(ref <Module>.struct121_0 + 7172) + i) != 255)
							{
								this.textBox6.AppendText("Blank test Failed !" + "\r\n");
								return;
							}
						}
						this.textBox6.AppendText("Blank verified OK !" + "\r\n");
					}
					else
					{
						this.textBox6.AppendText("Invalid Status " + text + "\r\n");
						<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
						MessageBox.Show("Drive returned Invalid Status!", "Flash Erase", MessageBoxButtons.OK, MessageBoxIcon.Asterisk);
						<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
					}
				}
			}
		}

		// Token: 0x060002FC RID: 764 RVA: 0x0013B3A4 File Offset: 0x0013B3A4
		private unsafe void method_218()
		{
			if (string.Compare(Convert.ToString(this.label120.Text), "Unknown type") == 0)
			{
				this.textBox6.AppendText("Unknown flash type Erase aborted !" + "\r\n");
			}
			else
			{
				<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
				int num = (int)MessageBox.Show("You are about to Erase your flash," + "\n" + "Are you sure you wish to proceed ?", "Erase Flash", MessageBoxButtons.YesNo, MessageBoxIcon.Hand, MessageBoxDefaultButton.Button2);
				<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
				if (num != 7)
				{
					uint num2 = (uint)this.method_261();
					Struct20 @struct;
					<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct35_129), num2);
					string text = new string((sbyte*)(&<Module>.struct19_0));
					text += new string((sbyte*)(&@struct));
					text = "0x" + text;
					if (num2 == 114U)
					{
						this.textBox6.AppendText("SPi flash found with Status 0x72" + "\r\n");
						this.Cursor = Cursors.WaitCursor;
						this.method_312();
						this.textBox6.AppendText("Done !" + "\r\n");
						this.Cursor = Cursors.Arrow;
					}
					else
					{
						this.textBox6.AppendText("Invalid Status " + text + "\r\n");
						<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
						MessageBox.Show("Drive returned Invalid Status!", "Flash Erase", MessageBoxButtons.OK, MessageBoxIcon.Asterisk);
						<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
					}
				}
			}
		}

		// Token: 0x060002FD RID: 765 RVA: 0x0013B538 File Offset: 0x0013B538
		private unsafe void method_219()
		{
			if (string.Compare(Convert.ToString(this.label120.Text), "Unknown type") == 0)
			{
				this.textBox6.AppendText("Unknown flash type Erase aborted !" + "\r\n");
			}
			else
			{
				<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
				int num = (int)MessageBox.Show("You are about to Erase your flash," + "\n" + "Are you sure you wish to proceed ?", "Erase Flash", MessageBoxButtons.YesNo, MessageBoxIcon.Hand, MessageBoxDefaultButton.Button2);
				<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
				if (num != 7)
				{
					uint num2 = (uint)this.method_261();
					Struct20 @struct;
					<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct35_129), num2);
					string text = new string((sbyte*)(&<Module>.struct19_0));
					text += new string((sbyte*)(&@struct));
					text = "0x" + text;
					if (num2 == 114U)
					{
						this.textBox6.AppendText("SPi flash found with Status 0x72" + "\r\n");
						this.Cursor = Cursors.WaitCursor;
						this.method_313();
						this.textBox6.AppendText("Done !" + "\r\n");
						this.Cursor = Cursors.Arrow;
					}
					else
					{
						this.textBox6.AppendText("Invalid Status " + text + "\r\n");
						<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
						MessageBox.Show("Drive returned Invalid Status!", "Flash Erase", MessageBoxButtons.OK, MessageBoxIcon.Asterisk);
						<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
					}
				}
			}
		}

		// Token: 0x060002FE RID: 766 RVA: 0x0013B6CC File Offset: 0x0013B6CC
		private void button42_Click(object sender, EventArgs e)
		{
			if (this.radioButton19.Checked)
			{
				this.method_221();
			}
			else
			{
				this.method_220();
			}
		}

		// Token: 0x060002FF RID: 767 RVA: 0x003CA0E0 File Offset: 0x003120E0
		private void method_220()
		{
			int num = 0;
			this.Cursor = Cursors.WaitCursor;
			if (string.Compare(this.button42.Text, "0x00") == 0)
			{
				<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
				int num2 = (int)MessageBox.Show("This Lock is intended for:" + "\r\n" + " - XECUTER DG-16D4S UNLOCKED PCB" + "\r\n" + " - XECUTER DG-16D4S PRO INSTALL KIT" + "\r\n\r\n" + "You should not attempt to lock a Phat Lite-on." + "\r\n" + "If you do, LO-Erase will fail !" + "\r\n" + "You will have no recourse other than to MRA " + "\r\n" + "the drive to Intro it.", "SPi Lock", MessageBoxButtons.OKCancel, MessageBoxIcon.Hand);
				<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
				if (num2 == 2)
				{
					this.Cursor = Cursors.Arrow;
					return;
				}
				this.textBox6.AppendText("\r\n" + "Sending Spi Lock request to Port " + this.label123.Text + "\r\n");
				if (this.method_314() == 1)
				{
					this.button42.Text = "0x8C";
					this.toolTip_0.SetToolTip(this.button42, "Click to clear Spi status register");
				}
				else
				{
					this.textBox6.AppendText("Lock Failed !" + "\r\n" + "Spi Status: 0x00" + "\r\n");
				}
			}
			else if (string.Compare(this.button42.Text, "0x8C") == 0)
			{
				this.textBox6.AppendText("\r\n" + "Sending Spi UnLock request to Port " + this.label123.Text + "\r\n");
				if (this.method_315() == 1)
				{
					this.button42.Text = "0x00";
					this.toolTip_0.SetToolTip(this.button42, "Click to lock Spi status register");
				}
				else
				{
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					int num2 = (int)MessageBox.Show("Spi Status Register is H/W protected" + "\n" + "If you wish to resend clear Spi Status Register" + "\n\n" + "Press Escape to cancel.", "SPI Status 0x8C", MessageBoxButtons.YesNo, MessageBoxIcon.Question);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
					if (num2 == 6)
					{
						this.Cursor = Cursors.AppStarting;
						while (this.method_315() == 0)
						{
							<Module>.Sleep(5);
							num++;
							if (<Module>.GetAsyncKeyState(27) != null)
							{
								this.textBox6.AppendText("\r\n" + "Aborted by User!" + "\r\n");
								this.Cursor = Cursors.Arrow;
								return;
							}
							if (num % 8 == 0)
							{
								this.textBox6.AppendText(".");
							}
							Application.DoEvents();
						}
						this.Cursor = Cursors.Arrow;
					}
				}
			}
			this.Cursor = Cursors.Arrow;
		}

		// Token: 0x06000300 RID: 768 RVA: 0x003CA390 File Offset: 0x00312390
		private void method_221()
		{
			int num = 0;
			this.Cursor = Cursors.WaitCursor;
			if (string.Compare(this.button42.Text, "0x00") == 0)
			{
				<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
				int num2 = (int)MessageBox.Show("***                                 Warning                                     ***" + "\r\n\r\n" + "This lock can be quite permanent... You should stop if: " + "\r\n" + "You do not have a Sputnik or Russian type hack for MXIC." + "\r\n" + "                                      -OR-  " + "\r\n" + "Cannot do a Kamikaze hack on Winbond.", "SPi Lock", MessageBoxButtons.OKCancel, MessageBoxIcon.Hand);
				<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
				if (num2 == 2)
				{
					this.Cursor = Cursors.Arrow;
					return;
				}
				this.textBox6.AppendText("\r\n" + "Sending Spi Lock request to Port " + this.label123.Text + "\r\n");
				if (this.method_322() == 1)
				{
					this.button42.Text = "0x8C";
					this.toolTip_0.SetToolTip(this.button42, "Click to clear Spi status register");
				}
				else
				{
					this.textBox6.AppendText("Lock Failed !" + "\r\n" + "Spi Status: 0x00" + "\r\n");
				}
			}
			else if (string.Compare(this.button42.Text, "0x8C") == 0)
			{
				this.textBox6.AppendText("\r\n" + "Sending Spi UnLock request to Port " + this.label123.Text + "\r\n");
				if (this.method_321() == 1)
				{
					this.button42.Text = "0x00";
					this.toolTip_0.SetToolTip(this.button42, "Click to lock Spi status register");
				}
				else
				{
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					int num2 = (int)MessageBox.Show("Spi Status Register is H/W protected" + "\n" + "If you wish to resend clear Spi Status Register" + "\n\n" + "Press Escape to cancel.", "SPI Status 0x8C", MessageBoxButtons.YesNo, MessageBoxIcon.Question);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
					if (num2 == 6)
					{
						this.Cursor = Cursors.AppStarting;
						while (this.method_321() == 0)
						{
							<Module>.Sleep(5);
							num++;
							if (<Module>.GetAsyncKeyState(27) != null)
							{
								this.textBox6.AppendText("\r\n" + "Aborted by User!" + "\r\n");
								this.Cursor = Cursors.Arrow;
								return;
							}
							if (num % 16 == 0)
							{
								this.textBox6.AppendText(".");
							}
							Application.DoEvents();
						}
						this.Cursor = Cursors.Arrow;
					}
				}
			}
			this.Cursor = Cursors.Arrow;
		}

		// Token: 0x06000301 RID: 769 RVA: 0x0013BC3C File Offset: 0x0013BC3C
		private void button13_Click(object sender, EventArgs e)
		{
			this.method_14();
			int num = <Module>.GetAsyncKeyState(17);
			num &= 32768;
			if (num != 0)
			{
				this.method_226();
			}
			else
			{
				this.method_222();
			}
			this.method_15();
		}

		// Token: 0x06000302 RID: 770 RVA: 0x0013BC80 File Offset: 0x0013BC80
		private void method_222()
		{
			if (this.radioButton19.Checked)
			{
				this.method_224();
			}
			else if (this.radioButton21.Checked)
			{
				this.method_225();
			}
			else
			{
				this.method_223();
			}
		}

		// Token: 0x06000303 RID: 771 RVA: 0x003CA62C File Offset: 0x0031262C
		private unsafe void method_223()
		{
			if (string.Compare(Convert.ToString(this.label120.Text), "Unknown type") == 0)
			{
				this.textBox6.AppendText("Unknown flash type Write aborted !" + "\r\n");
			}
			else
			{
				uint num = (uint)this.method_261();
				Struct20 @struct;
				<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct35_129), num);
				string text = new string((sbyte*)(&<Module>.struct19_0));
				text += new string((sbyte*)(&@struct));
				text = "0x" + text;
				if (*(*(ref <Module>.struct123_0 + 4)) == 0)
				{
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					MessageBox.Show("No Firmware is loaded to Target buffer", "F/W Write", MessageBoxButtons.OK, MessageBoxIcon.Hand);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
				}
				else
				{
					if (!this.bool_10 & !this.bool_11)
					{
						<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
						int num2 = (int)MessageBox.Show("Target has not been spoofed," + "\n" + "Are you sure you wish to proceed ?", "F/W Write", MessageBoxButtons.YesNo, MessageBoxIcon.Hand, MessageBoxDefaultButton.Button2);
						<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
						if (num2 == 7)
						{
							return;
						}
					}
					Application.DoEvents();
					if (num == 112U)
					{
						this.textBox6.AppendText("Parallel flash found with Status 0x70" + "\r\n");
						if (*(*(ref <Module>.struct123_0 + 4)) != 1)
						{
							<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
							MessageBox.Show("Firmware in Target buffer is not Samsung, write aborted", "F/W Write", MessageBoxButtons.OK, MessageBoxIcon.Hand);
							<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
						}
						else
						{
							this.textBox6.AppendText("Writing target buffer to flash" + "\r\n");
							this.Cursor = Cursors.WaitCursor;
							this.method_292();
							if (this.method_296() == 1)
							{
								this.Cursor = Cursors.Arrow;
							}
							else
							{
								this.Cursor = Cursors.Arrow;
								<Module>.Sleep(500);
								this.Cursor = Cursors.WaitCursor;
								this.textBox6.AppendText("\r\n" + "Flash Verification Test !");
								this.method_291();
								this.Cursor = Cursors.Arrow;
								for (int i = 0; i < 262144; i++)
								{
									if (*(*(ref <Module>.struct121_0 + 7172) + i) != *(*(ref <Module>.struct121_0 + 4780) + i))
									{
										this.textBox6.AppendText("Write Verify Failed !" + "\r\n");
										return;
									}
								}
								this.textBox6.AppendText("Write verified OK !" + "\r\n\r\n");
								this.string_2 = "Write verified !";
								this.string_3 = "OK";
							}
						}
					}
					else if (num == 115U)
					{
						this.textBox6.AppendText("SPi flash found with Status 0x73" + "\r\n");
						if (*(*(ref <Module>.struct123_0 + 4)) != 3)
						{
							<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
							MessageBox.Show("Firmware in Target buffer is not Benq, write aborted", "F/W Write", MessageBoxButtons.OK, MessageBoxIcon.Hand);
							<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
						}
						else
						{
							this.Cursor = Cursors.WaitCursor;
							this.method_299();
							this.textBox6.AppendText("Writing target buffer to flash" + "\r\n");
							if (this.method_302() == 1)
							{
								this.Cursor = Cursors.Arrow;
							}
							else
							{
								this.Cursor = Cursors.Arrow;
								<Module>.Sleep(500);
								this.Cursor = Cursors.WaitCursor;
								this.textBox6.AppendText("\r\n" + "Flash Verification Test !");
								this.method_298();
								this.Cursor = Cursors.Arrow;
								for (int i = 0; i < 262144; i++)
								{
									if (*(*(ref <Module>.struct121_0 + 7172) + i) != *(*(ref <Module>.struct121_0 + 4780) + i))
									{
										this.textBox6.AppendText("Write Verify Failed !" + "\r\n");
										return;
									}
								}
								this.textBox6.AppendText("Write verified OK !" + "\r\n\r\n");
								this.string_2 = "Write verified !";
								this.string_3 = "OK";
							}
						}
					}
					else if (num == 114U)
					{
						this.textBox6.AppendText("SPi flash found with Status 0x72" + "\r\n");
						uint num3 = (uint)this.method_317();
						if (num3 == 140U)
						{
							this.textBox6.AppendText("Spi is locked, Aborting!" + "\r\n");
						}
						else if (num3 == 142U)
						{
							this.textBox6.AppendText("Spi is locked, Aborting!" + "\r\n");
						}
						else if (*(*(ref <Module>.struct123_0 + 4)) != 7 && *(*(ref <Module>.struct123_0 + 4)) != 5 && *(*(ref <Module>.struct123_0 + 4)) != 4 && *(*(ref <Module>.struct123_0 + 4) + 560) != 70628 && *(*(ref <Module>.struct123_0 + 4) + 560) != 73464 && *(*(ref <Module>.struct123_0 + 4) + 560) != 82278)
						{
							<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
							MessageBox.Show("Firmware in Target buffer is not Lite-On, write aborted", "F/W Write", MessageBoxButtons.OK, MessageBoxIcon.Hand);
							<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
						}
						else
						{
							this.Cursor = Cursors.WaitCursor;
							this.method_311();
							this.textBox6.AppendText("Writing target buffer to flash" + "\r\n");
							if (this.method_326() == 1)
							{
								this.Cursor = Cursors.Arrow;
							}
							else
							{
								this.Cursor = Cursors.Arrow;
								if (this.radioButton20.Checked)
								{
									<Module>.Sleep(500);
									this.Cursor = Cursors.WaitCursor;
									this.textBox6.AppendText("\r\n" + "Flash Verification Test !");
									this.method_307();
									this.Cursor = Cursors.Arrow;
									for (int i = 0; i < 262144; i++)
									{
										if (*(*(ref <Module>.struct121_0 + 7172) + i) != *(*(ref <Module>.struct121_0 + 4780) + i))
										{
											this.textBox6.AppendText("Write Verify Failed !" + "\r\n");
											return;
										}
									}
									this.textBox6.AppendText("Write verified OK !" + "\r\n\r\n");
									this.string_2 = "Write verified !";
									this.string_3 = "OK";
								}
							}
						}
					}
					else
					{
						this.textBox6.AppendText("Invalid Status " + text + "\r\n");
						<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
						MessageBox.Show("Drive returned Invalid Status!", "F/W Write", MessageBoxButtons.OK, MessageBoxIcon.Asterisk);
						<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
					}
				}
			}
		}

		// Token: 0x06000304 RID: 772 RVA: 0x0013C3CC File Offset: 0x0013C3CC
		private unsafe void method_224()
		{
			string text = null;
			string strA = null;
			int num = 0;
			GStruct93 gstruct;
			<Module>.smethod_111(ref gstruct);
			GStruct19 gstruct2;
			try
			{
				<Module>.smethod_90(ref gstruct2);
				try
				{
					if (string.Compare(Convert.ToString(this.label120.Text), "Unknown type") != 0)
					{
						goto IL_80;
					}
					this.textBox6.AppendText("Unknown flash type Write aborted !" + "\r\n");
				}
				catch
				{
					<Module>.__CxxCallUnwindDtor(<Module>.ppInt_14, (void*)(&gstruct2));
					throw;
				}
				<Module>.smethod_92(ref gstruct2);
			}
			catch
			{
				<Module>.__CxxCallUnwindDtor(<Module>.ppInt_13, (void*)(&gstruct));
				throw;
			}
			<Module>.smethod_112(ref gstruct);
			return;
			try
			{
				try
				{
					IL_80:
					uint num2 = (uint)this.method_261();
					Struct20 @struct;
					<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct35_129), num2);
					text = new string((sbyte*)(&<Module>.struct19_0));
					text += new string((sbyte*)(&@struct));
					text = "0x" + text;
					if (*(*(ref <Module>.struct123_0 + 4)) != 0)
					{
						goto IL_13A;
					}
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					MessageBox.Show("No Firmware is loaded to Target buffer", "F/W Write", MessageBoxButtons.OK, MessageBoxIcon.Hand);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
				}
				catch
				{
					<Module>.__CxxCallUnwindDtor(<Module>.ppInt_14, (void*)(&gstruct2));
					throw;
				}
				<Module>.smethod_92(ref gstruct2);
			}
			catch
			{
				<Module>.__CxxCallUnwindDtor(<Module>.ppInt_13, (void*)(&gstruct));
				throw;
			}
			<Module>.smethod_112(ref gstruct);
			return;
			try
			{
				try
				{
					IL_13A:
					if (!(!this.bool_10 & !this.bool_11))
					{
						goto IL_1E1;
					}
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					int num3 = (int)MessageBox.Show("Target has not been spoofed," + "\n" + "Are you sure you wish to proceed ?", "F/W Write", MessageBoxButtons.YesNo, MessageBoxIcon.Hand, MessageBoxDefaultButton.Button2);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
					if (num3 != 7)
					{
						goto IL_1E1;
					}
				}
				catch
				{
					<Module>.__CxxCallUnwindDtor(<Module>.ppInt_14, (void*)(&gstruct2));
					throw;
				}
				<Module>.smethod_92(ref gstruct2);
			}
			catch
			{
				<Module>.__CxxCallUnwindDtor(<Module>.ppInt_13, (void*)(&gstruct));
				throw;
			}
			<Module>.smethod_112(ref gstruct);
			return;
			try
			{
				try
				{
					IL_1E1:
					Application.DoEvents();
					uint num2;
					if (num2 == 114U)
					{
						goto IL_27D;
					}
					this.textBox6.AppendText("Invalid Status " + text + "\r\n");
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					MessageBox.Show("Drive returned Invalid Status!", "F/W Write", MessageBoxButtons.OK, MessageBoxIcon.Asterisk);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
				}
				catch
				{
					<Module>.__CxxCallUnwindDtor(<Module>.ppInt_14, (void*)(&gstruct2));
					throw;
				}
				<Module>.smethod_92(ref gstruct2);
			}
			catch
			{
				<Module>.__CxxCallUnwindDtor(<Module>.ppInt_13, (void*)(&gstruct));
				throw;
			}
			<Module>.smethod_112(ref gstruct);
			return;
			try
			{
				try
				{
					IL_27D:
					this.textBox6.AppendText("SPi flash found with Status 0x72" + "\r\n");
					uint num4 = (uint)this.method_323();
					if (num4 != 140U)
					{
						goto IL_2F5;
					}
					this.textBox6.AppendText("Spi is locked, Aborting!" + "\r\n");
				}
				catch
				{
					<Module>.__CxxCallUnwindDtor(<Module>.ppInt_14, (void*)(&gstruct2));
					throw;
				}
				<Module>.smethod_92(ref gstruct2);
			}
			catch
			{
				<Module>.__CxxCallUnwindDtor(<Module>.ppInt_13, (void*)(&gstruct));
				throw;
			}
			<Module>.smethod_112(ref gstruct);
			return;
			try
			{
				try
				{
					IL_2F5:
					uint num4;
					if (num4 != 142U)
					{
						goto IL_34B;
					}
					this.textBox6.AppendText("Spi is locked, Aborting!" + "\r\n");
				}
				catch
				{
					<Module>.__CxxCallUnwindDtor(<Module>.ppInt_14, (void*)(&gstruct2));
					throw;
				}
				<Module>.smethod_92(ref gstruct2);
			}
			catch
			{
				<Module>.__CxxCallUnwindDtor(<Module>.ppInt_13, (void*)(&gstruct));
				throw;
			}
			<Module>.smethod_112(ref gstruct);
			return;
			try
			{
				try
				{
					IL_34B:
					if (*(*(ref <Module>.struct123_0 + 4)) == 5)
					{
						goto IL_3CA;
					}
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					MessageBox.Show("Firmware in Target buffer is not Lite-On, write aborted", "F/W Write", MessageBoxButtons.OK, MessageBoxIcon.Hand);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
				}
				catch
				{
					<Module>.__CxxCallUnwindDtor(<Module>.ppInt_14, (void*)(&gstruct2));
					throw;
				}
				<Module>.smethod_92(ref gstruct2);
			}
			catch
			{
				<Module>.__CxxCallUnwindDtor(<Module>.ppInt_13, (void*)(&gstruct));
				throw;
			}
			<Module>.smethod_112(ref gstruct);
			return;
			int i;
			try
			{
				try
				{
					IL_3CA:
					Struct33 struct2;
					<Module>.memcpy((void*)(&struct2), *(ref <Module>.struct121_0 + 4780) + 253952, 4096U);
					GStruct19 gstruct3;
					int pGstruct19_ = <Module>.smethod_115(ref gstruct, &gstruct3, (byte*)(&struct2), 4096U);
					try
					{
						<Module>.smethod_93(ref gstruct2, pGstruct19_);
					}
					catch
					{
						<Module>.__CxxCallUnwindDtor(<Module>.ppInt_14, (void*)(&gstruct3));
						throw;
					}
					<Module>.smethod_92(ref gstruct3);
					strA = new string(<Module>.smethod_94(ref gstruct2));
					if (*(*(ref <Module>.struct123_0 + 4) + 2) != 1)
					{
						goto IL_4E7;
					}
					if (string.Compare(strA, "72fedc223e7285fa14e97efc5c26f095") == 0)
					{
						Struct33 struct3;
						<Module>.memcpy((void*)(&struct3), (void*)(&struct2), 4096U);
						Struct33 struct4;
						<Module>.memcpy((void*)(&struct4), (void*)(&struct2), 4096U);
						for (i = 0; i < 1568; i++)
						{
							*(ref struct4 + (i + 1536)) = (*(ref struct4 + (i + 1536)) ^ *(ref <Module>.struct61_0 + i));
						}
						goto IL_4C8;
					}
				}
				catch
				{
					<Module>.__CxxCallUnwindDtor(<Module>.ppInt_14, (void*)(&gstruct2));
					throw;
				}
				<Module>.smethod_92(ref gstruct2);
			}
			catch
			{
				<Module>.__CxxCallUnwindDtor(<Module>.ppInt_13, (void*)(&gstruct));
				throw;
			}
			<Module>.smethod_112(ref gstruct);
			return;
			try
			{
				try
				{
					IL_4C8:
					goto IL_6A6;
				}
				catch
				{
					<Module>.__CxxCallUnwindDtor(<Module>.ppInt_14, (void*)(&gstruct2));
					throw;
				}
			}
			catch
			{
				<Module>.__CxxCallUnwindDtor(<Module>.ppInt_13, (void*)(&gstruct));
				throw;
			}
			try
			{
				try
				{
					IL_4E7:
					if (*(*(ref <Module>.struct123_0 + 4) + 2) != 2 && *(*(ref <Module>.struct123_0 + 4) + 2) != 3 && *(*(ref <Module>.struct123_0 + 4) + 2) != 5)
					{
						goto IL_5A8;
					}
					if (string.Compare(strA, "6ae59e64850377ee5470c854761551ea") == 0)
					{
						Struct33 struct2;
						Struct33 struct3;
						<Module>.memcpy((void*)(&struct3), (void*)(&struct2), 4096U);
						Struct33 struct4;
						<Module>.memcpy((void*)(&struct4), (void*)(&struct2), 4096U);
						<Module>.memcpy(ref struct4 + 2048, (void*)(&<Module>.struct59_1), 84U);
						goto IL_589;
					}
				}
				catch
				{
					<Module>.__CxxCallUnwindDtor(<Module>.ppInt_14, (void*)(&gstruct2));
					throw;
				}
				<Module>.smethod_92(ref gstruct2);
			}
			catch
			{
				<Module>.__CxxCallUnwindDtor(<Module>.ppInt_13, (void*)(&gstruct));
				throw;
			}
			<Module>.smethod_112(ref gstruct);
			return;
			try
			{
				try
				{
					IL_589:
					goto IL_6A6;
				}
				catch
				{
					<Module>.__CxxCallUnwindDtor(<Module>.ppInt_14, (void*)(&gstruct2));
					throw;
				}
			}
			catch
			{
				<Module>.__CxxCallUnwindDtor(<Module>.ppInt_13, (void*)(&gstruct));
				throw;
			}
			try
			{
				try
				{
					IL_5A8:
					if (*(*(ref <Module>.struct123_0 + 4) + 2) != 4)
					{
						goto IL_C14;
					}
					Struct33 struct2;
					Struct33 struct3;
					Struct33 struct4;
					if (string.Compare(strA, "6ae59e64850377ee5470c854761551ea") == 0)
					{
						<Module>.memcpy((void*)(&struct3), (void*)(&struct2), 4096U);
						<Module>.memcpy((void*)(&struct4), (void*)(&struct2), 4096U);
						<Module>.memcpy(ref struct4 + 2048, (void*)(&<Module>.struct59_0), 84U);
						goto IL_68A;
					}
					if (string.Compare(strA, "29d96e15f409aadec008b539203ff300") == 0)
					{
						<Module>.memcpy((void*)(&struct3), (void*)(&struct2), 4096U);
						<Module>.memcpy((void*)(&struct4), (void*)(&struct2), 4096U);
						for (i = 0; i < 80; i++)
						{
							*(ref struct4 + (i + 2064)) = (*(ref struct4 + (i + 2064)) ^ *(ref <Module>.struct31_0 + i));
						}
						goto IL_68A;
					}
				}
				catch
				{
					<Module>.__CxxCallUnwindDtor(<Module>.ppInt_14, (void*)(&gstruct2));
					throw;
				}
				<Module>.smethod_92(ref gstruct2);
			}
			catch
			{
				<Module>.__CxxCallUnwindDtor(<Module>.ppInt_13, (void*)(&gstruct));
				throw;
			}
			<Module>.smethod_112(ref gstruct);
			return;
			try
			{
				try
				{
					IL_68A:;
				}
				catch
				{
					<Module>.__CxxCallUnwindDtor(<Module>.ppInt_14, (void*)(&gstruct2));
					throw;
				}
			}
			catch
			{
				<Module>.__CxxCallUnwindDtor(<Module>.ppInt_13, (void*)(&gstruct));
				throw;
			}
			goto Block_14;
			try
			{
				IL_C14:
				<Module>.smethod_92(ref gstruct2);
			}
			catch
			{
				<Module>.__CxxCallUnwindDtor(<Module>.ppInt_13, (void*)(&gstruct));
				throw;
			}
			<Module>.smethod_112(ref gstruct);
			return;
			Block_14:
			try
			{
				try
				{
					IL_6A6:
					Struct33 struct4;
					<Module>.memcpy(*(ref <Module>.struct121_0 + 4780) + 253952, (void*)(&struct4), 4096U);
					this.Cursor = Cursors.WaitCursor;
					this.method_312();
					this.textBox6.AppendText("Writing target buffer to flash" + "\r\n");
					if (this.method_327() != 1)
					{
						goto IL_757;
					}
					this.Cursor = Cursors.Arrow;
					Struct33 struct3;
					<Module>.memcpy(*(ref <Module>.struct121_0 + 4780) + 253952, (void*)(&struct3), 4096U);
				}
				catch
				{
					<Module>.__CxxCallUnwindDtor(<Module>.ppInt_14, (void*)(&gstruct2));
					throw;
				}
				<Module>.smethod_92(ref gstruct2);
			}
			catch
			{
				<Module>.__CxxCallUnwindDtor(<Module>.ppInt_13, (void*)(&gstruct));
				throw;
			}
			<Module>.smethod_112(ref gstruct);
			return;
			try
			{
				try
				{
					IL_757:
					<Module>.Sleep(500);
					this.method_259();
					for (int j = 0; j < 12; j++)
					{
						<Module>.Sleep(250);
						this.textBox6.AppendText(".");
					}
					this.textBox6.AppendText("\r\n" + "Flash Verification Test !");
					Struct33 struct4;
					if (this.method_214((byte*)(&struct4)) != 0)
					{
						goto IL_805;
					}
					Struct33 struct3;
					<Module>.memcpy(*(ref <Module>.struct121_0 + 4780) + 253952, (void*)(&struct3), 4096U);
				}
				catch
				{
					<Module>.__CxxCallUnwindDtor(<Module>.ppInt_14, (void*)(&gstruct2));
					throw;
				}
				<Module>.smethod_92(ref gstruct2);
			}
			catch
			{
				<Module>.__CxxCallUnwindDtor(<Module>.ppInt_13, (void*)(&gstruct));
				throw;
			}
			<Module>.smethod_112(ref gstruct);
			return;
			try
			{
				try
				{
					IL_805:
					i = 0;
				}
				catch
				{
					<Module>.__CxxCallUnwindDtor(<Module>.ppInt_14, (void*)(&gstruct2));
					throw;
				}
			}
			catch
			{
				<Module>.__CxxCallUnwindDtor(<Module>.ppInt_13, (void*)(&gstruct));
				throw;
			}
			for (;;)
			{
				try
				{
					try
					{
						if (i >= 262144)
						{
							goto IL_8FD;
						}
						if (*(*(ref <Module>.struct121_0 + 7172) + i) == *(*(ref <Module>.struct121_0 + 4780) + i))
						{
							goto IL_8B0;
						}
						this.textBox6.AppendText("Write Verify Failed !" + "\r\n");
						Struct33 struct3;
						<Module>.memcpy(*(ref <Module>.struct121_0 + 4780) + 253952, (void*)(&struct3), 4096U);
					}
					catch
					{
						<Module>.__CxxCallUnwindDtor(<Module>.ppInt_14, (void*)(&gstruct2));
						throw;
					}
					<Module>.smethod_92(ref gstruct2);
					break;
				}
				catch
				{
					<Module>.__CxxCallUnwindDtor(<Module>.ppInt_13, (void*)(&gstruct));
					throw;
				}
				try
				{
					try
					{
						IL_8B0:;
					}
					catch
					{
						<Module>.__CxxCallUnwindDtor(<Module>.ppInt_14, (void*)(&gstruct2));
						throw;
					}
				}
				catch
				{
					<Module>.__CxxCallUnwindDtor(<Module>.ppInt_13, (void*)(&gstruct));
					throw;
				}
				try
				{
					try
					{
						i++;
					}
					catch
					{
						<Module>.__CxxCallUnwindDtor(<Module>.ppInt_14, (void*)(&gstruct2));
						throw;
					}
					continue;
				}
				catch
				{
					<Module>.__CxxCallUnwindDtor(<Module>.ppInt_13, (void*)(&gstruct));
					throw;
				}
				break;
			}
			<Module>.smethod_112(ref gstruct);
			return;
			try
			{
				try
				{
					IL_8FD:
					this.textBox6.AppendText("Write verified OK !" + "\r\n\r\n");
					this.string_2 = "Write verified !";
					this.string_3 = "OK";
					Struct33 struct3;
					<Module>.memcpy(*(ref <Module>.struct121_0 + 4780) + 253952, (void*)(&struct3), 4096U);
					this.method_253();
					this.textBox6.AppendText("Restoring sector 0x3E000." + "\r\n");
					if (this.method_324() != 0)
					{
						goto IL_9A8;
					}
				}
				catch
				{
					<Module>.__CxxCallUnwindDtor(<Module>.ppInt_14, (void*)(&gstruct2));
					throw;
				}
				<Module>.smethod_92(ref gstruct2);
			}
			catch
			{
				<Module>.__CxxCallUnwindDtor(<Module>.ppInt_13, (void*)(&gstruct));
				throw;
			}
			<Module>.smethod_112(ref gstruct);
			return;
			try
			{
				try
				{
					IL_9A8:
					if (this.method_329() != 0)
					{
						goto IL_9E3;
					}
				}
				catch
				{
					<Module>.__CxxCallUnwindDtor(<Module>.ppInt_14, (void*)(&gstruct2));
					throw;
				}
				<Module>.smethod_92(ref gstruct2);
			}
			catch
			{
				<Module>.__CxxCallUnwindDtor(<Module>.ppInt_13, (void*)(&gstruct));
				throw;
			}
			<Module>.smethod_112(ref gstruct);
			return;
			try
			{
				try
				{
					IL_9E3:
					Struct33 struct3;
					if (this.method_330((byte*)(&struct3)) != 0)
					{
						goto IL_A20;
					}
				}
				catch
				{
					<Module>.__CxxCallUnwindDtor(<Module>.ppInt_14, (void*)(&gstruct2));
					throw;
				}
				<Module>.smethod_92(ref gstruct2);
			}
			catch
			{
				<Module>.__CxxCallUnwindDtor(<Module>.ppInt_13, (void*)(&gstruct));
				throw;
			}
			<Module>.smethod_112(ref gstruct);
			return;
			try
			{
				try
				{
					IL_A20:
					this.method_259();
					for (int j = 0; j < 12; j++)
					{
						<Module>.Sleep(250);
						this.textBox6.AppendText(".");
					}
					if (this.method_107(*(ref <Module>.struct123_0 + 4) + 280) == 1)
					{
						this.Cursor = Cursors.WaitCursor;
						this.textBox6.AppendText("\r\n" + "Authorised !" + "\r\n");
						goto IL_AFB;
					}
					this.textBox6.AppendText("\r\n" + "Authorisation Failed!" + "\r\n");
					this.textBox6.AppendText("Restore Verify Failed !" + "\r\n");
				}
				catch
				{
					<Module>.__CxxCallUnwindDtor(<Module>.ppInt_14, (void*)(&gstruct2));
					throw;
				}
				<Module>.smethod_92(ref gstruct2);
			}
			catch
			{
				<Module>.__CxxCallUnwindDtor(<Module>.ppInt_13, (void*)(&gstruct));
				throw;
			}
			<Module>.smethod_112(ref gstruct);
			return;
			try
			{
				try
				{
					IL_AFB:
					Struct28 struct5;
					this.method_92(0, 0, 0, (byte*)(&struct5));
					Struct33 struct2;
					for (int k = 16; k < 32; k++)
					{
						i = 0;
						while (i < 256)
						{
							this.method_91(0, (byte)k, (byte)i, (byte*)(&struct5));
							<Module>.memcpy(ref struct2 + num, (void*)(&struct5), 16U);
							i += 16;
							num += 16;
						}
						this.textBox6.AppendText(".");
						Application.DoEvents();
					}
					this.textBox6.AppendText(string.Concat("\r\n"));
					for (i = 0; i < 4096; i++)
					{
						Struct33 struct3;
						if (*(ref struct3 + i) != *(ref struct2 + i))
						{
							this.textBox6.AppendText("Restore Verify Failed !" + "\r\n");
							break;
						}
					}
					if (i == 4096)
					{
						this.textBox6.AppendText("Restore verified OK !" + "\r\n");
						this.string_2 = "Restore verified !";
					}
					this.method_177();
				}
				catch
				{
					<Module>.__CxxCallUnwindDtor(<Module>.ppInt_14, (void*)(&gstruct2));
					throw;
				}
				<Module>.smethod_92(ref gstruct2);
			}
			catch
			{
				<Module>.__CxxCallUnwindDtor(<Module>.ppInt_13, (void*)(&gstruct));
				throw;
			}
			<Module>.smethod_112(ref gstruct);
		}

		// Token: 0x06000305 RID: 773 RVA: 0x003CAD40 File Offset: 0x00312D40
		private unsafe void method_225()
		{
			if (string.Compare(Convert.ToString(this.label120.Text), "Unknown type") == 0)
			{
				this.textBox6.AppendText("Unknown flash type Write aborted !" + "\r\n");
			}
			else
			{
				uint num = (uint)this.method_261();
				Struct20 @struct;
				<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct35_129), num);
				string text = new string((sbyte*)(&<Module>.struct19_0));
				text += new string((sbyte*)(&@struct));
				text = "0x" + text;
				if (*(*(ref <Module>.struct123_0 + 4)) == 0)
				{
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					MessageBox.Show("No Firmware is loaded to Target buffer", "F/W Write", MessageBoxButtons.OK, MessageBoxIcon.Hand);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
				}
				else
				{
					if (!this.bool_10 & !this.bool_11)
					{
						<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
						int num2 = (int)MessageBox.Show("Target has not been spoofed," + "\n" + "Are you sure you wish to proceed ?", "F/W Write", MessageBoxButtons.YesNo, MessageBoxIcon.Hand, MessageBoxDefaultButton.Button2);
						<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
						if (num2 == 7)
						{
							return;
						}
					}
					Application.DoEvents();
					if (num == 114U)
					{
						this.textBox6.AppendText("SPi flash found with Status 0x72" + "\r\n");
						uint num3 = (uint)this.method_325();
						if (num3 == 140U)
						{
							this.textBox6.AppendText("Spi is locked, Aborting!" + "\r\n");
						}
						else if (num3 == 142U)
						{
							this.textBox6.AppendText("Spi is locked, Aborting!" + "\r\n");
						}
						else if (*(*(ref <Module>.struct123_0 + 4)) != 6)
						{
							<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
							MessageBox.Show("Firmware in Target buffer is not Lite-On, write aborted", "F/W Write", MessageBoxButtons.OK, MessageBoxIcon.Hand);
							<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
						}
						else
						{
							this.Cursor = Cursors.WaitCursor;
							this.method_313();
							this.textBox6.AppendText("Writing target buffer to flash" + "\r\n");
							if (this.method_328() == 1)
							{
								this.Cursor = Cursors.Arrow;
							}
							else
							{
								this.Cursor = Cursors.Arrow;
								if (this.radioButton20.Checked)
								{
									<Module>.Sleep(500);
									this.Cursor = Cursors.WaitCursor;
									this.textBox6.AppendText("\r\n" + "Flash Verification Test !");
									this.method_310();
									this.Cursor = Cursors.Arrow;
									for (int i = 0; i < 262144; i++)
									{
										if (*(*(ref <Module>.struct121_0 + 7172) + i) != *(*(ref <Module>.struct121_0 + 4780) + i))
										{
											this.textBox6.AppendText("Write Verify Failed !" + "\r\n");
											return;
										}
									}
									this.textBox6.AppendText("Write verified OK !" + "\r\n\r\n");
									this.string_2 = "Write verified !";
									this.string_3 = "OK";
								}
							}
						}
					}
					else
					{
						this.textBox6.AppendText("Invalid Status " + text + "\r\n");
						<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
						MessageBox.Show("Drive returned Invalid Status!", "F/W Write", MessageBoxButtons.OK, MessageBoxIcon.Asterisk);
						<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
					}
				}
			}
		}

		// Token: 0x06000306 RID: 774 RVA: 0x003CB0D8 File Offset: 0x003130D8
		private unsafe void method_226()
		{
			uint num = (uint)this.method_261();
			Struct20 @struct;
			<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct35_129), num);
			string text = new string((sbyte*)(&<Module>.struct19_0));
			text += new string((sbyte*)(&@struct));
			text = "0x" + text;
			<Module>.memset(*(ref <Module>.struct123_0 + 4), 0, 2392U);
			this.method_43();
			this.label87.Text = "";
			this.label88.Text = "";
			Application.DoEvents();
			if (this.method_227() != 0)
			{
				if (num == 112U)
				{
					this.textBox6.AppendText("Parallel flash found with Status 0x70" + "\r\n");
					this.textBox6.AppendText("Writing target buffer to flash" + "\r\n");
					this.Cursor = Cursors.WaitCursor;
					this.method_292();
					if (this.method_296() == 1)
					{
						this.Cursor = Cursors.Arrow;
					}
					else
					{
						this.Cursor = Cursors.Arrow;
						<Module>.Sleep(500);
						this.Cursor = Cursors.WaitCursor;
						this.textBox6.AppendText("\r\n" + "Flash Verification Test !");
						this.method_291();
						this.Cursor = Cursors.Arrow;
						for (int i = 0; i < 262144; i++)
						{
							if (*(*(ref <Module>.struct121_0 + 7172) + i) != *(*(ref <Module>.struct121_0 + 4780) + i))
							{
								this.textBox6.AppendText("Write Verify Failed !" + "\r\n");
								return;
							}
						}
						this.textBox6.AppendText("Write verified OK !" + "\r\n\r\n");
						this.string_2 = "Write verified !";
						this.string_3 = "OK";
					}
				}
				else if (num == 115U)
				{
					this.textBox6.AppendText("SPi flash found with Status 0x73" + "\r\n");
					this.Cursor = Cursors.WaitCursor;
					this.method_299();
					this.textBox6.AppendText("Writing target buffer to flash" + "\r\n");
					if (this.method_302() == 1)
					{
						this.Cursor = Cursors.Arrow;
					}
					else
					{
						this.Cursor = Cursors.Arrow;
						<Module>.Sleep(500);
						this.Cursor = Cursors.WaitCursor;
						this.textBox6.AppendText("\r\n" + "Flash Verification Test !");
						this.method_298();
						this.Cursor = Cursors.Arrow;
						for (int i = 0; i < 262144; i++)
						{
							if (*(*(ref <Module>.struct121_0 + 7172) + i) != *(*(ref <Module>.struct121_0 + 4780) + i))
							{
								this.textBox6.AppendText("Write Verify Failed !" + "\r\n");
								return;
							}
						}
						this.textBox6.AppendText("Write verified OK !" + "\r\n\r\n");
						this.string_2 = "Write verified !";
						this.string_3 = "OK";
					}
				}
				else if (num == 114U)
				{
					this.textBox6.AppendText("SPi flash found with Status 0x72" + "\r\n");
					this.Cursor = Cursors.WaitCursor;
					if (this.radioButton20.Checked)
					{
						this.method_311();
						this.textBox6.AppendText("Writing target buffer to flash" + "\r\n");
						if (this.method_326() == 1)
						{
							this.Cursor = Cursors.Arrow;
						}
						else
						{
							this.Cursor = Cursors.Arrow;
							<Module>.Sleep(500);
							this.Cursor = Cursors.WaitCursor;
							this.textBox6.AppendText("\r\n" + "Flash Verification Test !");
							this.method_307();
							this.Cursor = Cursors.Arrow;
							for (int i = 0; i < 262144; i++)
							{
								if (*(*(ref <Module>.struct121_0 + 7172) + i) != *(*(ref <Module>.struct121_0 + 4780) + i))
								{
									this.textBox6.AppendText("Write Verify Failed !" + "\r\n");
									return;
								}
							}
							this.textBox6.AppendText("Write verified OK !" + "\r\n\r\n");
							this.string_2 = "Write verified !";
							this.string_3 = "OK";
						}
					}
					else if (this.radioButton19.Checked)
					{
						this.method_312();
						this.textBox6.AppendText("Writing target buffer to flash" + "\r\n");
						if (this.method_327() == 1)
						{
							this.Cursor = Cursors.Arrow;
						}
						else
						{
							this.Cursor = Cursors.Arrow;
						}
					}
					else
					{
						this.method_313();
						this.textBox6.AppendText("Writing target buffer to flash" + "\r\n");
						if (this.method_328() == 1)
						{
							this.Cursor = Cursors.Arrow;
						}
						else
						{
							this.Cursor = Cursors.Arrow;
						}
					}
				}
				else
				{
					this.textBox6.AppendText("Invalid Status " + text + "\r\n");
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					MessageBox.Show("Drive returned Invalid Status!", "F/W Write", MessageBoxButtons.OK, MessageBoxIcon.Asterisk);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
				}
			}
		}

		// Token: 0x06000307 RID: 775 RVA: 0x0013DDC4 File Offset: 0x0013DDC4
		private unsafe int method_227()
		{
			string[] commandLineArgs = Environment.GetCommandLineArgs();
			string directoryName = Path.GetDirectoryName(commandLineArgs[0]);
			OpenFileDialog openFileDialog = new OpenFileDialog();
			openFileDialog.Filter = "f/w files |*.bin|All Files (*.*)|*.*";
			openFileDialog.FileName = "firm.bin";
			openFileDialog.DefaultExt = ".bin";
			openFileDialog.CheckFileExists = true;
			openFileDialog.CheckPathExists = true;
			openFileDialog.RestoreDirectory = false;
			openFileDialog.InitialDirectory = directoryName + "\\firmware";
			int result;
			if (openFileDialog.ShowDialog() == DialogResult.OK)
			{
				string fullPath = Path.GetFullPath(openFileDialog.FileName);
				Struct68 @struct;
				<Module>.memset((void*)(&@struct), 0, 260U);
				string s = new string((sbyte*)(&<Module>.struct19_0));
				s = Path.GetFullPath(fullPath);
				IntPtr intPtr = Marshal.StringToHGlobalAnsi(s);
				IntPtr value = intPtr;
				sbyte* ptr = (sbyte*)((void*)value);
				<Module>.memcpy((void*)(&@struct), (void*)ptr, 260U);
				this.method_44((sbyte*)(&@struct), 1);
				result = 1;
			}
			else
			{
				result = 0;
			}
			return result;
		}

		// Token: 0x06000308 RID: 776 RVA: 0x0013DEA4 File Offset: 0x0013DEA4
		private int method_228(ushort ushort_0, byte byte_0, byte byte_1, ushort ushort_1, byte byte_2)
		{
			uint num;
			if (ushort_0 == 0)
			{
				num = 512U;
			}
			else
			{
				num = 327680U;
			}
			<Module>.smethod_2(ushort_0 + 6, byte_0);
			<Module>.smethod_2(ushort_0 + 4, (byte)(ushort_1 & 255));
			<Module>.smethod_2(ushort_0 + 5, (byte)((ushort_1 & 65280) >> 8));
			<Module>.smethod_2(ushort_0 + 3, byte_2);
			<Module>.smethod_2(ushort_0 + 7, 1);
			<Module>.smethod_2(ushort_0 + 6, byte_0);
			uint num2 = 0U;
			while (num2 <= num)
			{
				int result;
				if (<Module>.GetAsyncKeyState(27) == null)
				{
					if (<Module>.smethod_0(ushort_0 + 7) != byte_1)
					{
						num2 += 1U;
						continue;
					}
					result = 0;
				}
				else
				{
					result = 1;
				}
				return result;
			}
			return 1;
		}

		// Token: 0x06000309 RID: 777 RVA: 0x0013DF40 File Offset: 0x0013DF40
		private unsafe int method_229(ushort ushort_0, byte byte_0, byte byte_1, ushort ushort_1, byte* pByte_0)
		{
			uint num;
			if (ushort_0 == 0)
			{
				num = 512U;
			}
			else
			{
				num = 327680U;
			}
			<Module>.smethod_2(ushort_0 + 6, byte_0);
			<Module>.smethod_2(ushort_0 + 4, (byte)(ushort_1 & 255));
			<Module>.smethod_2(ushort_0 + 5, (byte)((ushort_1 & 65280) >> 8));
			<Module>.smethod_2(ushort_0 + 7, 0);
			<Module>.smethod_2(ushort_0 + 6, byte_0);
			uint num2;
			for (num2 = 0U; num2 <= num; num2 += 1U)
			{
				if (<Module>.GetAsyncKeyState(27) != null)
				{
					return 1;
				}
				if (<Module>.smethod_0(ushort_0 + 7) == byte_1)
				{
					break;
				}
			}
			if (num2 == num)
			{
				return 1;
			}
			*pByte_0 = <Module>.smethod_0(ushort_0 + 3);
			return 0;
		}

		// Token: 0x0600030A RID: 778 RVA: 0x0013DFE0 File Offset: 0x0013DFE0
		private unsafe int method_230(ushort ushort_0, byte byte_0, byte byte_1, ushort ushort_1, byte* pByte_0)
		{
			<Module>.smethod_2(ushort_0 + 6, byte_0);
			<Module>.smethod_2(ushort_0 + 4, (byte)(ushort_1 & 255));
			<Module>.smethod_2(ushort_0 + 5, (byte)((ushort_1 & 65280) >> 8));
			<Module>.smethod_2(ushort_0 + 7, 2);
			while ((<Module>.smethod_0(ushort_0 + 7) & 128) != null)
			{
			}
			ushort num = <Module>.smethod_1(ushort_0);
			*pByte_0 = (byte)(num & 255);
			pByte_0[1] = (byte)((num & 65280) >> 8);
			while ((<Module>.smethod_0(ushort_0 + 7) & 128) != null)
			{
			}
			num = <Module>.smethod_1(ushort_0);
			pByte_0[2] = (byte)(num & 255);
			pByte_0[3] = (byte)((num & 65280) >> 8);
			return 0;
		}

		// Token: 0x0600030B RID: 779 RVA: 0x0013E090 File Offset: 0x0013E090
		private int method_231(ushort ushort_0, byte byte_0, byte byte_1, byte byte_2, byte byte_3, byte byte_4, byte byte_5)
		{
			uint num;
			if (ushort_0 == 0)
			{
				num = 512U;
			}
			else
			{
				num = 327680U;
			}
			<Module>.smethod_2(ushort_0 + 6, byte_0);
			<Module>.smethod_2(ushort_0 + 1, byte_2);
			<Module>.smethod_2(ushort_0 + 2, byte_3);
			<Module>.smethod_2(ushort_0 + 3, 0);
			<Module>.smethod_2(ushort_0 + 4, byte_4);
			<Module>.smethod_2(ushort_0 + 5, byte_5);
			<Module>.smethod_2(ushort_0 + 7, 4);
			<Module>.smethod_2(ushort_0 + 6, byte_0);
			uint num2;
			for (num2 = 0U; num2 <= 327680U; num2 += 1U)
			{
				if (<Module>.GetAsyncKeyState(27) != null)
				{
					return 1;
				}
				if (<Module>.smethod_0(ushort_0 + 7) == byte_1)
				{
					break;
				}
			}
			if (num2 == 327680U)
			{
				return 1;
			}
			<Module>.smethod_2(ushort_0 + 6, byte_0);
			<Module>.smethod_2(ushort_0 + 7, 5);
			for (num2 = 0U; num2 <= num; num2 += 1U)
			{
				if (<Module>.GetAsyncKeyState(27) != null)
				{
					return 1;
				}
				if (<Module>.smethod_0(ushort_0 + 7) == byte_1)
				{
					return 0;
				}
			}
			return 1;
		}

		// Token: 0x0600030C RID: 780 RVA: 0x0013E17C File Offset: 0x0013E17C
		private unsafe int method_232(ushort ushort_0, byte byte_0, byte byte_1, byte byte_2)
		{
			uint num;
			if (ushort_0 == 0)
			{
				num = 512U;
			}
			else
			{
				num = 327680U;
			}
			int result;
			if (byte_1 == 115)
			{
				for (uint num2 = 0U; num2 <= num; num2 += 1U)
				{
					if (<Module>.GetAsyncKeyState(27) != null)
					{
						this.textBox6.AppendText("\r\n" + "Aborted by User!" + "\r\n");
						return 1;
					}
					this.method_228(ushort_0, byte_0, byte_1, 0, 5);
					this.method_231(ushort_0, byte_0, byte_1, 0, 1, 0, 1);
					byte b;
					this.method_229(ushort_0, byte_0, byte_1, 1, &b);
					if (b == byte_2)
					{
						return 0;
					}
				}
				result = 1;
			}
			else if (byte_1 == 114)
			{
				for (uint num3 = 0U; num3 <= num; num3 += 1U)
				{
					if (<Module>.GetAsyncKeyState(27) != null)
					{
						this.textBox6.AppendText("\r\n" + "Aborted by User!" + "\r\n");
						return 1;
					}
					this.method_228(ushort_0, byte_0, byte_1, 34816, 5);
					this.method_231(ushort_0, byte_0, byte_1, 1, 0, 1, 0);
					byte b;
					this.method_229(ushort_0, byte_0, byte_1, 1, &b);
					if (b == byte_2)
					{
						return 0;
					}
				}
				result = 1;
			}
			else
			{
				result = 1;
			}
			return result;
		}

		// Token: 0x0600030D RID: 781 RVA: 0x0013E28C File Offset: 0x0013E28C
		private byte method_233(ushort ushort_0, byte byte_0, byte byte_1, ushort ushort_1)
		{
			<Module>.smethod_2(ushort_0 + 6, byte_0);
			<Module>.smethod_2(ushort_0 + 4, (byte)(ushort_1 & 255));
			<Module>.smethod_2(ushort_0 + 5, (byte)((ushort_1 & 65280) >> 8));
			<Module>.smethod_2(ushort_0 + 7, 0);
			<Module>.smethod_2(ushort_0 + 6, byte_0);
			for (uint num = 0U; num <= 327680U; num += 1U)
			{
				if (<Module>.smethod_0(ushort_0 + 7) == byte_1)
				{
					break;
				}
			}
			return <Module>.smethod_0(ushort_0 + 3);
		}

		// Token: 0x0600030E RID: 782 RVA: 0x0013E308 File Offset: 0x0013E308
		private int method_234(ushort ushort_0, byte byte_0, byte byte_1, ushort ushort_1, byte byte_2)
		{
			uint num;
			if (ushort_0 == 0)
			{
				num = 512U;
			}
			else
			{
				num = 327680U;
			}
			<Module>.smethod_2(ushort_0 + 6, byte_0);
			<Module>.smethod_2(ushort_0 + 4, (byte)(ushort_1 & 255));
			<Module>.smethod_2(ushort_0 + 5, (byte)((ushort_1 & 65280) >> 8));
			<Module>.smethod_2(ushort_0 + 3, byte_2);
			<Module>.smethod_2(ushort_0 + 7, 104);
			<Module>.smethod_2(ushort_0 + 6, byte_0);
			uint num2 = 0U;
			while (num2 <= num)
			{
				int result;
				if (<Module>.GetAsyncKeyState(27) == null)
				{
					if (<Module>.smethod_0(ushort_0 + 7) != byte_1)
					{
						num2 += 1U;
						continue;
					}
					result = 0;
				}
				else
				{
					result = 1;
				}
				return result;
			}
			return 1;
		}

		// Token: 0x0600030F RID: 783 RVA: 0x0013E3A4 File Offset: 0x0013E3A4
		private unsafe int method_235(ushort ushort_0, byte byte_0, byte byte_1, ushort ushort_1, byte* pByte_0)
		{
			uint num;
			if (ushort_0 == 0)
			{
				num = 512U;
			}
			else
			{
				num = 327680U;
			}
			<Module>.smethod_2(ushort_0 + 6, byte_0);
			<Module>.smethod_2(ushort_0 + 4, (byte)(ushort_1 & 255));
			<Module>.smethod_2(ushort_0 + 5, (byte)((ushort_1 & 65280) >> 8));
			<Module>.smethod_2(ushort_0 + 7, 145);
			<Module>.smethod_2(ushort_0 + 6, byte_0);
			uint num2;
			for (num2 = 0U; num2 <= num; num2 += 1U)
			{
				if (<Module>.GetAsyncKeyState(27) != null)
				{
					return 0;
				}
				if (<Module>.smethod_0(ushort_0 + 7) == byte_1)
				{
					break;
				}
			}
			if (num2 == num)
			{
				return 0;
			}
			*pByte_0 = <Module>.smethod_0(ushort_0 + 3);
			return 1;
		}

		// Token: 0x06000310 RID: 784 RVA: 0x0013E448 File Offset: 0x0013E448
		private int method_236(ushort ushort_0, byte byte_0, byte byte_1, byte byte_2, byte byte_3, byte byte_4, byte byte_5)
		{
			uint num;
			if (ushort_0 == 0)
			{
				num = 512U;
			}
			else
			{
				num = 327680U;
			}
			<Module>.smethod_2(ushort_0 + 6, byte_0);
			<Module>.smethod_2(ushort_0 + 1, byte_2);
			<Module>.smethod_2(ushort_0 + 2, byte_3);
			<Module>.smethod_2(ushort_0 + 3, 0);
			<Module>.smethod_2(ushort_0 + 4, byte_4);
			<Module>.smethod_2(ushort_0 + 5, byte_5);
			<Module>.smethod_2(ushort_0 + 7, 27);
			<Module>.smethod_2(ushort_0 + 6, byte_0);
			uint num2;
			for (num2 = 0U; num2 <= num; num2 += 1U)
			{
				if (<Module>.GetAsyncKeyState(27) != null)
				{
					return 1;
				}
				if (<Module>.smethod_0(ushort_0 + 7) == byte_1)
				{
					break;
				}
			}
			return (num2 != num) ? 0 : 1;
		}

		// Token: 0x06000311 RID: 785 RVA: 0x0013E4F0 File Offset: 0x0013E4F0
		private unsafe int method_237(ushort ushort_0, byte byte_0, byte byte_1, byte byte_2)
		{
			uint num;
			if (ushort_0 == 0)
			{
				num = 512U;
			}
			else
			{
				num = 327680U;
			}
			uint num2 = 0U;
			while (num2 < num)
			{
				int result;
				if (<Module>.GetAsyncKeyState(27) == null)
				{
					this.method_234(ushort_0, byte_0, byte_1, 34816, 5);
					this.method_236(ushort_0, byte_0, byte_1, 1, 0, 1, 0);
					byte b;
					this.method_235(ushort_0, byte_0, byte_1, 1, &b);
					if (b != byte_2)
					{
						<Module>.Sleep(1);
						num2 += 1U;
						continue;
					}
					result = 0;
				}
				else
				{
					this.textBox6.AppendText("\r\n" + "Aborted by User!" + "\r\n");
					result = 1;
				}
				return result;
			}
			return 1;
		}

		// Token: 0x06000312 RID: 786 RVA: 0x0013E584 File Offset: 0x0013E584
		private unsafe void method_238()
		{
			int num = 0;
			if (this.comboBox1.Items.Count != 0)
			{
				uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
				byte byte_ = *(ref <Module>.struct38_0 + selectedIndex * 72U + 4);
				ushort ushort_ = *(ref <Module>.struct38_0 + selectedIndex * 72U);
				this.method_234(ushort_, byte_, 114, 34816, 5);
				this.method_236(ushort_, byte_, 114, 1, 0, 1, 0);
				Struct104 @struct;
				this.method_235(ushort_, byte_, 114, 1, (byte*)(&@struct));
				Struct20 struct2;
				<Module>.sprintf((sbyte*)(&struct2), (sbyte*)(&<Module>.struct35_121), @struct);
				string text = new string((sbyte*)(&<Module>.struct19_0));
				text += new string((sbyte*)(&struct2));
				this.textBox6.AppendText("Spi Status: 0x" + text + "\r\n");
				byte b = @struct;
				if ((b & 128) != 0)
				{
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					int num2 = (int)MessageBox.Show("Spi Status Register is S/W protected" + "\n" + "If you wish to resend clear Spi Status Register" + "\n\n" + "Press Escape to cancel.", "SPI Status 0x8C", MessageBoxButtons.YesNo, MessageBoxIcon.Question);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
					if (num2 == 6)
					{
						this.Cursor = Cursors.AppStarting;
						while (this.method_321() == 0)
						{
							<Module>.Sleep(5);
							num++;
							if (<Module>.GetAsyncKeyState(27) != null)
							{
								this.textBox6.AppendText("\r\n" + "Aborted by User!" + "\r\n");
								this.Cursor = Cursors.Arrow;
								return;
							}
							if (num % 16 == 0)
							{
								this.textBox6.AppendText(".");
							}
							Application.DoEvents();
						}
						this.Cursor = Cursors.Arrow;
					}
				}
			}
		}

		// Token: 0x06000313 RID: 787 RVA: 0x0013E73C File Offset: 0x0013E73C
		private unsafe void method_239()
		{
			uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
			byte byte_ = *(ref <Module>.struct38_0 + selectedIndex * 72U + 4);
			ushort ushort_ = *(ref <Module>.struct38_0 + selectedIndex * 72U);
			this.method_234(ushort_, byte_, 114, 34816, 5);
			this.method_236(ushort_, byte_, 114, 1, 0, 1, 0);
			Struct104 @struct;
			this.method_235(ushort_, byte_, 114, 1, (byte*)(&@struct));
			Struct20 struct2;
			<Module>.sprintf((sbyte*)(&struct2), (sbyte*)(&<Module>.struct35_121), @struct);
			string text = new string((sbyte*)(&<Module>.struct19_0));
			text += new string((sbyte*)(&struct2));
			this.textBox6.AppendText("Spi Status: 0x" + text + "\r\n");
			byte b = @struct;
			if (b == 140)
			{
				this.button42.Text = new string((sbyte*)(&<Module>.struct35_130));
				this.button42.Enabled = true;
				this.toolTip_0.SetToolTip(this.button42, "Click to clear Spi status register");
			}
			else if (b == 0)
			{
				this.button42.Text = new string((sbyte*)(&<Module>.struct35_131));
				this.button42.Enabled = true;
				this.toolTip_0.SetToolTip(this.button42, "Click to lock Spi status register");
			}
		}

		// Token: 0x06000314 RID: 788 RVA: 0x0013E86C File Offset: 0x0013E86C
		private unsafe void method_240()
		{
			uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
			byte byte_ = *(ref <Module>.struct38_0 + selectedIndex * 72U + 4);
			ushort ushort_ = *(ref <Module>.struct38_0 + selectedIndex * 72U);
			this.method_242(ushort_, byte_, 114, 34816, 5);
			this.method_244(ushort_, byte_, 114, 1, 0, 1, 0);
			Struct104 @struct;
			this.method_243(ushort_, byte_, 114, 1, (byte*)(&@struct));
			Struct20 struct2;
			<Module>.sprintf((sbyte*)(&struct2), (sbyte*)(&<Module>.struct35_121), @struct);
			string text = new string((sbyte*)(&<Module>.struct19_0));
			text += new string((sbyte*)(&struct2));
			this.textBox6.AppendText("Spi Status: 0x" + text + "\r\n");
			byte b = @struct;
			if (b == 140)
			{
				this.button42.Text = new string((sbyte*)(&<Module>.struct35_130));
				this.button42.Enabled = true;
				this.toolTip_0.SetToolTip(this.button42, "Click to clear Spi status register");
			}
			else if (b == 0)
			{
				this.button42.Text = new string((sbyte*)(&<Module>.struct35_131));
				this.button42.Enabled = true;
				this.toolTip_0.SetToolTip(this.button42, "Click to lock Spi status register");
			}
		}

		// Token: 0x06000315 RID: 789 RVA: 0x0013E99C File Offset: 0x0013E99C
		private unsafe void method_241()
		{
			uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
			byte byte_ = *(ref <Module>.struct38_0 + selectedIndex * 72U + 4);
			ushort ushort_ = *(ref <Module>.struct38_0 + selectedIndex * 72U);
			this.method_228(ushort_, byte_, 114, 34816, 5);
			this.method_231(ushort_, byte_, 114, 1, 0, 1, 0);
			Struct104 @struct;
			this.method_229(ushort_, byte_, 114, 1, (byte*)(&@struct));
			Struct20 struct2;
			<Module>.sprintf((sbyte*)(&struct2), (sbyte*)(&<Module>.struct35_121), @struct);
			string text = new string((sbyte*)(&<Module>.struct19_0));
			text += new string((sbyte*)(&struct2));
			this.textBox6.AppendText("Spi Status: 0x" + text + "\r\n");
			byte b = @struct;
			if (b == 140)
			{
				this.button42.Text = new string((sbyte*)(&<Module>.struct35_130));
				this.button42.Enabled = true;
				this.toolTip_0.SetToolTip(this.button42, "Click to clear Spi status register");
			}
			else if (b == 0)
			{
				this.button42.Text = new string((sbyte*)(&<Module>.struct35_131));
				this.button42.Enabled = true;
				this.toolTip_0.SetToolTip(this.button42, "Click to lock Spi status register");
			}
		}

		// Token: 0x06000316 RID: 790 RVA: 0x0013EACC File Offset: 0x0013EACC
		private int method_242(ushort ushort_0, byte byte_0, byte byte_1, ushort ushort_1, byte byte_2)
		{
			uint num;
			if (ushort_0 == 0)
			{
				num = 512U;
			}
			else
			{
				num = 327680U;
			}
			<Module>.smethod_2(ushort_0 + 6, byte_0);
			<Module>.smethod_2(ushort_0 + 4, (byte)(ushort_1 & 255));
			<Module>.smethod_2(ushort_0 + 5, (byte)((ushort_1 & 65280) >> 8));
			<Module>.smethod_2(ushort_0 + 3, byte_2);
			<Module>.smethod_2(ushort_0 + 7, 82);
			<Module>.smethod_2(ushort_0 + 6, byte_0);
			uint num2 = 0U;
			while (num2 <= num)
			{
				int result;
				if (<Module>.GetAsyncKeyState(27) == null)
				{
					if (<Module>.smethod_0(ushort_0 + 7) != byte_1)
					{
						num2 += 1U;
						continue;
					}
					result = 0;
				}
				else
				{
					result = 1;
				}
				return result;
			}
			return 1;
		}

		// Token: 0x06000317 RID: 791 RVA: 0x0013EB68 File Offset: 0x0013EB68
		private unsafe int method_243(ushort ushort_0, byte byte_0, byte byte_1, ushort ushort_1, byte* pByte_0)
		{
			uint num;
			if (ushort_0 == 0)
			{
				num = 512U;
			}
			else
			{
				num = 327680U;
			}
			<Module>.smethod_2(ushort_0 + 6, byte_0);
			<Module>.smethod_2(ushort_0 + 4, (byte)(ushort_1 & 255));
			<Module>.smethod_2(ushort_0 + 5, (byte)((ushort_1 & 65280) >> 8));
			<Module>.smethod_2(ushort_0 + 7, 31);
			<Module>.smethod_2(ushort_0 + 6, byte_0);
			uint num2;
			for (num2 = 0U; num2 <= num; num2 += 1U)
			{
				if (<Module>.GetAsyncKeyState(27) != null)
				{
					return 0;
				}
				if (<Module>.smethod_0(ushort_0 + 7) == byte_1)
				{
					break;
				}
			}
			if (num2 == num)
			{
				return 0;
			}
			*pByte_0 = <Module>.smethod_0(ushort_0 + 3);
			return 1;
		}

		// Token: 0x06000318 RID: 792 RVA: 0x0013EC0C File Offset: 0x0013EC0C
		private int method_244(ushort ushort_0, byte byte_0, byte byte_1, byte byte_2, byte byte_3, byte byte_4, byte byte_5)
		{
			uint num;
			if (ushort_0 == 0)
			{
				num = 512U;
			}
			else
			{
				num = 327680U;
			}
			<Module>.smethod_2(ushort_0 + 6, byte_0);
			<Module>.smethod_2(ushort_0 + 1, byte_2);
			<Module>.smethod_2(ushort_0 + 2, byte_3);
			<Module>.smethod_2(ushort_0 + 3, 0);
			<Module>.smethod_2(ushort_0 + 4, byte_4);
			<Module>.smethod_2(ushort_0 + 5, byte_5);
			<Module>.smethod_2(ushort_0 + 7, 194);
			<Module>.smethod_2(ushort_0 + 6, byte_0);
			uint num2;
			for (num2 = 0U; num2 <= num; num2 += 1U)
			{
				if (<Module>.GetAsyncKeyState(27) != null)
				{
					return 1;
				}
				if (<Module>.smethod_0(ushort_0 + 7) == byte_1)
				{
					break;
				}
			}
			return (num2 != num) ? 0 : 1;
		}

		// Token: 0x06000319 RID: 793 RVA: 0x0013ECB4 File Offset: 0x0013ECB4
		private unsafe int method_245(ushort ushort_0, byte byte_0, byte byte_1, byte byte_2)
		{
			uint num;
			if (ushort_0 == 0)
			{
				num = 512U;
			}
			else
			{
				num = 327680U;
			}
			uint num2 = 0U;
			while (num2 < num)
			{
				int result;
				if (<Module>.GetAsyncKeyState(27) == null)
				{
					this.method_242(ushort_0, byte_0, byte_1, 34816, 5);
					this.method_244(ushort_0, byte_0, byte_1, 1, 0, 1, 0);
					byte b;
					this.method_243(ushort_0, byte_0, byte_1, 1, &b);
					if (b != byte_2)
					{
						<Module>.Sleep(1);
						num2 += 1U;
						continue;
					}
					result = 0;
				}
				else
				{
					this.textBox6.AppendText("\r\n" + "Aborted by User!" + "\r\n");
					result = 1;
				}
				return result;
			}
			return 1;
		}

		// Token: 0x0600031A RID: 794 RVA: 0x0013ED48 File Offset: 0x0013ED48
		private int method_246(ushort ushort_0, byte byte_0, byte byte_1, uint uint_0, byte byte_2)
		{
			<Module>.smethod_2(ushort_0 + 6, byte_0);
			<Module>.smethod_2(ushort_0 + 4, (byte)(uint_0 & 255U));
			<Module>.smethod_2(ushort_0 + 5, (byte)((uint_0 & 65280U) >> 8));
			<Module>.smethod_2(ushort_0 + 6, (byte)((uint_0 & 16711680U) >> 16 | (uint)byte_0));
			<Module>.smethod_2(ushort_0 + 3, byte_2);
			<Module>.smethod_2(ushort_0 + 7, 1);
			<Module>.smethod_2(ushort_0 + 6, byte_0);
			for (uint num = 0U; num <= 327680U; num += 1U)
			{
				if (<Module>.smethod_0(ushort_0 + 7) == byte_1)
				{
					return 0;
				}
			}
			return 1;
		}

		// Token: 0x0600031B RID: 795 RVA: 0x0013EDE0 File Offset: 0x0013EDE0
		private unsafe int method_247(ushort ushort_0, byte byte_0, byte byte_1, uint uint_0, byte* pByte_0)
		{
			<Module>.smethod_2(ushort_0 + 6, byte_0);
			<Module>.smethod_2(ushort_0 + 4, (byte)(uint_0 & 255U));
			<Module>.smethod_2(ushort_0 + 5, (byte)((uint_0 & 65280U) >> 8));
			<Module>.smethod_2(ushort_0 + 6, (byte)((uint_0 & 16711680U) >> 16 | (uint)byte_0));
			<Module>.smethod_2(ushort_0 + 7, 0);
			<Module>.smethod_2(ushort_0 + 6, byte_0);
			uint num;
			for (num = 0U; num <= 327680U; num += 1U)
			{
				if (<Module>.smethod_0(ushort_0 + 7) == byte_1)
				{
					break;
				}
			}
			int result;
			if (num == 327680U)
			{
				result = 0;
			}
			else
			{
				*pByte_0 = <Module>.smethod_0(ushort_0 + 3);
				result = 1;
			}
			return result;
		}

		// Token: 0x0600031C RID: 796 RVA: 0x0013EE84 File Offset: 0x0013EE84
		private int method_248(ushort ushort_0, byte byte_0, byte byte_1)
		{
			<Module>.smethod_2(ushort_0 + 6, byte_0);
			for (uint num = 0U; num <= 327680U; num += 1U)
			{
				if (<Module>.smethod_0(ushort_0 + 7) == byte_1)
				{
					return 0;
				}
			}
			return 1;
		}

		// Token: 0x0600031D RID: 797 RVA: 0x0013EEC0 File Offset: 0x0013EEC0
		private byte method_249(ushort ushort_0, byte byte_0, byte byte_1, uint uint_0)
		{
			<Module>.smethod_2(ushort_0 + 6, byte_0);
			<Module>.smethod_2(ushort_0 + 4, (byte)(uint_0 & 255U));
			<Module>.smethod_2(ushort_0 + 5, (byte)((uint_0 & 65280U) >> 8));
			<Module>.smethod_2(ushort_0 + 6, (byte)((uint_0 & 16711680U) >> 16 | (uint)byte_0));
			<Module>.smethod_2(ushort_0 + 7, 0);
			<Module>.smethod_2(ushort_0 + 6, byte_0);
			for (uint num = 0U; num <= 327680U; num += 1U)
			{
				if (<Module>.smethod_0(ushort_0 + 7) == byte_1)
				{
					break;
				}
			}
			return <Module>.smethod_0(ushort_0 + 3);
		}

		// Token: 0x0600031E RID: 798 RVA: 0x0013EF54 File Offset: 0x0013EF54
		private uint method_250()
		{
			uint result;
			if (this.radioButton20.Checked)
			{
				result = this.method_252();
			}
			else if (this.radioButton19.Checked)
			{
				result = this.method_253();
			}
			else
			{
				result = this.method_254();
			}
			return result;
		}

		// Token: 0x0600031F RID: 799 RVA: 0x0013EF9C File Offset: 0x0013EF9C
		private uint method_251()
		{
			uint result;
			if (this.radioButton19.Checked)
			{
				result = this.method_259();
			}
			if (this.radioButton21.Checked)
			{
				result = this.method_260();
			}
			else
			{
				result = this.method_258();
			}
			return result;
		}

		// Token: 0x06000320 RID: 800 RVA: 0x0013EFE0 File Offset: 0x0013EFE0
		private unsafe uint method_252()
		{
			uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
			byte byte_ = *(ref <Module>.struct38_0 + selectedIndex * 72U + 4);
			ushort num = *(ref <Module>.struct38_0 + selectedIndex * 72U);
			if (num != 0)
			{
				<Module>.smethod_2(num + 6, byte_);
				<Module>.Sleep(250);
				<Module>.smethod_2(num + 6, byte_);
			}
			<Module>.smethod_2(num + 3, 42);
			<Module>.smethod_2(num + 7, 128);
			<Module>.Sleep(2);
			if (num != 0)
			{
				<Module>.smethod_2(num + 6, byte_);
			}
			uint result = (uint)<Module>.smethod_1(num + 7);
			<Module>.Sleep(1);
			return result;
		}

		// Token: 0x06000321 RID: 801 RVA: 0x0013F074 File Offset: 0x0013F074
		private unsafe uint method_253()
		{
			uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
			byte byte_ = *(ref <Module>.struct38_0 + selectedIndex * 72U + 4);
			ushort num = *(ref <Module>.struct38_0 + selectedIndex * 72U);
			if (num != 0)
			{
				<Module>.Sleep(250);
			}
			<Module>.smethod_2(num + 6, byte_);
			<Module>.smethod_2(num + 3, 217);
			<Module>.smethod_2(num + 7, 137);
			<Module>.Sleep(2);
			<Module>.smethod_2(num + 6, byte_);
			uint result = (uint)<Module>.smethod_1(num + 7);
			<Module>.Sleep(1);
			return result;
		}

		// Token: 0x06000322 RID: 802 RVA: 0x0013F100 File Offset: 0x0013F100
		private unsafe uint method_254()
		{
			uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
			byte byte_ = *(ref <Module>.struct38_0 + selectedIndex * 72U + 4);
			ushort num = *(ref <Module>.struct38_0 + selectedIndex * 72U);
			if (num != 0)
			{
				<Module>.Sleep(250);
			}
			<Module>.smethod_2(num + 6, byte_);
			<Module>.smethod_2(num + 3, 121);
			<Module>.smethod_2(num + 7, 141);
			<Module>.Sleep(2);
			<Module>.smethod_2(num + 6, byte_);
			uint result = (uint)<Module>.smethod_1(num + 7);
			<Module>.Sleep(1);
			return result;
		}

		// Token: 0x06000323 RID: 803 RVA: 0x0013F188 File Offset: 0x0013F188
		private unsafe uint method_255(byte byte_0, byte byte_1)
		{
			uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
			byte byte_2 = *(ref <Module>.struct38_0 + selectedIndex * 72U + 4);
			ushort num = *(ref <Module>.struct38_0 + selectedIndex * 72U);
			if (num != 0)
			{
				<Module>.Sleep(250);
			}
			<Module>.smethod_2(num + 6, byte_2);
			<Module>.smethod_2(num + 3, byte_0);
			<Module>.smethod_2(num + 7, byte_1);
			<Module>.Sleep(2);
			<Module>.smethod_2(num + 6, byte_2);
			uint result = (uint)<Module>.smethod_1(num + 7);
			<Module>.Sleep(1);
			return result;
		}

		// Token: 0x06000324 RID: 804 RVA: 0x0013F20C File Offset: 0x0013F20C
		private unsafe uint method_256()
		{
			Struct28 @struct = 0;
			initblk(ref @struct + 1, 0, 15);
			Struct43 struct2 = 0;
			initblk(ref struct2 + 1, 0, 255);
			uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
			byte byte_ = *(ref <Module>.struct38_0 + selectedIndex * 72U + 4);
			ushort num = *(ref <Module>.struct38_0 + selectedIndex * 72U);
			<Module>.smethod_2(num + 6, byte_);
			<Module>.Sleep(250);
			if (num == 0)
			{
				this.method_276(114, (byte*)(&struct2));
			}
			else
			{
				for (int i = 0; i < 256; i++)
				{
					<Module>.smethod_2(num + 6, byte_);
					<Module>.smethod_2(num + 2, 3);
					<Module>.smethod_2(num + 3, 217);
					<Module>.smethod_2(num + 4, (byte)i);
					<Module>.smethod_0(num + 7);
					<Module>.smethod_2(num + 7, 145);
					<Module>.smethod_0(num + 7);
					<Module>.smethod_2(num + 6, byte_);
					*(ref struct2 + i) = <Module>.smethod_1(num + 3);
					<Module>.smethod_0(num + 7);
				}
			}
			int num2;
			if (*(ref struct2 + 117) == 0 && *(ref struct2 + 118) == 0 && *(ref struct2 + 119) == 0)
			{
				num2 = 127;
			}
			else
			{
				num2 = 117;
			}
			uint result;
			if (*(ref struct2 + 127) == *(ref struct2 + 128) && *(ref struct2 + 127) == *(ref struct2 + 129) && *(ref struct2 + 127) == *(ref struct2 + 130) && *(ref struct2 + 127) == *(ref struct2 + 131))
			{
				result = 0U;
			}
			else
			{
				for (int i = 0; i < 16; i++)
				{
					*(ref @struct + i) = (*(ref struct2 + (i + num2)) ^ (byte)((sbyte)i));
				}
				<Module>.memcpy(*(ref <Module>.struct123_0 + 8) + 280, (void*)(&@struct), 16U);
				result = 1U;
			}
			return result;
		}

		// Token: 0x06000325 RID: 805 RVA: 0x0013F3AC File Offset: 0x0013F3AC
		private unsafe uint method_257()
		{
			uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
			byte byte_ = *(ref <Module>.struct38_0 + selectedIndex * 72U + 4);
			ushort num = *(ref <Module>.struct38_0 + selectedIndex * 72U);
			<Module>.smethod_2(num + 6, byte_);
			<Module>.Sleep(250);
			<Module>.smethod_2(num + 6, byte_);
			<Module>.smethod_2(num + 3, 46);
			<Module>.smethod_2(num + 7, 128);
			<Module>.Sleep(2);
			<Module>.smethod_2(num + 6, byte_);
			uint result = (uint)<Module>.smethod_1(num + 7);
			<Module>.Sleep(1);
			return result;
		}

		// Token: 0x06000326 RID: 806 RVA: 0x0013F43C File Offset: 0x0013F43C
		private unsafe uint method_258()
		{
			uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
			byte byte_ = *(ref <Module>.struct38_0 + selectedIndex * 72U + 4);
			ushort num = *(ref <Module>.struct38_0 + selectedIndex * 72U);
			uint result;
			if (num == 0)
			{
				<Module>.smethod_2(num + 7, 129);
				<Module>.smethod_2(num + 8, 4);
				<Module>.Sleep(1);
				<Module>.smethod_2(num + 8, 0);
				<Module>.Sleep(100);
				result = <Module>.smethod_0(7);
			}
			else
			{
				<Module>.smethod_2(num + 6, byte_);
				<Module>.smethod_2(num + 7, 129);
				<Module>.smethod_2(num + 6, byte_);
				<Module>.smethod_2(num + 7, 8);
				result = (uint)<Module>.smethod_1(num + 7);
			}
			<Module>.Sleep(350);
			return result;
		}

		// Token: 0x06000327 RID: 807 RVA: 0x0013F4F0 File Offset: 0x0013F4F0
		private unsafe uint method_259()
		{
			uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
			byte byte_ = *(ref <Module>.struct38_0 + selectedIndex * 72U + 4);
			ushort num = *(ref <Module>.struct38_0 + selectedIndex * 72U);
			<Module>.smethod_2(num + 6, byte_);
			<Module>.smethod_2(num + 7, 240);
			<Module>.Sleep(250);
			<Module>.smethod_2(num + 6, byte_);
			<Module>.smethod_2(num + 7, 8);
			<Module>.Sleep(500);
			return (uint)<Module>.smethod_1(num + 7);
		}

		// Token: 0x06000328 RID: 808 RVA: 0x0013F574 File Offset: 0x0013F574
		private unsafe uint method_260()
		{
			uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
			byte byte_ = *(ref <Module>.struct38_0 + selectedIndex * 72U + 4);
			ushort num = *(ref <Module>.struct38_0 + selectedIndex * 72U);
			<Module>.smethod_2(num + 6, byte_);
			<Module>.smethod_2(num + 7, 190);
			<Module>.Sleep(250);
			<Module>.smethod_2(num + 6, byte_);
			<Module>.smethod_2(num + 7, 8);
			<Module>.Sleep(500);
			return (uint)<Module>.smethod_1(num + 7);
		}

		// Token: 0x06000329 RID: 809 RVA: 0x0013F5F8 File Offset: 0x0013F5F8
		private unsafe int method_261()
		{
			uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
			byte byte_ = *(ref <Module>.struct38_0 + selectedIndex * 72U + 4);
			ushort num = *(ref <Module>.struct38_0 + selectedIndex * 72U);
			this.textBox6.AppendText("\r\n" + "Getting Status from port " + this.label123.Text + "\r\n");
			<Module>.smethod_2(num + 6, byte_);
			<Module>.Sleep(20);
			uint result = (uint)<Module>.smethod_1(num + 7);
			<Module>.Sleep(1);
			return (int)result;
		}

		// Token: 0x0600032A RID: 810 RVA: 0x0013F67C File Offset: 0x0013F67C
		private unsafe void method_262()
		{
			if (this.bool_2)
			{
				string text = this.string_10 + "\\SAM-OFW.bin";
				for (int i = 1; i < 10; i++)
				{
					if (!File.Exists(text))
					{
						IntPtr intPtr = Marshal.StringToHGlobalAnsi(text);
						IntPtr value = intPtr;
						sbyte* pSbyte_ = (sbyte*)((void*)value);
						GStruct5* ptr = <Module>.fopen((sbyte*)pSbyte_, (sbyte*)(&<Module>.struct18_5));
						if (ptr != null)
						{
							<Module>.fwrite(*(ref <Module>.struct121_0 + 7172), 262144U, 1U, ptr);
							<Module>.fclose(ptr);
							this.textBox6.AppendText("\r\n" + "Samsung Dump file saved to " + text + "\r\n");
							this.method_37(text, 0, *(ref <Module>.struct121_0 + 7172));
							return;
						}
					}
					else
					{
						text = this.string_10 + "\\SAM-OFW_" + Convert.ToString(i) + ".bin";
					}
				}
			}
			SaveFileDialog saveFileDialog = new SaveFileDialog();
			saveFileDialog.Filter = "Firmware Images (*.bin)|*.bin|All Files (*.*)|*.*";
			saveFileDialog.DefaultExt = ".bin";
			saveFileDialog.FileName = "SAM-OFW.bin";
			saveFileDialog.RestoreDirectory = false;
			if (this.bool_2)
			{
				saveFileDialog.InitialDirectory = this.string_10;
			}
			if (saveFileDialog.ShowDialog() == DialogResult.OK)
			{
				string fullPath = Path.GetFullPath(saveFileDialog.FileName);
				string fileName = Path.GetFileName(saveFileDialog.FileName);
				IntPtr intPtr2 = Marshal.StringToHGlobalAnsi(fullPath);
				IntPtr value2 = intPtr2;
				sbyte* pSbyte_2 = (sbyte*)((void*)value2);
				GStruct5* ptr = <Module>.fopen((sbyte*)pSbyte_2, (sbyte*)(&<Module>.struct18_5));
				if (ptr == null)
				{
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					MessageBox.Show(fileName, "Can't open file", MessageBoxButtons.OK);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
				}
				else
				{
					<Module>.fwrite(*(ref <Module>.struct121_0 + 7172), 262144U, 1U, ptr);
					<Module>.fclose(ptr);
					this.textBox6.AppendText("\r\n" + "Samsung Dump file saved to " + fileName + "\r\n");
					this.method_37(fullPath, 0, *(ref <Module>.struct121_0 + 7172));
				}
			}
			else
			{
				this.method_37("", 0, *(ref <Module>.struct121_0 + 7172));
			}
		}

		// Token: 0x0600032B RID: 811 RVA: 0x0013F8AC File Offset: 0x0013F8AC
		private unsafe void method_263()
		{
			if (this.bool_2)
			{
				string text = this.string_10 + "\\BENQ-OFW.bin";
				for (int i = 1; i < 10; i++)
				{
					if (!File.Exists(text))
					{
						IntPtr intPtr = Marshal.StringToHGlobalAnsi(text);
						IntPtr value = intPtr;
						sbyte* pSbyte_ = (sbyte*)((void*)value);
						GStruct5* ptr = <Module>.fopen((sbyte*)pSbyte_, (sbyte*)(&<Module>.struct18_5));
						if (ptr != null)
						{
							<Module>.fwrite(*(ref <Module>.struct121_0 + 7172), 262144U, 1U, ptr);
							<Module>.fclose(ptr);
							this.textBox6.AppendText("\r\n" + "Benq Dump file saved to " + text + "\r\n");
							this.method_37(text, 0, *(ref <Module>.struct121_0 + 7172));
							return;
						}
					}
					else
					{
						text = this.string_10 + "\\BENQ-OFW_" + Convert.ToString(i) + ".bin";
					}
				}
			}
			SaveFileDialog saveFileDialog = new SaveFileDialog();
			saveFileDialog.Filter = "Firmware Images (*.bin)|*.bin|All Files (*.*)|*.*";
			saveFileDialog.DefaultExt = ".bin";
			saveFileDialog.FileName = "BENQ-OFW.bin";
			saveFileDialog.RestoreDirectory = false;
			if (this.bool_2)
			{
				saveFileDialog.InitialDirectory = this.string_10;
			}
			if (saveFileDialog.ShowDialog() == DialogResult.OK)
			{
				string fullPath = Path.GetFullPath(saveFileDialog.FileName);
				string fileName = Path.GetFileName(saveFileDialog.FileName);
				IntPtr intPtr2 = Marshal.StringToHGlobalAnsi(fullPath);
				IntPtr value2 = intPtr2;
				sbyte* pSbyte_ = (sbyte*)((void*)value2);
				GStruct5* ptr = <Module>.fopen((sbyte*)pSbyte_, (sbyte*)(&<Module>.struct18_5));
				if (ptr == null)
				{
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					MessageBox.Show(fileName, "Can't open file", MessageBoxButtons.OK);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
				}
				else
				{
					<Module>.fwrite(*(ref <Module>.struct121_0 + 7172), 262144U, 1U, ptr);
					<Module>.fclose(ptr);
					this.textBox6.AppendText("\r\n" + "Benq Dump file saved to " + fileName + "\r\n");
					this.method_37(fullPath, 0, *(ref <Module>.struct121_0 + 7172));
				}
			}
			else
			{
				this.method_37("", 0, *(ref <Module>.struct121_0 + 7172));
			}
		}

		// Token: 0x0600032C RID: 812 RVA: 0x0013FADC File Offset: 0x0013FADC
		private unsafe void method_264()
		{
			if (this.bool_2)
			{
				string text = this.string_10 + "\\Lite-OFW.bin";
				for (int i = 1; i < 10; i++)
				{
					if (!File.Exists(text))
					{
						IntPtr intPtr = Marshal.StringToHGlobalAnsi(text);
						IntPtr value = intPtr;
						sbyte* pSbyte_ = (sbyte*)((void*)value);
						GStruct5* ptr = <Module>.fopen((sbyte*)pSbyte_, (sbyte*)(&<Module>.struct18_5));
						if (ptr != null)
						{
							<Module>.fwrite(*(ref <Module>.struct121_0 + 7172), 262144U, 1U, ptr);
							<Module>.fclose(ptr);
							this.textBox6.AppendText("\r\n" + "Lite-On Dump file saved to " + text + "\r\n");
							this.method_37(text, 0, *(ref <Module>.struct121_0 + 7172));
							return;
						}
					}
					else
					{
						text = this.string_10 + "\\Lite-OFW_" + Convert.ToString(i) + ".bin";
					}
				}
			}
			SaveFileDialog saveFileDialog = new SaveFileDialog();
			saveFileDialog.Filter = "Firmware Images (*.bin)|*.bin|All Files (*.*)|*.*";
			saveFileDialog.DefaultExt = ".bin";
			saveFileDialog.FileName = "Lite-OFW.bin";
			saveFileDialog.RestoreDirectory = false;
			if (this.bool_2)
			{
				saveFileDialog.InitialDirectory = this.string_10;
			}
			if (saveFileDialog.ShowDialog() == DialogResult.OK)
			{
				string fullPath = Path.GetFullPath(saveFileDialog.FileName);
				string fileName = Path.GetFileName(saveFileDialog.FileName);
				IntPtr intPtr2 = Marshal.StringToHGlobalAnsi(fullPath);
				IntPtr value2 = intPtr2;
				sbyte* pSbyte_2 = (sbyte*)((void*)value2);
				GStruct5* ptr = <Module>.fopen((sbyte*)pSbyte_2, (sbyte*)(&<Module>.struct18_5));
				if (ptr == null)
				{
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					MessageBox.Show(fileName, "Can't open file", MessageBoxButtons.OK);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
				}
				else
				{
					<Module>.fwrite(*(ref <Module>.struct121_0 + 7172), 262144U, 1U, ptr);
					<Module>.fclose(ptr);
					this.textBox6.AppendText("\r\n" + "Lite-On Dump file saved to " + fileName + "\r\n");
					this.method_37(fullPath, 0, *(ref <Module>.struct121_0 + 7172));
				}
			}
			else
			{
				this.method_37("", 0, *(ref <Module>.struct121_0 + 7172));
			}
		}

		// Token: 0x0600032D RID: 813 RVA: 0x0013FD0C File Offset: 0x0013FD0C
		private unsafe int method_265(byte byte_0, ushort ushort_0, byte byte_1, byte* pByte_0)
		{
			Struct3 @struct = 0;
			initblk(ref @struct + 1, 0, 63);
			Struct3 struct2 = 0;
			initblk(ref struct2 + 1, 0, 63);
			int num = 0;
			uint int_ = 6U;
			uint int_2 = (uint)(byte_1 + 6);
			@struct = 80;
			*(ref @struct + 1) = (byte)((sbyte)byte_0);
			*(ref @struct + 3) = (byte)((sbyte)byte_1);
			*(ref @struct + 4) = (byte)(ushort_0 & 255);
			*(ref @struct + 5) = (byte)((ushort_0 & 65280) >> 8);
			while (num != 8)
			{
				if (this.method_416((sbyte*)(&@struct), (int)int_, (sbyte*)(&struct2), (int)int_2) == 1)
				{
					int result;
					if (struct2 == 80 && *(ref struct2 + 2) == (sbyte)byte_0)
					{
						<Module>.memcpy((void*)pByte_0, ref struct2 + 6, (uint)byte_1);
						result = 1;
					}
					else
					{
						if (struct2 != 81)
						{
							num++;
							continue;
						}
						if (*(ref struct2 + 2) != (sbyte)byte_0)
						{
							num++;
							continue;
						}
						result = 0;
					}
					return result;
				}
				num++;
			}
			return 0;
		}

		// Token: 0x0600032E RID: 814 RVA: 0x0013FDC4 File Offset: 0x0013FDC4
		private unsafe int method_266(byte byte_0, byte* pByte_0)
		{
			Struct3 @struct = 0;
			initblk(ref @struct + 1, 0, 63);
			Struct105 struct2 = 0;
			initblk(ref struct2 + 1, 0, 285);
			int num = 0;
			@struct = 83;
			*(ref @struct + 1) = (byte)((sbyte)byte_0);
			while (num != 8)
			{
				if (<Module>.usb_bulk_write(<Module>.gstruct10_0, 1, (sbyte*)(&@struct), 6, 2000) == 6)
				{
					int num2 = <Module>.usb_bulk_read(<Module>.gstruct10_0, 129, (sbyte*)(&struct2), 286, 2000);
					if (num2 == 286)
					{
						if (*(ref struct2 + 2) != (sbyte)byte_0)
						{
							num++;
						}
						else if (*(ref struct2 + 66) != (sbyte)byte_0)
						{
							num++;
						}
						else if (*(ref struct2 + 130) != (sbyte)byte_0)
						{
							num++;
						}
						else if (*(ref struct2 + 194) != (sbyte)byte_0)
						{
							num++;
						}
						else
						{
							if (*(ref struct2 + 258) == (sbyte)byte_0)
							{
								<Module>.memcpy((void*)pByte_0, ref struct2 + 6, 58U);
								<Module>.memcpy((void*)(pByte_0 + 58), ref struct2 + 70, 58U);
								<Module>.memcpy((void*)(pByte_0 + 116), ref struct2 + 134, 58U);
								<Module>.memcpy((void*)(pByte_0 + 174), ref struct2 + 198, 58U);
								<Module>.memcpy((void*)(pByte_0 + 232), ref struct2 + 262, 24U);
								return 1;
							}
							num++;
						}
					}
					else
					{
						num++;
					}
				}
				else
				{
					num++;
				}
			}
			return 0;
		}

		// Token: 0x0600032F RID: 815 RVA: 0x0013FF18 File Offset: 0x0013FF18
		private unsafe int method_267(byte byte_0, byte* pByte_0)
		{
			Struct3 @struct = 0;
			initblk(ref @struct + 1, 0, 63);
			Struct106 struct2 = 0;
			initblk(ref struct2 + 1, 0, 293);
			int num = 0;
			@struct = 99;
			*(ref @struct + 1) = (byte)((sbyte)byte_0);
			while (num != 8)
			{
				if (<Module>.usb_bulk_write(<Module>.gstruct10_0, 1, (sbyte*)(&@struct), 6, 2000) == 6)
				{
					int num2 = <Module>.usb_bulk_read(<Module>.gstruct10_0, 129, (sbyte*)(&struct2), 294, 2000);
					if (num2 == 294)
					{
						if (*(ref struct2 + 2) != (sbyte)byte_0)
						{
							num++;
						}
						else if (*(ref struct2 + 66) != (sbyte)byte_0)
						{
							num++;
						}
						else if (*(ref struct2 + 130) != (sbyte)byte_0)
						{
							num++;
						}
						else if (*(ref struct2 + 194) != (sbyte)byte_0)
						{
							num++;
						}
						else
						{
							if (*(ref struct2 + 258) == (sbyte)byte_0)
							{
								<Module>.memcpy((void*)pByte_0, ref struct2 + 6, 56U);
								<Module>.memcpy((void*)(pByte_0 + 56), ref struct2 + 70, 56U);
								<Module>.memcpy((void*)(pByte_0 + 112), ref struct2 + 134, 56U);
								<Module>.memcpy((void*)(pByte_0 + 168), ref struct2 + 198, 56U);
								<Module>.memcpy((void*)(pByte_0 + 224), ref struct2 + 262, 32U);
								return 1;
							}
							num++;
						}
					}
					else
					{
						num++;
					}
				}
				else
				{
					num++;
				}
			}
			return 0;
		}

		// Token: 0x06000330 RID: 816 RVA: 0x0014006C File Offset: 0x0014006C
		private unsafe int method_268(byte byte_0, byte* pByte_0)
		{
			Struct3 @struct = 0;
			initblk(ref @struct + 1, 0, 63);
			Struct105 struct2 = 0;
			initblk(ref struct2 + 1, 0, 285);
			int num = 0;
			@struct = -109;
			*(ref @struct + 1) = (byte)((sbyte)byte_0);
			while (num != 8)
			{
				if (<Module>.usb_bulk_write(<Module>.gstruct10_0, 1, (sbyte*)(&@struct), 6, 2000) == 6)
				{
					int num2 = <Module>.usb_bulk_read(<Module>.gstruct10_0, 129, (sbyte*)(&struct2), 286, 2000);
					if (num2 == 286)
					{
						if (*(ref struct2 + 2) != (sbyte)byte_0)
						{
							num++;
						}
						else if (*(ref struct2 + 66) != (sbyte)byte_0)
						{
							num++;
						}
						else if (*(ref struct2 + 130) != (sbyte)byte_0)
						{
							num++;
						}
						else if (*(ref struct2 + 194) != (sbyte)byte_0)
						{
							num++;
						}
						else
						{
							if (*(ref struct2 + 258) == (sbyte)byte_0)
							{
								<Module>.memcpy((void*)pByte_0, ref struct2 + 6, 58U);
								<Module>.memcpy((void*)(pByte_0 + 58), ref struct2 + 70, 58U);
								<Module>.memcpy((void*)(pByte_0 + 116), ref struct2 + 134, 58U);
								<Module>.memcpy((void*)(pByte_0 + 174), ref struct2 + 198, 58U);
								<Module>.memcpy((void*)(pByte_0 + 232), ref struct2 + 262, 24U);
								return 1;
							}
							num++;
						}
					}
					else
					{
						num++;
					}
				}
				else
				{
					num++;
				}
			}
			return 0;
		}

		// Token: 0x06000331 RID: 817 RVA: 0x001401C0 File Offset: 0x001401C0
		private unsafe int method_269(byte byte_0, ushort ushort_0, byte byte_1, byte* pByte_0)
		{
			Struct3 @struct = 0;
			initblk(ref @struct + 1, 0, 63);
			Struct3 struct2 = 0;
			initblk(ref struct2 + 1, 0, 63);
			int int_ = (int)(byte_1 + 6);
			int int_2 = 6;
			int num = 0;
			@struct = 81;
			*(ref @struct + 1) = (byte)((sbyte)byte_0);
			*(ref @struct + 3) = (byte)((sbyte)byte_1);
			*(ref @struct + 4) = (byte)(ushort_0 & 255);
			*(ref @struct + 5) = (byte)((ushort_0 & 65280) >> 8);
			<Module>.memcpy(ref @struct + 6, (void*)pByte_0, (uint)byte_1);
			while (num != 8)
			{
				if (this.method_416((sbyte*)(&@struct), int_, (sbyte*)(&struct2), int_2) == 1)
				{
					int result;
					if (struct2 == 81 && *(ref struct2 + 2) == (sbyte)byte_0)
					{
						result = 1;
					}
					else
					{
						if (struct2 != 81)
						{
							num++;
							continue;
						}
						if (*(ref struct2 + 2) != (sbyte)byte_0)
						{
							num++;
							continue;
						}
						result = 0;
					}
					return result;
				}
				num++;
			}
			return 0;
		}

		// Token: 0x06000332 RID: 818 RVA: 0x00140278 File Offset: 0x00140278
		private unsafe int method_270(byte byte_0, byte* pByte_0)
		{
			Struct107 @struct = 0;
			initblk(ref @struct + 1, 0, 511);
			Struct3 struct2 = 0;
			initblk(ref struct2 + 1, 0, 63);
			int num = 0;
			@struct = 84;
			*(ref @struct + 1) = (byte)((sbyte)byte_0);
			<Module>.memcpy(ref @struct + 2, (void*)pByte_0, 260U);
			while (num != 8)
			{
				if (<Module>.usb_bulk_write(<Module>.gstruct10_0, 1, (sbyte*)(&@struct), 262, 1000) == 262)
				{
					if (<Module>.usb_bulk_read(<Module>.gstruct10_0, 129, (sbyte*)(&struct2), 2, 1000) == 2)
					{
						int result;
						if (struct2 == 84 && *(ref struct2 + 1) == (sbyte)byte_0)
						{
							result = 1;
						}
						else
						{
							if (struct2 != 84)
							{
								num++;
								continue;
							}
							if (*(ref struct2 + 2) != (sbyte)byte_0)
							{
								num++;
								continue;
							}
							result = 0;
						}
						return result;
					}
					num++;
				}
				else
				{
					num++;
				}
			}
			return 0;
		}

		// Token: 0x06000333 RID: 819 RVA: 0x00140350 File Offset: 0x00140350
		private unsafe int method_271(byte byte_0, byte* pByte_0)
		{
			Struct107 @struct = 0;
			initblk(ref @struct + 1, 0, 511);
			Struct3 struct2 = 0;
			initblk(ref struct2 + 1, 0, 63);
			int num = 0;
			@struct = 100;
			*(ref @struct + 1) = (byte)((sbyte)byte_0);
			*(ref @struct + 2) = 0;
			*(ref @struct + 3) = 0;
			<Module>.memcpy(ref @struct + 4, (void*)pByte_0, 260U);
			while (num != 8)
			{
				int num2 = <Module>.usb_bulk_write(<Module>.gstruct10_0, 1, (sbyte*)(&@struct), 264, 5000);
				if (num2 == 264)
				{
					num2 = <Module>.usb_bulk_read(<Module>.gstruct10_0, 129, (sbyte*)(&struct2), 6, 5000);
					if (num2 == 6)
					{
						int result;
						if (struct2 == 100 && *(ref struct2 + 1) == 88)
						{
							result = 1;
						}
						else
						{
							if (struct2 != 100)
							{
								num++;
								continue;
							}
							if (*(ref struct2 + 2) != (sbyte)byte_0)
							{
								num++;
								continue;
							}
							result = 0;
						}
						return result;
					}
					num++;
				}
				else
				{
					num++;
				}
			}
			return 0;
		}

		// Token: 0x06000334 RID: 820 RVA: 0x0014043C File Offset: 0x0014043C
		private unsafe int method_272(byte byte_0, byte byte_1, byte byte_2, byte byte_3, byte byte_4)
		{
			Struct3 @struct = 0;
			initblk(ref @struct + 1, 0, 63);
			Struct3 struct2 = 0;
			initblk(ref struct2 + 1, 0, 63);
			int int_ = 7;
			int int_2 = 7;
			int num = 0;
			@struct = 82;
			*(ref @struct + 1) = (byte)((sbyte)byte_0);
			*(ref @struct + 3) = (byte)((sbyte)byte_1);
			*(ref @struct + 4) = (byte)((sbyte)byte_2);
			*(ref @struct + 5) = (byte)((sbyte)byte_3);
			*(ref @struct + 6) = (byte)((sbyte)byte_4);
			while (num != 8)
			{
				if (this.method_416((sbyte*)(&@struct), int_, (sbyte*)(&struct2), int_2) == 1)
				{
					int result;
					if (struct2 == 82 && *(ref struct2 + 2) == (sbyte)byte_0)
					{
						result = 1;
					}
					else
					{
						if (struct2 != 81)
						{
							num++;
							continue;
						}
						if (*(ref struct2 + 2) != (sbyte)byte_0)
						{
							num++;
							continue;
						}
						result = 0;
					}
					return result;
				}
				num++;
			}
			return 0;
		}

		// Token: 0x06000335 RID: 821 RVA: 0x001404E4 File Offset: 0x001404E4
		private unsafe int method_273(byte byte_0, ushort ushort_0, byte byte_1, byte* pByte_0)
		{
			Struct3 @struct = 0;
			initblk(ref @struct + 1, 0, 63);
			Struct3 struct2 = 0;
			initblk(ref struct2 + 1, 0, 63);
			int num = 0;
			uint int_ = 6U;
			uint int_2 = (uint)(byte_1 + 6);
			@struct = 112;
			*(ref @struct + 1) = (byte)((sbyte)byte_0);
			*(ref @struct + 3) = (byte)((sbyte)byte_1);
			*(ref @struct + 4) = (byte)(ushort_0 & 255);
			*(ref @struct + 5) = (byte)((ushort_0 & 65280) >> 8);
			while (num != 8)
			{
				if (this.method_416((sbyte*)(&@struct), (int)int_, (sbyte*)(&struct2), (int)int_2) == 1)
				{
					int result;
					if (struct2 == 112 && *(ref struct2 + 2) == (sbyte)byte_0)
					{
						<Module>.memcpy((void*)pByte_0, ref struct2 + 6, (uint)byte_1);
						result = 1;
					}
					else
					{
						if (struct2 != 112)
						{
							num++;
							continue;
						}
						if (*(ref struct2 + 2) != (sbyte)byte_0)
						{
							num++;
							continue;
						}
						result = 0;
					}
					return result;
				}
				num++;
			}
			return 0;
		}

		// Token: 0x06000336 RID: 822 RVA: 0x0014059C File Offset: 0x0014059C
		private unsafe int method_274(byte byte_0, byte* pByte_0)
		{
			Struct3 @struct = 0;
			initblk(ref @struct + 1, 0, 63);
			Struct105 struct2 = 0;
			initblk(ref struct2 + 1, 0, 285);
			int num = 0;
			@struct = 115;
			*(ref @struct + 1) = (byte)((sbyte)byte_0);
			while (num != 8)
			{
				if (<Module>.usb_bulk_write(<Module>.gstruct10_0, 1, (sbyte*)(&@struct), 6, 2000) == 6)
				{
					int num2 = <Module>.usb_bulk_read(<Module>.gstruct10_0, 129, (sbyte*)(&struct2), 286, 2000);
					if (num2 == 286)
					{
						if (*(ref struct2 + 2) != (sbyte)byte_0)
						{
							num++;
						}
						else if (*(ref struct2 + 66) != (sbyte)byte_0)
						{
							num++;
						}
						else if (*(ref struct2 + 130) != (sbyte)byte_0)
						{
							num++;
						}
						else if (*(ref struct2 + 194) != (sbyte)byte_0)
						{
							num++;
						}
						else
						{
							if (*(ref struct2 + 258) == (sbyte)byte_0)
							{
								<Module>.memcpy((void*)pByte_0, ref struct2 + 6, 58U);
								<Module>.memcpy((void*)(pByte_0 + 58), ref struct2 + 70, 58U);
								<Module>.memcpy((void*)(pByte_0 + 116), ref struct2 + 134, 58U);
								<Module>.memcpy((void*)(pByte_0 + 174), ref struct2 + 198, 58U);
								<Module>.memcpy((void*)(pByte_0 + 232), ref struct2 + 262, 24U);
								return 1;
							}
							num++;
						}
					}
					else
					{
						num++;
					}
				}
				else
				{
					num++;
				}
			}
			return 0;
		}

		// Token: 0x06000337 RID: 823 RVA: 0x001406F0 File Offset: 0x001406F0
		private unsafe int method_275(byte byte_0, byte* pByte_0)
		{
			Struct3 @struct = 0;
			initblk(ref @struct + 1, 0, 63);
			Struct106 struct2 = 0;
			initblk(ref struct2 + 1, 0, 293);
			int num = 0;
			@struct = -125;
			*(ref @struct + 1) = (byte)((sbyte)byte_0);
			while (num != 8)
			{
				if (<Module>.usb_bulk_write(<Module>.gstruct10_0, 1, (sbyte*)(&@struct), 6, 2000) == 6)
				{
					int num2 = <Module>.usb_bulk_read(<Module>.gstruct10_0, 129, (sbyte*)(&struct2), 294, 2000);
					if (num2 == 294)
					{
						if (*(ref struct2 + 2) != (sbyte)byte_0)
						{
							num++;
						}
						else if (*(ref struct2 + 66) != (sbyte)byte_0)
						{
							num++;
						}
						else if (*(ref struct2 + 130) != (sbyte)byte_0)
						{
							num++;
						}
						else if (*(ref struct2 + 194) != (sbyte)byte_0)
						{
							num++;
						}
						else
						{
							if (*(ref struct2 + 258) == (sbyte)byte_0)
							{
								<Module>.memcpy((void*)pByte_0, ref struct2 + 6, 56U);
								<Module>.memcpy((void*)(pByte_0 + 56), ref struct2 + 70, 56U);
								<Module>.memcpy((void*)(pByte_0 + 112), ref struct2 + 134, 56U);
								<Module>.memcpy((void*)(pByte_0 + 168), ref struct2 + 198, 56U);
								<Module>.memcpy((void*)(pByte_0 + 224), ref struct2 + 262, 32U);
								return 1;
							}
							num++;
						}
					}
					else
					{
						num++;
					}
				}
				else
				{
					num++;
				}
			}
			return 0;
		}

		// Token: 0x06000338 RID: 824 RVA: 0x00140844 File Offset: 0x00140844
		private unsafe int method_276(byte byte_0, byte* pByte_0)
		{
			Struct3 @struct = 0;
			initblk(ref @struct + 1, 0, 63);
			Struct105 struct2 = 0;
			initblk(ref struct2 + 1, 0, 285);
			int num = 0;
			@struct = -108;
			*(ref @struct + 1) = (byte)((sbyte)byte_0);
			while (num != 8)
			{
				if (<Module>.usb_bulk_write(<Module>.gstruct10_0, 1, (sbyte*)(&@struct), 6, 2000) == 6)
				{
					int num2 = <Module>.usb_bulk_read(<Module>.gstruct10_0, 129, (sbyte*)(&struct2), 286, 2000);
					if (num2 == 286)
					{
						if (*(ref struct2 + 2) != (sbyte)byte_0)
						{
							num++;
						}
						else if (*(ref struct2 + 66) != (sbyte)byte_0)
						{
							num++;
						}
						else if (*(ref struct2 + 130) != (sbyte)byte_0)
						{
							num++;
						}
						else if (*(ref struct2 + 194) != (sbyte)byte_0)
						{
							num++;
						}
						else
						{
							if (*(ref struct2 + 258) == (sbyte)byte_0)
							{
								<Module>.memcpy((void*)pByte_0, ref struct2 + 6, 58U);
								<Module>.memcpy((void*)(pByte_0 + 58), ref struct2 + 70, 58U);
								<Module>.memcpy((void*)(pByte_0 + 116), ref struct2 + 134, 58U);
								<Module>.memcpy((void*)(pByte_0 + 174), ref struct2 + 198, 58U);
								<Module>.memcpy((void*)(pByte_0 + 232), ref struct2 + 262, 24U);
								return 1;
							}
							num++;
						}
					}
					else
					{
						num++;
					}
				}
				else
				{
					num++;
				}
			}
			return 0;
		}

		// Token: 0x06000339 RID: 825 RVA: 0x00140998 File Offset: 0x00140998
		private unsafe int method_277(byte byte_0, ushort ushort_0, byte byte_1, byte* pByte_0)
		{
			Struct3 @struct = 0;
			initblk(ref @struct + 1, 0, 63);
			Struct3 struct2 = 0;
			initblk(ref struct2 + 1, 0, 63);
			int int_ = (int)(byte_1 + 6);
			int int_2 = 6;
			int num = 0;
			@struct = 113;
			*(ref @struct + 1) = (byte)((sbyte)byte_0);
			*(ref @struct + 3) = (byte)((sbyte)byte_1);
			*(ref @struct + 4) = (byte)(ushort_0 & 255);
			*(ref @struct + 5) = (byte)((ushort_0 & 65280) >> 8);
			<Module>.memcpy(ref @struct + 6, (void*)pByte_0, (uint)byte_1);
			while (num != 8)
			{
				if (this.method_416((sbyte*)(&@struct), int_, (sbyte*)(&struct2), int_2) == 1)
				{
					int result;
					if (struct2 == 113 && *(ref struct2 + 2) == (sbyte)byte_0)
					{
						result = 1;
					}
					else
					{
						if (struct2 != 113)
						{
							num++;
							continue;
						}
						if (*(ref struct2 + 2) != (sbyte)byte_0)
						{
							num++;
							continue;
						}
						result = 0;
					}
					return result;
				}
				num++;
			}
			return 0;
		}

		// Token: 0x0600033A RID: 826 RVA: 0x00140A50 File Offset: 0x00140A50
		private unsafe int method_278(byte byte_0, byte* pByte_0)
		{
			Struct107 @struct = 0;
			initblk(ref @struct + 1, 0, 511);
			Struct3 struct2 = 0;
			initblk(ref struct2 + 1, 0, 63);
			int num = 0;
			@struct = 116;
			*(ref @struct + 1) = (byte)((sbyte)byte_0);
			<Module>.memcpy(ref @struct + 2, (void*)pByte_0, 260U);
			while (num != 8)
			{
				if (<Module>.usb_bulk_write(<Module>.gstruct10_0, 1, (sbyte*)(&@struct), 262, 1000) == 262)
				{
					if (<Module>.usb_bulk_read(<Module>.gstruct10_0, 129, (sbyte*)(&struct2), 2, 1000) == 2)
					{
						int result;
						if (struct2 == 116 && *(ref struct2 + 1) == (sbyte)byte_0)
						{
							result = 1;
						}
						else
						{
							if (struct2 != 116)
							{
								num++;
								continue;
							}
							if (*(ref struct2 + 2) != (sbyte)byte_0)
							{
								num++;
								continue;
							}
							result = 0;
						}
						return result;
					}
					num++;
				}
				else
				{
					num++;
				}
			}
			return 0;
		}

		// Token: 0x0600033B RID: 827 RVA: 0x00140B28 File Offset: 0x00140B28
		private unsafe int method_279(byte byte_0, byte byte_1, byte byte_2, byte byte_3, byte byte_4)
		{
			Struct3 @struct = 0;
			initblk(ref @struct + 1, 0, 63);
			Struct3 struct2 = 0;
			initblk(ref struct2 + 1, 0, 63);
			int int_ = 7;
			int int_2 = 7;
			int num = 0;
			@struct = 114;
			*(ref @struct + 1) = (byte)((sbyte)byte_0);
			*(ref @struct + 3) = (byte)((sbyte)byte_1);
			*(ref @struct + 4) = (byte)((sbyte)byte_2);
			*(ref @struct + 5) = (byte)((sbyte)byte_3);
			*(ref @struct + 6) = (byte)((sbyte)byte_4);
			while (num != 8)
			{
				if (this.method_416((sbyte*)(&@struct), int_, (sbyte*)(&struct2), int_2) == 1)
				{
					int result;
					if (struct2 == 114 && *(ref struct2 + 2) == (sbyte)byte_0)
					{
						result = 1;
					}
					else
					{
						if (struct2 != 114)
						{
							num++;
							continue;
						}
						if (*(ref struct2 + 2) != (sbyte)byte_0)
						{
							num++;
							continue;
						}
						result = 0;
					}
					return result;
				}
				num++;
			}
			return 0;
		}

		// Token: 0x0600033C RID: 828 RVA: 0x00140BD0 File Offset: 0x00140BD0
		private unsafe int method_280(byte byte_0, ushort ushort_0, byte byte_1, byte* pByte_0)
		{
			Struct3 @struct = 0;
			initblk(ref @struct + 1, 0, 63);
			Struct3 struct2 = 0;
			initblk(ref struct2 + 1, 0, 63);
			int num = 0;
			uint int_ = 6U;
			uint int_2 = (uint)(byte_1 + 6);
			@struct = -128;
			*(ref @struct + 1) = (byte)((sbyte)byte_0);
			*(ref @struct + 3) = (byte)((sbyte)byte_1);
			*(ref @struct + 4) = (byte)(ushort_0 & 255);
			*(ref @struct + 5) = (byte)((ushort_0 & 65280) >> 8);
			while (num != 8)
			{
				if (this.method_416((sbyte*)(&@struct), (int)int_, (sbyte*)(&struct2), (int)int_2) == 1)
				{
					int result;
					if (struct2 == 128 && (byte)(*(ref struct2 + 2)) == byte_0)
					{
						<Module>.memcpy((void*)pByte_0, ref struct2 + 6, (uint)byte_1);
						result = 1;
					}
					else
					{
						if (struct2 != 128)
						{
							num++;
							continue;
						}
						if ((byte)(*(ref struct2 + 2)) != byte_0)
						{
							num++;
							continue;
						}
						result = 0;
					}
					return result;
				}
				num++;
			}
			return 0;
		}

		// Token: 0x0600033D RID: 829 RVA: 0x00140C94 File Offset: 0x00140C94
		private unsafe int method_281(byte byte_0, byte* pByte_0)
		{
			Struct3 @struct = 0;
			initblk(ref @struct + 1, 0, 63);
			Struct105 struct2 = 0;
			initblk(ref struct2 + 1, 0, 285);
			int num = 0;
			@struct = -123;
			*(ref @struct + 1) = (byte)((sbyte)byte_0);
			while (num != 8)
			{
				if (<Module>.usb_bulk_write(<Module>.gstruct10_0, 1, (sbyte*)(&@struct), 6, 2000) == 6)
				{
					int num2 = <Module>.usb_bulk_read(<Module>.gstruct10_0, 129, (sbyte*)(&struct2), 286, 2000);
					if (num2 == 286)
					{
						if ((byte)(*(ref struct2 + 2)) != byte_0)
						{
							num++;
						}
						else if (*(ref struct2 + 66) != (sbyte)byte_0)
						{
							num++;
						}
						else if (*(ref struct2 + 130) != (sbyte)byte_0)
						{
							num++;
						}
						else if (*(ref struct2 + 194) != (sbyte)byte_0)
						{
							num++;
						}
						else
						{
							if (*(ref struct2 + 258) == (sbyte)byte_0)
							{
								<Module>.memcpy((void*)pByte_0, ref struct2 + 6, 58U);
								<Module>.memcpy((void*)(pByte_0 + 58), ref struct2 + 70, 58U);
								<Module>.memcpy((void*)(pByte_0 + 116), ref struct2 + 134, 58U);
								<Module>.memcpy((void*)(pByte_0 + 174), ref struct2 + 198, 58U);
								<Module>.memcpy((void*)(pByte_0 + 232), ref struct2 + 262, 24U);
								return 1;
							}
							num++;
						}
					}
					else
					{
						num++;
					}
				}
				else
				{
					num++;
				}
			}
			return 0;
		}

		// Token: 0x0600033E RID: 830 RVA: 0x00140DEC File Offset: 0x00140DEC
		private unsafe int method_282(byte byte_0, byte* pByte_0)
		{
			Struct3 @struct = 0;
			initblk(ref @struct + 1, 0, 63);
			Struct106 struct2 = 0;
			initblk(ref struct2 + 1, 0, 293);
			int num = 0;
			@struct = -122;
			*(ref @struct + 1) = (byte)((sbyte)byte_0);
			while (num != 8)
			{
				if (<Module>.usb_bulk_write(<Module>.gstruct10_0, 1, (sbyte*)(&@struct), 6, 2000) == 6)
				{
					int num2 = <Module>.usb_bulk_read(<Module>.gstruct10_0, 129, (sbyte*)(&struct2), 294, 2000);
					if (num2 == 294)
					{
						if ((byte)(*(ref struct2 + 2)) != byte_0)
						{
							num++;
						}
						else if (*(ref struct2 + 66) != (sbyte)byte_0)
						{
							num++;
						}
						else if (*(ref struct2 + 130) != (sbyte)byte_0)
						{
							num++;
						}
						else if (*(ref struct2 + 194) != (sbyte)byte_0)
						{
							num++;
						}
						else
						{
							if (*(ref struct2 + 258) == (sbyte)byte_0)
							{
								<Module>.memcpy((void*)pByte_0, ref struct2 + 6, 56U);
								<Module>.memcpy((void*)(pByte_0 + 56), ref struct2 + 70, 56U);
								<Module>.memcpy((void*)(pByte_0 + 112), ref struct2 + 134, 56U);
								<Module>.memcpy((void*)(pByte_0 + 168), ref struct2 + 198, 56U);
								<Module>.memcpy((void*)(pByte_0 + 224), ref struct2 + 262, 32U);
								return 1;
							}
							num++;
						}
					}
					else
					{
						num++;
					}
				}
				else
				{
					num++;
				}
			}
			return 0;
		}

		// Token: 0x0600033F RID: 831 RVA: 0x00140F44 File Offset: 0x00140F44
		private unsafe int method_283(byte byte_0, ushort ushort_0, byte byte_1, byte* pByte_0)
		{
			Struct3 @struct = 0;
			initblk(ref @struct + 1, 0, 63);
			Struct3 struct2 = 0;
			initblk(ref struct2 + 1, 0, 63);
			int int_ = (int)(byte_1 + 6);
			int int_2 = 6;
			int num = 0;
			@struct = -127;
			*(ref @struct + 1) = (byte)((sbyte)byte_0);
			*(ref @struct + 3) = (byte)((sbyte)byte_1);
			*(ref @struct + 4) = (byte)(ushort_0 & 255);
			*(ref @struct + 5) = (byte)((ushort_0 & 65280) >> 8);
			<Module>.memcpy(ref @struct + 6, (void*)pByte_0, (uint)byte_1);
			while (num != 8)
			{
				if (this.method_416((sbyte*)(&@struct), int_, (sbyte*)(&struct2), int_2) == 1)
				{
					int result;
					if (struct2 == 129 && (byte)(*(ref struct2 + 2)) == byte_0)
					{
						result = 1;
					}
					else
					{
						if (struct2 != 129)
						{
							num++;
							continue;
						}
						if ((byte)(*(ref struct2 + 2)) != byte_0)
						{
							num++;
							continue;
						}
						result = 0;
					}
					return result;
				}
				num++;
			}
			return 0;
		}

		// Token: 0x06000340 RID: 832 RVA: 0x00141008 File Offset: 0x00141008
		private unsafe int method_284(byte byte_0, byte* pByte_0)
		{
			Struct107 @struct = 0;
			initblk(ref @struct + 1, 0, 511);
			Struct3 struct2 = 0;
			initblk(ref struct2 + 1, 0, 63);
			int num = 0;
			@struct = -121;
			*(ref @struct + 1) = (byte)((sbyte)byte_0);
			<Module>.memcpy(ref @struct + 2, (void*)pByte_0, 260U);
			while (num != 8)
			{
				if (<Module>.usb_bulk_write(<Module>.gstruct10_0, 1, (sbyte*)(&@struct), 262, 1000) == 262)
				{
					if (<Module>.usb_bulk_read(<Module>.gstruct10_0, 129, (sbyte*)(&struct2), 2, 1000) == 2)
					{
						int result;
						if (struct2 == 135 && (byte)(*(ref struct2 + 1)) == byte_0)
						{
							result = 1;
						}
						else
						{
							if (struct2 != 135)
							{
								num++;
								continue;
							}
							if ((byte)(*(ref struct2 + 2)) != byte_0)
							{
								num++;
								continue;
							}
							result = 0;
						}
						return result;
					}
					num++;
				}
				else
				{
					num++;
				}
			}
			return 0;
		}

		// Token: 0x06000341 RID: 833 RVA: 0x001410EC File Offset: 0x001410EC
		private unsafe int method_285(byte byte_0, byte byte_1, byte byte_2, byte byte_3, byte byte_4)
		{
			Struct3 @struct = 0;
			initblk(ref @struct + 1, 0, 63);
			Struct3 struct2 = 0;
			initblk(ref struct2 + 1, 0, 63);
			int int_ = 7;
			int int_2 = 7;
			int num = 0;
			@struct = -126;
			*(ref @struct + 1) = (byte)((sbyte)byte_0);
			*(ref @struct + 3) = (byte)((sbyte)byte_1);
			*(ref @struct + 4) = (byte)((sbyte)byte_2);
			*(ref @struct + 5) = (byte)((sbyte)byte_3);
			*(ref @struct + 6) = (byte)((sbyte)byte_4);
			while (num != 8)
			{
				if (this.method_416((sbyte*)(&@struct), int_, (sbyte*)(&struct2), int_2) == 1)
				{
					int result;
					if (struct2 == 130 && (byte)(*(ref struct2 + 2)) == byte_0)
					{
						result = 1;
					}
					else
					{
						if (struct2 != 130)
						{
							num++;
							continue;
						}
						if ((byte)(*(ref struct2 + 2)) != byte_0)
						{
							num++;
							continue;
						}
						result = 0;
					}
					return result;
				}
				num++;
			}
			return 0;
		}

		// Token: 0x06000342 RID: 834 RVA: 0x0014119C File Offset: 0x0014119C
		private unsafe int method_286(byte byte_0, byte byte_1, byte byte_2, byte byte_3, byte* pByte_0)
		{
			Struct3 @struct = 0;
			initblk(ref @struct + 1, 0, 63);
			Struct3 struct2 = 0;
			initblk(ref struct2 + 1, 0, 63);
			uint int_ = 6U;
			uint int_2 = (uint)(byte_3 + 6);
			int num = 0;
			@struct = 85;
			*(ref @struct + 1) = 0;
			*(ref @struct + 2) = (byte)((sbyte)byte_3);
			*(ref @struct + 3) = (byte)((sbyte)byte_2);
			*(ref @struct + 4) = (byte)((sbyte)byte_1);
			*(ref @struct + 5) = (byte)((sbyte)byte_0);
			while (num != 2)
			{
				if (this.method_416((sbyte*)(&@struct), (int)int_, (sbyte*)(&struct2), (int)int_2) == 1)
				{
					int result;
					if (struct2 == 85 && *(ref struct2 + 1) == 112)
					{
						<Module>.memcpy((void*)pByte_0, ref struct2 + 6, (uint)byte_3);
						result = 1;
					}
					else
					{
						if (struct2 != 85)
						{
							num++;
							continue;
						}
						if (*(ref struct2 + 1) != 112)
						{
							num++;
							continue;
						}
						result = 0;
					}
					return result;
				}
				num++;
			}
			return 0;
		}

		// Token: 0x06000343 RID: 835 RVA: 0x00141254 File Offset: 0x00141254
		private unsafe int method_287(byte byte_0, byte byte_1, byte byte_2, byte byte_3, byte* pByte_0)
		{
			Struct3 @struct = 0;
			initblk(ref @struct + 1, 0, 63);
			Struct3 struct2 = 0;
			initblk(ref struct2 + 1, 0, 63);
			int num = 0;
			uint int_ = (uint)(byte_3 + 6);
			uint int_2 = 6U;
			@struct = 86;
			*(ref @struct + 1) = 0;
			*(ref @struct + 2) = (byte)((sbyte)byte_3);
			*(ref @struct + 3) = (byte)((sbyte)byte_2);
			*(ref @struct + 4) = (byte)((sbyte)byte_1);
			*(ref @struct + 5) = (byte)((sbyte)byte_0);
			<Module>.memcpy(ref @struct + 6, (void*)pByte_0, (uint)byte_3);
			while (num != 2)
			{
				if (this.method_416((sbyte*)(&@struct), (int)int_, (sbyte*)(&struct2), (int)int_2) == 1)
				{
					int result;
					if (struct2 == 86 && *(ref struct2 + 1) == 112)
					{
						result = 1;
					}
					else
					{
						if (struct2 != 86)
						{
							num++;
							continue;
						}
						if (*(ref struct2 + 1) != 112)
						{
							num++;
							continue;
						}
						result = 0;
					}
					return result;
				}
				num++;
			}
			return 0;
		}

		// Token: 0x06000344 RID: 836 RVA: 0x0014130C File Offset: 0x0014130C
		private unsafe int method_288(byte byte_0, byte byte_1, byte* pByte_0)
		{
			Struct3 @struct = 0;
			initblk(ref @struct + 1, 0, 63);
			Struct105 struct2 = 0;
			initblk(ref struct2 + 1, 0, 285);
			int num = 0;
			@struct = 87;
			*(ref @struct + 1) = 0;
			*(ref @struct + 2) = 0;
			*(ref @struct + 3) = 0;
			*(ref @struct + 4) = (byte)((sbyte)byte_1);
			*(ref @struct + 5) = (byte)((sbyte)byte_0);
			while (num != 8)
			{
				if (<Module>.usb_bulk_write(<Module>.gstruct10_0, 1, (sbyte*)(&@struct), 6, 2000) == 6)
				{
					int num2 = <Module>.usb_bulk_read(<Module>.gstruct10_0, 129, (sbyte*)(&struct2), 286, 2000);
					if (num2 == 286)
					{
						if (*(ref struct2 + 1) != 112)
						{
							num++;
						}
						else if (*(ref struct2 + 65) != 112)
						{
							num++;
						}
						else if (*(ref struct2 + 129) != 112)
						{
							num++;
						}
						else if (*(ref struct2 + 193) != 112)
						{
							num++;
						}
						else
						{
							if (*(ref struct2 + 257) == 112)
							{
								<Module>.memcpy((void*)pByte_0, ref struct2 + 6, 58U);
								<Module>.memcpy((void*)(pByte_0 + 58), ref struct2 + 70, 58U);
								<Module>.memcpy((void*)(pByte_0 + 116), ref struct2 + 134, 58U);
								<Module>.memcpy((void*)(pByte_0 + 174), ref struct2 + 198, 58U);
								<Module>.memcpy((void*)(pByte_0 + 232), ref struct2 + 262, 24U);
								return 1;
							}
							num++;
						}
					}
					else
					{
						num++;
					}
				}
				else
				{
					num++;
				}
			}
			return 0;
		}

		// Token: 0x06000345 RID: 837 RVA: 0x00141480 File Offset: 0x00141480
		private unsafe int method_289(byte byte_0, byte byte_1, byte* pByte_0)
		{
			Struct107 @struct = 0;
			initblk(ref @struct + 1, 0, 511);
			Struct3 struct2 = 0;
			initblk(ref struct2 + 1, 0, 63);
			int num = 0;
			@struct = 88;
			*(ref @struct + 1) = 0;
			*(ref @struct + 2) = 0;
			*(ref @struct + 3) = 0;
			*(ref @struct + 4) = (byte)((sbyte)byte_1);
			*(ref @struct + 5) = (byte)((sbyte)byte_0);
			<Module>.memcpy(ref @struct + 6, (void*)pByte_0, 256U);
			while (num != 8)
			{
				if (<Module>.usb_bulk_write(<Module>.gstruct10_0, 1, (sbyte*)(&@struct), 262, 1000) == 262)
				{
					if (<Module>.usb_bulk_read(<Module>.gstruct10_0, 129, (sbyte*)(&struct2), 2, 1000) == 2)
					{
						int result;
						if (struct2 == 88 && *(ref struct2 + 1) == 112)
						{
							result = 1;
						}
						else
						{
							if (struct2 != 88)
							{
								num++;
								continue;
							}
							if (*(ref struct2 + 2) != 112)
							{
								num++;
								continue;
							}
							result = 0;
						}
						return result;
					}
					num++;
				}
				else
				{
					num++;
				}
			}
			return 0;
		}

		// Token: 0x06000346 RID: 838 RVA: 0x00141574 File Offset: 0x00141574
		private unsafe int method_290()
		{
			uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
			byte byte_ = *(ref <Module>.struct38_0 + selectedIndex * 72U + 4);
			ushort ushort_ = *(ref <Module>.struct38_0 + selectedIndex * 72U);
			this.method_246(ushort_, byte_, 112, 21845U, 170);
			this.method_246(ushort_, byte_, 112, 10922U, 85);
			this.method_246(ushort_, byte_, 112, 21845U, 144);
			byte b;
			this.method_247(ushort_, byte_, 112, 0U, &b);
			byte b2;
			this.method_247(ushort_, byte_, 112, 1U, &b2);
			this.method_246(ushort_, byte_, 112, 21845U, 170);
			this.method_246(ushort_, byte_, 112, 10922U, 85);
			this.method_246(ushort_, byte_, 112, 21845U, 240);
			return (int)b2 | (int)b << 8;
		}

		// Token: 0x06000347 RID: 839 RVA: 0x00141648 File Offset: 0x00141648
		private unsafe int method_291()
		{
			byte b = 0;
			byte b2 = 0;
			uint num = 0U;
			int num2 = 0;
			uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
			byte byte_ = *(ref <Module>.struct38_0 + selectedIndex * 72U + 4);
			ushort num3 = *(ref <Module>.struct38_0 + selectedIndex * 72U);
			Struct32 struct2;
			for (uint num4 = 0U; num4 < 4U; num4 += 1U)
			{
				this.textBox6.AppendText("\r\n" + "Reading Bank " + Convert.ToString(num4) + ": ");
				this.string_2 = "Reading Bank " + Convert.ToString(num4) + ": ";
				this.string_3 = "";
				uint num5 = 0U;
				IL_20F:
				while (num5 < 256U)
				{
					uint num6 = num5 % 16U;
					if (<Module>.GetAsyncKeyState(27) == null)
					{
						if (num6 == 0U)
						{
							this.textBox6.AppendText(".");
							this.string_3 += ".";
							Application.DoEvents();
						}
						while (num2 != 2)
						{
							if (num3 == 0)
							{
								Struct43 @struct;
								if (this.method_286((byte)num4, (byte)num5, 0, 56, (byte*)(&@struct)) == 0)
								{
									num2++;
									continue;
								}
								if (this.method_286((byte)num4, (byte)num5, 56, 56, ref @struct + 56) == 0)
								{
									num2++;
									continue;
								}
								if (this.method_286((byte)num4, (byte)num5, 112, 56, ref @struct + 112) == 0)
								{
									num2++;
									continue;
								}
								if (this.method_286((byte)num4, (byte)num5, 168, 56, ref @struct + 168) == 0)
								{
									num2++;
									continue;
								}
								if (this.method_286((byte)num4, (byte)num5, 224, 32, ref @struct + 224) == 0)
								{
									num2++;
									continue;
								}
								byte* ptr = ref struct2 + (num5 * 256U + num4 * 65536U);
								<Module>.memcpy((void*)ptr, (void*)(&@struct), 256U);
							}
							else
							{
								for (uint num7 = 0U; num7 < 256U; num7 += 1U)
								{
									uint num8 = num7 | num5 << 8 | num4 << 16;
									this.method_247(num3, byte_, 112, num8, &b);
									this.method_247(num3, byte_, 112, num8, &b2);
									if (b2 != b)
									{
										this.textBox6.AppendText("x");
										num7 -= 1U;
										num += 1U;
										if (num > 16U)
										{
											this.textBox6.AppendText("Read Failed!" + "\r\n");
											return 1;
										}
									}
									else
									{
										*(ref struct2 + num8) = b;
									}
								}
							}
							num5 += 1U;
							goto IL_20F;
						}
						this.textBox6.AppendText("Read Failed!" + "\r\n");
						return 1;
					}
					this.textBox6.AppendText("\r\n" + "Aborted by User!" + "\r\n");
					return 1;
				}
				<Module>.Sleep(200);
			}
			this.textBox6.AppendText("\r\n");
			this.string_2 = "Done! ";
			this.string_3 = "";
			<Module>.memcpy(*(ref <Module>.struct121_0 + 7172), (void*)(&struct2), 262144U);
			return 0;
		}

		// Token: 0x06000348 RID: 840 RVA: 0x0014192C File Offset: 0x0014192C
		private unsafe void method_292()
		{
			uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
			byte byte_ = *(ref <Module>.struct38_0 + selectedIndex * 72U + 4);
			ushort ushort_ = *(ref <Module>.struct38_0 + selectedIndex * 72U);
			this.textBox6.AppendText("\r\n" + "Sending Chip Erase request to port " + this.label123.Text + "\r\n");
			this.method_246(ushort_, byte_, 112, 21845U, 170);
			this.method_246(ushort_, byte_, 112, 10922U, 85);
			this.method_246(ushort_, byte_, 112, 21845U, 128);
			this.method_246(ushort_, byte_, 112, 21845U, 170);
			this.method_246(ushort_, byte_, 112, 10922U, 85);
			this.method_246(ushort_, byte_, 112, 21845U, 16);
			this.textBox6.AppendText("Erasing:");
			this.string_2 = string.Concat("Erasing Chip: ");
			this.string_3 = "";
			for (uint num = 0U; num < 12U; num += 1U)
			{
				<Module>.Sleep(250);
				this.textBox6.AppendText(".");
				this.string_3 += ".";
			}
			this.textBox6.AppendText("\r\n");
		}

		// Token: 0x06000349 RID: 841 RVA: 0x00141A78 File Offset: 0x00141A78
		private unsafe int method_293()
		{
			byte b = 0;
			uint num = 0U;
			uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
			byte byte_ = *(ref <Module>.struct38_0 + selectedIndex * 72U + 4);
			ushort num2 = *(ref <Module>.struct38_0 + selectedIndex * 72U);
			for (uint num3 = 0U; num3 < 4U; num3 += 1U)
			{
				this.textBox6.AppendText("Reading Bank " + Convert.ToString(num3) + ": ");
				for (uint num4 = 0U; num4 < 256U; num4 += 1U)
				{
					if (num4 % 16U == 0U)
					{
						this.textBox6.AppendText(".");
						Application.DoEvents();
					}
					if (<Module>.GetAsyncKeyState(27) != null)
					{
						this.textBox6.AppendText("\r\n" + "Aborted by User!" + "\r\n");
						return 1;
					}
					if (num2 == 0)
					{
						Struct43 @struct;
						this.method_286((byte)num3, (byte)num4, 0, 56, (byte*)(&@struct));
						this.method_286((byte)num3, (byte)num4, 56, 56, ref @struct + 56);
						this.method_286((byte)num3, (byte)num4, 112, 56, ref @struct + 112);
						this.method_286((byte)num3, (byte)num4, 168, 56, ref @struct + 168);
						this.method_286((byte)num3, (byte)num4, 224, 32, ref @struct + 224);
						for (uint num5 = 0U; num5 < 256U; num5 += 1U)
						{
							if (*(ref @struct + num5) != 255)
							{
								this.textBox6.AppendText("x");
								num += 1U;
								if (num > 16U)
								{
									return 0;
								}
							}
						}
					}
					else
					{
						for (uint num5 = 0U; num5 < 256U; num5 += 1U)
						{
							this.method_247(num2, byte_, 112, num5 | num4 << 8 | num3 << 16, &b);
							if (b != 255)
							{
								num5 -= 1U;
								this.textBox6.AppendText("x");
								num += 1U;
								if (num > 16U)
								{
									return 0;
								}
							}
						}
					}
				}
				this.textBox6.AppendText("\r\n");
			}
			return 1;
		}

		// Token: 0x0600034A RID: 842 RVA: 0x00141C68 File Offset: 0x00141C68
		private unsafe void method_294(int int_16)
		{
			uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
			byte byte_ = *(ref <Module>.struct38_0 + selectedIndex * 72U + 4);
			ushort ushort_ = *(ref <Module>.struct38_0 + selectedIndex * 72U);
			for (ushort num = 0; num < 256; num += 16)
			{
				uint uint_ = (uint)((int)num << 8 | int_16 << 16);
				this.method_246(ushort_, byte_, 112, 21845U, 170);
				this.method_246(ushort_, byte_, 112, 10922U, 85);
				this.method_246(ushort_, byte_, 112, 21845U, 128);
				this.method_246(ushort_, byte_, 112, 21845U, 170);
				this.method_246(ushort_, byte_, 112, 10922U, 85);
				this.method_246(ushort_, byte_, 112, uint_, 48);
				<Module>.Sleep(100);
			}
		}

		// Token: 0x0600034B RID: 843 RVA: 0x003CB624 File Offset: 0x00313624
		private unsafe int method_295(int int_16)
		{
			byte b = 0;
			uint num = 0U;
			int num2 = 0;
			uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
			byte byte_ = *(ref <Module>.struct38_0 + selectedIndex * 72U + 4);
			ushort num3 = *(ref <Module>.struct38_0 + selectedIndex * 72U);
			Struct32 @struct;
			<Module>.memcpy((void*)(&@struct), *(ref <Module>.struct121_0 + 4780), 262144U);
			this.textBox6.AppendText("Writing Bank " + Convert.ToString(3 - int_16) + ": ");
			this.string_2 = "Writing Bank " + Convert.ToString(3 - int_16) + ": ";
			this.string_3 = "";
			uint num4 = 0U;
			while (num4 < 256U)
			{
				int result;
				if (<Module>.GetAsyncKeyState(27) == null)
				{
					if (num4 % 16U == 0U)
					{
						this.textBox6.AppendText(".");
						this.string_3 += ".";
						Application.DoEvents();
					}
					if (num2 != 8)
					{
						if (num3 == 0)
						{
							byte* ptr = ref @struct + (num4 * 256U + (uint)(int_16 * 65536));
							Struct43 struct2;
							<Module>.memcpy((void*)(&struct2), (void*)ptr, 256U);
							if (this.method_287((byte)int_16, (byte)num4, 0, 56, (byte*)(&struct2)) == 0)
							{
								this.textBox6.AppendText("Write Failed!" + "\r\n");
								return 1;
							}
							if (this.method_287((byte)int_16, (byte)num4, 56, 56, ref struct2 + 56) == 0)
							{
								this.textBox6.AppendText("Write Failed!" + "\r\n");
								return 1;
							}
							if (this.method_287((byte)int_16, (byte)num4, 112, 56, ref struct2 + 112) == 0)
							{
								this.textBox6.AppendText("Write Failed!" + "\r\n");
								return 1;
							}
							if (this.method_287((byte)int_16, (byte)num4, 168, 56, ref struct2 + 168) == 0)
							{
								this.textBox6.AppendText("Write Failed!" + "\r\n");
								return 1;
							}
							if (this.method_287((byte)int_16, (byte)num4, 224, 32, ref struct2 + 224) == 0)
							{
								this.textBox6.AppendText("Write Failed!" + "\r\n");
								return 1;
							}
						}
						else
						{
							for (uint num5 = 0U; num5 < 256U; num5 += 1U)
							{
								uint num6 = num5 | num4 << 8 | (uint)((uint)int_16 << 16);
								byte b2 = *(ref @struct + num6);
								this.method_246(num3, byte_, 112, 21845U, 170);
								this.method_246(num3, byte_, 112, 10922U, 85);
								this.method_246(num3, byte_, 112, 21845U, 160);
								this.method_246(num3, byte_, 112, num6, b2);
								this.method_247(num3, byte_, 112, num6, &b);
								if (b != b2)
								{
									this.method_247(num3, byte_, 112, num6, &b);
								}
								if (b != b2)
								{
									this.method_247(num3, byte_, 112, num6, &b);
								}
								if (b != b2)
								{
									num5 -= 1U;
									num += 1U;
									if (num > 16U)
									{
										this.textBox6.AppendText("Write Failed !");
										this.textBox6.AppendText("\r\n");
										return 1;
									}
								}
								else if (num > 0U)
								{
									this.textBox6.AppendText("y");
									num = 0U;
								}
							}
						}
						<Module>.Sleep(20);
						num4 += 1U;
						continue;
					}
					this.textBox6.AppendText("Read Failed!" + "\r\n");
					result = 1;
				}
				else
				{
					this.textBox6.AppendText("\r\n" + "Aborted by User!" + "\r\n");
					result = 1;
				}
				return result;
			}
			<Module>.Sleep(200);
			this.textBox6.AppendText("\r\n");
			this.string_2 = "Done! ";
			this.string_3 = "";
			return 0;
		}

		// Token: 0x0600034C RID: 844 RVA: 0x001420F8 File Offset: 0x001420F8
		private unsafe int method_296()
		{
			byte b = 0;
			uint num = 0U;
			int num2 = 0;
			uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
			byte byte_ = *(ref <Module>.struct38_0 + selectedIndex * 72U + 4);
			ushort num3 = *(ref <Module>.struct38_0 + selectedIndex * 72U);
			Struct32 @struct;
			<Module>.memcpy((void*)(&@struct), *(ref <Module>.struct121_0 + 4780), 262144U);
			uint num4;
			Struct43 struct2;
			for (num4 = 0U; num4 < 4U; num4 += 1U)
			{
				uint num5 = 3U - num4;
				this.textBox6.AppendText("Writing Bank " + Convert.ToString(num4) + ": .");
				this.string_2 = "Writing Bank " + Convert.ToString(num4) + ": ";
				this.string_3 = "";
				this.method_294((int)num5);
				uint num6 = 1U;
				IL_2B6:
				while (num6 < 256U)
				{
					if (<Module>.GetAsyncKeyState(27) == null)
					{
						if (num6 % 16U == 0U)
						{
							this.textBox6.AppendText(".");
							this.string_3 += ".";
							Application.DoEvents();
						}
						while (num2 != 2)
						{
							if (num3 == 0)
							{
								byte* ptr = ref @struct + (num6 * 256U + num5 * 65536U);
								<Module>.memcpy((void*)(&struct2), (void*)ptr, 256U);
								if (this.method_287((byte)num5, (byte)num6, 0, 56, (byte*)(&struct2)) == 0)
								{
									num2++;
									continue;
								}
								if (this.method_287((byte)num5, (byte)num6, 56, 56, ref struct2 + 56) == 0)
								{
									num2++;
									continue;
								}
								if (this.method_287((byte)num5, (byte)num6, 112, 56, ref struct2 + 112) == 0)
								{
									num2++;
									continue;
								}
								if (this.method_287((byte)num5, (byte)num6, 168, 56, ref struct2 + 168) == 0)
								{
									num2++;
									continue;
								}
								if (this.method_287((byte)num5, (byte)num6, 224, 32, ref struct2 + 224) == 0)
								{
									num2++;
									continue;
								}
							}
							else
							{
								for (uint num7 = 0U; num7 < 256U; num7 += 1U)
								{
									uint num8 = num7 | num6 << 8 | num5 << 16;
									byte b2 = *(ref @struct + num8);
									this.method_246(num3, byte_, 112, 21845U, 170);
									this.method_246(num3, byte_, 112, 10922U, 85);
									this.method_246(num3, byte_, 112, 21845U, 160);
									this.method_246(num3, byte_, 112, num8, b2);
									this.method_247(num3, byte_, 112, num8, &b);
									if (b != b2)
									{
										this.method_247(num3, byte_, 112, num8, &b);
									}
									if (b != b2)
									{
										this.method_247(num3, byte_, 112, num8, &b);
									}
									if (b != b2)
									{
										num7 -= 1U;
										num += 1U;
										if (num > 16U)
										{
											this.textBox6.AppendText("Write Failed !");
											this.textBox6.AppendText("\r\n");
											return 1;
										}
									}
									else if (num > 0U)
									{
										this.textBox6.AppendText("y");
										num = 0U;
									}
								}
							}
							<Module>.Sleep(20);
							num6 += 1U;
							goto IL_2B6;
						}
						this.textBox6.AppendText("Write Failed!" + "\r\n");
						return 1;
					}
					this.textBox6.AppendText("\r\n" + "Aborted by User!" + "\r\n");
					return 1;
				}
				this.textBox6.AppendText("\r\n");
			}
			num4 = 0U;
			IL_51E:
			while (num4 < 4U)
			{
				uint num5 = 3U - num4;
				uint num6 = 0U;
				while (num2 != 8)
				{
					if (num3 == 0)
					{
						byte* ptr = ref @struct + (num6 * 256U + num5 * 65536U);
						<Module>.memcpy((void*)(&struct2), (void*)ptr, 256U);
						if (this.method_287((byte)num5, (byte)num6, 0, 56, (byte*)(&struct2)) == 0)
						{
							num2++;
							continue;
						}
						if (this.method_287((byte)num5, (byte)num6, 56, 56, ref struct2 + 56) == 0)
						{
							num2++;
							continue;
						}
						if (this.method_287((byte)num5, (byte)num6, 112, 56, ref struct2 + 112) == 0)
						{
							num2++;
							continue;
						}
						if (this.method_287((byte)num5, (byte)num6, 168, 56, ref struct2 + 168) == 0)
						{
							num2++;
							continue;
						}
						if (this.method_287((byte)num5, (byte)num6, 224, 32, ref struct2 + 224) == 0)
						{
							num2++;
							continue;
						}
					}
					else
					{
						for (uint num7 = 0U; num7 < 256U; num7 += 1U)
						{
							uint num8 = num7 | num6 << 8 | num5 << 16;
							byte b2 = *(ref @struct + num8);
							this.method_246(num3, byte_, 112, 21845U, 170);
							this.method_246(num3, byte_, 112, 10922U, 85);
							this.method_246(num3, byte_, 112, 21845U, 160);
							this.method_246(num3, byte_, 112, num8, b2);
							this.method_247(num3, byte_, 112, num8, &b);
							if (b != b2)
							{
								this.method_247(num3, byte_, 112, num8, &b);
							}
							if (b != b2)
							{
								this.method_247(num3, byte_, 112, num8, &b);
							}
							if (b != b2)
							{
								num7 -= 1U;
								num += 1U;
								if (num > 16U)
								{
									this.textBox6.AppendText("Write Failed !");
									this.textBox6.AppendText("\r\n");
									return 1;
								}
							}
							else if (num > 0U)
							{
								this.textBox6.AppendText("y");
								num = 0U;
							}
						}
					}
					<Module>.Sleep(20);
					num4 += 1U;
					goto IL_51E;
				}
				this.textBox6.AppendText("Write Failed!" + "\r\n");
				return 1;
			}
			<Module>.Sleep(200);
			this.string_2 = "Done! ";
			this.string_3 = "";
			return 0;
		}

		// Token: 0x0600034D RID: 845 RVA: 0x00142690 File Offset: 0x00142690
		private unsafe int method_297()
		{
			uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
			byte byte_ = *(ref <Module>.struct38_0 + selectedIndex * 72U + 4);
			ushort ushort_ = *(ref <Module>.struct38_0 + selectedIndex * 72U);
			this.method_228(ushort_, byte_, 115, 0, 144);
			this.method_228(ushort_, byte_, 115, 1, 0);
			this.method_228(ushort_, byte_, 115, 2, 0);
			this.method_228(ushort_, byte_, 115, 3, 0);
			this.method_231(ushort_, byte_, 115, 1, 0, 3, 0);
			<Module>.Sleep(200);
			byte b;
			this.method_229(ushort_, byte_, 115, 4, &b);
			byte b2;
			this.method_229(ushort_, byte_, 115, 5, &b2);
			ushort num = (ushort)((int)b2 | (int)b << 8);
			if (num == 48963)
			{
				this.method_301();
			}
			return (int)num;
		}

		// Token: 0x0600034E RID: 846 RVA: 0x0014274C File Offset: 0x0014274C
		private unsafe int method_298()
		{
			uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
			byte byte_ = *(ref <Module>.struct38_0 + selectedIndex * 72U + 4);
			ushort num = *(ref <Module>.struct38_0 + selectedIndex * 72U);
			Struct63 @struct = 3;
			*(ref @struct + 1) = 0;
			*(ref @struct + 2) = 0;
			*(ref @struct + 3) = 0;
			Struct32 struct3;
			for (uint num2 = 0U; num2 < 4U; num2 += 1U)
			{
				this.textBox6.AppendText("\r\n" + "Reading Bank " + Convert.ToString(num2) + ": ");
				this.string_2 = "Reading Bank " + Convert.ToString(num2) + ": ";
				this.string_3 = "";
				*(ref @struct + 1) = (byte)num2;
				for (uint num3 = 0U; num3 < 256U; num3 += 1U)
				{
					if (<Module>.GetAsyncKeyState(27) != null)
					{
						this.textBox6.AppendText("\r\n" + "Aborted by User!" + "\r\n");
						return 1;
					}
					*(ref @struct + 2) = (byte)num3;
					if (num3 % 16U == 0U)
					{
						this.textBox6.AppendText(".");
						this.string_3 += ".";
						Application.DoEvents();
					}
					Struct43 struct2;
					if (num == 0)
					{
						if (this.method_269(115, 0, 4, (byte*)(&@struct)) == 0)
						{
							return 1;
						}
						if (this.method_272(115, 0, 4, 1, 0) == 0)
						{
							return 1;
						}
						if (this.method_266(115, (byte*)(&struct2)) == 0)
						{
							return 1;
						}
					}
					else
					{
						this.method_228(num, byte_, 115, 0, 3);
						this.method_228(num, byte_, 115, 1, (byte)num2);
						this.method_228(num, byte_, 115, 2, (byte)num3);
						this.method_228(num, byte_, 115, 3, 0);
						this.method_231(num, byte_, 115, 0, 4, 1, 0);
						for (uint num4 = 4U; num4 < 260U; num4 += 1U)
						{
							this.method_229(num, byte_, 115, (ushort)num4, ref struct2 + (num4 - 4U));
						}
					}
					byte* ptr = ref struct3 + (num3 * 256U + num2 * 65536U);
					<Module>.memcpy((void*)ptr, (void*)(&struct2), 256U);
				}
			}
			this.textBox6.AppendText("\r\n");
			this.string_2 = "Done! ";
			this.string_3 = "";
			<Module>.memcpy(*(ref <Module>.struct121_0 + 7172), (void*)(&struct3), 262144U);
			return 0;
		}

		// Token: 0x0600034F RID: 847 RVA: 0x00142994 File Offset: 0x00142994
		private unsafe int method_299()
		{
			uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
			byte byte_ = *(ref <Module>.struct38_0 + selectedIndex * 72U + 4);
			ushort ushort_ = *(ref <Module>.struct38_0 + selectedIndex * 72U);
			this.textBox6.AppendText("\r\n" + "Sending Chip Erase to Port " + this.label123.Text + "\r\n");
			this.method_228(ushort_, byte_, 115, 0, 6);
			this.method_231(ushort_, byte_, 115, 0, 1, 0, 0);
			int result;
			if (this.method_232(ushort_, byte_, 115, 2) == 1)
			{
				result = 0;
			}
			else
			{
				if (this.label118.Text == new string((sbyte*)(&<Module>.struct35_132)))
				{
					this.method_228(ushort_, byte_, 115, 0, 96);
				}
				else if (this.label118.Text == new string((sbyte*)(&<Module>.struct35_133)))
				{
					this.method_228(ushort_, byte_, 115, 0, 98);
				}
				else
				{
					this.method_228(ushort_, byte_, 115, 0, 199);
				}
				this.method_231(ushort_, byte_, 115, 0, 1, 0, 0);
				this.textBox6.AppendText("Erasing:");
				this.string_2 = string.Concat("Erasing Chip: ");
				this.string_3 = "";
				if (this.method_232(ushort_, byte_, 115, 0) == 1)
				{
					result = 0;
				}
				else
				{
					this.textBox6.AppendText("\r\n");
					result = 1;
				}
			}
			return result;
		}

		// Token: 0x06000350 RID: 848 RVA: 0x00142AE0 File Offset: 0x00142AE0
		private unsafe void method_300()
		{
			Struct63 @struct = 6;
			*(ref @struct + 1) = 0;
			*(ref @struct + 2) = 0;
			*(ref @struct + 3) = 0;
			uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
			byte byte_ = *(ref <Module>.struct38_0 + selectedIndex * 72U + 4);
			ushort num = *(ref <Module>.struct38_0 + selectedIndex * 72U);
			if (num == 0)
			{
				this.method_269(115, 0, 4, (byte*)(&@struct));
				this.method_272(115, 0, 1, 0, 0);
			}
			else
			{
				this.method_228(num, byte_, 115, 0, 6);
				this.method_231(num, byte_, 115, 0, 1, 0, 0);
			}
		}

		// Token: 0x06000351 RID: 849 RVA: 0x00142B64 File Offset: 0x00142B64
		private unsafe void method_301()
		{
			uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
			byte byte_ = *(ref <Module>.struct38_0 + selectedIndex * 72U + 4);
			ushort ushort_ = *(ref <Module>.struct38_0 + selectedIndex * 72U);
			this.method_228(ushort_, byte_, 115, 0, 80);
			this.method_231(ushort_, byte_, 115, 0, 1, 0, 0);
			this.method_228(ushort_, byte_, 115, 0, 1);
			this.method_228(ushort_, byte_, 115, 1, 0);
			this.method_231(ushort_, byte_, 115, 0, 2, 0, 0);
		}

		// Token: 0x06000352 RID: 850 RVA: 0x00142BE0 File Offset: 0x00142BE0
		private unsafe int method_302()
		{
			Struct63 @struct = 6;
			*(ref @struct + 1) = 0;
			*(ref @struct + 2) = 0;
			*(ref @struct + 3) = 0;
			Struct76 struct2 = 2;
			*(ref struct2 + 1) = 0;
			*(ref struct2 + 2) = 0;
			*(ref struct2 + 3) = 0;
			Struct32 struct3;
			<Module>.memcpy((void*)(&struct3), *(ref <Module>.struct121_0 + 4780), 262144U);
			uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
			byte byte_ = *(ref <Module>.struct38_0 + selectedIndex * 72U + 4);
			ushort num = *(ref <Module>.struct38_0 + selectedIndex * 72U);
			for (uint num2 = 0U; num2 < 4U; num2 += 1U)
			{
				this.textBox6.AppendText("Writing Bank " + Convert.ToString(num2) + ": ");
				this.string_2 = "Writing Bank " + Convert.ToString(num2) + ": ";
				this.string_3 = "";
				*(ref struct2 + 1) = (byte)num2;
				for (uint num3 = 0U; num3 < 256U; num3 += 1U)
				{
					if (<Module>.GetAsyncKeyState(27) != null)
					{
						this.textBox6.AppendText("\r\n" + "Aborted by User!" + "\r\n");
						return 1;
					}
					if (num3 % 16U == 0U)
					{
						this.textBox6.AppendText(".");
						this.string_3 += ".";
						Application.DoEvents();
					}
					if (num == 0)
					{
						*(ref struct2 + 2) = (byte)num3;
						<Module>.memcpy(ref struct2 + 4, ref struct3 + (num3 * 256U + num2 * 65536U), 256U);
						if (this.method_270(115, (byte*)(&struct2)) == 0)
						{
							return 1;
						}
					}
					else
					{
						this.method_228(num, byte_, 115, 0, 6);
						this.method_231(num, byte_, 115, 0, 1, 0, 0);
						if (this.method_232(num, byte_, 115, 2) == 1)
						{
							return 1;
						}
						this.method_228(num, byte_, 115, 0, 2);
						this.method_228(num, byte_, 115, 1, (byte)num2);
						this.method_228(num, byte_, 115, 2, (byte)num3);
						this.method_228(num, byte_, 115, 3, 0);
						for (uint num4 = 0U; num4 < 256U; num4 += 1U)
						{
							this.method_228(num, byte_, 115, (ushort)(num4 + 4U), *(ref struct3 + (num4 + num3 * 256U + num2 * 65536U)));
						}
						this.method_231(num, byte_, 115, 1, 4, 0, 0);
						if (this.method_232(num, byte_, 115, 0) == 1)
						{
							return 1;
						}
					}
				}
				this.textBox6.AppendText("\r\n");
				this.string_2 = "Done! ";
				this.string_3 = "";
			}
			return 0;
		}

		// Token: 0x06000353 RID: 851 RVA: 0x003CB9F8 File Offset: 0x003139F8
		private int method_303()
		{
			ushort num;
			if (this.radioButton19.Checked)
			{
				num = (ushort)this.method_305();
				if (num == 0)
				{
					num = (ushort)this.method_304();
					if (num == 0)
					{
						num = (ushort)this.method_306();
						if (num != 0 && this.radioButton21.Visible)
						{
							this.radioButton21.Checked = true;
						}
					}
					else
					{
						this.radioButton20.Checked = true;
					}
				}
			}
			else if (this.radioButton21.Checked)
			{
				num = (ushort)this.method_306();
				if (num == 0)
				{
					num = (ushort)this.method_304();
					if (num == 0)
					{
						num = (ushort)this.method_305();
						if (num != 0)
						{
							this.radioButton19.Checked = true;
						}
					}
					else
					{
						this.radioButton20.Checked = true;
					}
				}
			}
			else
			{
				num = (ushort)this.method_304();
				if (num == 0)
				{
					num = (ushort)this.method_306();
					if (num == 0)
					{
						num = (ushort)this.method_305();
						if (num != 0)
						{
							this.radioButton19.Checked = true;
						}
					}
					else if (this.radioButton21.Visible)
					{
						this.radioButton21.Checked = true;
					}
				}
				if (num == 48963)
				{
					this.method_316();
				}
			}
			return (int)num;
		}

		// Token: 0x06000354 RID: 852 RVA: 0x00142F6C File Offset: 0x00142F6C
		private unsafe int method_304()
		{
			uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
			byte byte_ = *(ref <Module>.struct38_0 + selectedIndex * 72U + 4);
			ushort ushort_ = *(ref <Module>.struct38_0 + selectedIndex * 72U);
			this.method_228(ushort_, byte_, 114, 34816, 144);
			this.method_228(ushort_, byte_, 114, 34817, 0);
			this.method_228(ushort_, byte_, 114, 34818, 0);
			this.method_228(ushort_, byte_, 114, 34819, 0);
			this.method_231(ushort_, byte_, 114, 4, 0, 2, 0);
			<Module>.Sleep(200);
			byte b;
			this.method_229(ushort_, byte_, 114, 34820, &b);
			byte b2;
			this.method_229(ushort_, byte_, 114, 34821, &b2);
			return (int)b2 | (int)b << 8;
		}

		// Token: 0x06000355 RID: 853 RVA: 0x00143030 File Offset: 0x00143030
		private unsafe int method_305()
		{
			uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
			byte byte_ = *(ref <Module>.struct38_0 + selectedIndex * 72U + 4);
			ushort ushort_ = *(ref <Module>.struct38_0 + selectedIndex * 72U);
			this.method_234(ushort_, byte_, 114, 0, 144);
			this.method_234(ushort_, byte_, 114, 1, 0);
			this.method_234(ushort_, byte_, 114, 2, 0);
			this.method_234(ushort_, byte_, 114, 3, 0);
			this.method_236(ushort_, byte_, 114, 4, 0, 2, 0);
			<Module>.Sleep(200);
			byte b;
			this.method_235(ushort_, byte_, 114, 4, &b);
			byte b2;
			this.method_235(ushort_, byte_, 114, 5, &b2);
			return (int)b2 | (int)b << 8;
		}

		// Token: 0x06000356 RID: 854 RVA: 0x001430DC File Offset: 0x001430DC
		private unsafe int method_306()
		{
			uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
			byte byte_ = *(ref <Module>.struct38_0 + selectedIndex * 72U + 4);
			ushort ushort_ = *(ref <Module>.struct38_0 + selectedIndex * 72U);
			this.method_242(ushort_, byte_, 114, 0, 144);
			this.method_242(ushort_, byte_, 114, 1, 0);
			this.method_242(ushort_, byte_, 114, 2, 0);
			this.method_242(ushort_, byte_, 114, 3, 0);
			this.method_244(ushort_, byte_, 114, 4, 0, 2, 0);
			<Module>.Sleep(200);
			byte b;
			this.method_243(ushort_, byte_, 114, 4, &b);
			byte b2;
			this.method_243(ushort_, byte_, 114, 5, &b2);
			return (int)b2 | (int)b << 8;
		}

		// Token: 0x06000357 RID: 855 RVA: 0x00143188 File Offset: 0x00143188
		private int method_307()
		{
			uint result;
			if (this.radioButton19.Checked)
			{
				result = (uint)this.method_309();
			}
			if (this.radioButton21.Checked)
			{
				result = (uint)this.method_310();
			}
			else
			{
				result = (uint)this.method_308();
			}
			return (int)result;
		}

		// Token: 0x06000358 RID: 856 RVA: 0x001431CC File Offset: 0x001431CC
		private unsafe int method_308()
		{
			uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
			byte byte_ = *(ref <Module>.struct38_0 + selectedIndex * 72U + 4);
			ushort num = *(ref <Module>.struct38_0 + selectedIndex * 72U);
			Struct63 @struct = 3;
			*(ref @struct + 1) = 0;
			*(ref @struct + 2) = 0;
			*(ref @struct + 3) = 0;
			Struct32 struct3;
			for (uint num2 = 0U; num2 < 4U; num2 += 1U)
			{
				this.textBox6.AppendText("\r\n" + "Reading Bank " + Convert.ToString(num2) + ": ");
				this.string_2 = "Reading Bank " + Convert.ToString(num2) + ": ";
				this.string_3 = "";
				*(ref @struct + 1) = (byte)num2;
				for (uint num3 = 0U; num3 < 256U; num3 += 1U)
				{
					if (<Module>.GetAsyncKeyState(27) != null)
					{
						this.textBox6.AppendText("\r\n" + "Aborted by User!" + "\r\n");
						return 1;
					}
					*(ref @struct + 2) = (byte)num3;
					if (num3 % 16U == 0U)
					{
						this.textBox6.AppendText(".");
						this.string_3 += ".";
						Application.DoEvents();
					}
					Struct43 struct2;
					if (num == 0)
					{
						if (this.method_269(114, 0, 4, (byte*)(&@struct)) == 0)
						{
							return 1;
						}
						if (this.method_272(114, 4, 0, 0, 1) == 0)
						{
							return 1;
						}
						if (this.method_266(114, (byte*)(&struct2)) == 0)
						{
							return 1;
						}
					}
					else
					{
						this.method_228(num, byte_, 114, 34816, 3);
						this.method_228(num, byte_, 114, 34817, (byte)num2);
						this.method_228(num, byte_, 114, 34818, (byte)num3);
						this.method_228(num, byte_, 114, 34819, 0);
						this.method_231(num, byte_, 114, 4, 0, 0, 1);
						for (uint num4 = 4U; num4 < 260U; num4 += 1U)
						{
							this.method_229(num, byte_, 114, (ushort)(num4 + 34816U), ref struct2 + (num4 - 4U));
						}
					}
					byte* ptr = ref struct3 + (num3 * 256U + num2 * 65536U);
					<Module>.memcpy((void*)ptr, (void*)(&struct2), 256U);
				}
			}
			this.textBox6.AppendText("\r\n");
			this.string_2 = "Done! ";
			this.string_3 = "";
			<Module>.memcpy(*(ref <Module>.struct121_0 + 7172), (void*)(&struct3), 262144U);
			return 0;
		}

		// Token: 0x06000359 RID: 857 RVA: 0x0014342C File Offset: 0x0014342C
		private unsafe int method_309()
		{
			uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
			byte byte_ = *(ref <Module>.struct38_0 + selectedIndex * 72U + 4);
			ushort num = *(ref <Module>.struct38_0 + selectedIndex * 72U);
			Struct63 @struct = 3;
			*(ref @struct + 1) = 0;
			*(ref @struct + 2) = 0;
			*(ref @struct + 3) = 0;
			Struct32 struct3;
			for (uint num2 = 0U; num2 < 4U; num2 += 1U)
			{
				this.textBox6.AppendText("\r\n" + "Reading Bank " + Convert.ToString(num2) + ": ");
				this.string_2 = "Reading Bank " + Convert.ToString(num2) + ": ";
				this.string_3 = "";
				*(ref @struct + 1) = (byte)num2;
				for (uint num3 = 0U; num3 < 256U; num3 += 1U)
				{
					if (<Module>.GetAsyncKeyState(27) != null)
					{
						this.textBox6.AppendText("\r\n" + "Aborted by User!" + "\r\n");
						return 1;
					}
					*(ref @struct + 2) = (byte)num3;
					if (num3 % 16U == 0U)
					{
						this.textBox6.AppendText(".");
						this.string_3 += ".";
						Application.DoEvents();
					}
					Struct43 struct2;
					if (num == 0)
					{
						if (this.method_277(114, 0, 4, (byte*)(&@struct)) == 0)
						{
							return 1;
						}
						if (this.method_279(114, 4, 0, 0, 1) == 0)
						{
							return 1;
						}
						if (this.method_274(114, (byte*)(&struct2)) == 0)
						{
							return 1;
						}
					}
					else
					{
						this.method_234(num, byte_, 114, 34816, 3);
						this.method_234(num, byte_, 114, 34817, (byte)num2);
						this.method_234(num, byte_, 114, 34818, (byte)num3);
						this.method_234(num, byte_, 114, 34819, 0);
						this.method_236(num, byte_, 114, 4, 0, 0, 1);
						for (uint num4 = 4U; num4 < 260U; num4 += 1U)
						{
							this.method_235(num, byte_, 114, (ushort)(num4 + 34816U), ref struct2 + (num4 - 4U));
						}
					}
					byte* ptr = ref struct3 + (num3 * 256U + num2 * 65536U);
					<Module>.memcpy((void*)ptr, (void*)(&struct2), 256U);
				}
			}
			this.textBox6.AppendText("\r\n");
			this.string_2 = "Done! ";
			this.string_3 = "";
			<Module>.memcpy(*(ref <Module>.struct121_0 + 7172), (void*)(&struct3), 262144U);
			return 0;
		}

		// Token: 0x0600035A RID: 858 RVA: 0x0014368C File Offset: 0x0014368C
		private unsafe int method_310()
		{
			uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
			byte byte_ = *(ref <Module>.struct38_0 + selectedIndex * 72U + 4);
			ushort num = *(ref <Module>.struct38_0 + selectedIndex * 72U);
			Struct63 @struct = 3;
			*(ref @struct + 1) = 0;
			*(ref @struct + 2) = 0;
			*(ref @struct + 3) = 0;
			Struct32 struct3;
			for (uint num2 = 0U; num2 < 4U; num2 += 1U)
			{
				this.textBox6.AppendText("\r\n" + "Reading Bank " + Convert.ToString(num2) + ": ");
				this.string_2 = "Reading Bank " + Convert.ToString(num2) + ": ";
				this.string_3 = "";
				*(ref @struct + 1) = (byte)num2;
				for (uint num3 = 0U; num3 < 256U; num3 += 1U)
				{
					if (<Module>.GetAsyncKeyState(27) != null)
					{
						this.textBox6.AppendText("\r\n" + "Aborted by User!" + "\r\n");
						return 1;
					}
					*(ref @struct + 2) = (byte)num3;
					if (num3 % 16U == 0U)
					{
						this.textBox6.AppendText(".");
						this.string_3 += ".";
						Application.DoEvents();
					}
					Struct43 struct2;
					if (num == 0)
					{
						if (this.method_283(114, 0, 4, (byte*)(&@struct)) == 0)
						{
							return 1;
						}
						if (this.method_285(114, 4, 0, 0, 1) == 0)
						{
							return 1;
						}
						if (this.method_281(114, (byte*)(&struct2)) == 0)
						{
							return 1;
						}
					}
					else
					{
						this.method_242(num, byte_, 114, 34816, 3);
						this.method_242(num, byte_, 114, 34817, (byte)num2);
						this.method_242(num, byte_, 114, 34818, (byte)num3);
						this.method_242(num, byte_, 114, 34819, 0);
						this.method_244(num, byte_, 114, 4, 0, 0, 1);
						for (uint num4 = 4U; num4 < 260U; num4 += 1U)
						{
							this.method_235(num, byte_, 114, (ushort)(num4 + 34816U), ref struct2 + (num4 - 4U));
						}
					}
					byte* ptr = ref struct3 + (num3 * 256U + num2 * 65536U);
					<Module>.memcpy((void*)ptr, (void*)(&struct2), 256U);
				}
			}
			this.textBox6.AppendText("\r\n");
			this.string_2 = "Done! ";
			this.string_3 = "";
			<Module>.memcpy(*(ref <Module>.struct121_0 + 7172), (void*)(&struct3), 262144U);
			return 0;
		}

		// Token: 0x0600035B RID: 859 RVA: 0x001438EC File Offset: 0x001438EC
		private unsafe int method_311()
		{
			uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
			byte byte_ = *(ref <Module>.struct38_0 + selectedIndex * 72U + 4);
			ushort ushort_ = *(ref <Module>.struct38_0 + selectedIndex * 72U);
			this.textBox6.AppendText("\r\n" + "Sending Chip Erase to Port " + this.label123.Text + "\r\n");
			this.method_228(ushort_, byte_, 114, 34816, 6);
			this.method_231(ushort_, byte_, 114, 1, 0, 0, 0);
			int result;
			if (this.method_232(ushort_, byte_, 114, 2) == 1)
			{
				result = 0;
			}
			else
			{
				if (string.Compare(this.label118.Text, "0xBF") == 0)
				{
					this.method_228(ushort_, byte_, 114, 34816, 96);
				}
				else if (string.Compare(this.label118.Text, "0x1F") == 0)
				{
					this.method_228(ushort_, byte_, 114, 34816, 98);
				}
				else
				{
					this.method_228(ushort_, byte_, 114, 34816, 199);
				}
				this.method_231(ushort_, byte_, 114, 1, 0, 0, 0);
				this.textBox6.AppendText("Erasing:");
				this.string_2 = string.Concat("Erasing Chip: ");
				this.string_3 = "";
				if (this.method_232(ushort_, byte_, 114, 0) == 1)
				{
					result = 0;
				}
				else
				{
					this.textBox6.AppendText("\r\n");
					result = 1;
				}
			}
			return result;
		}

		// Token: 0x0600035C RID: 860 RVA: 0x00143A48 File Offset: 0x00143A48
		private unsafe int method_312()
		{
			uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
			byte byte_ = *(ref <Module>.struct38_0 + selectedIndex * 72U + 4);
			ushort ushort_ = *(ref <Module>.struct38_0 + selectedIndex * 72U);
			this.textBox6.AppendText("\r\n" + "Sending Chip Erase to Port " + this.label123.Text + "\r\n");
			this.method_234(ushort_, byte_, 114, 34816, 6);
			this.method_236(ushort_, byte_, 114, 1, 0, 0, 0);
			int result;
			if (this.method_237(ushort_, byte_, 114, 2) == 1)
			{
				result = 0;
			}
			else
			{
				if (this.label118.Text == new string((sbyte*)(&<Module>.struct35_132)))
				{
					this.method_234(ushort_, byte_, 114, 34816, 96);
				}
				else if (this.label118.Text == new string((sbyte*)(&<Module>.struct35_133)))
				{
					this.method_234(ushort_, byte_, 114, 34816, 98);
				}
				else
				{
					this.method_234(ushort_, byte_, 114, 34816, 199);
				}
				this.method_236(ushort_, byte_, 114, 1, 0, 0, 0);
				this.textBox6.AppendText("Erasing:");
				this.string_2 = string.Concat("Erasing Chip: ");
				this.string_3 = "";
				if (this.method_237(ushort_, byte_, 114, 0) == 1)
				{
					result = 0;
				}
				else
				{
					this.textBox6.AppendText("\r\n");
					result = 1;
				}
			}
			return result;
		}

		// Token: 0x0600035D RID: 861 RVA: 0x00143BA4 File Offset: 0x00143BA4
		private unsafe int method_313()
		{
			uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
			byte byte_ = *(ref <Module>.struct38_0 + selectedIndex * 72U + 4);
			ushort ushort_ = *(ref <Module>.struct38_0 + selectedIndex * 72U);
			this.textBox6.AppendText("\r\n" + "Sending Chip Erase to Port " + this.label123.Text + "\r\n");
			this.method_242(ushort_, byte_, 114, 34816, 6);
			this.method_244(ushort_, byte_, 114, 1, 0, 0, 0);
			int result;
			if (this.method_245(ushort_, byte_, 114, 2) == 1)
			{
				result = 0;
			}
			else
			{
				if (this.label118.Text == new string((sbyte*)(&<Module>.struct35_132)))
				{
					this.method_242(ushort_, byte_, 114, 34816, 96);
				}
				else if (this.label118.Text == new string((sbyte*)(&<Module>.struct35_133)))
				{
					this.method_242(ushort_, byte_, 114, 34816, 98);
				}
				else
				{
					this.method_242(ushort_, byte_, 114, 34816, 199);
				}
				this.method_244(ushort_, byte_, 114, 1, 0, 0, 0);
				this.textBox6.AppendText("Erasing:");
				this.string_2 = string.Concat("Erasing Chip: ");
				this.string_3 = "";
				if (this.method_245(ushort_, byte_, 114, 0) == 1)
				{
					result = 0;
				}
				else
				{
					this.textBox6.AppendText("\r\n");
					result = 1;
				}
			}
			return result;
		}

		// Token: 0x0600035E RID: 862 RVA: 0x00143D00 File Offset: 0x00143D00
		private unsafe int method_314()
		{
			uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
			byte byte_ = *(ref <Module>.struct38_0 + selectedIndex * 72U + 4);
			ushort ushort_ = *(ref <Module>.struct38_0 + selectedIndex * 72U);
			this.method_228(ushort_, byte_, 114, 34816, 5);
			this.method_231(ushort_, byte_, 114, 1, 0, 1, 0);
			byte b;
			this.method_229(ushort_, byte_, 114, 1, &b);
			int result;
			if (b == 140)
			{
				this.textBox6.AppendText("Spi Status: 0x8C.. Already locked !" + "\r\n");
				result = 0;
			}
			else if (b == 142)
			{
				this.textBox6.AppendText("Spi Status: 0x8E.. Already locked !" + "\r\n");
				result = 0;
			}
			else
			{
				this.method_228(ushort_, byte_, 114, 34816, 6);
				this.method_231(ushort_, byte_, 114, 1, 0, 0, 0);
				this.method_228(ushort_, byte_, 114, 34816, 1);
				this.method_228(ushort_, byte_, 114, 34817, 140);
				this.method_231(ushort_, byte_, 114, 2, 0, 0, 0);
				<Module>.Sleep(500);
				this.method_228(ushort_, byte_, 114, 34816, 5);
				this.method_231(ushort_, byte_, 114, 1, 0, 1, 0);
				this.method_229(ushort_, byte_, 114, 1, &b);
				if ((b & 128) != 0)
				{
					this.textBox6.AppendText("Spi Status: 0x8C" + "\r\n");
					result = 1;
				}
				else
				{
					result = 0;
				}
			}
			return result;
		}

		// Token: 0x0600035F RID: 863 RVA: 0x00143E68 File Offset: 0x00143E68
		private unsafe int method_315()
		{
			byte b = 140;
			uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
			byte byte_ = *(ref <Module>.struct38_0 + selectedIndex * 72U + 4);
			ushort ushort_ = *(ref <Module>.struct38_0 + selectedIndex * 72U);
			this.method_228(ushort_, byte_, 114, 34816, 6);
			this.method_231(ushort_, byte_, 114, 1, 0, 0, 0);
			this.method_228(ushort_, byte_, 114, 34816, 1);
			this.method_228(ushort_, byte_, 114, 34817, 0);
			this.method_231(ushort_, byte_, 114, 2, 0, 0, 0);
			this.method_228(ushort_, byte_, 114, 34816, 5);
			this.method_231(ushort_, byte_, 114, 1, 0, 1, 0);
			this.method_229(ushort_, byte_, 114, 1, &b);
			Struct20 @struct;
			<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct35_121), b);
			string text = new string((sbyte*)(&<Module>.struct19_0));
			text += new string((sbyte*)(&@struct));
			this.label122.Text = "Spi Status register 0x" + text;
			if ((b & 128) == 0)
			{
				<Module>.Sleep(500);
				this.method_228(ushort_, byte_, 114, 34816, 5);
				this.method_231(ushort_, byte_, 114, 1, 0, 1, 0);
				this.method_229(ushort_, byte_, 114, 1, &b);
				if (b == 0)
				{
					this.textBox6.AppendText("." + "\r\n" + "Spi Status: 0x00" + "\r\n");
					this.button42.Text = new string((sbyte*)(&<Module>.struct35_131));
					this.button42.Enabled = true;
					this.toolTip_0.SetToolTip(this.button42, "Click to lock Spi status register");
					return 1;
				}
			}
			return 0;
		}

		// Token: 0x06000360 RID: 864 RVA: 0x0014400C File Offset: 0x0014400C
		private unsafe void method_316()
		{
			uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
			byte byte_ = *(ref <Module>.struct38_0 + selectedIndex * 72U + 4);
			ushort ushort_ = *(ref <Module>.struct38_0 + selectedIndex * 72U);
			this.method_228(ushort_, byte_, 114, 34816, 80);
			this.method_231(ushort_, byte_, 114, 1, 0, 0, 0);
			this.method_228(ushort_, byte_, 114, 34816, 1);
			this.method_228(ushort_, byte_, 114, 34817, 0);
			this.method_231(ushort_, byte_, 114, 2, 0, 0, 0);
		}

		// Token: 0x06000361 RID: 865 RVA: 0x00144094 File Offset: 0x00144094
		private unsafe int method_317()
		{
			uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
			byte byte_ = *(ref <Module>.struct38_0 + selectedIndex * 72U + 4);
			ushort ushort_ = *(ref <Module>.struct38_0 + selectedIndex * 72U);
			this.method_228(ushort_, byte_, 114, 34816, 5);
			this.method_231(ushort_, byte_, 114, 1, 0, 1, 0);
			byte result;
			this.method_229(ushort_, byte_, 114, 1, &result);
			return (int)result;
		}

		// Token: 0x06000362 RID: 866 RVA: 0x001440F8 File Offset: 0x001440F8
		private int method_318()
		{
			if (this.radioButton19.Checked)
			{
				if (this.method_320() == 1)
				{
					return 1;
				}
			}
			else if (this.method_319() == 1)
			{
				return 1;
			}
			return 0;
		}

		// Token: 0x06000363 RID: 867 RVA: 0x00144130 File Offset: 0x00144130
		private unsafe int method_319()
		{
			Struct63 @struct = 6;
			*(ref @struct + 1) = 0;
			*(ref @struct + 2) = 0;
			*(ref @struct + 3) = 0;
			uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
			byte byte_ = *(ref <Module>.struct38_0 + selectedIndex * 72U + 4);
			ushort num = *(ref <Module>.struct38_0 + selectedIndex * 72U);
			if (num == 0)
			{
				if (this.method_269(114, 0, 4, (byte*)(&@struct)) == 0)
				{
					return 1;
				}
				if (this.method_272(114, 1, 0, 0, 0) == 0)
				{
					return 1;
				}
			}
			else
			{
				this.method_228(num, byte_, 114, 34816, 6);
				this.method_231(num, byte_, 114, 1, 0, 0, 0);
			}
			return 0;
		}

		// Token: 0x06000364 RID: 868 RVA: 0x001441C4 File Offset: 0x001441C4
		private unsafe int method_320()
		{
			Struct63 @struct = 6;
			*(ref @struct + 1) = 0;
			*(ref @struct + 2) = 0;
			*(ref @struct + 3) = 0;
			uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
			byte byte_ = *(ref <Module>.struct38_0 + selectedIndex * 72U + 4);
			ushort num = *(ref <Module>.struct38_0 + selectedIndex * 72U);
			if (num == 0)
			{
				if (this.method_277(114, 0, 4, (byte*)(&@struct)) == 0)
				{
					return 1;
				}
				if (this.method_279(114, 1, 0, 0, 0) == 0)
				{
					return 1;
				}
			}
			else
			{
				this.method_234(num, byte_, 114, 34816, 6);
				this.method_236(num, byte_, 114, 1, 0, 0, 0);
			}
			return 0;
		}

		// Token: 0x06000365 RID: 869 RVA: 0x00144258 File Offset: 0x00144258
		private unsafe int method_321()
		{
			byte b = 140;
			uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
			byte byte_ = *(ref <Module>.struct38_0 + selectedIndex * 72U + 4);
			ushort num = *(ref <Module>.struct38_0 + selectedIndex * 72U);
			<Module>.smethod_2(num + 6, byte_);
			<Module>.smethod_2(num + 3, 217);
			<Module>.smethod_2(num + 7, 137);
			<Module>.Sleep(2);
			<Module>.smethod_2(num + 6, byte_);
			byte b2 = <Module>.smethod_1(num + 7);
			int result;
			if (b2 != 114)
			{
				Struct20 @struct;
				<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct35_121), b);
				string text = new string((sbyte*)(&<Module>.struct19_0));
				text += new string((sbyte*)(&@struct));
				this.label122.Text = "Status 0x" + text;
				result = 0;
			}
			else
			{
				this.method_234(num, byte_, 114, 34816, 6);
				this.method_236(num, byte_, 114, 1, 0, 0, 0);
				this.method_234(num, byte_, 114, 34816, 1);
				this.method_234(num, byte_, 114, 34817, 0);
				this.method_236(num, byte_, 114, 2, 0, 0, 0);
				this.method_234(num, byte_, 114, 34816, 5);
				this.method_236(num, byte_, 114, 1, 0, 1, 0);
				this.method_235(num, byte_, 114, 1, &b);
				Struct20 @struct;
				<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct35_121), b);
				string text = new string((sbyte*)(&<Module>.struct19_0));
				text += new string((sbyte*)(&@struct));
				this.label122.Text = "Spi Status register 0x" + text;
				if ((b & 128) == 0)
				{
					<Module>.Sleep(500);
					this.method_234(num, byte_, 114, 34816, 5);
					this.method_236(num, byte_, 114, 1, 0, 1, 0);
					this.method_235(num, byte_, 114, 1, &b);
					if (b == 0)
					{
						this.textBox6.AppendText("\r\n" + "Spi Status: 0x00" + "\r\n");
						this.button42.Text = new string((sbyte*)(&<Module>.struct35_131));
						this.button42.Enabled = true;
						this.toolTip_0.SetToolTip(this.button42, "Click to lock Spi status register");
						<Module>.MessageBeep(0U);
						<Module>.Beep(500, 500);
						<Module>.MessageBeep(0U);
						<Module>.Beep(750, 500);
						<Module>.MessageBeep(0U);
						<Module>.Beep(500, 500);
						return 1;
					}
				}
				result = 0;
			}
			return result;
		}

		// Token: 0x06000366 RID: 870 RVA: 0x001444C8 File Offset: 0x001444C8
		private unsafe int method_322()
		{
			uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
			byte byte_ = *(ref <Module>.struct38_0 + selectedIndex * 72U + 4);
			ushort ushort_ = *(ref <Module>.struct38_0 + selectedIndex * 72U);
			this.method_234(ushort_, byte_, 114, 34816, 5);
			this.method_236(ushort_, byte_, 114, 1, 0, 1, 0);
			byte b;
			this.method_235(ushort_, byte_, 114, 1, &b);
			int result;
			if (b == 140)
			{
				this.textBox6.AppendText("Spi Status: 0x8C.. Already locked !" + "\r\n");
				result = 0;
			}
			else if (b == 142)
			{
				this.textBox6.AppendText("Spi Status: 0x8E.. Already locked !" + "\r\n");
				result = 0;
			}
			else
			{
				this.method_234(ushort_, byte_, 114, 34816, 6);
				this.method_236(ushort_, byte_, 114, 1, 0, 0, 0);
				this.method_234(ushort_, byte_, 114, 34816, 1);
				this.method_234(ushort_, byte_, 114, 34817, 140);
				this.method_236(ushort_, byte_, 114, 2, 0, 0, 0);
				<Module>.Sleep(500);
				this.method_234(ushort_, byte_, 114, 34816, 5);
				this.method_236(ushort_, byte_, 114, 1, 0, 1, 0);
				this.method_235(ushort_, byte_, 114, 1, &b);
				if ((b & 128) != 0)
				{
					this.textBox6.AppendText("Spi Status: 0x8C" + "\r\n");
					result = 1;
				}
				else
				{
					result = 0;
				}
			}
			return result;
		}

		// Token: 0x06000367 RID: 871 RVA: 0x00144630 File Offset: 0x00144630
		private unsafe int method_323()
		{
			uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
			byte byte_ = *(ref <Module>.struct38_0 + selectedIndex * 72U + 4);
			ushort ushort_ = *(ref <Module>.struct38_0 + selectedIndex * 72U);
			this.method_234(ushort_, byte_, 114, 34816, 5);
			this.method_236(ushort_, byte_, 114, 1, 0, 1, 0);
			byte result;
			this.method_235(ushort_, byte_, 114, 1, &result);
			return (int)result;
		}

		// Token: 0x06000368 RID: 872 RVA: 0x00144694 File Offset: 0x00144694
		private unsafe int method_324()
		{
			uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
			byte byte_ = *(ref <Module>.struct38_0 + selectedIndex * 72U + 4);
			ushort ushort_ = *(ref <Module>.struct38_0 + selectedIndex * 72U);
			this.method_234(ushort_, byte_, 114, 34816, 6);
			this.method_236(ushort_, byte_, 114, 1, 0, 0, 0);
			this.method_234(ushort_, byte_, 114, 34816, 1);
			this.method_234(ushort_, byte_, 114, 34817, 0);
			this.method_236(ushort_, byte_, 114, 2, 0, 0, 0);
			this.method_234(ushort_, byte_, 114, 34816, 5);
			this.method_236(ushort_, byte_, 114, 1, 0, 1, 0);
			byte b;
			this.method_235(ushort_, byte_, 114, 1, &b);
			if ((b & 128) == 0)
			{
				<Module>.Sleep(500);
				this.method_234(ushort_, byte_, 114, 34816, 5);
				this.method_236(ushort_, byte_, 114, 1, 0, 1, 0);
				this.method_235(ushort_, byte_, 114, 1, &b);
				if (b == 0)
				{
					return 1;
				}
			}
			return 0;
		}

		// Token: 0x06000369 RID: 873 RVA: 0x00144790 File Offset: 0x00144790
		private unsafe int method_325()
		{
			uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
			byte byte_ = *(ref <Module>.struct38_0 + selectedIndex * 72U + 4);
			ushort ushort_ = *(ref <Module>.struct38_0 + selectedIndex * 72U);
			this.method_242(ushort_, byte_, 114, 34816, 5);
			this.method_244(ushort_, byte_, 114, 1, 0, 1, 0);
			byte result;
			this.method_243(ushort_, byte_, 114, 1, &result);
			return (int)result;
		}

		// Token: 0x0600036A RID: 874 RVA: 0x001447F4 File Offset: 0x001447F4
		private unsafe int method_326()
		{
			Struct63 @struct = 6;
			*(ref @struct + 1) = 0;
			*(ref @struct + 2) = 0;
			*(ref @struct + 3) = 0;
			Struct76 struct2 = 2;
			*(ref struct2 + 1) = 0;
			*(ref struct2 + 2) = 0;
			*(ref struct2 + 3) = 0;
			Struct32 struct3;
			<Module>.memcpy((void*)(&struct3), *(ref <Module>.struct121_0 + 4780), 262144U);
			uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
			byte byte_ = *(ref <Module>.struct38_0 + selectedIndex * 72U + 4);
			ushort num = *(ref <Module>.struct38_0 + selectedIndex * 72U);
			for (uint num2 = 0U; num2 < 4U; num2 += 1U)
			{
				this.textBox6.AppendText("Writing Bank " + Convert.ToString(num2) + ": ");
				this.string_2 = "Writing Bank " + Convert.ToString(num2) + ": ";
				this.string_3 = "";
				*(ref struct2 + 1) = (byte)num2;
				for (uint num3 = 0U; num3 < 256U; num3 += 1U)
				{
					if (<Module>.GetAsyncKeyState(27) != null)
					{
						this.textBox6.AppendText("\r\n" + "Aborted by User!" + "\r\n");
						return 1;
					}
					if (num3 % 16U == 0U)
					{
						this.textBox6.AppendText(".");
						this.string_3 += ".";
						Application.DoEvents();
					}
					if (num == 0)
					{
						*(ref struct2 + 2) = (byte)num3;
						<Module>.memcpy(ref struct2 + 4, ref struct3 + (num3 * 256U + num2 * 65536U), 256U);
						if (this.method_270(114, (byte*)(&struct2)) == 0)
						{
							return 1;
						}
					}
					else
					{
						this.method_228(num, byte_, 114, 34816, 6);
						this.method_231(num, byte_, 114, 1, 0, 0, 0);
						if (this.method_232(num, byte_, 114, 2) == 1)
						{
							return 1;
						}
						this.method_228(num, byte_, 114, 34816, 2);
						this.method_228(num, byte_, 114, 34817, (byte)num2);
						this.method_228(num, byte_, 114, 34818, (byte)num3);
						this.method_228(num, byte_, 114, 34819, 0);
						for (uint num4 = 0U; num4 < 256U; num4 += 1U)
						{
							this.method_228(num, byte_, 114, (ushort)(num4 + 34820U), *(ref struct3 + (num4 + num3 * 256U + num2 * 65536U)));
						}
						this.method_231(num, byte_, 114, 4, 1, 0, 0);
						if (this.method_232(num, byte_, 114, 0) == 1)
						{
							return 1;
						}
					}
				}
				this.textBox6.AppendText("\r\n");
				this.string_2 = "Done! ";
				this.string_3 = "";
			}
			return 0;
		}

		// Token: 0x0600036B RID: 875 RVA: 0x00144A90 File Offset: 0x00144A90
		private unsafe int method_327()
		{
			Struct63 @struct = 6;
			*(ref @struct + 1) = 0;
			*(ref @struct + 2) = 0;
			*(ref @struct + 3) = 0;
			Struct76 struct2 = 2;
			*(ref struct2 + 1) = 0;
			*(ref struct2 + 2) = 0;
			*(ref struct2 + 3) = 0;
			Struct32 struct3;
			<Module>.memcpy((void*)(&struct3), *(ref <Module>.struct121_0 + 4780), 262144U);
			uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
			byte byte_ = *(ref <Module>.struct38_0 + selectedIndex * 72U + 4);
			ushort num = *(ref <Module>.struct38_0 + selectedIndex * 72U);
			for (uint num2 = 0U; num2 < 4U; num2 += 1U)
			{
				this.textBox6.AppendText("Writing Bank " + Convert.ToString(num2) + ": ");
				this.string_2 = "Writing Bank " + Convert.ToString(num2) + ": ";
				this.string_3 = "";
				*(ref struct2 + 1) = (byte)num2;
				for (uint num3 = 0U; num3 < 256U; num3 += 1U)
				{
					if (<Module>.GetAsyncKeyState(27) != null)
					{
						this.textBox6.AppendText("\r\n" + "Aborted by User!" + "\r\n");
						return 1;
					}
					if (num3 % 16U == 0U)
					{
						this.textBox6.AppendText(".");
						this.string_3 += ".";
						Application.DoEvents();
					}
					if (num == 0)
					{
						*(ref struct2 + 2) = (byte)num3;
						<Module>.memcpy(ref struct2 + 4, ref struct3 + (num3 * 256U + num2 * 65536U), 256U);
						if (this.method_278(114, (byte*)(&struct2)) == 0)
						{
							return 1;
						}
					}
					else
					{
						this.method_234(num, byte_, 114, 34816, 6);
						this.method_236(num, byte_, 114, 1, 0, 0, 0);
						if (this.method_237(num, byte_, 114, 2) == 1)
						{
							return 1;
						}
						this.method_234(num, byte_, 114, 34816, 2);
						this.method_234(num, byte_, 114, 34817, (byte)num2);
						this.method_234(num, byte_, 114, 34818, (byte)num3);
						this.method_234(num, byte_, 114, 34819, 0);
						for (uint num4 = 0U; num4 < 256U; num4 += 1U)
						{
							this.method_234(num, byte_, 114, (ushort)(num4 + 34820U), *(ref struct3 + (num4 + num3 * 256U + num2 * 65536U)));
						}
						this.method_236(num, byte_, 114, 4, 1, 0, 0);
						if (this.method_237(num, byte_, 114, 0) == 1)
						{
							return 1;
						}
					}
				}
				this.textBox6.AppendText("\r\n");
				this.string_2 = "Done! ";
				this.string_3 = "";
			}
			return 0;
		}

		// Token: 0x0600036C RID: 876 RVA: 0x00144D2C File Offset: 0x00144D2C
		private unsafe int method_328()
		{
			Struct63 @struct = 6;
			*(ref @struct + 1) = 0;
			*(ref @struct + 2) = 0;
			*(ref @struct + 3) = 0;
			Struct76 struct2 = 2;
			*(ref struct2 + 1) = 0;
			*(ref struct2 + 2) = 0;
			*(ref struct2 + 3) = 0;
			Struct32 struct3;
			<Module>.memcpy((void*)(&struct3), *(ref <Module>.struct121_0 + 4780), 262144U);
			uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
			byte byte_ = *(ref <Module>.struct38_0 + selectedIndex * 72U + 4);
			ushort num = *(ref <Module>.struct38_0 + selectedIndex * 72U);
			for (uint num2 = 0U; num2 < 4U; num2 += 1U)
			{
				this.textBox6.AppendText("Writing Bank " + Convert.ToString(num2) + ": ");
				this.string_2 = "Writing Bank " + Convert.ToString(num2) + ": ";
				this.string_3 = "";
				*(ref struct2 + 1) = (byte)num2;
				for (uint num3 = 0U; num3 < 256U; num3 += 1U)
				{
					if (<Module>.GetAsyncKeyState(27) != null)
					{
						this.textBox6.AppendText("\r\n" + "Aborted by User!" + "\r\n");
						return 1;
					}
					if (num3 % 16U == 0U)
					{
						this.textBox6.AppendText(".");
						this.string_3 += ".";
						Application.DoEvents();
					}
					if (num == 0)
					{
						*(ref struct2 + 2) = (byte)num3;
						<Module>.memcpy(ref struct2 + 4, ref struct3 + (num3 * 256U + num2 * 65536U), 256U);
						if (this.method_284(114, (byte*)(&struct2)) == 0)
						{
							return 1;
						}
					}
					else
					{
						this.method_242(num, byte_, 114, 34816, 6);
						this.method_244(num, byte_, 114, 1, 0, 0, 0);
						if (this.method_245(num, byte_, 114, 2) == 1)
						{
							return 1;
						}
						this.method_242(num, byte_, 114, 34816, 2);
						this.method_242(num, byte_, 114, 34817, (byte)num2);
						this.method_242(num, byte_, 114, 34818, (byte)num3);
						this.method_242(num, byte_, 114, 34819, 0);
						for (uint num4 = 0U; num4 < 256U; num4 += 1U)
						{
							this.method_242(num, byte_, 114, (ushort)(num4 + 34820U), *(ref struct3 + (num4 + num3 * 256U + num2 * 65536U)));
						}
						this.method_244(num, byte_, 114, 4, 1, 0, 0);
						if (this.method_245(num, byte_, 114, 0) == 1)
						{
							return 1;
						}
					}
				}
				this.textBox6.AppendText("\r\n");
				this.string_2 = "Done! ";
				this.string_3 = "";
			}
			return 0;
		}

		// Token: 0x0600036D RID: 877 RVA: 0x00144FC8 File Offset: 0x00144FC8
		private unsafe int method_329()
		{
			uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
			byte byte_ = *(ref <Module>.struct38_0 + selectedIndex * 72U + 4);
			ushort ushort_ = *(ref <Module>.struct38_0 + selectedIndex * 72U);
			this.textBox6.AppendText("\r\n" + "Sending Sector Erase to Port " + this.label123.Text + "\r\n");
			this.method_234(ushort_, byte_, 114, 34816, 6);
			this.method_236(ushort_, byte_, 114, 1, 0, 0, 0);
			int result;
			if (this.method_237(ushort_, byte_, 114, 2) == 1)
			{
				result = 0;
			}
			else
			{
				this.method_234(ushort_, byte_, 114, 34816, 32);
				this.method_234(ushort_, byte_, 114, 34817, 3);
				this.method_234(ushort_, byte_, 114, 34818, 224);
				this.method_234(ushort_, byte_, 114, 34819, 0);
				this.method_236(ushort_, byte_, 114, 4, 0, 0, 0);
				if (this.method_237(ushort_, byte_, 114, 0) == 1)
				{
					result = 0;
				}
				else
				{
					this.textBox6.AppendText("Erasing: 0x3E000");
					this.string_2 = string.Concat("Erasing:  0x3E000");
					this.string_3 = "";
					this.textBox6.AppendText("\r\n");
					result = 1;
				}
			}
			return result;
		}

		// Token: 0x0600036E RID: 878 RVA: 0x00145100 File Offset: 0x00145100
		private unsafe int method_330(byte* pByte_0)
		{
			Struct63 @struct = 6;
			*(ref @struct + 1) = 0;
			*(ref @struct + 2) = 0;
			*(ref @struct + 3) = 0;
			Struct76 struct2 = 2;
			*(ref struct2 + 1) = 0;
			*(ref struct2 + 2) = 0;
			*(ref struct2 + 3) = 0;
			Struct33 struct3;
			<Module>.memcpy((void*)(&struct3), (void*)pByte_0, 4096U);
			uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
			byte byte_ = *(ref <Module>.struct38_0 + selectedIndex * 72U + 4);
			ushort num = *(ref <Module>.struct38_0 + selectedIndex * 72U);
			this.textBox6.AppendText(string.Concat("Writing: 0x3E000 "));
			this.string_2 = string.Concat("Writing: 0x3E000 ");
			this.string_3 = "";
			uint num2 = 3U;
			*(ref struct2 + 1) = 3;
			uint num3 = 224U;
			while (num3 < 240U)
			{
				if (<Module>.GetAsyncKeyState(27) == null)
				{
					if (num == 0)
					{
						*(ref struct2 + 2) = (byte)num3;
						<Module>.memcpy(ref struct2 + 4, ref struct3 + (num3 - 224U) * 256U, 256U);
						if (this.method_278(114, (byte*)(&struct2)) == 0)
						{
							return 0;
						}
					}
					else
					{
						this.method_234(num, byte_, 114, 34816, 6);
						this.method_236(num, byte_, 114, 1, 0, 0, 0);
						if (this.method_237(num, byte_, 114, 2) == 1)
						{
							return 0;
						}
						this.method_234(num, byte_, 114, 34816, 2);
						this.method_234(num, byte_, 114, 34817, (byte)num2);
						this.method_234(num, byte_, 114, 34818, (byte)num3);
						this.method_234(num, byte_, 114, 34819, 0);
						for (uint num4 = 0U; num4 < 256U; num4 += 1U)
						{
							this.method_234(num, byte_, 114, (ushort)(num4 + 34820U), *(ref struct3 + (num4 + (num3 - 224U) * 256U)));
						}
						this.method_236(num, byte_, 114, 4, 1, 0, 0);
						if (this.method_237(num, byte_, 114, 0) == 1)
						{
							return 0;
						}
					}
					num3 += 1U;
					continue;
				}
				this.textBox6.AppendText("\r\n" + "Aborted by User!" + "\r\n");
				return 0;
			}
			this.textBox6.AppendText("\r\n");
			this.string_2 = "Done! ";
			this.string_3 = "";
			return 1;
		}

		// Token: 0x0600036F RID: 879 RVA: 0x003CBB0C File Offset: 0x00313B0C
		private unsafe int method_331()
		{
			int result;
			if (this.comboBox1.Items.Count == 0)
			{
				result = 0;
			}
			else
			{
				uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
				ushort num = *(ref <Module>.struct38_0 + selectedIndex * 72U);
				uint num2;
				if (*(ref <Module>.struct38_0 + selectedIndex * 72U + 4) == 160)
				{
					num2 = 0U;
				}
				else
				{
					num2 = 16U;
				}
				if (!this.bool_2)
				{
					string text = "" + "You are about to send the mode-B command to your Hitachi Drive." + "\n";
					text = text + "For Best results open drive tray now and power off the drive." + "\n";
					text = text + "Then press OK to continue. When dots show, power on the drive." + "\n";
					text = text + "Drive should respond to normal windows Inquiry and close." + "\n";
					if (this.radioButton17.Checked)
					{
						text = text + "Wait 15 seconds for Windows to recognise drive.." + "\n";
					}
					text = text + "\n" + "When done, it's important to confirm Mode-B with double press to" + "\n";
					text = text + "open and close drive tray." + "\n\n";
					text += "Press Escape to cancel.";
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					uint num3 = (uint)MessageBox.Show(text, "Send Mode-B Command", MessageBoxButtons.OKCancel, MessageBoxIcon.Question);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
					if (num3 == 2U)
					{
						return 1;
					}
				}
				GStruct3 gstruct;
				<Module>.smethod_21(&gstruct, num, 0, 1, 250U);
				Struct52 @struct;
				<Module>.memset((void*)(&@struct), 0, 12U);
				@struct = 231;
				*(ref @struct + 1) = 72;
				*(ref @struct + 2) = 73;
				*(ref @struct + 3) = 84;
				*(ref @struct + 4) = 48;
				*(ref @struct + 5) = 144;
				*(ref @struct + 6) = 144;
				*(ref @struct + 7) = 208;
				*(ref @struct + 8) = 1;
				while (<Module>.smethod_15((byte*)(&@struct), 12U, (byte)num2, 1, &gstruct) != null)
				{
					this.textBox6.AppendText(".");
					Application.DoEvents();
					<Module>.Sleep(250);
					if (<Module>.GetAsyncKeyState(27) != null)
					{
						this.textBox6.AppendText("\r\n" + "Aborted by User!" + "\r\n");
						return 1;
					}
				}
				<Module>.memset((void*)(&@struct), 0, 12U);
				@struct = 18;
				*(ref @struct + 1) = 0;
				*(ref @struct + 2) = 0;
				*(ref @struct + 3) = 0;
				*(ref @struct + 4) = 36;
				*(ref @struct + 5) = 0;
				Struct100 struct2;
				uint num4;
				if (<Module>.smethod_16((byte*)(&@struct), 12U, (byte)num2, 512, (void*)(&struct2), &num4, 36U, 1, &gstruct) != null)
				{
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					MessageBox.Show("Inquiry command Failed !", "Warning", MessageBoxButtons.OK, MessageBoxIcon.Hand);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
					result = 1;
				}
				else
				{
					this.method_5((byte*)(&struct2), 36U, 0U);
					this.textBox6.AppendText("\r\n" + "Drive, answers normal Windows Inquiry 12 0 0 0 24 0" + "\r\n");
					this.textBox6.AppendText(this.string_0 + "\r\n");
					this.textBox6.AppendText("Mode-B Done! " + "\r\n");
					if (*(ref struct2 + 34) == 53)
					{
						this.radioButton4.Checked = true;
					}
					else if (*(ref struct2 + 34) == 55)
					{
						this.radioButton5.Checked = true;
					}
					else if (*(ref struct2 + 34) == 52 & *(ref struct2 + 35) != 48)
					{
						this.radioButton3.Checked = true;
					}
					else if (*(ref struct2 + 34) == 51 & *(ref struct2 + 35) == 54)
					{
						this.radioButton2.Checked = true;
					}
					else
					{
						this.radioButton1.Checked = true;
					}
					uint num5 = 0U;
					for (;;)
					{
						<Module>.memset((void*)(&@struct), 0, 12U);
						@struct = 27;
						*(ref @struct + 4) = 3;
						if (<Module>.smethod_15((byte*)(&@struct), 12U, (byte)num2, 1, &gstruct) == null)
						{
							goto IL_3BD;
						}
						<Module>.Sleep(200);
						if (num5 == 10U)
						{
							break;
						}
						num5 += 1U;
					}
					return 1;
					IL_3BD:
					if (num == 0 && this.checkBox15.CheckState == CheckState.Unchecked)
					{
						this.method_424(1);
						this.bool_9 = true;
						<Module>.Sleep(10);
						this.method_424(5);
						<Module>.Sleep(25);
						this.method_424(7);
						this.method_422();
					}
					result = 0;
				}
			}
			return result;
		}

		// Token: 0x06000370 RID: 880 RVA: 0x0014573C File Offset: 0x0014573C
		private void button27_Click(object sender, EventArgs e)
		{
			if (this.radioButton17.Checked)
			{
				this.textBox6.AppendText("Scanning for hardware changes" + "\r\n");
				if (<Module>.smethod_121() != null)
				{
					this.textBox6.AppendText("Scan returned an error!" + "\r\n");
				}
			}
		}

		// Token: 0x06000371 RID: 881 RVA: 0x00145794 File Offset: 0x00145794
		private unsafe void method_332()
		{
			if (this.comboBox16.Items.Count == 0)
			{
				<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
				MessageBox.Show("No drive Selected", "Warning", MessageBoxButtons.OK, MessageBoxIcon.Hand);
				<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
			}
			else
			{
				string text = this.comboBox16.Text;
				Struct84 @struct;
				<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct18_9), text);
				this.textBox6.AppendText("Attempting to remove " + text + "\r\n");
				int num = <Module>.smethod_122((byte*)(&@struct));
				if (num == 1)
				{
					this.textBox6.AppendText("Removal of " + text + " Failed!" + "\r\n");
				}
				else
				{
					this.textBox6.AppendText("Done!" + "\r\n");
				}
				this.method_360();
			}
		}

		// Token: 0x06000372 RID: 882 RVA: 0x00145880 File Offset: 0x00145880
		private void method_333()
		{
			this.textBox6.AppendText("Enabling All CDROMS" + "\r\n");
			<Module>.smethod_125();
			this.textBox6.AppendText("Done!" + "\r\n");
			this.method_360();
		}

		// Token: 0x06000373 RID: 883 RVA: 0x001458D0 File Offset: 0x001458D0
		private unsafe void method_334()
		{
			if (this.comboBox16.Items.Count == 0)
			{
				<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
				MessageBox.Show("No drive Selected", "Warning", MessageBoxButtons.OK, MessageBoxIcon.Hand);
				<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
			}
			else
			{
				string text = this.comboBox16.Text;
				Struct84 @struct;
				<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct18_9), text);
				this.textBox6.AppendText("Attempting to disable " + text + "\r\n");
				int num = <Module>.smethod_124((byte*)(&@struct));
				if (num == 1)
				{
					this.textBox6.AppendText("Disabling of " + text + " Failed!" + "\r\n");
				}
				else
				{
					this.textBox6.AppendText("Done!" + "\r\n");
				}
				this.method_360();
			}
		}

		// Token: 0x06000374 RID: 884 RVA: 0x001459BC File Offset: 0x001459BC
		private unsafe void method_335(string string_25)
		{
			if (this.comboBox16.Items.Count == 0)
			{
				<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
				MessageBox.Show("No drive Selected", "Warning", MessageBoxButtons.OK, MessageBoxIcon.Hand);
				<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
			}
			else
			{
				Struct84 @struct;
				<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct18_9), string_25.Substring(0, 1));
				this.textBox6.AppendText("Attempting to disable " + string_25 + "\r\n");
				int num = <Module>.smethod_124((byte*)(&@struct));
				if (num == 1)
				{
					this.textBox6.AppendText("Disabling of " + string_25 + " Failed!" + "\r\n");
				}
				else
				{
					this.textBox6.AppendText("Done!" + "\r\n");
				}
				this.method_360();
			}
		}

		// Token: 0x06000375 RID: 885 RVA: 0x00145AA0 File Offset: 0x00145AA0
		private void button11_Click(object sender, EventArgs e)
		{
			this.method_336();
		}

		// Token: 0x06000376 RID: 886 RVA: 0x00145AB4 File Offset: 0x00145AB4
		private unsafe void method_336()
		{
			if (this.comboBox1.Items.Count != 0)
			{
				uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
				uint count = (uint)this.comboBox1.Items.Count;
				ushort num = *(ref <Module>.struct38_0 + selectedIndex * 72U);
				if (this.radioButton17.Checked && num == 0 && count != 0U)
				{
					this.method_424(2);
					this.bool_9 = false;
					<Module>.Sleep(10);
				}
				if (this.method_331() == 0 && this.radioButton17.Checked)
				{
					if (num == 0 && count != 0U)
					{
						this.method_424(1);
						this.bool_9 = true;
						<Module>.Sleep(10);
					}
					this.Cursor = Cursors.WaitCursor;
					<Module>.Sleep(3000);
					Application.DoEvents();
					this.method_361();
					this.Cursor = Cursors.Arrow;
				}
			}
		}

		// Token: 0x06000377 RID: 887 RVA: 0x00145B8C File Offset: 0x00145B8C
		private void button23_Click(object sender, EventArgs e)
		{
			string text = "" + "You are about to scan for your Hitachi Drive and send USmodeB." + "\n";
			text = text + "You will need to use the JungleUSB driver for this to work." + "\n";
			text = text + "Connect the USB-2-SATA to the USB port with the drive connected" + "\n";
			text = text + "and powered on, wait 15 seconds, then press OK." + "\n\n";
			text += "Press Escape to cancel.";
			<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
			int num = (int)MessageBox.Show(text, "USmodeB", MessageBoxButtons.OKCancel, MessageBoxIcon.Question);
			<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
			if (num != 2)
			{
				if (this.method_361() != 0)
				{
					this.method_362();
				}
			}
		}

		// Token: 0x06000378 RID: 888 RVA: 0x00145C40 File Offset: 0x00145C40
		private unsafe void method_337()
		{
			if (this.comboBox1.Items.Count != 0)
			{
				uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
				uint count = (uint)this.comboBox1.Items.Count;
				ushort num = *(ref <Module>.struct38_0 + selectedIndex * 72U);
				uint num2;
				if (*(ref <Module>.struct38_0 + selectedIndex * 72U + 4) == 160)
				{
					num2 = 0U;
				}
				else
				{
					num2 = 16U;
				}
				if (this.radioButton17.Checked && num == 0 && count != 0U)
				{
					this.method_424(2);
					this.bool_9 = false;
					<Module>.Sleep(100);
				}
				GStruct3 gstruct;
				<Module>.smethod_21(&gstruct, num, 0, 1, 10000U);
				Struct52 @struct;
				<Module>.memset((void*)(&@struct), 0, 12U);
				@struct = 27;
				*(ref @struct + 4) = 2;
				if (<Module>.smethod_15((byte*)(&@struct), 12U, (byte)num2, 1, &gstruct) != null)
				{
					<Module>.Sleep(1500);
					if (<Module>.smethod_15((byte*)(&@struct), 12U, (byte)num2, 1, &gstruct) != null)
					{
						this.textBox6.AppendText("Drive Aborted the command" + "\r\n");
					}
					else
					{
						this.textBox6.AppendText("Tray Opening" + "\r\n");
					}
				}
				else
				{
					this.textBox6.AppendText("Tray Opening" + "\r\n");
				}
				if (this.radioButton17.Checked && num == 0 && count != 0U)
				{
					this.method_424(1);
					this.bool_9 = true;
				}
			}
		}

		// Token: 0x06000379 RID: 889 RVA: 0x00145D98 File Offset: 0x00145D98
		private unsafe void method_338()
		{
			if (this.comboBox1.Items.Count != 0)
			{
				uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
				uint count = (uint)this.comboBox1.Items.Count;
				ushort num = *(ref <Module>.struct38_0 + selectedIndex * 72U);
				uint num2;
				if (*(ref <Module>.struct38_0 + selectedIndex * 72U + 4) == 160)
				{
					num2 = 0U;
				}
				else
				{
					num2 = 16U;
				}
				if (this.radioButton17.Checked && num == 0 && count != 0U)
				{
					this.method_424(2);
					this.bool_9 = false;
					<Module>.Sleep(100);
				}
				GStruct3 gstruct;
				<Module>.smethod_21(&gstruct, num, 0, 1, 10000U);
				Struct52 @struct;
				<Module>.memset((void*)(&@struct), 0, 12U);
				@struct = 27;
				*(ref @struct + 4) = 3;
				if (<Module>.smethod_15((byte*)(&@struct), 12U, (byte)num2, 1, &gstruct) != null)
				{
					<Module>.Sleep(1500);
					if (<Module>.smethod_15((byte*)(&@struct), 12U, (byte)num2, 1, &gstruct) != null)
					{
						this.textBox6.AppendText("Drive Aborted the command" + "\r\n");
					}
					else
					{
						this.textBox6.AppendText("Tray Closing" + "\r\n");
					}
				}
				else
				{
					this.textBox6.AppendText("Tray Closing" + "\r\n");
				}
				if (this.radioButton17.Checked && num == 0 && count != 0U)
				{
					this.method_424(1);
					this.bool_9 = true;
					<Module>.Sleep(10);
					this.method_424(5);
					<Module>.Sleep(25);
					this.method_424(7);
				}
			}
		}

		// Token: 0x0600037A RID: 890 RVA: 0x00145F0C File Offset: 0x00145F0C
		private unsafe int method_339()
		{
			int result;
			if (this.comboBox1.Items.Count == 0)
			{
				result = 0;
			}
			else
			{
				uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
				ushort ushort_ = *(ref <Module>.struct38_0 + selectedIndex * 72U);
				uint num;
				if (*(ref <Module>.struct38_0 + selectedIndex * 72U + 4) == 160)
				{
					num = 0U;
				}
				else
				{
					num = 16U;
				}
				GStruct3 gstruct;
				<Module>.smethod_21(&gstruct, ushort_, 0, 1, 1000U);
				Struct52 @struct;
				<Module>.memset((void*)(&@struct), 0, 12U);
				if (<Module>.smethod_15((byte*)(&@struct), 12U, (byte)num, 1, &gstruct) != null)
				{
					result = 1;
				}
				else
				{
					<Module>.memset((void*)(&@struct), 0, 12U);
					@struct = 3;
					*(ref @struct + 4) = 18;
					Struct55 struct2;
					uint num2;
					result = ((<Module>.smethod_16((byte*)(&@struct), 12U, (byte)num, 512, (void*)(&struct2), &num2, 20U, 1, &gstruct) == null) ? (((*(ref struct2 + 2) & 15) != 0 || *(ref struct2 + 12) != 0 || *(ref struct2 + 13) != 0) ? 1 : 0) : 1);
				}
			}
			return result;
		}

		// Token: 0x0600037B RID: 891 RVA: 0x00145FE8 File Offset: 0x00145FE8
		private unsafe void method_340()
		{
			if (this.comboBox16.Items.Count == 0)
			{
				<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
				MessageBox.Show("No drive Selected", "Warning", MessageBoxButtons.OK, MessageBoxIcon.Hand);
				<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
			}
			else
			{
				Struct108 @struct;
				byte* ptr = ref @struct + 44;
				IntPtr intPtr = Marshal.StringToHGlobalAnsi(this.comboBox16.Text);
				IntPtr value = intPtr;
				sbyte* ptr2 = (sbyte*)((void*)value);
				if (!(*(sbyte*)ptr2 < 65 | *(sbyte*)ptr2 > 122))
				{
					Struct109 struct2;
					<Module>.sprintf((sbyte*)(&struct2), (sbyte*)(&<Module>.struct22_5), *(sbyte*)ptr2);
					void* ptr3 = <Module>.CreateFileA((sbyte*)(&struct2), -1073741824, 3, null, 3, 128, null);
					if (ptr3 != -1)
					{
						<Module>.memset((void*)(&@struct), 0, 62U);
						*(ref @struct + 28) = 27;
						*(ref @struct + 32) = 2;
						@struct = 44;
						*(ref @struct + 6) = 12;
						*(ref @struct + 7) = 18;
						*(ref @struct + 8) = 2;
						*(ref @struct + 16) = 15;
						*(ref @struct + 24) = 44;
						uint num;
						if (<Module>.DeviceIoControl(ptr3, 315412, (void*)(&@struct), 62, (void*)(&@struct), 62, (uint*)(&num), null) == null || (ptr[2] & 15) != 0)
						{
							this.textBox6.AppendText("Tray Open Failed" + "\r\n");
						}
						<Module>.CloseHandle(ptr3);
					}
				}
			}
		}

		// Token: 0x0600037C RID: 892 RVA: 0x00146130 File Offset: 0x00146130
		private unsafe void method_341()
		{
			if (this.comboBox16.Items.Count == 0)
			{
				<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
				MessageBox.Show("No drive Selected", "Warning", MessageBoxButtons.OK, MessageBoxIcon.Hand);
				<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
			}
			else
			{
				Struct108 @struct;
				byte* ptr = ref @struct + 44;
				IntPtr intPtr = Marshal.StringToHGlobalAnsi(this.comboBox16.Text);
				IntPtr value = intPtr;
				sbyte* ptr2 = (sbyte*)((void*)value);
				if (!(*(sbyte*)ptr2 < 65 | *(sbyte*)ptr2 > 122))
				{
					Struct109 struct2;
					<Module>.sprintf((sbyte*)(&struct2), (sbyte*)(&<Module>.struct22_5), *(sbyte*)ptr2);
					void* ptr3 = <Module>.CreateFileA((sbyte*)(&struct2), -1073741824, 3, null, 3, 128, null);
					if (ptr3 != -1)
					{
						<Module>.memset((void*)(&@struct), 0, 62U);
						*(ref @struct + 28) = 27;
						*(ref @struct + 32) = 3;
						@struct = 44;
						*(ref @struct + 6) = 12;
						*(ref @struct + 7) = 18;
						*(ref @struct + 8) = 2;
						*(ref @struct + 16) = 15;
						*(ref @struct + 24) = 44;
						uint num;
						if (<Module>.DeviceIoControl(ptr3, 315412, (void*)(&@struct), 62, (void*)(&@struct), 62, (uint*)(&num), null) == null || (ptr[2] & 15) != 0)
						{
							this.textBox6.AppendText("Tray Close Failed" + "\r\n");
						}
						<Module>.CloseHandle(ptr3);
					}
				}
			}
		}

		// Token: 0x0600037D RID: 893 RVA: 0x00146278 File Offset: 0x00146278
		private unsafe void method_342()
		{
			Struct52 @struct = 137;
			*(ref @struct + 1) = 137;
			*(ref @struct + 2) = 137;
			*(ref @struct + 3) = 134;
			*(ref @struct + 4) = 134;
			*(ref @struct + 5) = 134;
			*(ref @struct + 6) = 134;
			*(ref @struct + 7) = 134;
			*(ref @struct + 8) = 134;
			*(ref @struct + 9) = 134;
			*(ref @struct + 10) = 134;
			*(ref @struct + 11) = 134;
			Struct52 struct2 = 216;
			*(ref struct2 + 1) = 217;
			*(ref struct2 + 2) = 218;
			*(ref struct2 + 3) = 221;
			*(ref struct2 + 4) = 222;
			*(ref struct2 + 5) = 223;
			*(ref struct2 + 6) = 217;
			*(ref struct2 + 7) = 218;
			*(ref struct2 + 8) = 219;
			*(ref struct2 + 9) = 233;
			*(ref struct2 + 10) = 234;
			*(ref struct2 + 11) = 235;
			Struct52 struct3 = 35;
			*(ref struct3 + 1) = 142;
			*(ref struct3 + 2) = 16;
			*(ref struct3 + 3) = 35;
			*(ref struct3 + 4) = 142;
			*(ref struct3 + 5) = 16;
			*(ref struct3 + 6) = 68;
			*(ref struct3 + 7) = 28;
			*(ref struct3 + 8) = 32;
			*(ref struct3 + 9) = 68;
			*(ref struct3 + 10) = 28;
			*(ref struct3 + 11) = 32;
			if (this.comboBox16.Items.Count == 0)
			{
				<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
				MessageBox.Show("No drive Selected", "Warning", MessageBoxButtons.OK, MessageBoxIcon.Hand);
				<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
			}
			else
			{
				Struct108 struct4;
				byte* ptr = ref struct4 + 44;
				IntPtr intPtr = Marshal.StringToHGlobalAnsi(this.comboBox16.Text);
				IntPtr value = intPtr;
				sbyte* ptr2 = (sbyte*)((void*)value);
				if (!(*(sbyte*)ptr2 < 65 | *(sbyte*)ptr2 > 122))
				{
					Struct109 struct5;
					<Module>.sprintf((sbyte*)(&struct5), (sbyte*)(&<Module>.struct22_5), *(sbyte*)ptr2);
					void* ptr3 = <Module>.CreateFileA((sbyte*)(&struct5), -1073741824, 3, null, 3, 128, null);
					if (ptr3 != -1)
					{
						for (int i = 0; i < 12; i++)
						{
							<Module>.memset((void*)(&struct4), 0, 62U);
							*(ref struct4 + 28) = 241;
							*(ref struct4 + 29) = 1;
							*(ref struct4 + 32) = *(ref @struct + i);
							*(ref struct4 + 33) = *(ref struct2 + i);
							*(ref struct4 + 37) = *(ref struct3 + i);
							struct4 = 44;
							*(ref struct4 + 6) = 12;
							*(ref struct4 + 7) = 18;
							*(ref struct4 + 8) = 2;
							*(ref struct4 + 16) = 15;
							*(ref struct4 + 24) = 44;
							uint num;
							if (<Module>.DeviceIoControl(ptr3, 315412, (void*)(&struct4), 62, (void*)(&struct4), 62, (uint*)(&num), null) == null || (ptr[2] & 15) != 0)
							{
								this.textBox6.AppendText("Command Failed" + "\r\n");
								return;
							}
						}
						this.textBox6.AppendText("BurnMax Enabled !!!" + "\r\n");
						<Module>.CloseHandle(ptr3);
					}
				}
			}
		}

		// Token: 0x0600037E RID: 894 RVA: 0x00146560 File Offset: 0x00146560
		private unsafe void method_343()
		{
			Struct52 @struct = 134;
			*(ref @struct + 1) = 134;
			*(ref @struct + 2) = 134;
			*(ref @struct + 3) = 134;
			*(ref @struct + 4) = 134;
			*(ref @struct + 5) = 134;
			*(ref @struct + 6) = 134;
			*(ref @struct + 7) = 134;
			*(ref @struct + 8) = 134;
			*(ref @struct + 9) = 134;
			*(ref @struct + 10) = 134;
			*(ref @struct + 11) = 134;
			Struct52 struct2 = 130;
			*(ref struct2 + 1) = 131;
			*(ref struct2 + 2) = 132;
			*(ref struct2 + 3) = 221;
			*(ref struct2 + 4) = 222;
			*(ref struct2 + 5) = 223;
			*(ref struct2 + 6) = 217;
			*(ref struct2 + 7) = 218;
			*(ref struct2 + 8) = 219;
			*(ref struct2 + 9) = 233;
			*(ref struct2 + 10) = 234;
			*(ref struct2 + 11) = 235;
			Struct52 struct3 = 35;
			*(ref struct3 + 1) = 142;
			*(ref struct3 + 2) = 16;
			*(ref struct3 + 3) = 35;
			*(ref struct3 + 4) = 142;
			*(ref struct3 + 5) = 16;
			*(ref struct3 + 6) = 68;
			*(ref struct3 + 7) = 28;
			*(ref struct3 + 8) = 32;
			*(ref struct3 + 9) = 68;
			*(ref struct3 + 10) = 28;
			*(ref struct3 + 11) = 32;
			if (this.comboBox16.Items.Count == 0)
			{
				<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
				MessageBox.Show("No drive Selected", "Warning", MessageBoxButtons.OK, MessageBoxIcon.Hand);
				<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
			}
			else
			{
				Struct108 struct4;
				byte* ptr = ref struct4 + 44;
				IntPtr intPtr = Marshal.StringToHGlobalAnsi(this.comboBox16.Text);
				IntPtr value = intPtr;
				sbyte* ptr2 = (sbyte*)((void*)value);
				if (!(*(sbyte*)ptr2 < 65 | *(sbyte*)ptr2 > 122))
				{
					Struct109 struct5;
					<Module>.sprintf((sbyte*)(&struct5), (sbyte*)(&<Module>.struct22_5), *(sbyte*)ptr2);
					void* ptr3 = <Module>.CreateFileA((sbyte*)(&struct5), -1073741824, 3, null, 3, 128, null);
					if (ptr3 != -1)
					{
						for (int i = 0; i < 12; i++)
						{
							<Module>.memset((void*)(&struct4), 0, 62U);
							*(ref struct4 + 28) = 241;
							*(ref struct4 + 29) = 1;
							*(ref struct4 + 32) = *(ref @struct + i);
							*(ref struct4 + 33) = *(ref struct2 + i);
							*(ref struct4 + 37) = *(ref struct3 + i);
							struct4 = 44;
							*(ref struct4 + 6) = 12;
							*(ref struct4 + 7) = 18;
							*(ref struct4 + 8) = 2;
							*(ref struct4 + 16) = 15;
							*(ref struct4 + 24) = 44;
							uint num;
							if (<Module>.DeviceIoControl(ptr3, 315412, (void*)(&struct4), 62, (void*)(&struct4), 62, (uint*)(&num), null) == null || (ptr[2] & 15) != 0)
							{
								this.textBox6.AppendText("Command Failed" + "\r\n");
								return;
							}
						}
						this.textBox6.AppendText("BurnMax Enabled !!!" + "\r\n");
						<Module>.CloseHandle(ptr3);
					}
				}
			}
		}

		// Token: 0x0600037F RID: 895 RVA: 0x00146848 File Offset: 0x00146848
		private unsafe void method_344()
		{
			Struct52 @struct = 138;
			*(ref @struct + 1) = 138;
			*(ref @struct + 2) = 138;
			*(ref @struct + 3) = 142;
			*(ref @struct + 4) = 142;
			*(ref @struct + 5) = 142;
			*(ref @struct + 6) = 142;
			*(ref @struct + 7) = 142;
			*(ref @struct + 8) = 142;
			*(ref @struct + 9) = 142;
			*(ref @struct + 10) = 142;
			*(ref @struct + 11) = 142;
			Struct52 struct2 = 90;
			*(ref struct2 + 1) = 91;
			*(ref struct2 + 2) = 92;
			*(ref struct2 + 3) = 94;
			*(ref struct2 + 4) = 95;
			*(ref struct2 + 5) = 96;
			*(ref struct2 + 6) = 90;
			*(ref struct2 + 7) = 91;
			*(ref struct2 + 8) = 92;
			*(ref struct2 + 9) = 114;
			*(ref struct2 + 10) = 115;
			*(ref struct2 + 11) = 116;
			Struct52 struct3 = 35;
			*(ref struct3 + 1) = 142;
			*(ref struct3 + 2) = 16;
			*(ref struct3 + 3) = 35;
			*(ref struct3 + 4) = 142;
			*(ref struct3 + 5) = 16;
			*(ref struct3 + 6) = 68;
			*(ref struct3 + 7) = 28;
			*(ref struct3 + 8) = 32;
			*(ref struct3 + 9) = 68;
			*(ref struct3 + 10) = 28;
			*(ref struct3 + 11) = 32;
			if (this.comboBox16.Items.Count == 0)
			{
				<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
				MessageBox.Show("No drive Selected", "Warning", MessageBoxButtons.OK, MessageBoxIcon.Hand);
				<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
			}
			else
			{
				Struct108 struct4;
				byte* ptr = ref struct4 + 44;
				IntPtr intPtr = Marshal.StringToHGlobalAnsi(this.comboBox16.Text);
				IntPtr value = intPtr;
				sbyte* ptr2 = (sbyte*)((void*)value);
				if (!(*(sbyte*)ptr2 < 65 | *(sbyte*)ptr2 > 122))
				{
					Struct109 struct5;
					<Module>.sprintf((sbyte*)(&struct5), (sbyte*)(&<Module>.struct22_5), *(sbyte*)ptr2);
					void* ptr3 = <Module>.CreateFileA((sbyte*)(&struct5), -1073741824, 3, null, 3, 128, null);
					if (ptr3 != -1)
					{
						for (int i = 0; i < 12; i++)
						{
							<Module>.memset((void*)(&struct4), 0, 62U);
							*(ref struct4 + 28) = 223;
							*(ref struct4 + 29) = 132;
							*(ref struct4 + 32) = 1;
							*(ref struct4 + 35) = *(ref @struct + i);
							*(ref struct4 + 36) = *(ref struct2 + i);
							*(ref struct4 + 37) = *(ref struct3 + i);
							struct4 = 44;
							*(ref struct4 + 6) = 12;
							*(ref struct4 + 7) = 18;
							*(ref struct4 + 8) = 2;
							*(ref struct4 + 16) = 15;
							*(ref struct4 + 24) = 44;
							uint num;
							if (<Module>.DeviceIoControl(ptr3, 315412, (void*)(&struct4), 62, (void*)(&struct4), 62, (uint*)(&num), null) == null || (ptr[2] & 15) != 0)
							{
								this.textBox6.AppendText("Command Failed" + "\r\n");
								return;
							}
						}
						this.textBox6.AppendText("BurnMax Enabled !!!" + "\r\n");
						<Module>.CloseHandle(ptr3);
					}
				}
			}
		}

		// Token: 0x06000380 RID: 896 RVA: 0x00146B18 File Offset: 0x00146B18
		private unsafe void method_345()
		{
			Struct110 @struct = 136;
			*(ref @struct + 1) = 136;
			*(ref @struct + 2) = 136;
			*(ref @struct + 3) = 141;
			*(ref @struct + 4) = 141;
			*(ref @struct + 5) = 141;
			*(ref @struct + 6) = 136;
			*(ref @struct + 7) = 136;
			*(ref @struct + 8) = 136;
			*(ref @struct + 9) = 136;
			*(ref @struct + 10) = 136;
			*(ref @struct + 11) = 136;
			*(ref @struct + 12) = 136;
			*(ref @struct + 13) = 136;
			*(ref @struct + 14) = 136;
			Struct110 struct2 = 36;
			*(ref struct2 + 1) = 37;
			*(ref struct2 + 2) = 38;
			*(ref struct2 + 3) = 162;
			*(ref struct2 + 4) = 163;
			*(ref struct2 + 5) = 164;
			*(ref struct2 + 6) = 3;
			*(ref struct2 + 7) = 3;
			*(ref struct2 + 8) = 5;
			*(ref struct2 + 9) = 32;
			*(ref struct2 + 10) = 33;
			*(ref struct2 + 11) = 34;
			*(ref struct2 + 12) = 60;
			*(ref struct2 + 13) = 61;
			*(ref struct2 + 14) = 62;
			Struct110 struct3 = 35;
			*(ref struct3 + 1) = 142;
			*(ref struct3 + 2) = 16;
			*(ref struct3 + 3) = 35;
			*(ref struct3 + 4) = 142;
			*(ref struct3 + 5) = 16;
			*(ref struct3 + 6) = 68;
			*(ref struct3 + 7) = 28;
			*(ref struct3 + 8) = 32;
			*(ref struct3 + 9) = 68;
			*(ref struct3 + 10) = 28;
			*(ref struct3 + 11) = 32;
			*(ref struct3 + 12) = 68;
			*(ref struct3 + 13) = 28;
			*(ref struct3 + 14) = 32;
			if (this.comboBox16.Items.Count == 0)
			{
				<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
				MessageBox.Show("No drive Selected", "Warning", MessageBoxButtons.OK, MessageBoxIcon.Hand);
				<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
			}
			else
			{
				Struct108 struct4;
				byte* ptr = ref struct4 + 44;
				IntPtr intPtr = Marshal.StringToHGlobalAnsi(this.comboBox16.Text);
				IntPtr value = intPtr;
				sbyte* ptr2 = (sbyte*)((void*)value);
				if (!(*(sbyte*)ptr2 < 65 | *(sbyte*)ptr2 > 122))
				{
					Struct109 struct5;
					<Module>.sprintf((sbyte*)(&struct5), (sbyte*)(&<Module>.struct22_5), *(sbyte*)ptr2);
					void* ptr3 = <Module>.CreateFileA((sbyte*)(&struct5), -1073741824, 3, null, 3, 128, null);
					if (ptr3 != -1)
					{
						for (int i = 0; i < 15; i++)
						{
							<Module>.memset((void*)(&struct4), 0, 62U);
							*(ref struct4 + 28) = 223;
							*(ref struct4 + 29) = 132;
							*(ref struct4 + 32) = 1;
							*(ref struct4 + 35) = *(ref @struct + i);
							*(ref struct4 + 36) = *(ref struct2 + i);
							*(ref struct4 + 37) = *(ref struct3 + i);
							struct4 = 44;
							*(ref struct4 + 6) = 12;
							*(ref struct4 + 7) = 18;
							*(ref struct4 + 8) = 2;
							*(ref struct4 + 16) = 15;
							*(ref struct4 + 24) = 44;
							uint num;
							if (<Module>.DeviceIoControl(ptr3, 315412, (void*)(&struct4), 62, (void*)(&struct4), 62, (uint*)(&num), null) == null || (ptr[2] & 15) != 0)
							{
								this.textBox6.AppendText("Command Failed" + "\r\n");
								return;
							}
						}
						this.textBox6.AppendText("BurnMax Enabled !!!" + "\r\n");
						<Module>.CloseHandle(ptr3);
					}
				}
			}
		}

		// Token: 0x06000381 RID: 897 RVA: 0x00146E40 File Offset: 0x00146E40
		private unsafe void method_346()
		{
			Struct52 @struct = 134;
			*(ref @struct + 1) = 134;
			*(ref @struct + 2) = 134;
			*(ref @struct + 3) = 134;
			*(ref @struct + 4) = 134;
			*(ref @struct + 5) = 134;
			*(ref @struct + 6) = 134;
			*(ref @struct + 7) = 134;
			*(ref @struct + 8) = 134;
			*(ref @struct + 9) = 134;
			*(ref @struct + 10) = 134;
			*(ref @struct + 11) = 134;
			Struct52 struct2 = 130;
			*(ref struct2 + 1) = 131;
			*(ref struct2 + 2) = 132;
			*(ref struct2 + 3) = 221;
			*(ref struct2 + 4) = 222;
			*(ref struct2 + 5) = 223;
			*(ref struct2 + 6) = 217;
			*(ref struct2 + 7) = 218;
			*(ref struct2 + 8) = 219;
			*(ref struct2 + 9) = 233;
			*(ref struct2 + 10) = 234;
			*(ref struct2 + 11) = 235;
			Struct52 struct3 = 35;
			*(ref struct3 + 1) = 142;
			*(ref struct3 + 2) = 16;
			*(ref struct3 + 3) = 35;
			*(ref struct3 + 4) = 142;
			*(ref struct3 + 5) = 16;
			*(ref struct3 + 6) = 68;
			*(ref struct3 + 7) = 28;
			*(ref struct3 + 8) = 32;
			*(ref struct3 + 9) = 68;
			*(ref struct3 + 10) = 28;
			*(ref struct3 + 11) = 32;
			if (this.comboBox16.Items.Count == 0)
			{
				<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
				MessageBox.Show("No drive Selected", "Warning", MessageBoxButtons.OK, MessageBoxIcon.Hand);
				<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
			}
			else
			{
				Struct108 struct4;
				byte* ptr = ref struct4 + 44;
				IntPtr intPtr = Marshal.StringToHGlobalAnsi(this.comboBox16.Text);
				IntPtr value = intPtr;
				sbyte* ptr2 = (sbyte*)((void*)value);
				if (!(*(sbyte*)ptr2 < 65 | *(sbyte*)ptr2 > 122))
				{
					Struct109 struct5;
					<Module>.sprintf((sbyte*)(&struct5), (sbyte*)(&<Module>.struct22_5), *(sbyte*)ptr2);
					void* ptr3 = <Module>.CreateFileA((sbyte*)(&struct5), -1073741824, 3, null, 3, 128, null);
					if (ptr3 != -1)
					{
						for (int i = 0; i < 12; i++)
						{
							<Module>.memset((void*)(&struct4), 0, 62U);
							*(ref struct4 + 28) = 241;
							*(ref struct4 + 29) = 1;
							*(ref struct4 + 32) = *(ref @struct + i);
							*(ref struct4 + 33) = *(ref struct2 + i);
							*(ref struct4 + 37) = *(ref struct3 + i);
							struct4 = 44;
							*(ref struct4 + 6) = 12;
							*(ref struct4 + 7) = 18;
							*(ref struct4 + 8) = 2;
							*(ref struct4 + 16) = 15;
							*(ref struct4 + 24) = 44;
							uint num;
							if (<Module>.DeviceIoControl(ptr3, 315412, (void*)(&struct4), 62, (void*)(&struct4), 62, (uint*)(&num), null) == null || (ptr[2] & 15) != 0)
							{
								this.textBox6.AppendText("Command Failed" + "\r\n");
								return;
							}
						}
						this.textBox6.AppendText("BurnMax Enabled !!!" + "\r\n");
						<Module>.CloseHandle(ptr3);
					}
				}
			}
		}

		// Token: 0x06000382 RID: 898 RVA: 0x00147128 File Offset: 0x00147128
		private unsafe void method_347()
		{
			Struct52 @struct = 133;
			*(ref @struct + 1) = 133;
			*(ref @struct + 2) = 133;
			*(ref @struct + 3) = 134;
			*(ref @struct + 4) = 134;
			*(ref @struct + 5) = 134;
			*(ref @struct + 6) = 134;
			*(ref @struct + 7) = 134;
			*(ref @struct + 8) = 134;
			*(ref @struct + 9) = 134;
			*(ref @struct + 10) = 134;
			*(ref @struct + 11) = 134;
			Struct52 struct2 = 222;
			*(ref struct2 + 1) = 223;
			*(ref struct2 + 2) = 224;
			*(ref struct2 + 3) = 221;
			*(ref struct2 + 4) = 222;
			*(ref struct2 + 5) = 223;
			*(ref struct2 + 6) = 217;
			*(ref struct2 + 7) = 218;
			*(ref struct2 + 8) = 219;
			*(ref struct2 + 9) = 233;
			*(ref struct2 + 10) = 234;
			*(ref struct2 + 11) = 235;
			Struct52 struct3 = 35;
			*(ref struct3 + 1) = 142;
			*(ref struct3 + 2) = 16;
			*(ref struct3 + 3) = 35;
			*(ref struct3 + 4) = 142;
			*(ref struct3 + 5) = 16;
			*(ref struct3 + 6) = 68;
			*(ref struct3 + 7) = 28;
			*(ref struct3 + 8) = 32;
			*(ref struct3 + 9) = 68;
			*(ref struct3 + 10) = 28;
			*(ref struct3 + 11) = 32;
			if (this.comboBox16.Items.Count == 0)
			{
				<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
				MessageBox.Show("No drive Selected", "Warning", MessageBoxButtons.OK, MessageBoxIcon.Hand);
				<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
			}
			else
			{
				Struct108 struct4;
				byte* ptr = ref struct4 + 44;
				IntPtr intPtr = Marshal.StringToHGlobalAnsi(this.comboBox16.Text);
				IntPtr value = intPtr;
				sbyte* ptr2 = (sbyte*)((void*)value);
				if (!(*(sbyte*)ptr2 < 65 | *(sbyte*)ptr2 > 122))
				{
					Struct109 struct5;
					<Module>.sprintf((sbyte*)(&struct5), (sbyte*)(&<Module>.struct22_5), *(sbyte*)ptr2);
					void* ptr3 = <Module>.CreateFileA((sbyte*)(&struct5), -1073741824, 3, null, 3, 128, null);
					if (ptr3 != -1)
					{
						for (int i = 0; i < 12; i++)
						{
							<Module>.memset((void*)(&struct4), 0, 62U);
							*(ref struct4 + 28) = 241;
							*(ref struct4 + 29) = 1;
							*(ref struct4 + 32) = *(ref @struct + i);
							*(ref struct4 + 33) = *(ref struct2 + i);
							*(ref struct4 + 37) = *(ref struct3 + i);
							struct4 = 44;
							*(ref struct4 + 6) = 12;
							*(ref struct4 + 7) = 18;
							*(ref struct4 + 8) = 2;
							*(ref struct4 + 16) = 15;
							*(ref struct4 + 24) = 44;
							uint num;
							if (<Module>.DeviceIoControl(ptr3, 315412, (void*)(&struct4), 62, (void*)(&struct4), 62, (uint*)(&num), null) == null || (ptr[2] & 15) != 0)
							{
								this.textBox6.AppendText("Command Failed" + "\r\n");
								return;
							}
						}
						this.textBox6.AppendText("BurnMax Enabled !!!" + "\r\n");
						<Module>.CloseHandle(ptr3);
					}
				}
			}
		}

		// Token: 0x06000383 RID: 899 RVA: 0x00147410 File Offset: 0x00147410
		private unsafe void method_348()
		{
			Struct52 @struct = 136;
			*(ref @struct + 1) = 136;
			*(ref @struct + 2) = 136;
			*(ref @struct + 3) = 134;
			*(ref @struct + 4) = 134;
			*(ref @struct + 5) = 134;
			*(ref @struct + 6) = 134;
			*(ref @struct + 7) = 134;
			*(ref @struct + 8) = 134;
			*(ref @struct + 9) = 134;
			*(ref @struct + 10) = 134;
			*(ref @struct + 11) = 134;
			Struct52 struct2 = 160;
			*(ref struct2 + 1) = 161;
			*(ref struct2 + 2) = 162;
			*(ref struct2 + 3) = 221;
			*(ref struct2 + 4) = 222;
			*(ref struct2 + 5) = 223;
			*(ref struct2 + 6) = 217;
			*(ref struct2 + 7) = 218;
			*(ref struct2 + 8) = 219;
			*(ref struct2 + 9) = 233;
			*(ref struct2 + 10) = 234;
			*(ref struct2 + 11) = 235;
			Struct52 struct3 = 35;
			*(ref struct3 + 1) = 142;
			*(ref struct3 + 2) = 16;
			*(ref struct3 + 3) = 35;
			*(ref struct3 + 4) = 142;
			*(ref struct3 + 5) = 16;
			*(ref struct3 + 6) = 68;
			*(ref struct3 + 7) = 28;
			*(ref struct3 + 8) = 32;
			*(ref struct3 + 9) = 68;
			*(ref struct3 + 10) = 28;
			*(ref struct3 + 11) = 32;
			if (this.comboBox16.Items.Count == 0)
			{
				<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
				MessageBox.Show("No drive Selected", "Warning", MessageBoxButtons.OK, MessageBoxIcon.Hand);
				<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
			}
			else
			{
				Struct108 struct4;
				byte* ptr = ref struct4 + 44;
				IntPtr intPtr = Marshal.StringToHGlobalAnsi(this.comboBox16.Text);
				IntPtr value = intPtr;
				sbyte* ptr2 = (sbyte*)((void*)value);
				if (!(*(sbyte*)ptr2 < 65 | *(sbyte*)ptr2 > 122))
				{
					Struct109 struct5;
					<Module>.sprintf((sbyte*)(&struct5), (sbyte*)(&<Module>.struct22_5), *(sbyte*)ptr2);
					void* ptr3 = <Module>.CreateFileA((sbyte*)(&struct5), -1073741824, 3, null, 3, 128, null);
					if (ptr3 != -1)
					{
						for (int i = 0; i < 12; i++)
						{
							<Module>.memset((void*)(&struct4), 0, 62U);
							*(ref struct4 + 28) = 241;
							*(ref struct4 + 29) = 1;
							*(ref struct4 + 32) = *(ref @struct + i);
							*(ref struct4 + 33) = *(ref struct2 + i);
							*(ref struct4 + 37) = *(ref struct3 + i);
							struct4 = 44;
							*(ref struct4 + 6) = 12;
							*(ref struct4 + 7) = 18;
							*(ref struct4 + 8) = 2;
							*(ref struct4 + 16) = 15;
							*(ref struct4 + 24) = 44;
							uint num;
							if (<Module>.DeviceIoControl(ptr3, 315412, (void*)(&struct4), 62, (void*)(&struct4), 62, (uint*)(&num), null) == null || (ptr[2] & 15) != 0)
							{
								this.textBox6.AppendText("Command Failed" + "\r\n");
								return;
							}
						}
						this.textBox6.AppendText("BurnMax Enabled !!!" + "\r\n");
						<Module>.CloseHandle(ptr3);
					}
				}
			}
		}

		// Token: 0x06000384 RID: 900 RVA: 0x001476F8 File Offset: 0x001476F8
		private unsafe void method_349()
		{
			Struct52 @struct = 138;
			*(ref @struct + 1) = 138;
			*(ref @struct + 2) = 138;
			*(ref @struct + 3) = 134;
			*(ref @struct + 4) = 134;
			*(ref @struct + 5) = 134;
			*(ref @struct + 6) = 134;
			*(ref @struct + 7) = 134;
			*(ref @struct + 8) = 134;
			*(ref @struct + 9) = 134;
			*(ref @struct + 10) = 134;
			*(ref @struct + 11) = 134;
			Struct52 struct2 = 82;
			*(ref struct2 + 1) = 83;
			*(ref struct2 + 2) = 84;
			*(ref struct2 + 3) = 220;
			*(ref struct2 + 4) = 221;
			*(ref struct2 + 5) = 222;
			*(ref struct2 + 6) = 216;
			*(ref struct2 + 7) = 217;
			*(ref struct2 + 8) = 218;
			*(ref struct2 + 9) = 232;
			*(ref struct2 + 10) = 233;
			*(ref struct2 + 11) = 234;
			Struct52 struct3 = 35;
			*(ref struct3 + 1) = 142;
			*(ref struct3 + 2) = 16;
			*(ref struct3 + 3) = 35;
			*(ref struct3 + 4) = 142;
			*(ref struct3 + 5) = 16;
			*(ref struct3 + 6) = 68;
			*(ref struct3 + 7) = 28;
			*(ref struct3 + 8) = 32;
			*(ref struct3 + 9) = 68;
			*(ref struct3 + 10) = 28;
			*(ref struct3 + 11) = 32;
			if (this.comboBox16.Items.Count == 0)
			{
				<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
				MessageBox.Show("No drive Selected", "Warning", MessageBoxButtons.OK, MessageBoxIcon.Hand);
				<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
			}
			else
			{
				Struct108 struct4;
				byte* ptr = ref struct4 + 44;
				IntPtr intPtr = Marshal.StringToHGlobalAnsi(this.comboBox16.Text);
				IntPtr value = intPtr;
				sbyte* ptr2 = (sbyte*)((void*)value);
				if (!(*(sbyte*)ptr2 < 65 | *(sbyte*)ptr2 > 122))
				{
					Struct109 struct5;
					<Module>.sprintf((sbyte*)(&struct5), (sbyte*)(&<Module>.struct22_5), *(sbyte*)ptr2);
					void* ptr3 = <Module>.CreateFileA((sbyte*)(&struct5), -1073741824, 3, null, 3, 128, null);
					if (ptr3 != -1)
					{
						for (int i = 0; i < 12; i++)
						{
							<Module>.memset((void*)(&struct4), 0, 62U);
							*(ref struct4 + 28) = 241;
							*(ref struct4 + 29) = 1;
							*(ref struct4 + 32) = *(ref @struct + i);
							*(ref struct4 + 33) = *(ref struct2 + i);
							*(ref struct4 + 37) = *(ref struct3 + i);
							struct4 = 44;
							*(ref struct4 + 6) = 12;
							*(ref struct4 + 7) = 18;
							*(ref struct4 + 8) = 2;
							*(ref struct4 + 16) = 15;
							*(ref struct4 + 24) = 44;
							uint num;
							if (<Module>.DeviceIoControl(ptr3, 315412, (void*)(&struct4), 62, (void*)(&struct4), 62, (uint*)(&num), null) == null || (ptr[2] & 15) != 0)
							{
								this.textBox6.AppendText("Command Failed" + "\r\n");
								return;
							}
						}
						this.textBox6.AppendText("BurnMax Enabled !!!" + "\r\n");
						<Module>.CloseHandle(ptr3);
					}
				}
			}
		}

		// Token: 0x06000385 RID: 901 RVA: 0x001479D8 File Offset: 0x001479D8
		private unsafe void method_350()
		{
			Struct110 @struct = 135;
			*(ref @struct + 1) = 135;
			*(ref @struct + 2) = 135;
			*(ref @struct + 3) = 137;
			*(ref @struct + 4) = 137;
			*(ref @struct + 5) = 137;
			*(ref @struct + 6) = 135;
			*(ref @struct + 7) = 135;
			*(ref @struct + 8) = 135;
			*(ref @struct + 9) = 135;
			*(ref @struct + 10) = 135;
			*(ref @struct + 11) = 135;
			*(ref @struct + 12) = 135;
			*(ref @struct + 13) = 135;
			*(ref @struct + 14) = 135;
			Struct110 struct2 = 47;
			*(ref struct2 + 1) = 48;
			*(ref struct2 + 2) = 49;
			*(ref struct2 + 3) = 202;
			*(ref struct2 + 4) = 203;
			*(ref struct2 + 5) = 204;
			*(ref struct2 + 6) = 14;
			*(ref struct2 + 7) = 15;
			*(ref struct2 + 8) = 16;
			*(ref struct2 + 9) = 43;
			*(ref struct2 + 10) = 44;
			*(ref struct2 + 11) = 45;
			*(ref struct2 + 12) = 71;
			*(ref struct2 + 13) = 72;
			*(ref struct2 + 14) = 73;
			Struct110 struct3 = 35;
			*(ref struct3 + 1) = 142;
			*(ref struct3 + 2) = 16;
			*(ref struct3 + 3) = 35;
			*(ref struct3 + 4) = 142;
			*(ref struct3 + 5) = 16;
			*(ref struct3 + 6) = 68;
			*(ref struct3 + 7) = 28;
			*(ref struct3 + 8) = 32;
			*(ref struct3 + 9) = 68;
			*(ref struct3 + 10) = 28;
			*(ref struct3 + 11) = 32;
			*(ref struct3 + 12) = 68;
			*(ref struct3 + 13) = 28;
			*(ref struct3 + 14) = 32;
			if (this.comboBox16.Items.Count == 0)
			{
				<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
				MessageBox.Show("No drive Selected", "Warning", MessageBoxButtons.OK, MessageBoxIcon.Hand);
				<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
			}
			else
			{
				Struct108 struct4;
				byte* ptr = ref struct4 + 44;
				IntPtr intPtr = Marshal.StringToHGlobalAnsi(this.comboBox16.Text);
				IntPtr value = intPtr;
				sbyte* ptr2 = (sbyte*)((void*)value);
				if (!(*(sbyte*)ptr2 < 65 | *(sbyte*)ptr2 > 122))
				{
					Struct109 struct5;
					<Module>.sprintf((sbyte*)(&struct5), (sbyte*)(&<Module>.struct22_5), *(sbyte*)ptr2);
					void* ptr3 = <Module>.CreateFileA((sbyte*)(&struct5), -1073741824, 3, null, 3, 128, null);
					if (ptr3 != -1)
					{
						for (int i = 0; i < 15; i++)
						{
							<Module>.memset((void*)(&struct4), 0, 62U);
							*(ref struct4 + 28) = 241;
							*(ref struct4 + 29) = 1;
							*(ref struct4 + 32) = *(ref @struct + i);
							*(ref struct4 + 33) = *(ref struct2 + i);
							*(ref struct4 + 37) = *(ref struct3 + i);
							struct4 = 44;
							*(ref struct4 + 6) = 12;
							*(ref struct4 + 7) = 18;
							*(ref struct4 + 8) = 2;
							*(ref struct4 + 16) = 15;
							*(ref struct4 + 24) = 44;
							uint num;
							if (<Module>.DeviceIoControl(ptr3, 315412, (void*)(&struct4), 62, (void*)(&struct4), 62, (uint*)(&num), null) == null || (ptr[2] & 15) != 0)
							{
								this.textBox6.AppendText("Command Failed" + "\r\n");
								return;
							}
						}
						this.textBox6.AppendText("BurnMax Enabled !!!" + "\r\n");
						<Module>.CloseHandle(ptr3);
					}
				}
			}
		}

		// Token: 0x06000386 RID: 902 RVA: 0x00147CF8 File Offset: 0x00147CF8
		private unsafe void method_351()
		{
			GStruct5* pGstruct5_ = <Module>.fopen((sbyte*)(&<Module>.struct14_1), (sbyte*)(&<Module>.struct18_5));
			if (this.comboBox16.Text == new string((sbyte*)(&<Module>.struct19_0)))
			{
				<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
				MessageBox.Show("No drive Selected", "Warning", MessageBoxButtons.OK, MessageBoxIcon.Hand);
				<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
			}
			else
			{
				this.comboBox16.Text.Substring(0, 1);
				IntPtr intPtr = Marshal.StringToHGlobalAnsi(this.comboBox16.Text);
				IntPtr value = intPtr;
				sbyte* ptr = (sbyte*)((void*)value);
				if (!(*(sbyte*)ptr < 65 | *(sbyte*)ptr > 122))
				{
					Struct109 @struct;
					<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct22_5), *(sbyte*)ptr);
					void* ptr2 = <Module>.CreateFileA((sbyte*)(&@struct), -1073741824, 3, null, 3, 128, null);
					if (ptr2 != -1)
					{
						for (int i = 32768; i < 36864; i += 128)
						{
							Struct111 struct2;
							<Module>.memset((void*)(&struct2), 48, 128U);
							Struct108 struct3;
							<Module>.memset((void*)(&struct3), 0, 62U);
							*(ref struct3 + 28) = 223;
							*(ref struct3 + 29) = 133;
							*(ref struct3 + 31) = byte.MaxValue;
							*(ref struct3 + 35) = (byte)((i & 65280) >> 8);
							*(ref struct3 + 36) = (byte)(i & 255);
							struct3 = 44;
							*(ref struct3 + 6) = 12;
							*(ref struct3 + 7) = 18;
							*(ref struct3 + 8) = 1;
							*(ref struct3 + 12) = 128;
							*(ref struct3 + 16) = 15;
							*(ref struct3 + 20) = ref struct2;
							*(ref struct3 + 24) = 44;
							uint num;
							if (<Module>.DeviceIoControl(ptr2, 315412, (void*)(&struct3), 62, (void*)(&struct3), 62, (uint*)(&num), null) == null)
							{
								this.textBox6.AppendText("CDB failed" + "\r\n");
								return;
							}
							<Module>.fwrite((void*)(&struct2), 128U, 1U, pGstruct5_);
						}
					}
					else
					{
						this.textBox6.AppendText("Failed to open drive" + "\r\n");
					}
					<Module>.fclose(pGstruct5_);
					<Module>.CloseHandle(ptr2);
				}
			}
		}

		// Token: 0x06000387 RID: 903 RVA: 0x00147F08 File Offset: 0x00147F08
		private unsafe void method_352()
		{
			GStruct5* pGstruct5_ = <Module>.fopen((sbyte*)(&<Module>.struct14_2), (sbyte*)(&<Module>.struct18_5));
			if (this.comboBox16.Text == new string((sbyte*)(&<Module>.struct19_0)))
			{
				<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
				MessageBox.Show("No drive Selected", "Warning", MessageBoxButtons.OK, MessageBoxIcon.Hand);
				<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
			}
			else
			{
				this.comboBox16.Text.Substring(0, 1);
				IntPtr intPtr = Marshal.StringToHGlobalAnsi(this.comboBox16.Text);
				IntPtr value = intPtr;
				sbyte* ptr = (sbyte*)((void*)value);
				if (!(*(sbyte*)ptr < 65 | *(sbyte*)ptr > 122))
				{
					Struct109 @struct;
					<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct22_5), *(sbyte*)ptr);
					void* ptr2 = <Module>.CreateFileA((sbyte*)(&@struct), -1073741824, 3, null, 3, 128, null);
					if (ptr2 != -1)
					{
						for (int i = 32768; i < 36864; i++)
						{
							Struct28 struct2;
							<Module>.memset((void*)(&struct2), 48, 16U);
							Struct108 struct3;
							<Module>.memset((void*)(&struct3), 0, 62U);
							*(ref struct3 + 28) = 241;
							*(ref struct3 + 29) = 2;
							*(ref struct3 + 32) = (byte)((i & 65280) >> 8);
							*(ref struct3 + 33) = (byte)(i & 255);
							*(ref struct3 + 34) = 1;
							struct3 = 44;
							*(ref struct3 + 6) = 12;
							*(ref struct3 + 7) = 18;
							*(ref struct3 + 8) = 1;
							*(ref struct3 + 12) = 4;
							*(ref struct3 + 16) = 15;
							*(ref struct3 + 20) = ref struct2;
							*(ref struct3 + 24) = 44;
							uint num;
							if (<Module>.DeviceIoControl(ptr2, 315412, (void*)(&struct3), 62, (void*)(&struct3), 62, (uint*)(&num), null) == null)
							{
								this.textBox6.AppendText("CDB failed" + "\r\n");
								return;
							}
							<Module>.fwrite(ref struct2 + 3, 1U, 1U, pGstruct5_);
						}
					}
					else
					{
						this.textBox6.AppendText("Failed to open drive" + "\r\n");
					}
					<Module>.fclose(pGstruct5_);
					<Module>.CloseHandle(ptr2);
				}
			}
		}

		// Token: 0x06000388 RID: 904 RVA: 0x00148100 File Offset: 0x00148100
		private unsafe void method_353()
		{
			if (this.comboBox16.Text == new string((sbyte*)(&<Module>.struct19_0)))
			{
				<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
				MessageBox.Show("No drive Selected", "Warning", MessageBoxButtons.OK, MessageBoxIcon.Hand);
				<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
			}
			else
			{
				this.comboBox16.Text.Substring(0, 1);
				IntPtr intPtr = Marshal.StringToHGlobalAnsi(this.comboBox16.Text);
				IntPtr value = intPtr;
				sbyte* ptr = (sbyte*)((void*)value);
				if (!(*(sbyte*)ptr < 65 | *(sbyte*)ptr > 122))
				{
					Struct109 @struct;
					<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct22_5), *(sbyte*)ptr);
					void* ptr2 = <Module>.CreateFileA((sbyte*)(&@struct), -1073741824, 3, null, 3, 128, null);
					if (ptr2 != -1)
					{
						Struct112 struct2;
						<Module>.memset((void*)(&struct2), 48, 2052U);
						Struct108 struct3;
						<Module>.memset((void*)(&struct3), 0, 62U);
						*(ref struct3 + 28) = 173;
						*(ref struct3 + 34) = 1;
						*(ref struct3 + 36) = 8;
						*(ref struct3 + 37) = 4;
						struct3 = 44;
						*(ref struct3 + 6) = 12;
						*(ref struct3 + 7) = 18;
						*(ref struct3 + 8) = 1;
						*(ref struct3 + 12) = 2052;
						*(ref struct3 + 16) = 15;
						*(ref struct3 + 20) = ref struct2;
						*(ref struct3 + 24) = 44;
						uint num;
						if (<Module>.DeviceIoControl(ptr2, 315412, (void*)(&struct3), 62, (void*)(&struct3), 62, (uint*)(&num), null) != null)
						{
							this.method_5((byte*)(&struct2), 2052U, 0U);
							this.textBox6.AppendText(this.string_0 + "\r\n");
						}
						else
						{
							this.textBox6.AppendText("CDB failed" + "\r\n");
						}
					}
					else
					{
						this.textBox6.AppendText("Failed to open drive" + "\r\n");
					}
				}
			}
		}

		// Token: 0x06000389 RID: 905 RVA: 0x001482C8 File Offset: 0x001482C8
		private unsafe void method_354()
		{
			if (this.comboBox16.Text == new string((sbyte*)(&<Module>.struct19_0)))
			{
				<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
				MessageBox.Show("No drive Selected", "Warning", MessageBoxButtons.OK, MessageBoxIcon.Hand);
				<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
			}
			else
			{
				this.comboBox16.Text.Substring(0, 1);
				IntPtr intPtr = Marshal.StringToHGlobalAnsi(this.comboBox16.Text);
				IntPtr value = intPtr;
				sbyte* ptr = (sbyte*)((void*)value);
				if (!(*(sbyte*)ptr < 65 | *(sbyte*)ptr > 122))
				{
					Struct109 @struct;
					<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct22_5), *(sbyte*)ptr);
					void* ptr2 = <Module>.CreateFileA((sbyte*)(&@struct), -1073741824, 3, null, 3, 128, null);
					if (ptr2 != -1)
					{
						Struct52 struct2;
						<Module>.memset((void*)(&struct2), 48, 12U);
						Struct108 struct3;
						<Module>.memset((void*)(&struct3), 0, 62U);
						*(ref struct3 + 28) = 173;
						*(ref struct3 + 35) = 32;
						*(ref struct3 + 37) = 12;
						struct3 = 44;
						*(ref struct3 + 6) = 12;
						*(ref struct3 + 7) = 18;
						*(ref struct3 + 8) = 1;
						*(ref struct3 + 12) = 12;
						*(ref struct3 + 16) = 15;
						*(ref struct3 + 20) = ref struct2;
						*(ref struct3 + 24) = 44;
						uint num;
						if (<Module>.DeviceIoControl(ptr2, 315412, (void*)(&struct3), 62, (void*)(&struct3), 62, (uint*)(&num), null) != null)
						{
							this.method_5((byte*)(&struct2), 12U, 0U);
							this.textBox6.AppendText(this.string_0 + "\r\n");
						}
						else
						{
							this.textBox6.AppendText("CDB failed" + "\r\n");
						}
					}
					else
					{
						this.textBox6.AppendText("Failed to open drive" + "\r\n");
					}
				}
			}
		}

		// Token: 0x0600038A RID: 906 RVA: 0x00148484 File Offset: 0x00148484
		private unsafe void method_355()
		{
			if (this.comboBox16.Text == new string((sbyte*)(&<Module>.struct19_0)))
			{
				<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
				MessageBox.Show("No drive Selected", "Warning", MessageBoxButtons.OK, MessageBoxIcon.Hand);
				<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
			}
			else
			{
				this.comboBox16.Text.Substring(0, 1);
				IntPtr intPtr = Marshal.StringToHGlobalAnsi(this.comboBox16.Text);
				IntPtr value = intPtr;
				sbyte* ptr = (sbyte*)((void*)value);
				if (!(*(sbyte*)ptr < 65 | *(sbyte*)ptr > 122))
				{
					Struct109 @struct;
					<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct22_5), *(sbyte*)ptr);
					void* ptr2 = <Module>.CreateFileA((sbyte*)(&@struct), -1073741824, 3, null, 3, 128, null);
					if (ptr2 != -1)
					{
						Struct5 struct2;
						<Module>.memset((void*)(&struct2), 48, 56U);
						Struct108 struct3;
						<Module>.memset((void*)(&struct3), 0, 62U);
						*(ref struct3 + 28) = 3;
						*(ref struct3 + 32) = 18;
						struct3 = 44;
						*(ref struct3 + 6) = 12;
						*(ref struct3 + 7) = 18;
						*(ref struct3 + 8) = 1;
						*(ref struct3 + 12) = 18;
						*(ref struct3 + 16) = 15;
						*(ref struct3 + 20) = ref struct2;
						*(ref struct3 + 24) = 44;
						uint num;
						if (<Module>.DeviceIoControl(ptr2, 315412, (void*)(&struct3), 62, (void*)(&struct3), 62, (uint*)(&num), null) != null)
						{
							this.method_5((byte*)(&struct2), 18U, 0U);
							this.textBox6.AppendText(this.string_0 + "\r\n");
						}
						else
						{
							this.textBox6.AppendText("Inquiry failed" + "\r\n");
						}
					}
					else
					{
						this.textBox6.AppendText("Failed to open drive " + "\r\n");
					}
					<Module>.CloseHandle(ptr2);
				}
			}
		}

		// Token: 0x0600038B RID: 907 RVA: 0x0014863C File Offset: 0x0014863C
		private void button19_Click(object sender, EventArgs e)
		{
			this.method_337();
		}

		// Token: 0x0600038C RID: 908 RVA: 0x00148650 File Offset: 0x00148650
		private void button20_Click(object sender, EventArgs e)
		{
			this.method_338();
		}

		// Token: 0x0600038D RID: 909 RVA: 0x00148664 File Offset: 0x00148664
		private void button3_Click(object sender, EventArgs e)
		{
			this.Cursor = Cursors.WaitCursor;
			this.method_361();
			this.Cursor = Cursors.Arrow;
		}

		// Token: 0x0600038E RID: 910 RVA: 0x00148690 File Offset: 0x00148690
		private void button22_Click(object sender, EventArgs e)
		{
			this.method_363();
		}

		// Token: 0x0600038F RID: 911 RVA: 0x001486A4 File Offset: 0x001486A4
		private void method_356()
		{
			this.method_358(0);
			this.textBox6.AppendText("Loading Hitachi Dump to Source Buffer" + "\r\n");
		}

		// Token: 0x06000390 RID: 912 RVA: 0x001486D4 File Offset: 0x001486D4
		private void method_357()
		{
			this.method_358(1);
			this.textBox6.AppendText("Loading Hitachi Dump to Target Buffer " + "\r\n");
		}

		// Token: 0x06000391 RID: 913 RVA: 0x00148704 File Offset: 0x00148704
		private unsafe void method_358(int int_16)
		{
			if (this.bool_2)
			{
				string text = this.string_10 + "\\Hit-OFW.bin";
				for (int i = 1; i < 10; i++)
				{
					if (!File.Exists(text))
					{
						IntPtr intPtr = Marshal.StringToHGlobalAnsi(text);
						IntPtr value = intPtr;
						sbyte* pSbyte_ = (sbyte*)((void*)value);
						GStruct5* ptr = <Module>.fopen((sbyte*)pSbyte_, (sbyte*)(&<Module>.struct18_5));
						if (ptr != null)
						{
							<Module>.fwrite(*(ref <Module>.struct121_0 + 7172), 262144U, 1U, ptr);
							<Module>.fclose(ptr);
							this.textBox6.AppendText("\r\n" + "Hitachi-On Dump file saved to " + text + "\r\n");
							this.method_37(text, 0, *(ref <Module>.struct121_0 + 7172));
							return;
						}
					}
					else
					{
						text = this.string_10 + "\\Hit-OFW_" + Convert.ToString(i) + ".bin";
					}
				}
			}
			SaveFileDialog saveFileDialog = new SaveFileDialog();
			saveFileDialog.Filter = "Firmware Images (*.bin)|*.bin|All Files (*.*)|*.*";
			saveFileDialog.DefaultExt = ".bin";
			saveFileDialog.FileName = "Hit-OFW.bin";
			saveFileDialog.RestoreDirectory = false;
			if (this.bool_2)
			{
				saveFileDialog.InitialDirectory = this.string_10;
			}
			if (saveFileDialog.ShowDialog() == DialogResult.OK)
			{
				string fullPath = Path.GetFullPath(saveFileDialog.FileName);
				string fileName = Path.GetFileName(saveFileDialog.FileName);
				IntPtr intPtr2 = Marshal.StringToHGlobalAnsi(fullPath);
				IntPtr value2 = intPtr2;
				sbyte* pSbyte_2 = (sbyte*)((void*)value2);
				GStruct5* ptr = <Module>.fopen((sbyte*)pSbyte_2, (sbyte*)(&<Module>.struct18_5));
				if (ptr == null)
				{
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					MessageBox.Show(fileName, "Can't open file", MessageBoxButtons.OK);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
				}
				else
				{
					<Module>.fwrite(*(ref <Module>.struct121_0 + 7172), 262144U, 1U, ptr);
					<Module>.fclose(ptr);
					this.textBox6.AppendText("\r\n" + "Hitachi Dump file saved to " + fileName + "\r\n");
					this.method_37(fullPath, int_16, *(ref <Module>.struct121_0 + 7172));
				}
			}
			else
			{
				this.method_37("", int_16, *(ref <Module>.struct121_0 + 7172));
			}
		}

		// Token: 0x06000392 RID: 914 RVA: 0x00148934 File Offset: 0x00148934
		private unsafe void method_359()
		{
			string text = null;
			string text2 = null;
			int num = 0;
			int num2 = 0;
			int selectedIndex = 0;
			this.int_10 = 0;
			int num3 = 65;
			this.comboBox16.Items.Clear();
			this.comboBox16.Text = "";
			uint num4 = <Module>.GetLogicalDrives();
			int i = 0;
			while (i <= 26)
			{
				if ((num4 & 1U) == 0U)
				{
					goto IL_2CA;
				}
				Struct20 @struct;
				<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct25_11), num3);
				num++;
				int driveTypeA = <Module>.GetDriveTypeA((sbyte*)(&@struct));
				text = text + " " + new string((sbyte*)(&@struct));
				if (driveTypeA != 5)
				{
					goto IL_2CA;
				}
				Struct109 struct2;
				<Module>.sprintf((sbyte*)(&struct2), (sbyte*)(&<Module>.struct22_5), num3);
				text2 = text2 + " " + new string((sbyte*)(&@struct));
				void* ptr = <Module>.CreateFileA((sbyte*)(&struct2), -1073741824, 3, null, 3, 128, null);
				if (ptr != -1)
				{
					"Inquiry failed to drive " + Convert.ToString(i);
					Struct5 struct3;
					<Module>.memset((void*)(&struct3), 48, 56U);
					Struct108 struct4;
					<Module>.memset((void*)(&struct4), 0, 62U);
					*(ref struct4 + 28) = 18;
					*(ref struct4 + 32) = 56;
					*(ref struct4 + 33) = 192;
					struct4 = 44;
					*(ref struct4 + 6) = 12;
					*(ref struct4 + 7) = 18;
					*(ref struct4 + 8) = 1;
					*(ref struct4 + 12) = 56;
					*(ref struct4 + 16) = 15;
					*(ref struct4 + 20) = ref struct3;
					*(ref struct4 + 24) = 44;
					try
					{
						uint num5;
						<Module>.DeviceIoControl(ptr, 315412, (void*)(&struct4), 62, (void*)(&struct4), 62, (uint*)(&num5), null);
					}
					catch (Exception ex)
					{
						string message = ex.Message;
						<Module>.CloseHandle(ptr);
						goto IL_2DA;
					}
					num2++;
					this.method_5((byte*)(&struct3), 56U, 0U);
					byte* pByte_ = ref struct3 + 8;
					string str = this.method_176(pByte_, 28U);
					this.comboBox16.Items.Add(new string((sbyte*)(&@struct)) + "\\ [" + str + "]");
					if (*(ref struct3 + 24) == 71 && *(ref struct3 + 25) == 68 && *(ref struct3 + 26) == 82 && *(ref struct3 + 27) == 51 && *(ref struct3 + 28) == 49 && *(ref struct3 + 29) == 50 && *(ref struct3 + 30) == 48 && *(ref struct3 + 31) == 76)
					{
						selectedIndex = num2 - 1;
						if (*(ref struct3 + 34) == 53)
						{
							this.radioButton4.Checked = true;
						}
						else if (*(ref struct3 + 34) == 55)
						{
							this.radioButton5.Checked = true;
						}
						else if (*(ref struct3 + 34) == 52 & *(ref struct3 + 35) != 48)
						{
							this.radioButton3.Checked = true;
						}
						else if (*(ref struct3 + 34) == 51 & *(ref struct3 + 35) == 54)
						{
							this.radioButton2.Checked = true;
						}
						else
						{
							this.radioButton1.Checked = true;
						}
					}
				}
				<Module>.CloseHandle(ptr);
				goto IL_2CA;
				IL_2DA:
				i++;
				continue;
				IL_2CA:
				num4 >>= 1;
				num3++;
				if (num4 != 0U)
				{
					goto IL_2DA;
				}
				break;
			}
			this.textBox6.AppendText("Found " + Convert.ToString(num) + " windows drives" + text + "\r\n");
			this.textBox6.AppendText("Found " + Convert.ToString(num2) + " CD/DVD drives" + text2 + "\r\n\r\n");
			if (num2 > 0)
			{
				this.comboBox16.SelectedIndex = selectedIndex;
			}
			this.int_10 = num2;
		}

		// Token: 0x06000393 RID: 915 RVA: 0x00148CBC File Offset: 0x00148CBC
		private unsafe void method_360()
		{
			string str = null;
			string str2 = null;
			int num = 0;
			int num2 = 0;
			int selectedIndex = 0;
			this.int_10 = 0;
			int num3 = 65;
			this.comboBox16.Items.Clear();
			this.comboBox16.Text = "";
			uint num4 = <Module>.GetLogicalDrives();
			int i = 0;
			while (i <= 26)
			{
				if ((num4 & 1U) == 0U)
				{
					goto IL_2CA;
				}
				Struct20 @struct;
				<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct25_11), num3);
				num++;
				int driveTypeA = <Module>.GetDriveTypeA((sbyte*)(&@struct));
				str = str + " " + new string((sbyte*)(&@struct));
				if (driveTypeA != 5)
				{
					goto IL_2CA;
				}
				Struct109 struct2;
				<Module>.sprintf((sbyte*)(&struct2), (sbyte*)(&<Module>.struct22_5), num3);
				str2 = str2 + " " + new string((sbyte*)(&@struct));
				void* ptr = <Module>.CreateFileA((sbyte*)(&struct2), -1073741824, 3, null, 3, 128, null);
				if (ptr != -1)
				{
					"Inquiry failed to drive " + Convert.ToString(i);
					Struct5 struct3;
					<Module>.memset((void*)(&struct3), 48, 56U);
					Struct108 struct4;
					<Module>.memset((void*)(&struct4), 0, 62U);
					*(ref struct4 + 28) = 18;
					*(ref struct4 + 32) = 56;
					*(ref struct4 + 33) = 192;
					struct4 = 44;
					*(ref struct4 + 6) = 12;
					*(ref struct4 + 7) = 18;
					*(ref struct4 + 8) = 1;
					*(ref struct4 + 12) = 56;
					*(ref struct4 + 16) = 15;
					*(ref struct4 + 20) = ref struct3;
					*(ref struct4 + 24) = 44;
					try
					{
						uint num5;
						<Module>.DeviceIoControl(ptr, 315412, (void*)(&struct4), 62, (void*)(&struct4), 62, (uint*)(&num5), null);
					}
					catch (Exception ex)
					{
						string message = ex.Message;
						<Module>.CloseHandle(ptr);
						goto IL_2DA;
					}
					num2++;
					this.method_5((byte*)(&struct3), 56U, 0U);
					byte* pByte_ = ref struct3 + 8;
					string str3 = this.method_176(pByte_, 28U);
					this.comboBox16.Items.Add(new string((sbyte*)(&@struct)) + "\\ [" + str3 + "]");
					if (*(ref struct3 + 24) == 71 && *(ref struct3 + 25) == 68 && *(ref struct3 + 26) == 82 && *(ref struct3 + 27) == 51 && *(ref struct3 + 28) == 49 && *(ref struct3 + 29) == 50 && *(ref struct3 + 30) == 48 && *(ref struct3 + 31) == 76)
					{
						selectedIndex = num2 - 1;
						if (*(ref struct3 + 34) == 53)
						{
							this.radioButton4.Checked = true;
						}
						else if (*(ref struct3 + 34) == 55)
						{
							this.radioButton5.Checked = true;
						}
						else if (*(ref struct3 + 34) == 52 & *(ref struct3 + 35) != 48)
						{
							this.radioButton3.Checked = true;
						}
						else if (*(ref struct3 + 34) == 51 & *(ref struct3 + 35) == 54)
						{
							this.radioButton2.Checked = true;
						}
						else
						{
							this.radioButton1.Checked = true;
						}
					}
				}
				<Module>.CloseHandle(ptr);
				goto IL_2CA;
				IL_2DA:
				i++;
				continue;
				IL_2CA:
				num4 >>= 1;
				num3++;
				if (num4 != 0U)
				{
					goto IL_2DA;
				}
				break;
			}
			if (num2 > 0)
			{
				this.comboBox16.SelectedIndex = selectedIndex;
			}
			this.int_10 = num2;
		}

		// Token: 0x06000394 RID: 916 RVA: 0x00148FF8 File Offset: 0x00148FF8
		private unsafe int method_361()
		{
			uint num = <Module>.GetLogicalDrives();
			int num2 = 65;
			int num3 = 0;
			int num4 = 0;
			int selectedIndex = 0;
			bool flag = false;
			this.int_10 = 0;
			this.comboBox16.Items.Clear();
			this.comboBox16.Text = "";
			int i = 0;
			while (i <= 26)
			{
				if ((num & 1U) == 0U)
				{
					goto IL_3AB;
				}
				Struct20 @struct;
				<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct25_11), num2);
				this.textBox6.AppendText("Found drive " + new string((sbyte*)(&@struct)) + " - ");
				switch (<Module>.GetDriveTypeA((sbyte*)(&@struct)))
				{
				case 0U:
					this.textBox6.AppendText("Unknown." + new string((sbyte*)(&<Module>.struct18_12)));
					goto IL_3AB;
				case 1U:
					this.textBox6.AppendText("Invalid." + new string((sbyte*)(&<Module>.struct18_12)));
					goto IL_3AB;
				case 2U:
					this.textBox6.AppendText("Removable." + new string((sbyte*)(&<Module>.struct18_12)));
					goto IL_3AB;
				case 3U:
					this.textBox6.AppendText("Hard Drive." + new string((sbyte*)(&<Module>.struct18_12)));
					goto IL_3AB;
				case 4U:
					this.textBox6.AppendText("Network." + new string((sbyte*)(&<Module>.struct18_12)));
					goto IL_3AB;
				case 5U:
				{
					this.textBox6.AppendText("CD/DVD.");
					Struct109 struct2;
					<Module>.sprintf((sbyte*)(&struct2), (sbyte*)(&<Module>.struct22_5), num2);
					void* ptr = <Module>.CreateFileA((sbyte*)(&struct2), -1073741824, 3, null, 3, 128, null);
					if (ptr != -1)
					{
						num3++;
						"Inquiry failed to drive " + Convert.ToString(i);
						Struct5 struct3;
						<Module>.memset((void*)(&struct3), 48, 56U);
						Struct108 struct4;
						<Module>.memset((void*)(&struct4), 0, 62U);
						*(ref struct4 + 28) = 18;
						*(ref struct4 + 32) = 56;
						*(ref struct4 + 33) = 192;
						struct4 = 44;
						*(ref struct4 + 6) = 12;
						*(ref struct4 + 7) = 18;
						*(ref struct4 + 8) = 1;
						*(ref struct4 + 12) = 56;
						*(ref struct4 + 16) = 15;
						*(ref struct4 + 20) = ref struct3;
						*(ref struct4 + 24) = 44;
						try
						{
							uint num5;
							<Module>.DeviceIoControl(ptr, 315412, (void*)(&struct4), 62, (void*)(&struct4), 62, (uint*)(&num5), null);
						}
						catch (Exception ex)
						{
							string message = ex.Message;
							<Module>.CloseHandle(ptr);
							break;
						}
						num4++;
						this.method_5((byte*)(&struct3), 56U, 0U);
						byte* pByte_ = ref struct3 + 8;
						string str = this.method_176(pByte_, 28U);
						this.comboBox16.Items.Add(new string((sbyte*)(&@struct)) + "\\ [" + str + "]");
						if (<Module>.memcmp(ref struct3 + 24, (void*)(&<Module>.struct24_10), 8U) == null)
						{
							selectedIndex = num4 - 1;
							flag = true;
							this.textBox6.AppendText(" <--- Hitachi found" + new string((sbyte*)(&<Module>.struct18_12)));
							if (*(ref struct3 + 34) == 53)
							{
								this.radioButton4.Checked = true;
							}
							else if (*(ref struct3 + 34) == 55)
							{
								this.radioButton5.Checked = true;
							}
							else if (*(ref struct3 + 34) == 52 & *(ref struct3 + 35) != 48)
							{
								this.radioButton3.Checked = true;
							}
							else if (*(ref struct3 + 34) == 51 & *(ref struct3 + 35) == 54)
							{
								this.radioButton2.Checked = true;
							}
							else
							{
								this.radioButton1.Checked = true;
							}
						}
						else
						{
							this.textBox6.AppendText(new string((sbyte*)(&<Module>.struct18_12)));
						}
					}
					<Module>.CloseHandle(ptr);
					goto IL_3AB;
				}
				case 6U:
					this.textBox6.AppendText("Ramdisk." + new string((sbyte*)(&<Module>.struct18_12)));
					goto IL_3AB;
				default:
					goto IL_3AB;
				}
				IL_3B6:
				i++;
				continue;
				IL_3AB:
				num >>= 1;
				num2++;
				if (num != 0U)
				{
					goto IL_3B6;
				}
				break;
			}
			int result;
			if (flag)
			{
				this.comboBox16.SelectedIndex = selectedIndex;
				this.int_10 = num4;
				result = 1;
			}
			else
			{
				this.textBox6.AppendText("No Hitachi drives were found!" + "\r\n");
				if (num4 > 0)
				{
					this.comboBox16.SelectedIndex = 0;
				}
				this.int_10 = num4;
				result = 0;
			}
			return result;
		}

		// Token: 0x06000395 RID: 917 RVA: 0x003CBF1C File Offset: 0x00313F1C
		private unsafe int method_362()
		{
			int result;
			if (this.comboBox16.Items.Count == 0)
			{
				<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
				MessageBox.Show("No drive Selected", "Warning", MessageBoxButtons.OK, MessageBoxIcon.Hand);
				<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
				result = 1;
			}
			else
			{
				IntPtr intPtr = Marshal.StringToHGlobalAnsi(this.comboBox16.Text);
				IntPtr value = intPtr;
				sbyte* ptr = (sbyte*)((void*)value);
				if (*(sbyte*)ptr < 65 | *(sbyte*)ptr > 122)
				{
					result = 1;
				}
				else
				{
					Struct109 @struct;
					<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct22_5), *(sbyte*)ptr);
					void* ptr2;
					do
					{
						ptr2 = <Module>.CreateFileA((sbyte*)(&@struct), -1073741824, 3, null, 3, 128, null);
						if (ptr2 != -1)
						{
							goto IL_10A;
						}
						this.textBox6.AppendText(".");
						Application.DoEvents();
						<Module>.Sleep(250);
					}
					while (<Module>.GetAsyncKeyState(27) == null);
					this.textBox6.AppendText("\r\n" + "Aborted by User!" + "\r\n");
					return 1;
					IL_10A:
					Struct108 struct2;
					<Module>.memset((void*)(&struct2), 0, 62U);
					*(ref struct2 + 28) = 231;
					*(ref struct2 + 29) = 72;
					*(ref struct2 + 30) = 73;
					*(ref struct2 + 31) = 84;
					*(ref struct2 + 32) = 48;
					*(ref struct2 + 33) = 144;
					*(ref struct2 + 34) = 144;
					*(ref struct2 + 35) = 208;
					*(ref struct2 + 36) = 1;
					struct2 = 44;
					*(ref struct2 + 6) = 12;
					*(ref struct2 + 7) = 18;
					*(ref struct2 + 8) = 2;
					*(ref struct2 + 16) = 15;
					*(ref struct2 + 24) = 44;
					uint num;
					if (<Module>.DeviceIoControl(ptr2, 315412, (void*)(&struct2), 62, (void*)(&struct2), 62, (uint*)(&num), null) == null)
					{
						this.textBox6.AppendText("Send Mode-B Failed" + "\r\n");
						<Module>.CloseHandle(ptr2);
						result = 1;
					}
					else
					{
						Struct5 struct3;
						<Module>.memset((void*)(&struct3), 48, 56U);
						<Module>.memset((void*)(&struct2), 0, 62U);
						*(ref struct2 + 28) = 18;
						*(ref struct2 + 32) = 56;
						*(ref struct2 + 33) = 0;
						struct2 = 44;
						*(ref struct2 + 6) = 12;
						*(ref struct2 + 7) = 18;
						*(ref struct2 + 8) = 1;
						*(ref struct2 + 12) = 56;
						*(ref struct2 + 16) = 15;
						*(ref struct2 + 20) = ref struct3;
						*(ref struct2 + 24) = 44;
						if (<Module>.DeviceIoControl(ptr2, 315412, (void*)(&struct2), 62, (void*)(&struct2), 62, (uint*)(&num), null) != null)
						{
							this.method_5((byte*)(&struct3), 56U, 0U);
							this.textBox6.AppendText(this.comboBox16.Text + " returns with normal Windows Inquiry" + "\r\n");
							this.textBox6.AppendText(this.string_0);
							if (*(ref struct3 + 24) == 71 && *(ref struct3 + 25) == 68 && *(ref struct3 + 26) == 82 && *(ref struct3 + 27) == 51 && *(ref struct3 + 28) == 49 && *(ref struct3 + 29) == 50 && *(ref struct3 + 30) == 48 && *(ref struct3 + 31) == 76)
							{
								if (*(ref struct3 + 34) == 53)
								{
									this.radioButton4.Checked = true;
								}
								else if (*(ref struct3 + 34) == 55)
								{
									this.radioButton5.Checked = true;
								}
								else if (*(ref struct3 + 34) == 52 & *(ref struct3 + 35) != 48)
								{
									this.radioButton3.Checked = true;
								}
								else if (*(ref struct3 + 34) == 51 & *(ref struct3 + 35) == 54)
								{
									this.radioButton2.Checked = true;
								}
								else
								{
									this.radioButton1.Checked = true;
								}
							}
						}
						else
						{
							this.textBox6.AppendText("Inquiry failed" + "\r\n");
						}
						<Module>.CloseHandle(ptr2);
						result = 0;
					}
				}
			}
			return result;
		}

		// Token: 0x06000396 RID: 918 RVA: 0x001497DC File Offset: 0x001497DC
		private unsafe void method_363()
		{
			if (this.comboBox16.Text == new string((sbyte*)(&<Module>.struct19_0)))
			{
				<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
				MessageBox.Show("No drive Selected", "Warning", MessageBoxButtons.OK, MessageBoxIcon.Hand);
				<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
			}
			else
			{
				this.comboBox16.Text.Substring(0, 1);
				IntPtr intPtr = Marshal.StringToHGlobalAnsi(this.comboBox16.Text);
				IntPtr value = intPtr;
				sbyte* ptr = (sbyte*)((void*)value);
				if (!(*(sbyte*)ptr < 65 | *(sbyte*)ptr > 122))
				{
					Struct109 @struct;
					<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct22_5), *(sbyte*)ptr);
					void* ptr2 = <Module>.CreateFileA((sbyte*)(&@struct), -1073741824, 3, null, 3, 128, null);
					if (ptr2 != -1)
					{
						Struct5 struct2;
						<Module>.memset((void*)(&struct2), 48, 56U);
						Struct108 struct3;
						<Module>.memset((void*)(&struct3), 0, 62U);
						*(ref struct3 + 28) = 18;
						*(ref struct3 + 32) = 56;
						*(ref struct3 + 33) = 0;
						struct3 = 44;
						*(ref struct3 + 6) = 12;
						*(ref struct3 + 7) = 18;
						*(ref struct3 + 8) = 1;
						*(ref struct3 + 12) = 56;
						*(ref struct3 + 16) = 15;
						*(ref struct3 + 20) = ref struct2;
						*(ref struct3 + 24) = 44;
						uint num;
						if (<Module>.DeviceIoControl(ptr2, 315412, (void*)(&struct3), 62, (void*)(&struct3), 62, (uint*)(&num), null) != null)
						{
							this.method_5((byte*)(&struct2), 56U, 0U);
							this.textBox6.AppendText(this.comboBox16.Text + " returns Inquiry" + "\r\n");
							this.textBox6.AppendText(this.string_0 + "\r\n");
							if (*(ref struct2 + 24) == 71 && *(ref struct2 + 25) == 68 && *(ref struct2 + 26) == 82 && *(ref struct2 + 27) == 51 && *(ref struct2 + 28) == 49 && *(ref struct2 + 29) == 50 && *(ref struct2 + 30) == 48 && *(ref struct2 + 31) == 76)
							{
								if (*(ref struct2 + 34) == 53)
								{
									this.radioButton4.Checked = true;
								}
								else if (*(ref struct2 + 34) == 55)
								{
									this.radioButton5.Checked = true;
								}
								else if (*(ref struct2 + 34) == 52 & *(ref struct2 + 35) != 48)
								{
									this.radioButton3.Checked = true;
								}
								else if (*(ref struct2 + 34) == 51 & *(ref struct2 + 35) == 54)
								{
									this.radioButton2.Checked = true;
								}
								else
								{
									this.radioButton1.Checked = true;
								}
							}
						}
						else
						{
							this.textBox6.AppendText("Inquiry failed" + "\r\n");
						}
					}
					else
					{
						this.textBox6.AppendText("Failed to open drive " + "\r\n");
					}
					<Module>.CloseHandle(ptr2);
				}
			}
		}

		// Token: 0x06000397 RID: 919 RVA: 0x00149AB4 File Offset: 0x00149AB4
		private void menuItem_0_Click(object sender, EventArgs e)
		{
			this.method_340();
		}

		// Token: 0x06000398 RID: 920 RVA: 0x00149AC8 File Offset: 0x00149AC8
		private void menuItem_1_Click(object sender, EventArgs e)
		{
			this.method_341();
		}

		// Token: 0x06000399 RID: 921 RVA: 0x00149ADC File Offset: 0x00149ADC
		private void menuItem_8_Click(object sender, EventArgs e)
		{
			this.method_332();
		}

		// Token: 0x0600039A RID: 922 RVA: 0x00149AF0 File Offset: 0x00149AF0
		private void menuItem_9_Click(object sender, EventArgs e)
		{
			this.method_334();
		}

		// Token: 0x0600039B RID: 923 RVA: 0x00149B04 File Offset: 0x00149B04
		private void menuItem_10_Click(object sender, EventArgs e)
		{
			this.method_333();
		}

		// Token: 0x0600039C RID: 924 RVA: 0x00149B18 File Offset: 0x00149B18
		private void menuItem_39_Click(object sender, EventArgs e)
		{
			this.method_346();
		}

		// Token: 0x0600039D RID: 925 RVA: 0x00149B2C File Offset: 0x00149B2C
		private void menuItem_40_Click(object sender, EventArgs e)
		{
			this.method_342();
		}

		// Token: 0x0600039E RID: 926 RVA: 0x00149B40 File Offset: 0x00149B40
		private void menuItem_41_Click(object sender, EventArgs e)
		{
			this.method_343();
		}

		// Token: 0x0600039F RID: 927 RVA: 0x00149B54 File Offset: 0x00149B54
		private void menuItem_42_Click(object sender, EventArgs e)
		{
			this.method_344();
		}

		// Token: 0x060003A0 RID: 928 RVA: 0x00149B68 File Offset: 0x00149B68
		private void menuItem_44_Click(object sender, EventArgs e)
		{
			this.method_348();
		}

		// Token: 0x060003A1 RID: 929 RVA: 0x00149B7C File Offset: 0x00149B7C
		private void menuItem_45_Click(object sender, EventArgs e)
		{
			this.method_349();
		}

		// Token: 0x060003A2 RID: 930 RVA: 0x00149B90 File Offset: 0x00149B90
		private void menuItem_46_Click(object sender, EventArgs e)
		{
			this.method_347();
		}

		// Token: 0x060003A3 RID: 931 RVA: 0x00149BA4 File Offset: 0x00149BA4
		private void menuItem_47_Click(object sender, EventArgs e)
		{
			this.method_350();
		}

		// Token: 0x060003A4 RID: 932 RVA: 0x00149BB8 File Offset: 0x00149BB8
		private void menuItem_49_Click(object sender, EventArgs e)
		{
			this.method_345();
		}

		// Token: 0x060003A5 RID: 933 RVA: 0x00149BCC File Offset: 0x00149BCC
		private void menuItem_43_Click(object sender, EventArgs e)
		{
			this.method_351();
			this.method_352();
		}

		// Token: 0x060003A6 RID: 934 RVA: 0x00149BE8 File Offset: 0x00149BE8
		private void button26_Click(object sender, EventArgs e)
		{
			this.method_364();
		}

		// Token: 0x060003A7 RID: 935 RVA: 0x00149BFC File Offset: 0x00149BFC
		private unsafe void method_364()
		{
			Struct113 @struct = 0;
			initblk(ref @struct + 4, 0, 252);
			this.method_376();
			this.textBox6.AppendText(this.string_21 + " Hitachi " + this.string_19 + " by ");
			this.textBox6.AppendText(this.string_20 + " " + this.string_22 + "\r\n");
			if (this.int_15 == 0)
			{
				this.method_380();
			}
			else if (this.int_15 == 1)
			{
				this.method_381();
			}
			uint uint_;
			uint uint_2;
			uint uint_3;
			uint uint_4;
			if (this.checkBox7.CheckState == CheckState.Unchecked)
			{
				uint_ = 296960U;
				uint_2 = 32U;
				uint_3 = 8192U;
				uint_4 = 1U;
			}
			else
			{
				uint_ = 2375680U;
				uint_2 = 256U;
				uint_3 = 1024U;
				uint_4 = 8U;
			}
			if (this.int_13 == 0 & this.int_14 == 0 & this.int_12 != 79 & this.int_15 == 0)
			{
				string text = "";
				text = text + "If the drive is modified with a firmware that employs f/w stealth" + "\r\n";
				text = text + "a Classic Dump will appear to be stock firmware. For a true dump" + "\r\n";
				text = text + "use one of the other transfer methods." + "\r\n";
				<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
				int num = (int)MessageBox.Show(text, "Classic Dump", MessageBoxButtons.OK, MessageBoxIcon.Asterisk);
				<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
				int num2 = <Module>.clock();
				if (this.method_394(uint_, uint_2, uint_3, uint_4) == 0)
				{
					uint num3 = (uint)this.method_374(*(ref <Module>.struct121_0 + 7172));
					if (this.method_367(num3) == 0)
					{
						num3 = (uint)this.method_374(*(ref <Module>.struct121_0 + 7172));
						this.method_368(num3);
						int num4 = <Module>.clock();
						int value = num4 - num2;
						this.textBox6.AppendText("\r\n" + "Dumped in " + Convert.ToString(value) + "mS" + "\r\n");
						this.method_356();
					}
				}
			}
			else if (this.int_13 == 0 & this.int_14 == 0 & this.int_12 != 79 & this.int_15 == 1)
			{
				string text = "";
				text = text + "If the drive is modified with a firmware that employs f/w stealth" + "\r\n";
				text = text + "a Classic Dump will appear to be stock firmware. For a true dump" + "\r\n";
				text = text + "use one of the other transfer methods." + "\r\n\r\n";
				text = text + "Also, classic mode works in mode-a over PortIO as there is no" + "\r\n";
				text = text + "requirement for a windows drive letter and will return data." + "\r\n";
				text = text + "A classic dump is no guarantee the drive is in mode-b." + "\r\n";
				<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
				int num = (int)MessageBox.Show(text, "Classic Dump", MessageBoxButtons.OK, MessageBoxIcon.Asterisk);
				<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
				int num5 = <Module>.clock();
				if (this.method_395(uint_, uint_2, uint_3, uint_4) == 0)
				{
					uint num3 = (uint)this.method_374(*(ref <Module>.struct121_0 + 7172));
					if (this.method_367(num3) == 0)
					{
						num3 = (uint)this.method_374(*(ref <Module>.struct121_0 + 7172));
						this.method_368(num3);
						int num6 = <Module>.clock();
						int value2 = num6 - num5;
						this.textBox6.AppendText("\r\n" + "Dumped in " + Convert.ToString(value2) + "mS" + "\r\n");
						this.method_356();
					}
				}
			}
			else if (this.int_14 == 0)
			{
				if (this.method_382() == 0)
				{
					int num7 = <Module>.clock();
					if (this.method_393(uint_, uint_2, uint_3, uint_4) == 0)
					{
						uint num3 = (uint)this.method_374(*(ref <Module>.struct121_0 + 7172));
						if (this.method_367(num3) == 0)
						{
							int num8 = <Module>.clock();
							int value3 = num8 - num7;
							this.textBox6.AppendText("\r\n" + "Dumped in " + Convert.ToString(value3) + "mS" + "\r\n");
							this.method_356();
						}
					}
				}
			}
			else if (this.int_14 == 1)
			{
				<Module>.memset(<Module>.struct123_0, 0, 2392U);
				this.method_40();
				if (this.method_382() == 0)
				{
					this.textBox6.AppendText(string.Concat("Dumping Flash:"));
					if (this.method_393(uint_, uint_2, uint_3, uint_4) == 0)
					{
						uint num3 = (uint)this.method_374(*(ref <Module>.struct121_0 + 7172));
						if (this.method_367(num3) == 0)
						{
							this.method_37("", 1, *(ref <Module>.struct121_0 + 7172));
							FreeKey freeKey = new FreeKey();
							freeKey.ushort_0 = *(*(ref <Module>.struct123_0 + 4));
							freeKey.ushort_1 = *(*(ref <Module>.struct123_0 + 4) + 2);
							freeKey.ushort_2 = *(*(ref <Module>.struct123_0 + 4) + 2382);
							freeKey.ushort_3 = *(*(ref <Module>.struct123_0 + 4) + 2384);
							freeKey.textBox1.Text = this.textBox11.Text;
							if (freeKey.pByte_0 != null)
							{
								<Module>.free((void*)freeKey.pByte_0);
							}
							freeKey.pByte_0 = <Module>.malloc(16U);
							<Module>.memcpy((void*)freeKey.pByte_0, *(ref <Module>.struct123_0 + 4) + 280, 16U);
							if (freeKey.pByte_1 != null)
							{
								<Module>.free((void*)freeKey.pByte_1);
							}
							freeKey.pByte_1 = <Module>.malloc(96U);
							<Module>.memcpy((void*)freeKey.pByte_1, *(ref <Module>.struct123_0 + 4) + 568, 96U);
							if (freeKey.pByte_2 != null)
							{
								<Module>.free((void*)freeKey.pByte_2);
							}
							freeKey.pByte_2 = <Module>.malloc(180U);
							<Module>.memcpy((void*)freeKey.pByte_2, *(ref <Module>.struct123_0 + 4) + 780, 180U);
							if (*(*(ref <Module>.struct123_0 + 4) + 2382) == 4)
							{
								this.method_9(*(ref <Module>.struct123_0 + 4) + 610, 20U);
								freeKey.textBox2.Text = this.string_0;
								if (freeKey.pByte_4 != null)
								{
									<Module>.free((void*)freeKey.pByte_4);
								}
								freeKey.pByte_4 = <Module>.malloc(20U);
								<Module>.memset((void*)freeKey.pByte_4, 32, 20U);
								<Module>.memcpy((void*)freeKey.pByte_4, *(ref <Module>.struct123_0 + 4) + 610, 20U);
							}
							if (freeKey.ShowDialog(this) == DialogResult.OK)
							{
								<Module>.memcpy(*(ref <Module>.struct123_0 + 4) + 280, (void*)freeKey.pByte_0, 16U);
								<Module>.memcpy(*(ref <Module>.struct123_0 + 4) + 568, (void*)freeKey.pByte_1, 96U);
								<Module>.memcpy(*(ref <Module>.struct123_0 + 4) + 2316, *(ref <Module>.struct123_0 + 4) + 576, 28U);
								<Module>.memcpy(*(ref <Module>.struct123_0 + 4) + 780, (void*)freeKey.pByte_2, 180U);
								*(*(ref <Module>.struct123_0 + 4) + 2382) = (short)freeKey.ushort_2;
								*(*(ref <Module>.struct123_0 + 4) + 2384) = (short)freeKey.ushort_3;
								if (*(*(ref <Module>.struct123_0 + 4)) != *(*(ref <Module>.struct123_0 + 4) + 2382) || *(*(ref <Module>.struct123_0 + 4) + 2) != *(*(ref <Module>.struct123_0 + 4) + 2384))
								{
									*(*(ref <Module>.struct123_0 + 4) + 2020) = 0;
								}
								this.bool_10 = true;
								this.method_47();
								this.method_41();
								int num9 = this.method_370(*(ref <Module>.struct121_0 + 7172), *(ref <Module>.struct121_0 + 4780), (int*)(&@struct));
								if (num9 > 3)
								{
									this.textBox6.AppendText("Too many Sector Differences Found, Flash aborted !!" + "\r\n");
								}
								else
								{
									Struct32 struct2;
									<Module>.memcpy((void*)(&struct2), *(ref <Module>.struct121_0 + 7172), 262144U);
									<Module>.memcpy(*(ref <Module>.struct121_0 + 7172) + 258096, (void*)(&<Module>.struct34_1), 48U);
									Struct33 struct3;
									<Module>.memcpy((void*)(&struct3), *(ref <Module>.struct121_0 + 7172) + 258048, 4096U);
									this.textBox6.AppendText("Flash Stability Test" + "\r\n");
									this.method_391(*(ref <Module>.struct121_0 + 7172), *(ref <Module>.struct121_0 + 9564), 262144);
									this.method_403(*(ref <Module>.struct121_0 + 9564), 2416177152U, 4096U);
									this.textBox6.AppendText(string.Concat("Dumping Sector 9003F000:"));
									if (this.method_393(2375932U, 4U, 1024U, 1U) == 0)
									{
										if (<Module>.memcmp(*(ref <Module>.struct121_0 + 7172), (void*)(&struct3), 4096U) != null)
										{
											this.textBox6.AppendText("\r\n" + "Read back mis-compare, Restore Aborted" + "\r\n");
										}
										else
										{
											this.textBox6.AppendText("\r\n" + "Read back & compare, complete, Flashing Stable!" + "\r\n");
											this.textBox6.AppendText("Repairing Test Sector." + "\r\n");
											<Module>.memcpy(*(ref <Module>.struct121_0 + 7172), (void*)(&struct2), 262144U);
											this.method_391(*(ref <Module>.struct121_0 + 7172), *(ref <Module>.struct121_0 + 9564), 262144);
											this.method_403(*(ref <Module>.struct121_0 + 9564), 2416177152U, 4096U);
											this.textBox6.AppendText("Done !" + "\r\n");
											if (!this.bool_2)
											{
												<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
												int num = (int)MessageBox.Show("Flashing stabilty test reports stable." + "\n\n" + "Do you wish to Continue ?", "Flash Keys", MessageBoxButtons.YesNo, MessageBoxIcon.Question, MessageBoxDefaultButton.Button2);
												<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
												if (num == 7)
												{
													this.textBox6.AppendText("Flash Keys Aborted !" + "\r\n");
													return;
												}
											}
											this.method_391(*(ref <Module>.struct121_0 + 4780), *(ref <Module>.struct121_0 + 9564), 262144);
											if (*(ref @struct + (num9 - 1) * 4) == -1878794240)
											{
												this.method_403(*(ref <Module>.struct121_0 + 9564), 2416173056U, 4096U);
												num9--;
											}
											for (int i = 0; i < num9; i++)
											{
												this.method_403(*(ref <Module>.struct121_0 + 9564), (uint)(*(ref @struct + i * 4)), 4096U);
												Application.DoEvents();
											}
											this.textBox6.AppendText("Done !" + "\r\n");
											this.textBox6.AppendText("Write verify test.." + "\r\n");
											this.textBox6.AppendText(string.Concat("Dumping Flash:"));
											if (this.method_393(uint_, uint_2, uint_3, uint_4) == 0)
											{
												if (<Module>.memcmp(*(ref <Module>.struct121_0 + 7172), *(ref <Module>.struct121_0 + 4780), 262144U) != null)
												{
													this.textBox6.AppendText("\r\n" + "Read back mis-compare, Flash process has errors" + "\r\n");
												}
												else
												{
													this.textBox6.AppendText("\r\n" + "Read back & compare completed, Write Verified!" + "\r\n");
													this.textBox6.AppendText("Flash Complete !" + "\r\n");
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
			else if (this.int_14 == 2)
			{
				if (this.method_382() == 0)
				{
					this.textBox6.AppendText(string.Concat("Dumping Flash:"));
					if (this.method_393(uint_, uint_2, uint_3, uint_4) == 0)
					{
						uint num3 = (uint)this.method_374(*(ref <Module>.struct121_0 + 7172));
						if (this.method_367(num3) == 0)
						{
							this.method_37("", 1, *(ref <Module>.struct121_0 + 7172));
							if (*<Module>.struct123_0 == 0)
							{
								this.method_50(5);
							}
							if (*<Module>.struct123_0 != 0)
							{
								*(*(ref <Module>.struct123_0 + 4) + 2020) = 0;
								this.textBox6.AppendText(string.Concat("Setting Master Checksum."));
								this.method_46();
								this.method_47();
								this.method_41();
								int num10 = this.method_370(*(ref <Module>.struct121_0 + 7172), *(ref <Module>.struct121_0 + 4780), (int*)(&@struct));
								if (num10 > 4)
								{
									this.textBox6.AppendText("Too many Sector Differences Found, Flash aborted !!" + "\r\n");
								}
								else
								{
									Struct32 struct2;
									<Module>.memcpy((void*)(&struct2), *(ref <Module>.struct121_0 + 7172), 262144U);
									<Module>.memcpy(*(ref <Module>.struct121_0 + 7172) + 258096, (void*)(&<Module>.struct34_1), 48U);
									Struct33 struct3;
									<Module>.memcpy((void*)(&struct3), *(ref <Module>.struct121_0 + 7172) + 258048, 4096U);
									this.textBox6.AppendText("Flash Stability Test" + "\r\n");
									this.method_391(*(ref <Module>.struct121_0 + 7172), *(ref <Module>.struct121_0 + 9564), 262144);
									this.method_403(*(ref <Module>.struct121_0 + 9564), 2416177152U, 4096U);
									this.textBox6.AppendText(string.Concat("Dumping Sector 9003F000:"));
									if (this.method_393(2375932U, 4U, 1024U, 1U) == 0)
									{
										if (<Module>.memcmp(*(ref <Module>.struct121_0 + 7172), (void*)(&struct3), 4096U) != null)
										{
											this.textBox6.AppendText("\r\n" + "Read back mis-compare, Restore Aborted" + "\r\n");
										}
										else
										{
											this.textBox6.AppendText("\r\n" + "Read back & compare, complete, Flashing Stable!" + "\r\n");
											this.textBox6.AppendText("Repairing Test Sector." + "\r\n");
											<Module>.memcpy(*(ref <Module>.struct121_0 + 7172), (void*)(&struct2), 262144U);
											this.method_391(*(ref <Module>.struct121_0 + 7172), *(ref <Module>.struct121_0 + 9564), 262144);
											this.method_403(*(ref <Module>.struct121_0 + 9564), 2416177152U, 4096U);
											this.textBox6.AppendText("Done !" + "\r\n");
											if (!this.bool_2)
											{
												<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
												int num = (int)MessageBox.Show("Flashing stabilty test reports stable." + "\n\n" + "Do you wish to Continue ?", "Flash ID Strings", MessageBoxButtons.YesNo, MessageBoxIcon.Question, MessageBoxDefaultButton.Button2);
												<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
												if (num == 7)
												{
													this.textBox6.AppendText("Flash ID Strings Aborted !" + "\r\n");
													return;
												}
											}
											this.method_391(*(ref <Module>.struct121_0 + 4780), *(ref <Module>.struct121_0 + 9564), 262144);
											if (*(ref @struct + (num10 - 1) * 4) == -1878794240)
											{
												this.method_403(*(ref <Module>.struct121_0 + 9564), 2416173056U, 4096U);
												num10--;
											}
											for (int i = 0; i < num10; i++)
											{
												this.method_403(*(ref <Module>.struct121_0 + 9564), (uint)(*(ref @struct + i * 4)), 4096U);
												Application.DoEvents();
											}
											this.textBox6.AppendText("Done !" + "\r\n");
											this.textBox6.AppendText("Write verify test.." + "\r\n");
											this.textBox6.AppendText(string.Concat("Dumping Flash:"));
											if (this.method_393(uint_, uint_2, uint_3, uint_4) == 0)
											{
												if (<Module>.memcmp(*(ref <Module>.struct121_0 + 7172), *(ref <Module>.struct121_0 + 4780), 262144U) != null)
												{
													this.textBox6.AppendText("\r\n" + "Read back mis-compare, Flash process has errors" + "\r\n");
												}
												else
												{
													this.textBox6.AppendText("\r\n" + "Read back & compare completed, Write Verified!" + "\r\n");
													this.textBox6.AppendText("Flash Complete !" + "\r\n");
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
			else if (this.int_14 == 3)
			{
				if (this.method_382() == 0)
				{
					this.textBox6.AppendText(string.Concat("Dumping Flash:"));
					if (this.method_393(uint_, uint_2, uint_3, uint_4) == 0)
					{
						uint num3 = (uint)this.method_374(*(ref <Module>.struct121_0 + 7172));
						if (this.method_367(num3) == 0)
						{
							this.method_37("", 0, *(ref <Module>.struct121_0 + 7172));
							uint num11 = (uint)((int)(*(*(ref <Module>.struct121_0 + 7172) + 255999)) << 24 | (int)(*(*(ref <Module>.struct121_0 + 7172) + 255998)) << 16 | (int)(*(*(ref <Module>.struct121_0 + 7172) + 255997)) << 8 | (int)(*(*(ref <Module>.struct121_0 + 7172) + 255996)));
							if (num11 == 0U)
							{
								<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
								MessageBox.Show("Master Checksum is Set, this is normal for a modded drive." + "\n" + "Restore Drive to Stock first", "Flash iXtreme", MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
								<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
								this.textBox6.AppendText("Flash Aborted" + "\r\n");
							}
							else
							{
								num3 = (uint)this.method_374(*(ref <Module>.struct121_0 + 7172));
								if (this.method_365(num3, num11) == 0)
								{
									this.method_377();
									int num12 = this.method_369(*(ref <Module>.struct121_0 + 7172), *(ref <Module>.struct121_0 + 4780), (int*)(&@struct));
									if (num12 > 16)
									{
										this.textBox6.AppendText("Too many Sector Differences Found, Flash aborted !!" + "\r\n");
									}
									else
									{
										Struct32 struct2;
										<Module>.memcpy((void*)(&struct2), *(ref <Module>.struct121_0 + 7172), 262144U);
										<Module>.memcpy(*(ref <Module>.struct121_0 + 7172) + 258096, (void*)(&<Module>.struct34_1), 48U);
										Struct33 struct3;
										<Module>.memcpy((void*)(&struct3), *(ref <Module>.struct121_0 + 7172) + 258048, 4096U);
										this.textBox6.AppendText("Flash Stability Test" + "\r\n");
										this.method_391(*(ref <Module>.struct121_0 + 7172), *(ref <Module>.struct121_0 + 9564), 262144);
										this.method_403(*(ref <Module>.struct121_0 + 9564), 2416177152U, 4096U);
										this.textBox6.AppendText(string.Concat("Dumping Sector 9003F000:"));
										if (this.method_393(2375932U, 4U, 1024U, 1U) == 0)
										{
											if (<Module>.memcmp(*(ref <Module>.struct121_0 + 7172), (void*)(&struct3), 4096U) != null)
											{
												this.textBox6.AppendText("\r\n" + "Read back mis-compare, Flash Aborted" + "\r\n");
											}
											else
											{
												this.textBox6.AppendText("\r\n" + "Read back & compare completed, Flashing Stable!" + "\r\n");
												this.textBox6.AppendText("Repairing Test Sector." + "\r\n");
												<Module>.memcpy(*(ref <Module>.struct121_0 + 7172), (void*)(&struct2), 262144U);
												this.method_391(*(ref <Module>.struct121_0 + 7172), *(ref <Module>.struct121_0 + 9564), 262144);
												this.method_403(*(ref <Module>.struct121_0 + 9564), 2416177152U, 4096U);
												this.textBox6.AppendText("Done !" + "\r\n");
												if (!this.bool_2)
												{
													<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
													int num = (int)MessageBox.Show("Flashing stabilty test reports stable." + "\n\n" + "Do you wish to Continue ?", "Flash iXtreme", MessageBoxButtons.YesNo, MessageBoxIcon.Question, MessageBoxDefaultButton.Button2);
													<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
													if (num == 7)
													{
														this.textBox6.AppendText("Flash Aborted !" + "\r\n");
														return;
													}
												}
												this.method_391(*(ref <Module>.struct121_0 + 4780), *(ref <Module>.struct121_0 + 9564), 262144);
												if (*(ref @struct + (num12 - 1) * 4) == -1878794240)
												{
													this.method_403(*(ref <Module>.struct121_0 + 9564), 2416173056U, 4096U);
													num12--;
												}
												for (int i = 0; i < num12; i++)
												{
													this.method_403(*(ref <Module>.struct121_0 + 9564), (uint)(*(ref @struct + i * 4)), 4096U);
													Application.DoEvents();
												}
												this.textBox6.AppendText("Done !" + "\r\n");
												this.textBox6.AppendText("Write verify test.." + "\r\n");
												this.textBox6.AppendText(string.Concat("Dumping Flash:"));
												if (this.method_393(uint_, uint_2, uint_3, uint_4) == 0)
												{
													if (<Module>.memcmp(*(ref <Module>.struct121_0 + 7172), *(ref <Module>.struct121_0 + 4780), 262144U) != null)
													{
														this.textBox6.AppendText("\r\n" + "Read back mis-compare, Flash process has errors" + "\r\n");
													}
													else
													{
														this.textBox6.AppendText("\r\n" + "Read back & compare completed, Write Verified!" + "\r\n");
														this.textBox6.AppendText("Flash Complete !" + "\r\n");
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
			else if (this.int_14 == 4)
			{
				if (this.method_382() == 0)
				{
					this.textBox6.AppendText(string.Concat("Dumping Flash:"));
					if (this.method_393(uint_, uint_2, uint_3, uint_4) == 0)
					{
						this.method_37("", 0, *(ref <Module>.struct121_0 + 7172));
						uint num3 = (uint)this.method_374(*(ref <Module>.struct121_0 + 7172));
						if (this.method_367(num3) == 0)
						{
							uint num11 = (uint)((int)(*(*(ref <Module>.struct121_0 + 7172) + 255999)) << 24 | (int)(*(*(ref <Module>.struct121_0 + 7172) + 255998)) << 16 | (int)(*(*(ref <Module>.struct121_0 + 7172) + 255997)) << 8 | (int)(*(*(ref <Module>.struct121_0 + 7172) + 255996)));
							if (num11 != 0U)
							{
								<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
								MessageBox.Show("Master Checksum is not Set, this is not normal for a modded drive." + "\n" + "Drive is not likely Hacked", "Flash Restore", MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
								<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
								this.textBox6.AppendText("Restore Aborted" + "\r\n");
							}
							else
							{
								num3 = (uint)this.method_374(*(ref <Module>.struct121_0 + 7172));
								if (this.method_366(num3) == 0)
								{
									this.method_377();
									int num13 = this.method_371(*(ref <Module>.struct121_0 + 7172), *(ref <Module>.struct121_0 + 4780), (int*)(&@struct));
									if (num13 > 16)
									{
										this.textBox6.AppendText("Too many Sector Differences Found, Flash aborted !!" + "\r\n");
									}
									else
									{
										Struct32 struct2;
										<Module>.memcpy((void*)(&struct2), *(ref <Module>.struct121_0 + 7172), 262144U);
										<Module>.memcpy(*(ref <Module>.struct121_0 + 7172) + 258096, (void*)(&<Module>.struct34_1), 48U);
										Struct33 struct3;
										<Module>.memcpy((void*)(&struct3), *(ref <Module>.struct121_0 + 7172) + 258048, 4096U);
										this.textBox6.AppendText("Flash Stability Test" + "\r\n");
										this.method_391(*(ref <Module>.struct121_0 + 7172), *(ref <Module>.struct121_0 + 9564), 262144);
										this.method_403(*(ref <Module>.struct121_0 + 9564), 2416177152U, 4096U);
										this.textBox6.AppendText(string.Concat("Dumping Sector 9003F000:"));
										if (this.method_393(2375932U, 4U, 1024U, 1U) == 0)
										{
											if (<Module>.memcmp(*(ref <Module>.struct121_0 + 7172), (void*)(&struct3), 4096U) != null)
											{
												this.textBox6.AppendText("\r\n" + "Read back mis-compare, Restore Aborted" + "\r\n");
											}
											else
											{
												this.textBox6.AppendText("\r\n" + "Read back & compare completed, Flashing Stable!" + "\r\n");
												this.textBox6.AppendText("Repairing Test Sector." + "\r\n");
												<Module>.memcpy(*(ref <Module>.struct121_0 + 7172), (void*)(&struct2), 262144U);
												this.method_391(*(ref <Module>.struct121_0 + 7172), *(ref <Module>.struct121_0 + 9564), 262144);
												this.method_403(*(ref <Module>.struct121_0 + 9564), 2416177152U, 4096U);
												this.textBox6.AppendText("Done !" + "\r\n");
												if (!this.bool_2)
												{
													<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
													int num = (int)MessageBox.Show("Flashing stabilty test reports stable." + "\n\n" + "Do you wish to Continue ?", "Restore Firmware", MessageBoxButtons.YesNo, MessageBoxIcon.Question, MessageBoxDefaultButton.Button2);
													<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
													if (num == 7)
													{
														this.textBox6.AppendText("Restore Aborted !" + "\r\n");
														return;
													}
												}
												this.method_391(*(ref <Module>.struct121_0 + 4780), *(ref <Module>.struct121_0 + 9564), 262144);
												for (int i = 0; i < num13; i++)
												{
													this.method_403(*(ref <Module>.struct121_0 + 9564), (uint)(*(ref @struct + i * 4)), 4096U);
													Application.DoEvents();
												}
												this.textBox6.AppendText("Done !" + "\r\n");
												this.textBox6.AppendText("Write verify test.." + "\r\n");
												this.textBox6.AppendText(string.Concat("Dumping Flash:"));
												if (this.method_393(uint_, uint_2, uint_3, uint_4) == 0)
												{
													if (<Module>.memcmp(*(ref <Module>.struct121_0 + 7172), *(ref <Module>.struct121_0 + 4780), 262144U) != null)
													{
														this.textBox6.AppendText("\r\n" + "Read back mis-compare, Flash process has errors" + "\r\n");
													}
													else
													{
														this.textBox6.AppendText("\r\n" + "Read back & compare completed, Write Verified!" + "\r\n");
														this.textBox6.AppendText("Flash Complete !" + "\r\n");
														this.textBox6.AppendText("\r\n" + "Setting Checksum!" + "\r\n");
														num11 = (uint)((int)(*(*(ref <Module>.struct121_0 + 7172) + 255999)) << 24 | (int)(*(*(ref <Module>.struct121_0 + 7172) + 255998)) << 16 | (int)(*(*(ref <Module>.struct121_0 + 7172) + 255997)) << 8 | (int)(*(*(ref <Module>.struct121_0 + 7172) + 255996)));
														uint num14 = (uint)this.method_373(*(ref <Module>.struct121_0 + 7172));
														*(*(ref <Module>.struct121_0 + 7172) + 255996) = (byte)(num14 & 255U);
														*(*(ref <Module>.struct121_0 + 7172) + 255997) = (byte)((num14 & 65280U) >> 8);
														*(*(ref <Module>.struct121_0 + 7172) + 255998) = (byte)((num14 & 16711680U) >> 16);
														*(*(ref <Module>.struct121_0 + 7172) + 255999) = (byte)((num14 & 4278190080U) >> 24);
														if (num11 == 0U && !this.bool_2)
														{
															<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
															MessageBox.Show("Master Checksum is still Set, this is normal for a modded drive." + "\n" + "However Checksum should be set for a full restore!", "Fix Checksum", MessageBoxButtons.OK, MessageBoxIcon.Asterisk);
															<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
														}
														this.method_391(*(ref <Module>.struct121_0 + 7172), *(ref <Module>.struct121_0 + 9564), 262144);
														this.method_403(*(ref <Module>.struct121_0 + 9564), 2416173056U, 4096U);
														<Module>.memcpy((void*)(&struct3), *(ref <Module>.struct121_0 + 7172) + 253952, 4096U);
														this.textBox6.AppendText(string.Concat("Dumping Sector 9003E000:"));
														if (this.method_393(2375928U, 4U, 1024U, 1U) == 0)
														{
															if (<Module>.memcmp(*(ref <Module>.struct121_0 + 7172), (void*)(&struct3), 4096U) != null)
															{
																this.textBox6.AppendText("\r\n" + "Read back mis-compare, Flash Spoof ID's Failed" + "\r\n");
															}
															else
															{
																this.textBox6.AppendText("\r\n" + "Read back & compare completed, Write Verified!" + "\r\n");
																this.textBox6.AppendText("Flash Checksum Complete !" + "\r\n");
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
			else if (this.int_14 == 5)
			{
				if (this.method_382() == 0 && this.method_393(uint_, uint_2, uint_3, uint_4) == 0)
				{
					uint num3 = (uint)this.method_374(*(ref <Module>.struct121_0 + 7172));
					if (this.method_367(num3) == 0)
					{
						uint num11 = (uint)((int)(*(*(ref <Module>.struct121_0 + 7172) + 255999)) << 24 | (int)(*(*(ref <Module>.struct121_0 + 7172) + 255998)) << 16 | (int)(*(*(ref <Module>.struct121_0 + 7172) + 255997)) << 8 | (int)(*(*(ref <Module>.struct121_0 + 7172) + 255996)));
						uint num14 = (uint)this.method_373(*(ref <Module>.struct121_0 + 7172));
						if (num11 == 0U)
						{
							<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
							int num = (int)MessageBox.Show("Master Checksum is Set, this is normal for a modded drive." + "\n" + "Do you wish to Continue ?", "Fix Checksum", MessageBoxButtons.YesNo, MessageBoxIcon.Question, MessageBoxDefaultButton.Button2);
							<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
							if (num == 7)
							{
								return;
							}
						}
						if (num11 == num14)
						{
							<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
							int num = (int)MessageBox.Show("The Correct Checksum is already set !" + "\n" + "Continue and set Master Checksum ?", "Fix Checksum", MessageBoxButtons.YesNo, MessageBoxIcon.Question, MessageBoxDefaultButton.Button2);
							<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
							if (num == 7)
							{
								return;
							}
							*(*(ref <Module>.struct121_0 + 7172) + 255996) = 0;
							*(*(ref <Module>.struct121_0 + 7172) + 255997) = 0;
							*(*(ref <Module>.struct121_0 + 7172) + 255998) = 0;
							*(*(ref <Module>.struct121_0 + 7172) + 255999) = 0;
						}
						if (num11 != num14 & num11 == 0U)
						{
							<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
							int num = (int)MessageBox.Show("The current Checksum is incorrect, but is set to Master Checksum!" + "\n\n" + "Continue and flash Checksum ?", "Fix Checksum", MessageBoxButtons.YesNo, MessageBoxIcon.Question, MessageBoxDefaultButton.Button2);
							<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
							if (num == 7)
							{
								return;
							}
							*(*(ref <Module>.struct121_0 + 7172) + 255996) = (byte)(num14 & 255U);
							*(*(ref <Module>.struct121_0 + 7172) + 255997) = (byte)((num14 & 65280U) >> 8);
							*(*(ref <Module>.struct121_0 + 7172) + 255998) = (byte)((num14 & 16711680U) >> 16);
							*(*(ref <Module>.struct121_0 + 7172) + 255999) = (byte)((num14 & 4278190080U) >> 24);
						}
						if (num11 != num14 & num11 != 0U)
						{
							<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
							int num = (int)MessageBox.Show("The current Checksum is incorrect, AND is NOT set to Master Checksum!" + "\n" + "Drive will not boot next time if not corrected !!" + "\n" + "Continue and flash Checksum ?", "Fix Checksum", MessageBoxButtons.YesNo, MessageBoxIcon.Question, MessageBoxDefaultButton.Button2);
							<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
							if (num == 7)
							{
								return;
							}
							*(*(ref <Module>.struct121_0 + 7172) + 255996) = (byte)(num14 & 255U);
							*(*(ref <Module>.struct121_0 + 7172) + 255997) = (byte)((num14 & 65280U) >> 8);
							*(*(ref <Module>.struct121_0 + 7172) + 255998) = (byte)((num14 & 16711680U) >> 16);
							*(*(ref <Module>.struct121_0 + 7172) + 255999) = (byte)((num14 & 4278190080U) >> 24);
						}
						Struct32 struct2;
						<Module>.memcpy((void*)(&struct2), *(ref <Module>.struct121_0 + 7172), 262144U);
						<Module>.memcpy(*(ref <Module>.struct121_0 + 7172) + 258096, (void*)(&<Module>.struct34_1), 48U);
						Struct33 struct3;
						<Module>.memcpy((void*)(&struct3), *(ref <Module>.struct121_0 + 7172) + 258048, 4096U);
						this.textBox6.AppendText("Flash Stability Test" + "\r\n");
						this.method_391(*(ref <Module>.struct121_0 + 7172), *(ref <Module>.struct121_0 + 9564), 262144);
						this.method_403(*(ref <Module>.struct121_0 + 9564), 2416177152U, 4096U);
						this.textBox6.AppendText(string.Concat("Dumping Sector 9003F000:"));
						if (this.method_393(2375932U, 4U, 1024U, 1U) == 0)
						{
							if (<Module>.memcmp(*(ref <Module>.struct121_0 + 7172), (void*)(&struct3), 4096U) != null)
							{
								this.textBox6.AppendText("\r\n" + "Read back mis-compare, Restore Aborted" + "\r\n");
							}
							else
							{
								this.textBox6.AppendText("\r\n" + "Read back & compare completed, Flashing Stable!" + "\r\n");
								this.textBox6.AppendText("Repairing Test Sector." + "\r\n");
								<Module>.memcpy(*(ref <Module>.struct121_0 + 7172), (void*)(&struct2), 262144U);
								this.method_391(*(ref <Module>.struct121_0 + 7172), *(ref <Module>.struct121_0 + 9564), 262144);
								this.method_403(*(ref <Module>.struct121_0 + 9564), 2416177152U, 4096U);
								this.textBox6.AppendText("Done !" + "\r\n");
								if (!this.bool_2)
								{
									<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
									int num = (int)MessageBox.Show("Flashing stabilty test reports stable." + "\n\n" + "Do you wish to Continue ?", "Fix Checksum", MessageBoxButtons.YesNo, MessageBoxIcon.Question, MessageBoxDefaultButton.Button2);
									<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
									if (num == 7)
									{
										this.textBox6.AppendText("Fix Checksum Aborted !" + "\r\n");
										return;
									}
								}
								this.method_391(*(ref <Module>.struct121_0 + 7172), *(ref <Module>.struct121_0 + 9564), 262144);
								this.method_403(*(ref <Module>.struct121_0 + 9564), 2416173056U, 4096U);
								<Module>.memcpy((void*)(&struct3), *(ref <Module>.struct121_0 + 7172) + 253952, 4096U);
								this.textBox6.AppendText(string.Concat("Dumping Sector 9003E000:"));
								if (this.method_393(2375928U, 4U, 1024U, 1U) == 0)
								{
									if (<Module>.memcmp(*(ref <Module>.struct121_0 + 7172), (void*)(&struct3), 4096U) != null)
									{
										this.textBox6.AppendText("\r\n" + "Read back mis-compare, Flash Spoof ID's Failed" + "\r\n");
									}
									else
									{
										this.textBox6.AppendText("\r\n" + "Read back & compare completed, Write Verified!" + "\r\n");
										this.textBox6.AppendText("Flash Checksum Complete !" + "\r\n");
									}
								}
							}
						}
					}
				}
			}
			else if (!this.SaveTarget.Enabled)
			{
				<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
				MessageBox.Show("No Firmware is loaded to Target buffer", "Free Flash", MessageBoxButtons.OK, MessageBoxIcon.Hand);
				<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
			}
			else if (this.int_14 == 6 && this.method_382() == 0)
			{
				this.textBox6.AppendText(string.Concat("Dumping Flash:"));
				if (this.method_393(uint_, uint_2, uint_3, uint_4) == 0)
				{
					uint num3 = (uint)this.method_374(*(ref <Module>.struct121_0 + 7172));
					if (this.method_367(num3) == 0)
					{
						this.textBox6.AppendText(string.Concat("\r\n"));
						num3 = (uint)this.method_374(*(ref <Module>.struct121_0 + 7172));
						uint num15 = (uint)this.method_374(*(ref <Module>.struct121_0 + 4780));
						int num;
						if (num3 != num15)
						{
							this.textBox6.AppendText("Rev of Attached Drive and Target buffer do Not Match!" + "\r\n");
							<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
							num = (int)MessageBox.Show("Rev of Attached Drive and Target buffer do Not Match!" + "\n\n" + "Are you absolutely sure you wish to Continue ?", "Free Flash Firmware", MessageBoxButtons.YesNo, MessageBoxIcon.Question, MessageBoxDefaultButton.Button2);
							<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
							if (num == 7)
							{
								this.textBox6.AppendText("User Aborted !" + "\r\n");
								return;
							}
							this.textBox6.AppendText("Rev of Attached Drive and Target buffer are a Match!" + "\r\n");
						}
						int num16 = this.method_372(*(ref <Module>.struct121_0 + 7172), *(ref <Module>.struct121_0 + 4780), (int*)(&@struct));
						string text2 = "Sector Compare detected " + Convert.ToString(num16) + " Differences!";
						text2 += "\n\n" + "Are you sure you wish to Continue ?";
						<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
						num = (int)MessageBox.Show(text2, "Free Flash Firmware", MessageBoxButtons.YesNo, MessageBoxIcon.Question, MessageBoxDefaultButton.Button2);
						<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
						if (num == 7)
						{
							this.textBox6.AppendText("Free Flash Aborted by User !" + "\r\n");
						}
						else
						{
							Struct32 struct2;
							<Module>.memcpy((void*)(&struct2), *(ref <Module>.struct121_0 + 7172), 262144U);
							<Module>.memcpy(*(ref <Module>.struct121_0 + 7172) + 258096, (void*)(&<Module>.struct34_1), 48U);
							Struct33 struct3;
							<Module>.memcpy((void*)(&struct3), *(ref <Module>.struct121_0 + 7172) + 258048, 4096U);
							this.textBox6.AppendText("Flash Stability Test" + "\r\n");
							this.method_391(*(ref <Module>.struct121_0 + 7172), *(ref <Module>.struct121_0 + 9564), 262144);
							this.method_403(*(ref <Module>.struct121_0 + 9564), 2416177152U, 4096U);
							this.textBox6.AppendText(string.Concat("Dumping Sector 9003F000:"));
							if (this.method_393(2375932U, 4U, 1024U, 1U) == 0)
							{
								if (<Module>.memcmp(*(ref <Module>.struct121_0 + 7172), (void*)(&struct3), 4096U) != null)
								{
									this.textBox6.AppendText("\r\n" + "Read back mis-compare, Restore Aborted" + "\r\n");
								}
								else
								{
									this.textBox6.AppendText("\r\n" + "Read back & compare completed, Flashing Stable!" + "\r\n");
									this.textBox6.AppendText("Repairing Test Sector." + "\r\n");
									<Module>.memcpy(*(ref <Module>.struct121_0 + 7172), (void*)(&struct2), 262144U);
									this.method_391(*(ref <Module>.struct121_0 + 7172), *(ref <Module>.struct121_0 + 9564), 262144);
									this.method_403(*(ref <Module>.struct121_0 + 9564), 2416177152U, 4096U);
									this.textBox6.AppendText("Done !" + "\r\n");
									if (!this.bool_2)
									{
										<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
										num = (int)MessageBox.Show("Flashing stabilty test reports stable." + "\n\n" + "Do you wish to Continue ?", "Restore Firmware", MessageBoxButtons.YesNo, MessageBoxIcon.Question, MessageBoxDefaultButton.Button2);
										<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
										if (num == 7)
										{
											this.textBox6.AppendText("Free Flash Aborted by User !" + "\r\n");
											return;
										}
									}
									this.method_391(*(ref <Module>.struct121_0 + 4780), *(ref <Module>.struct121_0 + 9564), 262144);
									for (int i = 0; i < num16; i++)
									{
										this.method_403(*(ref <Module>.struct121_0 + 9564), (uint)(*(ref @struct + i * 4)), 4096U);
									}
									this.textBox6.AppendText("Done !" + "\r\n");
									this.textBox6.AppendText("Write verify test.." + "\r\n");
									this.textBox6.AppendText(string.Concat("Dumping Flash:"));
									if (this.method_393(uint_, uint_2, uint_3, uint_4) == 0)
									{
										<Module>.memcpy(*(ref <Module>.struct121_0 + 4780) + 16384, *(ref <Module>.struct121_0 + 7172) + 16384, 4096U);
										if (<Module>.memcmp(*(ref <Module>.struct121_0 + 7172), *(ref <Module>.struct121_0 + 4780), 262144U) != null)
										{
											this.textBox6.AppendText("\r\n" + "Read back mis-compare, Flash process has errors" + "\r\n");
										}
										else
										{
											this.textBox6.AppendText("\r\n" + "Read back & compare completed, Write Verified!" + "\r\n");
											this.textBox6.AppendText("Flash Complete !" + "\r\n");
										}
									}
								}
							}
						}
					}
				}
			}
		}

		// Token: 0x060003A8 RID: 936 RVA: 0x0014C660 File Offset: 0x0014C660
		private unsafe int method_365(uint uint_0, uint uint_1)
		{
			string text = null;
			string[] commandLineArgs = Environment.GetCommandLineArgs();
			text = Path.GetDirectoryName(commandLineArgs[0]);
			string strB;
			if (uint_0 == 789421430U & uint_1 == 209244429U)
			{
				this.textBox6.AppendText("\r\n" + "Drive is Stock, rev 0032" + "\r\n");
				text += "\\firmware\\LTPlus-32-2.0.bin";
				strB = "b0967f0c91d94983bdc491b584376164";
			}
			else if (uint_0 == 529584510U & uint_1 == 269849813U)
			{
				this.textBox6.AppendText("\r\n" + "Drive is Stock, rev 0036" + "\r\n");
				text += "\\firmware\\LTPlus-36-2.0.bin";
				strB = "a7417f533673b4378d5899aa2703f80e";
			}
			else if (uint_0 == 1731285449U & uint_1 == 564514654U)
			{
				this.textBox6.AppendText("\r\n" + "Drive is Stock, rev 0040" + "\r\n");
				text += "\\firmware\\LTPlus-40-2.0.bin";
				strB = "dbc02297fe8416c10d722e8febef3529";
			}
			else if (uint_0 == 4236510092U & uint_1 == 3746272492U)
			{
				this.textBox6.AppendText("\r\n" + "Drive is Stock, rev 0046" + "\r\n");
				text += "\\firmware\\LTPlus-46-2.0.bin";
				strB = "7b4277d66791adefca382dda7776c3fb";
			}
			else if (uint_0 == 17588177U & uint_1 == 862461110U)
			{
				this.textBox6.AppendText("\r\n" + "Drive is Stock, rev 0047" + "\r\n");
				text += "\\firmware\\LTPlus-47-2.0.bin";
				strB = "d0aa72da4a0663ba90dcd464ba70417f";
			}
			else if (uint_0 == 2999884414U & uint_1 == 2132095234U)
			{
				this.textBox6.AppendText("\r\n" + "Drive is Stock, rev 0058" + "\r\n");
				text += "\\firmware\\LTPlus-58-2.0.bin";
				strB = "3a5b12f9570dea10d5fcceab8f866777";
			}
			else if (uint_0 == 253026502U & uint_1 == 1729595577U)
			{
				this.textBox6.AppendText("\r\n" + "Drive is Stock, rev 0059" + "\r\n");
				text += "\\firmware\\LTPlus-59-2.0.bin";
				strB = "eddd064142a0fc770bc6077e49de9791";
			}
			else if (uint_0 == 771127765U & uint_1 == 3665783978U)
			{
				this.textBox6.AppendText("\r\n" + "Drive is Stock, rev 0078" + "\r\n");
				text += "\\firmware\\LTPlus-78-4b00-3.0.bin";
				strB = "8def3de4f7b43c49d5e2c70bbd7ca02f";
			}
			else if (uint_0 == 2680630850U & uint_1 == 372531126U)
			{
				this.textBox6.AppendText("\r\n" + "Drive is Stock, rev 0078" + "\r\n");
				text += "\\firmware\\LTPlus-78-4c30-3.0.bin";
				strB = "234f01b84a4c1114082e94ebacf856d5";
			}
			else if (uint_0 == 3231213612U & uint_1 == 623629642U)
			{
				this.textBox6.AppendText("\r\n" + "Drive is Stock, rev 0078" + "\r\n");
				text += "\\firmware\\LTPlus-78-4d20-3.0.bin";
				strB = "56633315e7ad292781dde92b9502682c";
			}
			else if (uint_0 == 1482142839U & uint_1 == 1838511619U)
			{
				this.textBox6.AppendText("\r\n" + "Drive is Stock, rev 0078" + "\r\n");
				text += "\\firmware\\LTPlus-78-4e10-3.0.bin";
				strB = "5851cf7254417842aa99e8fbdf741a29";
			}
			else if (uint_0 == 2691219462U & uint_1 == 1702627297U)
			{
				this.textBox6.AppendText("\r\n" + "Drive is Stock, rev 0079" + "\r\n");
				text += "\\firmware\\LTPlus-79-4b00-3.0.bin";
				strB = "ca7d8743b2574f99121791ee3e09d3ed";
			}
			else if (uint_0 == 811045522U & uint_1 == 646507808U)
			{
				this.textBox6.AppendText("\r\n" + "LTPlus is Stock, rev 0079" + "\r\n");
				text += "\\firmware\\LTPlus-79-4c30-3.0.bin";
				strB = "ba28a150680f636fbde8e493def1a51c";
			}
			else if (uint_0 == 1009034336U & uint_1 == 2894005260U)
			{
				this.textBox6.AppendText("\r\n" + "Drive is Stock, rev 0079" + "\r\n");
				text += "\\firmware\\LTPlus-79-4d20-3.0.bin";
				strB = "a10b48a812341119e1b7b926151ce3d1";
			}
			else if (uint_0 == 3402234535U & uint_1 == 55405718U)
			{
				this.textBox6.AppendText("\r\n" + "Drive is Stock, rev 0079" + "\r\n");
				text += "\\firmware\\LTPlus-79-4e10-3.0.bin";
				strB = "f746451ff81bbf8546449223f9e88a10";
			}
			else
			{
				if (uint_0 == 789421430U & uint_1 != 209244429U)
				{
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					MessageBox.Show("Drive is Non-Stock rev 0032 But Master Checksum is not Set" + "\n" + "Use Fix Checksum to set Master Checksum, then" + "\n" + "Use Restore Firmware to Restore to Stock!", "Non-Stock f/w", MessageBoxButtons.OK, MessageBoxIcon.Asterisk);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
					return 1;
				}
				if (uint_0 == 529584510U & uint_1 != 269849813U)
				{
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					MessageBox.Show("Drive is Non-Stock rev 0036 But Master Checksum is not Set" + "\n" + "Use Fix Checksum to set Master Checksum, then" + "\n" + "Use Restore Firmware to Restore to Stock!", "Non-Stock f/w", MessageBoxButtons.OK, MessageBoxIcon.Asterisk);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
					return 1;
				}
				if (uint_0 == 1731285449U & uint_1 != 564514654U)
				{
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					MessageBox.Show("Drive is Non-Stock rev 0036 But Master Checksum is not Set" + "\n" + "Use Fix Checksum to set Master Checksum, then" + "\n" + "Use Restore Firmware to Restore to Stock!", "Non-Stock f/w", MessageBoxButtons.OK, MessageBoxIcon.Asterisk);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
					return 1;
				}
				if (uint_0 == 4236510092U & uint_1 != 3746272492U)
				{
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					MessageBox.Show("Drive is Non-Stock rev 0040 But Master Checksum is not Set" + "\n" + "Use Fix Checksum to set Master Checksum, then" + "\n" + "Use Restore Firmware to Restore to Stock!", "Non-Stock f/w", MessageBoxButtons.OK, MessageBoxIcon.Asterisk);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
					return 1;
				}
				if (uint_0 == 17588177U & uint_1 != 862461110U)
				{
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					MessageBox.Show("Drive is Non-Stock rev 0047 But Master Checksum is not Set" + "\n" + "Use Fix Checksum to set Master Checksum, then" + "\n" + "Use Restore Firmware to Restore to Stock!", "Non-Stock f/w", MessageBoxButtons.OK, MessageBoxIcon.Asterisk);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
					return 1;
				}
				if (uint_0 == 2999884414U & uint_1 != 2132095234U)
				{
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					MessageBox.Show("Drive is Non-Stock rev 0058 But Master Checksum is not Set" + "\n" + "Use Fix Checksum to set Master Checksum, then" + "\n" + "Use Restore Firmware to Restore to Stock!", "Non-Stock f/w", MessageBoxButtons.OK, MessageBoxIcon.Asterisk);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
					return 1;
				}
				if (uint_0 == 253026502U & uint_1 != 1729595577U)
				{
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					MessageBox.Show("Drive is Non-Stock rev 0059 But Master Checksum is not Set" + "\n" + "Use Fix Checksum to set Master Checksum, then" + "\n" + "Use Restore Firmware to Restore to Stock!", "Non-Stock f/w", MessageBoxButtons.OK, MessageBoxIcon.Asterisk);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
					return 1;
				}
				if (uint_0 == 771127765U & uint_1 != 3665783978U)
				{
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					MessageBox.Show("Drive is Non-Stock rev 0078 But Master Checksum is not Set" + "\n" + "Use Fix Checksum to set Master Checksum, then" + "\n" + "Use Restore Firmware to Restore to Stock!", "Non-Stock f/w", MessageBoxButtons.OK, MessageBoxIcon.Asterisk);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
					return 1;
				}
				if (uint_0 == 2680630850U & uint_1 != 372531126U)
				{
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					MessageBox.Show("Drive is Non-Stock rev 0078 But Master Checksum is not Set" + "\n" + "Use Fix Checksum to set Master Checksum, then" + "\n" + "Use Restore Firmware to Restore to Stock!", "Non-Stock f/w", MessageBoxButtons.OK, MessageBoxIcon.Asterisk);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
					return 1;
				}
				if (uint_0 == 3231213612U & uint_1 != 623629642U)
				{
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					MessageBox.Show("Drive is Non-Stock rev 0078 But Master Checksum is not Set" + "\n" + "Use Fix Checksum to set Master Checksum, then" + "\n" + "Use Restore Firmware to Restore to Stock!", "Non-Stock f/w", MessageBoxButtons.OK, MessageBoxIcon.Asterisk);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
					return 1;
				}
				if (uint_0 == 1482142839U & uint_1 != 1838511619U)
				{
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					MessageBox.Show("Drive is Non-Stock rev 0078 But Master Checksum is not Set" + "\n" + "Use Fix Checksum to set Master Checksum, then" + "\n" + "Use Restore Firmware to Restore to Stock!", "Non-Stock f/w", MessageBoxButtons.OK, MessageBoxIcon.Asterisk);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
					return 1;
				}
				if (uint_0 == 2691219462U & uint_1 != 1702627297U)
				{
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					MessageBox.Show("Drive is Non-Stock rev 0079 But Master Checksum is not Set" + "\n" + "Use Fix Checksum to set Master Checksum, then" + "\n" + "Use Restore Firmware to Restore to Stock!", "Non-Stock f/w", MessageBoxButtons.OK, MessageBoxIcon.Asterisk);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
					return 1;
				}
				if (uint_0 == 811045522U & uint_1 != 646507808U)
				{
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					MessageBox.Show("Drive is Non-Stock rev 0079 But Master Checksum is not Set" + "\n" + "Use Fix Checksum to set Master Checksum, then" + "\n" + "Use Restore Firmware to Restore to Stock!", "Non-Stock f/w", MessageBoxButtons.OK, MessageBoxIcon.Asterisk);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
					return 1;
				}
				if (uint_0 == 1009034336U & uint_1 != 2894005260U)
				{
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					MessageBox.Show("Drive is Non-Stock rev 0079 But Master Checksum is not Set" + "\n" + "Use Fix Checksum to set Master Checksum, then" + "\n" + "Use Restore Firmware to Restore to Stock!", "Non-Stock f/w", MessageBoxButtons.OK, MessageBoxIcon.Asterisk);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
					return 1;
				}
				if (uint_0 == 3402234535U & uint_1 != 55405718U)
				{
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					MessageBox.Show("Drive is Non-Stock rev 0079 But Master Checksum is not Set" + "\n" + "Use Fix Checksum to set Master Checksum, then" + "\n" + "Use Restore Firmware to Restore to Stock!", "Non-Stock f/w", MessageBoxButtons.OK, MessageBoxIcon.Asterisk);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
					return 1;
				}
				return 1;
			}
			IntPtr intPtr = Marshal.StringToHGlobalAnsi(text);
			IntPtr value = intPtr;
			sbyte* pSbyte_ = (sbyte*)((void*)value);
			int result;
			if (<Module>.fopen((sbyte*)pSbyte_, (sbyte*)(&<Module>.struct18_4)) == null)
			{
				<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
				MessageBox.Show("Can't open file" + " " + text, "Auto-Load LT-Plus", MessageBoxButtons.OK);
				<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
				result = 1;
			}
			else
			{
				GStruct93 gstruct;
				<Module>.smethod_111(ref gstruct);
				int result2;
				try
				{
					GStruct19 gstruct2;
					GStruct19* pGstruct19_ = <Module>.smethod_91(ref gstruct2, (sbyte*)pSbyte_);
					GStruct19 gstruct3;
					<Module>.smethod_114(ref gstruct, &gstruct3, (GStruct19*)pGstruct19_);
					try
					{
						string strA = new string(<Module>.smethod_94(ref gstruct3));
						if (string.Compare(strA, strB) == 0)
						{
							goto IL_58A;
						}
						<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
						MessageBox.Show("LT-Plus file failed MD5 hash check!", "Flash LT-Plus", MessageBoxButtons.OK);
						<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
						result2 = 1;
					}
					catch
					{
						<Module>.__CxxCallUnwindDtor(<Module>.ppInt_14, (void*)(&gstruct3));
						throw;
					}
					<Module>.smethod_92(ref gstruct3);
				}
				catch
				{
					<Module>.__CxxCallUnwindDtor(<Module>.ppInt_13, (void*)(&gstruct));
					throw;
				}
				<Module>.smethod_112(ref gstruct);
				return result2;
				int num;
				try
				{
					GStruct19 gstruct3;
					try
					{
						IL_58A:
						this.textBox6.AppendText(string.Concat("Auto-"));
						this.method_36(text, 1);
						num = 0;
					}
					catch
					{
						<Module>.__CxxCallUnwindDtor(<Module>.ppInt_14, (void*)(&gstruct3));
						throw;
					}
					<Module>.smethod_92(ref gstruct3);
				}
				catch
				{
					<Module>.__CxxCallUnwindDtor(<Module>.ppInt_13, (void*)(&gstruct));
					throw;
				}
				<Module>.smethod_112(ref gstruct);
				result = num;
			}
			return result;
		}

		// Token: 0x060003A9 RID: 937 RVA: 0x0014D3A0 File Offset: 0x0014D3A0
		private unsafe int method_366(uint uint_0)
		{
			string text = null;
			string[] commandLineArgs = Environment.GetCommandLineArgs();
			text = Path.GetDirectoryName(commandLineArgs[0]);
			string strB;
			if (uint_0 == 789421430U)
			{
				this.textBox6.AppendText("\r\n" + "Drive is rev 0032" + "\r\n");
				text += "\\firmware\\orig32.bin";
				strB = "058074454a168a18129d44c4b504ae51";
			}
			else if (uint_0 == 529584510U)
			{
				this.textBox6.AppendText("\r\n" + "Drive is rev 0036" + "\r\n");
				text += "\\firmware\\orig36.bin";
				strB = "0de3e5f4a183ccad27b88c484770511e";
			}
			else if (uint_0 == 1731285449U)
			{
				this.textBox6.AppendText("\r\n" + "Drive is rev 0040" + "\r\n");
				text += "\\firmware\\orig40.bin";
				strB = "c7ed7f4594262037abfc1dafd2319e02";
			}
			else if (uint_0 == 4236510092U)
			{
				this.textBox6.AppendText("\r\n" + "Drive is rev 0046" + "\r\n");
				text += "\\firmware\\orig46.bin";
				strB = "8d6a1b95ca4ec5862be291446264aae7";
			}
			else if (uint_0 == 17588177U)
			{
				this.textBox6.AppendText("\r\n" + "Drive is rev 0047" + "\r\n");
				text += "\\firmware\\orig47.bin";
				strB = "a784664c1e38cb928014c60aa0ddbf9e";
			}
			else if (uint_0 == 2999884414U)
			{
				this.textBox6.AppendText("\r\n" + "Drive is rev 0058" + "\r\n");
				text += "\\firmware\\orig58.bin";
				strB = "6c4fb9606c3594e061b09cb90629c149";
			}
			else if (uint_0 == 253026502U)
			{
				this.textBox6.AppendText("\r\n" + "Drive is rev 0059" + "\r\n");
				text += "\\firmware\\orig59.bin";
				strB = "8788995e164450f026f7bc0ac828e353";
			}
			else if (uint_0 == 771127765U)
			{
				this.textBox6.AppendText("\r\n" + "Drive is rev 0078-4B00" + "\r\n");
				text += "\\firmware\\orig78-4b00.bin";
				strB = "8b77fdc3478e8491da7b84a5225fd5d3";
			}
			else if (uint_0 == 2680630850U)
			{
				this.textBox6.AppendText("\r\n" + "Drive is rev 0078-4C30" + "\r\n");
				text += "\\firmware\\orig78-4c30.bin";
				strB = "35cf4723847cdcb3e0fec8ec983058b5";
			}
			else if (uint_0 == 3231213612U)
			{
				this.textBox6.AppendText("\r\n" + "Drive is rev 0078-4D20" + "\r\n");
				text += "\\firmware\\orig78-4d20.bin";
				strB = "ec14386c45bcb8f2915a122c0b84ca73";
			}
			else if (uint_0 == 1482142839U)
			{
				this.textBox6.AppendText("\r\n" + "Drive is rev 0078-4E10" + "\r\n");
				text += "\\firmware\\orig78-4e10.bin";
				strB = "7446249cfbd63642632e2481e0dc7b7d";
			}
			else if (uint_0 == 2691219462U)
			{
				this.textBox6.AppendText("\r\n" + "Drive is rev 0079-4B00" + "\r\n");
				text += "\\firmware\\orig79-4b00.bin";
				strB = "bb08e540dcabb44cb15551d10e6a4b03";
			}
			else if (uint_0 == 811045522U)
			{
				this.textBox6.AppendText("\r\n" + "Drive is rev 0079-4C30" + "\r\n");
				text += "\\firmware\\orig79-4c30.bin";
				strB = "53f8bb9c57b2e1f3d643adfe6fa3ff30";
			}
			else if (uint_0 == 1009034336U)
			{
				this.textBox6.AppendText("\r\n" + "Drive is rev 0079-4D20" + "\r\n");
				text += "\\firmware\\orig79-4d20.bin";
				strB = "df7bcaa6c29063e3da95800d7694d5d9";
			}
			else
			{
				if (uint_0 != 3402234535U)
				{
					this.textBox6.AppendText("\r\n" + "Drive rev undetermined, Aborting!" + "\r\n");
					return 1;
				}
				this.textBox6.AppendText("\r\n" + "Drive is rev 0079-4E10" + "\r\n");
				text += "\\firmware\\orig79-4e10.bin";
				strB = "a61fa8b34dfe21531d1428346d68149d";
			}
			IntPtr intPtr = Marshal.StringToHGlobalAnsi(text);
			IntPtr value = intPtr;
			sbyte* pSbyte_ = (sbyte*)((void*)value);
			int result;
			if (<Module>.fopen((sbyte*)pSbyte_, (sbyte*)(&<Module>.struct18_4)) == null)
			{
				<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
				MessageBox.Show("Can't open file" + " " + text, "Auto-Load Stock f/w", MessageBoxButtons.OK);
				<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
				result = 1;
			}
			else
			{
				GStruct93 gstruct;
				<Module>.smethod_111(ref gstruct);
				int result2;
				try
				{
					GStruct19 gstruct2;
					GStruct19* pGstruct19_ = <Module>.smethod_91(ref gstruct2, (sbyte*)pSbyte_);
					GStruct19 gstruct3;
					<Module>.smethod_114(ref gstruct, &gstruct3, (GStruct19*)pGstruct19_);
					try
					{
						string strA = new string(<Module>.smethod_94(ref gstruct3));
						if (string.Compare(strA, strB) == 0)
						{
							goto IL_4DF;
						}
						<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
						MessageBox.Show("Orig bin file failed MD5 hash check!", "Restore Firmware", MessageBoxButtons.OK);
						<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
						result2 = 1;
					}
					catch
					{
						<Module>.__CxxCallUnwindDtor(<Module>.ppInt_14, (void*)(&gstruct3));
						throw;
					}
					<Module>.smethod_92(ref gstruct3);
				}
				catch
				{
					<Module>.__CxxCallUnwindDtor(<Module>.ppInt_13, (void*)(&gstruct));
					throw;
				}
				<Module>.smethod_112(ref gstruct);
				return result2;
				int num;
				try
				{
					GStruct19 gstruct3;
					try
					{
						IL_4DF:
						this.textBox6.AppendText(string.Concat("Auto-"));
						this.method_36(text, 1);
						num = 0;
					}
					catch
					{
						<Module>.__CxxCallUnwindDtor(<Module>.ppInt_14, (void*)(&gstruct3));
						throw;
					}
					<Module>.smethod_92(ref gstruct3);
				}
				catch
				{
					<Module>.__CxxCallUnwindDtor(<Module>.ppInt_13, (void*)(&gstruct));
					throw;
				}
				<Module>.smethod_112(ref gstruct);
				result = num;
			}
			return result;
		}

		// Token: 0x060003AA RID: 938 RVA: 0x0014D968 File Offset: 0x0014D968
		private int method_367(uint uint_0)
		{
			string[] commandLineArgs = Environment.GetCommandLineArgs();
			Path.GetDirectoryName(commandLineArgs[0]);
			if (uint_0 == 789421430U)
			{
				this.textBox6.AppendText("\r\n" + "Drive is rev 0032" + "\r\n");
			}
			else if (uint_0 == 529584510U)
			{
				this.textBox6.AppendText("\r\n" + "Drive is rev 0036" + "\r\n");
			}
			else if (uint_0 == 1731285449U)
			{
				this.textBox6.AppendText("\r\n" + "Drive is rev 0040" + "\r\n");
			}
			else if (uint_0 == 4236510092U)
			{
				this.textBox6.AppendText("\r\n" + "Drive is rev 0046" + "\r\n");
			}
			else if (uint_0 == 17588177U)
			{
				this.textBox6.AppendText("\r\n" + "Drive is rev 0047" + "\r\n");
			}
			else if (uint_0 == 2999884414U)
			{
				this.textBox6.AppendText("\r\n" + "Drive is rev 0058" + "\r\n");
			}
			else if (uint_0 == 253026502U)
			{
				this.textBox6.AppendText("\r\n" + "Drive is rev 0059" + "\r\n");
			}
			else if (uint_0 == 771127765U)
			{
				this.textBox6.AppendText("\r\n" + "Drive is rev 0078-4B00" + "\r\n");
			}
			else if (uint_0 == 2680630850U)
			{
				this.textBox6.AppendText("\r\n" + "Drive is rev 0078-4C30" + "\r\n");
			}
			else if (uint_0 == 3231213612U)
			{
				this.textBox6.AppendText("\r\n" + "Drive is rev 0078-4D20" + "\r\n");
			}
			else if (uint_0 == 1482142839U)
			{
				this.textBox6.AppendText("\r\n" + "Drive is rev 0078-4E10" + "\r\n");
			}
			else if (uint_0 == 2691219462U)
			{
				this.textBox6.AppendText("\r\n" + "Drive is rev 0079-4B00" + "\r\n");
			}
			else if (uint_0 == 811045522U)
			{
				this.textBox6.AppendText("\r\n" + "Drive is rev 0079-4C30" + "\r\n");
			}
			else if (uint_0 == 1009034336U)
			{
				this.textBox6.AppendText("\r\n" + "Drive is rev 0079-4D20" + "\r\n");
			}
			else
			{
				if (uint_0 != 3402234535U)
				{
					this.textBox6.AppendText("\r\n" + "Drive rev undetermined, Aborting!" + "\r\n");
					return 1;
				}
				this.textBox6.AppendText("\r\n" + "Drive is rev 0079-4E10" + "\r\n");
			}
			return 0;
		}

		// Token: 0x060003AB RID: 939 RVA: 0x0014DC44 File Offset: 0x0014DC44
		private void method_368(uint uint_0)
		{
			if (uint_0 == 789421430U | uint_0 == 1731285449U)
			{
				this.radioButton1.Checked = true;
			}
			else if (uint_0 == 529584510U)
			{
				this.radioButton2.Checked = true;
			}
			else if (uint_0 == 4236510092U | uint_0 == 17588177U)
			{
				this.radioButton3.Checked = true;
			}
			else if (uint_0 == 2999884414U | uint_0 == 253026502U)
			{
				this.radioButton4.Checked = true;
			}
			else if (uint_0 == 771127765U | uint_0 == 2680630850U | uint_0 == 3231213612U | uint_0 == 1482142839U | uint_0 == 2691219462U | uint_0 == 811045522U | uint_0 == 1009034336U | uint_0 == 3402234535U)
			{
				this.radioButton5.Checked = true;
			}
		}

		// Token: 0x060003AC RID: 940 RVA: 0x0014DD28 File Offset: 0x0014DD28
		private unsafe int method_369(byte* pByte_0, byte* pByte_1, int* pInt_0)
		{
			int num = 0;
			this.listBox5.Items.Clear();
			if (this.method_375(pByte_0, pByte_1, 253952U) != 0)
			{
				pInt_0[num] = -1878794240;
				num++;
			}
			for (int i = 0; i < 262144; i += 4096)
			{
				if (!(i == 16384 | i == 253952) && this.method_375(pByte_0, pByte_1, (uint)i) != 0)
				{
					pInt_0[num] = i + -1879048192;
					num++;
				}
			}
			this.textBox6.AppendText(Convert.ToString(num) + " Sector Differences Found" + "\r\n");
			for (int i = 0; i < num; i++)
			{
				Struct63 @struct;
				*(ref @struct + 3) = (byte)(pInt_0[i] & 255);
				*(ref @struct + 2) = (byte)((pInt_0[i] & 65280) >> 8);
				*(ref @struct + 1) = (byte)((pInt_0[i] & 16711680) >> 16);
				@struct = (uint)(pInt_0[i] & -16777216) >> 24;
				this.listBox5.Items.Add(this.method_171((byte*)(&@struct), 4U, 0U));
			}
			Application.DoEvents();
			return num;
		}

		// Token: 0x060003AD RID: 941 RVA: 0x0014DE48 File Offset: 0x0014DE48
		private unsafe int method_370(byte* pByte_0, byte* pByte_1, int* pInt_0)
		{
			int num = 0;
			this.listBox5.Items.Clear();
			for (int i = 0; i < 262144; i += 4096)
			{
				if (this.method_375(pByte_0, pByte_1, (uint)i) != 0)
				{
					pInt_0[num] = i + -1879048192;
					num++;
				}
			}
			this.textBox6.AppendText(Convert.ToString(num) + " Sector Differences Found" + "\r\n");
			for (int i = 0; i < num; i++)
			{
				Struct63 @struct;
				*(ref @struct + 3) = (byte)(pInt_0[i] & 255);
				*(ref @struct + 2) = (byte)((pInt_0[i] & 65280) >> 8);
				*(ref @struct + 1) = (byte)((pInt_0[i] & 16711680) >> 16);
				@struct = (uint)(pInt_0[i] & -16777216) >> 24;
				this.listBox5.Items.Add(this.method_171((byte*)(&@struct), 4U, 0U));
			}
			Application.DoEvents();
			return num;
		}

		// Token: 0x060003AE RID: 942 RVA: 0x0014DF34 File Offset: 0x0014DF34
		private unsafe int method_371(byte* pByte_0, byte* pByte_1, int* pInt_0)
		{
			int num = 0;
			this.listBox5.Items.Clear();
			for (int i = 24576; i < 262144; i += 4096)
			{
				if (!(i == 118784 | i == 147456 | i == 151552 | i == 258048) && this.method_375(pByte_0, pByte_1, (uint)i) != 0)
				{
					pInt_0[num] = i + -1879048192;
					num++;
				}
			}
			if (this.method_375(pByte_0, pByte_1, 12288U) != 0)
			{
				pInt_0[num] = -1879035904;
				num++;
			}
			if (this.method_375(pByte_0, pByte_1, 118784U) != 0)
			{
				pInt_0[num] = -1878929408;
				num++;
			}
			if (this.method_375(pByte_0, pByte_1, 147456U) != 0)
			{
				pInt_0[num] = -1878900736;
				num++;
			}
			if (this.method_375(pByte_0, pByte_1, 151552U) != 0)
			{
				pInt_0[num] = -1878896640;
				num++;
			}
			if (this.method_375(pByte_0, pByte_1, 258048U) != 0)
			{
				pInt_0[num] = -1878790144;
				num++;
			}
			if (this.method_375(pByte_0, pByte_1, 20480U) != 0)
			{
				pInt_0[num] = -1879027712;
				num++;
			}
			this.textBox6.AppendText(Convert.ToString(num) + " Sector Differences Found" + "\r\n");
			for (int i = 0; i < num; i++)
			{
				Struct63 @struct;
				*(ref @struct + 3) = (byte)(pInt_0[i] & 255);
				*(ref @struct + 2) = (byte)((pInt_0[i] & 65280) >> 8);
				*(ref @struct + 1) = (byte)((pInt_0[i] & 16711680) >> 16);
				@struct = (uint)(pInt_0[i] & -16777216) >> 24;
				this.listBox5.Items.Add(this.method_171((byte*)(&@struct), 4U, 0U));
			}
			Application.DoEvents();
			return num;
		}

		// Token: 0x060003AF RID: 943 RVA: 0x0014E100 File Offset: 0x0014E100
		private unsafe int method_372(byte* pByte_0, byte* pByte_1, int* pInt_0)
		{
			int num = 0;
			this.listBox5.Items.Clear();
			for (int i = 0; i < 262144; i += 4096)
			{
				if (i == 16384)
				{
					if (this.method_375(pByte_0, pByte_1, (uint)i) != 0)
					{
						<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
						int num2 = (int)MessageBox.Show(new string((sbyte*)(&<Module>.struct114_0)), "Free Flash Firmware", MessageBoxButtons.YesNo, MessageBoxIcon.Question, MessageBoxDefaultButton.Button2);
						<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
						if (num2 == 6)
						{
							pInt_0[num] = i + -1879048192;
							num++;
						}
					}
				}
				else if (this.method_375(pByte_0, pByte_1, (uint)i) != 0)
				{
					pInt_0[num] = i + -1879048192;
					num++;
				}
			}
			this.textBox6.AppendText(Convert.ToString(num) + " Sector Differences Found" + "\r\n");
			for (int i = 0; i < num; i++)
			{
				Struct63 @struct;
				*(ref @struct + 3) = (byte)(pInt_0[i] & 255);
				*(ref @struct + 2) = (byte)((pInt_0[i] & 65280) >> 8);
				*(ref @struct + 1) = (byte)((pInt_0[i] & 16711680) >> 16);
				@struct = (uint)(pInt_0[i] & -16777216) >> 24;
				this.listBox5.Items.Add(this.method_171((byte*)(&@struct), 4U, 0U));
			}
			Application.DoEvents();
			return num;
		}

		// Token: 0x060003B0 RID: 944 RVA: 0x0014E26C File Offset: 0x0014E26C
		private unsafe int method_373(byte* pByte_0)
		{
			uint num = 0U;
			uint num2 = 0U;
			for (uint num3 = 24576U; num3 < 256000U; num3 += 4U)
			{
				num2 += num;
				num = (uint)((int)pByte_0[num3 + 3U] << 24 | (int)pByte_0[num3 + 2U] << 16 | (int)pByte_0[num3 + 1U] << 8 | (int)pByte_0[num3]);
			}
			num2 = 0U - num2;
			Struct63 @struct;
			*(ref @struct + 3) = (byte)(num2 & 255U);
			*(ref @struct + 2) = (byte)((num2 & 65280U) >> 8);
			*(ref @struct + 1) = (byte)((num2 & 16711680U) >> 16);
			@struct = (num2 & 4278190080U) >> 24;
			this.textBox6.AppendText("\r\n" + "Calculated Checksum " + this.method_171((byte*)(&@struct), 4U, 0U) + "\r\n");
			*(ref @struct + 3) = pByte_0[255996];
			*(ref @struct + 2) = pByte_0[255997];
			*(ref @struct + 1) = pByte_0[255998];
			@struct = pByte_0[255999];
			this.textBox6.AppendText("Actual Checksum     " + this.method_171((byte*)(&@struct), 4U, 0U) + "\r\n");
			return (int)num2;
		}

		// Token: 0x060003B1 RID: 945 RVA: 0x0014E37C File Offset: 0x0014E37C
		private unsafe int method_374(byte* pByte_0)
		{
			uint num = 0U;
			uint num2 = 0U;
			for (uint num3 = 45056U; num3 < 110592U; num3 += 4U)
			{
				num2 += num;
				num = (uint)((int)pByte_0[num3 + 3U] << 24 | (int)pByte_0[num3 + 2U] << 16 | (int)pByte_0[num3 + 1U] << 8 | (int)pByte_0[num3]);
			}
			return (int)(0U - num2);
		}

		// Token: 0x060003B2 RID: 946 RVA: 0x0014E3D0 File Offset: 0x0014E3D0
		private unsafe int method_375(byte* pByte_0, byte* pByte_1, uint uint_0)
		{
			byte* ptr = pByte_0 + uint_0;
			byte* ptr2 = pByte_1 + uint_0;
			for (int i = 0; i < 4096; i++)
			{
				if (ptr[i] != ptr2[i])
				{
					return 1;
				}
			}
			return 0;
		}

		// Token: 0x060003B3 RID: 947 RVA: 0x0014E408 File Offset: 0x0014E408
		private void method_376()
		{
			if (this.radioButton1.Checked)
			{
				this.int_12 = 32;
				this.string_19 = "0032/0040";
			}
			else if (this.radioButton2.Checked)
			{
				this.int_12 = 36;
				this.string_19 = "0036";
			}
			else if (this.radioButton3.Checked)
			{
				this.int_12 = 47;
				this.string_19 = "0046/0047";
			}
			else if (this.radioButton4.Checked)
			{
				this.int_12 = 59;
				this.string_19 = "0058/0059";
			}
			else if (this.radioButton5.Checked)
			{
				this.int_12 = 79;
				this.string_19 = "0078/0079";
			}
			if (this.radioButton15.Checked)
			{
				this.int_13 = 0;
				this.string_20 = "Classic Ram Peek";
			}
			else if (this.radioButton14.Checked)
			{
				this.int_13 = 1;
				this.string_20 = "Ram Upload";
			}
			else if (this.radioButton13.Checked)
			{
				this.int_13 = 2;
				this.string_20 = "Mode Select";
			}
			else if (this.radioButton12.Checked)
			{
				this.int_13 = 3;
				this.string_20 = "Ram Poke";
			}
			if (this.radioButton11.Checked)
			{
				this.int_14 = 0;
				this.string_21 = "Dumping f/w of";
			}
			else if (this.radioButton6.Checked)
			{
				this.int_14 = 1;
				this.string_21 = "Flashing Keys to";
			}
			else if (this.radioButton7.Checked)
			{
				this.int_14 = 2;
				this.string_21 = "Flashing Spoof ID's to";
			}
			else if (this.radioButton8.Checked)
			{
				this.int_14 = 3;
				this.string_21 = "Flashing Hacked f/w to";
			}
			else if (this.radioButton9.Checked)
			{
				this.int_14 = 4;
				this.string_21 = "Restoring Stock f/w to";
			}
			else if (this.radioButton10.Checked)
			{
				this.int_14 = 5;
				this.string_21 = "Fixing Checksum of";
			}
			else if (this.radioButton16.Checked)
			{
				this.int_14 = 6;
				this.string_21 = "Free flashing to";
			}
			if (this.int_13 == 0 & this.int_14 == 0 & this.int_12 != 79)
			{
				this.string_19 = "Pre 78";
			}
			if (this.radioButton17.Checked)
			{
				this.int_15 = 0;
				this.string_22 = "Method via WIN32 API";
			}
			else if (this.radioButton18.Checked)
			{
				this.int_15 = 1;
				this.string_22 = "Method over Port IO";
			}
		}

		// Token: 0x060003B4 RID: 948 RVA: 0x0014E6B4 File Offset: 0x0014E6B4
		private unsafe void method_377()
		{
			Struct68 @struct = 0;
			initblk(ref @struct + 1, 0, 259);
			<Module>.memcpy(*(ref <Module>.struct121_0 + 4780) + 16384, *(ref <Module>.struct121_0 + 2388) + 16384, 4096U);
			<Module>.memcpy(*(ref <Module>.struct123_0 + 4) + 280, <Module>.struct123_0 + 280, 16U);
			<Module>.memcpy(*(ref <Module>.struct123_0 + 4) + 2028, <Module>.struct123_0 + 2028, 20U);
			string str = "";
			<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct19_0));
			for (int i = 0; i < 16; i++)
			{
				<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct10_20), ref @struct, *(*(ref <Module>.struct123_0 + 4) + 280 + i));
			}
			this.textBox11.Text = str + new string((sbyte*)(&@struct));
			this.textBox1.Text = this.textBox11.Text;
			this.method_5(*(ref <Module>.struct123_0 + 4) + 2028, 20U, 0U);
			this.textBox13.Text = this.string_0;
		}

		// Token: 0x060003B5 RID: 949 RVA: 0x0014E7E0 File Offset: 0x0014E7E0
		private void radioButton11_CheckedChanged(object sender, EventArgs e)
		{
			this.button26.Text = "Read to Source";
			this.listBox5.Items.Clear();
			this.button26.Enabled = true;
			this.method_378();
		}

		// Token: 0x060003B6 RID: 950 RVA: 0x0014E820 File Offset: 0x0014E820
		private unsafe void radioButton18_CheckedChanged(object sender, EventArgs e)
		{
			uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
			uint count = (uint)this.comboBox1.Items.Count;
			ushort num = *(ref <Module>.struct38_0 + selectedIndex * 72U);
			if (this.bool_1 && num == 0 && count != 0U)
			{
				if (this.radioButton18.Checked)
				{
					this.method_424(2);
					this.bool_9 = false;
					<Module>.Sleep(10);
				}
				else if (this.bool_5 && !this.bool_9)
				{
					this.method_424(1);
					this.bool_9 = true;
					<Module>.Sleep(10);
					this.method_424(5);
					<Module>.Sleep(25);
					this.method_424(7);
				}
			}
			<Module>.Sleep(200);
			this.method_378();
		}

		// Token: 0x060003B7 RID: 951 RVA: 0x0014E8D8 File Offset: 0x0014E8D8
		private void radioButton6_CheckedChanged(object sender, EventArgs e)
		{
			if (this.radioButton6.Checked)
			{
				this.button26.Text = "Manual Spoof";
				this.listBox5.Items.Clear();
				this.listBox5.Items.Add("Calculated at");
				this.listBox5.Items.Add("Run time.....");
				this.button26.Enabled = true;
			}
		}

		// Token: 0x060003B8 RID: 952 RVA: 0x0014E94C File Offset: 0x0014E94C
		private void radioButton7_CheckedChanged(object sender, EventArgs e)
		{
			if (this.radioButton7.Checked)
			{
				this.button26.Text = "Auto Spoof";
				this.listBox5.Items.Clear();
				this.listBox5.Items.Add("Calculated at");
				this.listBox5.Items.Add("Run time.....");
				this.button26.Enabled = true;
			}
		}

		// Token: 0x060003B9 RID: 953 RVA: 0x0014E9C0 File Offset: 0x0014E9C0
		private void radioButton8_CheckedChanged(object sender, EventArgs e)
		{
			if (this.radioButton8.Checked)
			{
				this.button26.Text = "Flash LT-Plus";
				this.listBox5.Items.Clear();
				this.listBox5.Items.Add("Calculated at");
				this.listBox5.Items.Add("Run time.....");
				this.button26.Enabled = true;
			}
		}

		// Token: 0x060003BA RID: 954 RVA: 0x0014EA34 File Offset: 0x0014EA34
		private void radioButton9_CheckedChanged(object sender, EventArgs e)
		{
			if (this.radioButton9.Checked)
			{
				this.button26.Text = "Restore to Stock";
				this.listBox5.Items.Clear();
				this.listBox5.Items.Add("Calculated at");
				this.listBox5.Items.Add("Run time.....");
				this.button26.Enabled = true;
			}
		}

		// Token: 0x060003BB RID: 955 RVA: 0x0014EAA8 File Offset: 0x0014EAA8
		private void radioButton10_CheckedChanged(object sender, EventArgs e)
		{
			if (this.radioButton10.Checked)
			{
				this.button26.Text = "Fix Checksum";
				this.listBox5.Items.Clear();
				this.listBox5.Items.Add("0x9003E000");
				this.button26.Enabled = true;
			}
		}

		// Token: 0x060003BC RID: 956 RVA: 0x0014EB08 File Offset: 0x0014EB08
		private void radioButton16_CheckedChanged(object sender, EventArgs e)
		{
			if (this.radioButton16.Checked)
			{
				this.button26.Text = "Free Flash";
				this.listBox5.Items.Clear();
				this.listBox5.Items.Add("Calculated at");
				this.listBox5.Items.Add("Run time.....");
				this.button26.Enabled = true;
			}
		}

		// Token: 0x060003BD RID: 957 RVA: 0x0014EB7C File Offset: 0x0014EB7C
		private void radioButton5_CheckedChanged(object sender, EventArgs e)
		{
			this.method_378();
		}

		// Token: 0x060003BE RID: 958 RVA: 0x003CC2BC File Offset: 0x003142BC
		private void method_378()
		{
			if (this.radioButton5.Checked)
			{
				this.radioButton15.Enabled = false;
				this.radioButton14.Checked = true;
				this.radioButton13.Enabled = false;
				this.radioButton12.Enabled = false;
			}
			else if (!this.radioButton5.Checked & this.radioButton17.Checked)
			{
				if (this.radioButton11.Checked)
				{
					this.radioButton15.Enabled = true;
					if (!this.radioButton14.Checked)
					{
						this.radioButton15.Checked = true;
					}
					this.radioButton13.Enabled = true;
					if (this.radioButton16.Enabled)
					{
						this.radioButton12.Enabled = true;
					}
				}
				else
				{
					this.radioButton15.Enabled = false;
					this.radioButton14.Checked = true;
					this.radioButton13.Enabled = true;
					if (this.radioButton16.Enabled)
					{
						this.radioButton12.Enabled = true;
					}
				}
			}
			else if (!this.radioButton5.Checked & this.radioButton18.Checked)
			{
				if (this.radioButton11.Checked)
				{
					this.radioButton15.Enabled = true;
					this.radioButton14.Checked = true;
					this.radioButton13.Enabled = false;
					this.radioButton12.Enabled = false;
				}
				else
				{
					this.radioButton15.Enabled = false;
					this.radioButton14.Checked = true;
					this.radioButton13.Enabled = false;
					this.radioButton12.Enabled = false;
				}
			}
		}

		// Token: 0x060003BF RID: 959 RVA: 0x0014ED30 File Offset: 0x0014ED30
		private void checkBox1_CheckedChanged(object sender, EventArgs e)
		{
			if (this.checkBox1.CheckState == CheckState.Checked)
			{
				this.button24.Enabled = false;
				this.button12.Text = "79 Unlock";
				this.textBox6.AppendText("79 Unlock set to Automatic." + "\r\n");
			}
			else
			{
				this.button24.Enabled = true;
				this.button12.Text = "Execute";
				this.textBox6.AppendText("79 Unlock set to manual mode." + "\r\n");
			}
		}

		// Token: 0x060003C0 RID: 960 RVA: 0x0014EDBC File Offset: 0x0014EDBC
		private void button12_Click(object sender, EventArgs e)
		{
			this.method_379();
		}

		// Token: 0x060003C1 RID: 961 RVA: 0x0014EDD0 File Offset: 0x0014EDD0
		private void method_379()
		{
			if (this.checkBox1.CheckState == CheckState.Unchecked)
			{
				if (this.radioButton18.Checked)
				{
					this.method_388();
				}
				else if (this.radioButton17.Checked)
				{
					this.method_387();
				}
			}
			if (this.checkBox1.CheckState == CheckState.Checked)
			{
				if (this.radioButton18.Checked)
				{
					this.method_390();
				}
				else if (this.radioButton17.Checked)
				{
					this.method_389();
				}
			}
		}

		// Token: 0x060003C2 RID: 962 RVA: 0x0014EE4C File Offset: 0x0014EE4C
		private void button24_Click(object sender, EventArgs e)
		{
			if (this.radioButton18.Checked)
			{
				this.method_386();
			}
			else if (this.radioButton17.Checked)
			{
				this.method_385();
			}
		}

		// Token: 0x060003C3 RID: 963 RVA: 0x0014EE84 File Offset: 0x0014EE84
		private unsafe void method_380()
		{
			if (this.comboBox16.Items.Count == 0)
			{
				<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
				MessageBox.Show("No drive Selected", "Warning", MessageBoxButtons.OK, MessageBoxIcon.Hand);
				<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
			}
			else
			{
				Struct108 @struct;
				byte* ptr = ref @struct + 44;
				IntPtr intPtr = Marshal.StringToHGlobalAnsi(this.comboBox16.Text);
				IntPtr value = intPtr;
				sbyte* ptr2 = (sbyte*)((void*)value);
				if (!(*(sbyte*)ptr2 < 65 | *(sbyte*)ptr2 > 122))
				{
					Struct109 struct2;
					<Module>.sprintf((sbyte*)(&struct2), (sbyte*)(&<Module>.struct22_5), *(sbyte*)ptr2);
					void* ptr3 = <Module>.CreateFileA((sbyte*)(&struct2), -1073741824, 3, null, 3, 128, null);
					if (ptr3 != -1)
					{
						<Module>.memset((void*)(&@struct), 0, 62U);
						*(ref @struct + 28) = 27;
						@struct = 44;
						*(ref @struct + 6) = 12;
						*(ref @struct + 7) = 18;
						*(ref @struct + 8) = 2;
						*(ref @struct + 16) = 15;
						*(ref @struct + 24) = 44;
						uint num;
						if (<Module>.DeviceIoControl(ptr3, 315412, (void*)(&@struct), 62, (void*)(&@struct), 62, (uint*)(&num), null) != null && (ptr[2] & 15) == 0)
						{
							this.textBox6.AppendText("Stopping the Disk - No disk is required, remove next time..." + "\r\n");
							<Module>.Sleep(7000);
						}
						<Module>.CloseHandle(ptr3);
					}
				}
			}
		}

		// Token: 0x060003C4 RID: 964 RVA: 0x0014EFD4 File Offset: 0x0014EFD4
		private unsafe void method_381()
		{
			if (this.comboBox1.Items.Count != 0)
			{
				uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
				ushort ushort_ = *(ref <Module>.struct38_0 + selectedIndex * 72U);
				uint num;
				if (*(ref <Module>.struct38_0 + selectedIndex * 72U + 4) == 160)
				{
					num = 0U;
				}
				else
				{
					num = 16U;
				}
				GStruct3 gstruct;
				<Module>.smethod_21(&gstruct, ushort_, 0, 1, 10000U);
				Struct52 @struct;
				<Module>.memset((void*)(&@struct), 0, 12U);
				@struct = 0;
				<Module>.smethod_15((byte*)(&@struct), 12U, (byte)num, 1, &gstruct);
				<Module>.memset((void*)(&@struct), 0, 12U);
				Struct41 struct2;
				<Module>.memset((void*)(&struct2), 0, 18U);
				@struct = 3;
				*(ref @struct + 4) = 18;
				uint num2;
				if (<Module>.smethod_16((byte*)(&@struct), 12U, (byte)num, 512, (void*)(&struct2), &num2, 18U, 1, &gstruct) != null)
				{
					this.textBox6.AppendText("Error Grabbing Sence Data..." + "\r\n");
				}
				else if ((*(ref struct2 + 2) & 15) == 2 && *(ref struct2 + 12) == 58 && *(ref struct2 + 13) == 0)
				{
					this.textBox6.AppendText("No Disc in Drive, proceeding." + "\r\n");
				}
				else
				{
					if ((*(ref struct2 + 2) & 15) == 2 && *(ref struct2 + 12) == 4 && *(ref struct2 + 13) == 1)
					{
						this.textBox6.AppendText("Disc in Tray - No disc is required, Ejecting, remove next time..." + "\r\n");
					}
					else if ((*(ref struct2 + 2) & 15) == 0 && *(ref struct2 + 12) == 0 && *(ref struct2 + 13) == 0)
					{
						this.textBox6.AppendText("Disc in Tray - No disc is required, Ejecting, remove next time..." + "\r\n");
					}
					else
					{
						if ((*(ref struct2 + 2) & 15) != 6 || *(ref struct2 + 12) != 40 || *(ref struct2 + 13) != 0)
						{
							return;
						}
						this.textBox6.AppendText("Unit Not ready... Ejecting" + "\r\n");
					}
					@struct = 27;
					*(ref @struct + 4) = 2;
					if (<Module>.smethod_15((byte*)(&@struct), 12U, (byte)num, 1, &gstruct) != null)
					{
						this.textBox6.AppendText("Error Sending Stop Unit Command..." + "\r\n");
					}
					else
					{
						<Module>.Sleep(2000);
					}
				}
			}
		}

		// Token: 0x060003C5 RID: 965 RVA: 0x0014F1DC File Offset: 0x0014F1DC
		private int method_382()
		{
			return (this.int_15 != 0 || this.method_383() == 0) ? ((this.int_15 != 1 || this.method_384() == 0) ? 0 : 1) : 1;
		}

		// Token: 0x060003C6 RID: 966 RVA: 0x003CC468 File Offset: 0x00314468
		private unsafe int method_383()
		{
			int result;
			if (this.comboBox16.Items.Count == 0)
			{
				<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
				MessageBox.Show("No drive Selected", "Warning", MessageBoxButtons.OK, MessageBoxIcon.Hand);
				<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
				result = 1;
			}
			else
			{
				Struct52 @struct;
				if (this.int_12 == 47)
				{
					<Module>.memcpy((void*)(&@struct), (void*)(&<Module>.struct52_0), 12U);
				}
				else
				{
					if (this.int_12 != 59)
					{
						return 0;
					}
					<Module>.memcpy((void*)(&@struct), (void*)(&<Module>.struct52_1), 12U);
				}
				this.comboBox16.Text.Substring(0, 1);
				IntPtr intPtr = Marshal.StringToHGlobalAnsi(this.comboBox16.Text);
				IntPtr value = intPtr;
				sbyte* ptr = (sbyte*)((void*)value);
				if (*(sbyte*)ptr < 65 | *(sbyte*)ptr > 122)
				{
					result = 1;
				}
				else
				{
					Struct109 struct2;
					<Module>.sprintf((sbyte*)(&struct2), (sbyte*)(&<Module>.struct22_5), *(sbyte*)ptr);
					void* ptr2 = <Module>.CreateFileA((sbyte*)(&struct2), -1073741824, 3, null, 3, 128, null);
					if (ptr2 == -1)
					{
						result = 1;
					}
					else
					{
						Struct108 struct3;
						uint num2;
						for (uint num = 0U; num < 12U; num += 1U)
						{
							<Module>.memset((void*)(&struct3), 0, 62U);
							*(ref struct3 + 28) = 231;
							*(ref struct3 + 29) = 72;
							*(ref struct3 + 30) = 73;
							*(ref struct3 + 31) = 84;
							*(ref struct3 + 32) = 204;
							*(ref struct3 + 33) = *(ref @struct + num);
							*(ref struct3 + 36) = (byte)((num + 2147483648U & 4278190080U) >> 24);
							*(ref struct3 + 37) = (byte)((num + 2147483648U & 16711680U) >> 16);
							*(ref struct3 + 38) = (byte)((num + 2147483648U & 65280U) >> 8);
							*(ref struct3 + 39) = (byte)(num + 2147483648U & 255U);
							struct3 = 44;
							*(ref struct3 + 6) = 12;
							*(ref struct3 + 7) = 18;
							*(ref struct3 + 8) = 2;
							*(ref struct3 + 16) = 15;
							*(ref struct3 + 24) = 44;
							if (<Module>.DeviceIoControl(ptr2, 315412, (void*)(&struct3), 62, (void*)(&struct3), 62, (uint*)(&num2), null) == null)
							{
								this.textBox6.AppendText("Ram Poke Failed" + "\r\n");
								<Module>.CloseHandle(ptr2);
								return 1;
							}
						}
						<Module>.memset((void*)(&struct3), 0, 62U);
						*(ref struct3 + 28) = 85;
						*(ref struct3 + 29) = 16;
						*(ref struct3 + 36) = 8;
						Struct103 struct4;
						<Module>.memset((void*)(&struct4), 0, 8U);
						*(ref struct4 + 1) = 6;
						struct3 = 44;
						*(ref struct3 + 6) = 12;
						*(ref struct3 + 7) = 18;
						*(ref struct3 + 8) = 0;
						*(ref struct3 + 12) = 8;
						*(ref struct3 + 16) = 15;
						*(ref struct3 + 20) = ref struct4;
						*(ref struct3 + 24) = 44;
						if (<Module>.DeviceIoControl(ptr2, 315412, (void*)(&struct3), 62, (void*)(&struct3), 62, (uint*)(&num2), null) == null && <Module>.DeviceIoControl(ptr2, 315412, (void*)(&struct3), 62, (void*)(&struct3), 62, (uint*)(&num2), null) == null && <Module>.DeviceIoControl(ptr2, 315412, (void*)(&struct3), 62, (void*)(&struct3), 62, (uint*)(&num2), null) == null)
						{
							this.textBox6.AppendText("Enable Execute Failed" + "\r\n");
							<Module>.CloseHandle(ptr2);
							result = 1;
						}
						else
						{
							<Module>.memset((void*)(&struct3), 0, 62U);
							*(ref struct3 + 28) = 85;
							*(ref struct3 + 29) = 16;
							*(ref struct3 + 31) = 72;
							*(ref struct3 + 32) = 76;
							*(ref struct3 + 34) = 1;
							*(ref struct3 + 39) = 1;
							struct3 = 44;
							*(ref struct3 + 6) = 12;
							*(ref struct3 + 7) = 18;
							*(ref struct3 + 8) = 2;
							*(ref struct3 + 16) = 15;
							*(ref struct3 + 24) = 44;
							if (<Module>.DeviceIoControl(ptr2, 315412, (void*)(&struct3), 62, (void*)(&struct3), 62, (uint*)(&num2), null) == null)
							{
								this.textBox6.AppendText("UnLock Failed" + "\r\n");
								<Module>.CloseHandle(ptr2);
								result = 1;
							}
							else
							{
								this.textBox6.AppendText("UnLocked!" + "\r\n");
								<Module>.CloseHandle(ptr2);
								result = 0;
							}
						}
					}
				}
			}
			return result;
		}

		// Token: 0x060003C7 RID: 967 RVA: 0x0014F5B4 File Offset: 0x0014F5B4
		private unsafe int method_384()
		{
			int result;
			if (this.comboBox1.Items.Count == 0)
			{
				result = 0;
			}
			else
			{
				uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
				ushort ushort_ = *(ref <Module>.struct38_0 + selectedIndex * 72U);
				uint num;
				if (*(ref <Module>.struct38_0 + selectedIndex * 72U + 4) == 160)
				{
					num = 0U;
				}
				else
				{
					num = 16U;
				}
				GStruct3 gstruct;
				<Module>.smethod_21(&gstruct, ushort_, 0, 1, 10000U);
				Struct52 @struct;
				if (this.int_12 == 47)
				{
					<Module>.memcpy((void*)(&@struct), (void*)(&<Module>.struct52_0), 12U);
				}
				else
				{
					if (this.int_12 != 59)
					{
						return 0;
					}
					<Module>.memcpy((void*)(&@struct), (void*)(&<Module>.struct52_1), 12U);
				}
				Struct52 struct2;
				for (uint num2 = 0U; num2 < 12U; num2 += 1U)
				{
					<Module>.memset((void*)(&struct2), 0, 12U);
					struct2 = 231;
					*(ref struct2 + 1) = 72;
					*(ref struct2 + 2) = 73;
					*(ref struct2 + 3) = 84;
					*(ref struct2 + 4) = 204;
					*(ref struct2 + 5) = *(ref @struct + num2);
					*(ref struct2 + 8) = (byte)((num2 + 2147483648U & 4278190080U) >> 24);
					*(ref struct2 + 9) = (byte)((num2 + 2147483648U & 16711680U) >> 16);
					*(ref struct2 + 10) = (byte)((num2 + 2147483648U & 65280U) >> 8);
					*(ref struct2 + 11) = (byte)(num2 + 2147483648U & 255U);
					if (<Module>.smethod_15((byte*)(&struct2), 12U, (byte)num, 1, &gstruct) != null)
					{
						this.textBox6.AppendText("Ram Poke Failed" + "\r\n");
						this.Cursor = Cursors.Arrow;
						return 1;
					}
				}
				<Module>.Sleep(100);
				<Module>.memset((void*)(&struct2), 0, 12U);
				Struct103 struct3;
				<Module>.memset((void*)(&struct3), 0, 8U);
				struct2 = 85;
				*(ref struct2 + 1) = 16;
				*(ref struct2 + 8) = 8;
				*(ref struct3 + 1) = 6;
				uint num3;
				if (<Module>.smethod_17((byte*)(&struct2), 12U, (byte)num, 512, (void*)(&struct3), &num3, 8U, 1, &gstruct) != null && <Module>.smethod_17((byte*)(&struct2), 12U, (byte)num, 512, (void*)(&struct3), &num3, 8U, 1, &gstruct) != null && <Module>.smethod_17((byte*)(&struct2), 12U, (byte)num, 512, (void*)(&struct3), &num3, 8U, 1, &gstruct) != null)
				{
					this.textBox6.AppendText("Enable Execute Failed" + "\r\n");
					this.Cursor = Cursors.Arrow;
					result = 1;
				}
				else
				{
					<Module>.Sleep(100);
					<Module>.memset((void*)(&struct2), 0, 12U);
					<Module>.memset((void*)(&struct3), 0, 8U);
					struct2 = 85;
					*(ref struct2 + 1) = 16;
					*(ref struct2 + 3) = 72;
					*(ref struct2 + 4) = 76;
					*(ref struct2 + 8) = 8;
					*(ref struct3 + 1) = 6;
					<Module>.smethod_17((byte*)(&struct2), 12U, (byte)num, 512, (void*)(&struct3), &num3, 8U, 1, &gstruct);
					this.textBox6.AppendText("UnLocked!" + "\r\n");
					<Module>.memset((void*)(&struct2), 0, 12U);
					struct2 = 85;
					if (<Module>.smethod_15((byte*)(&struct2), 12U, (byte)num, 1, &gstruct) != null && <Module>.smethod_15((byte*)(&struct2), 12U, (byte)num, 1, &gstruct) != null)
					{
						this.textBox6.AppendText("Disable Execute Failed" + "\r\n");
						this.Cursor = Cursors.Arrow;
						result = 1;
					}
					else
					{
						this.Cursor = Cursors.Arrow;
						result = 0;
					}
				}
			}
			return result;
		}

		// Token: 0x060003C8 RID: 968 RVA: 0x003CC810 File Offset: 0x00314810
		private unsafe void method_385()
		{
			if (this.comboBox16.Items.Count == 0)
			{
				<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
				MessageBox.Show("No drive Selected", "Warning", MessageBoxButtons.OK, MessageBoxIcon.Hand);
				<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
			}
			else
			{
				Struct108 @struct;
				byte* ptr = ref @struct + 44;
				IntPtr intPtr = Marshal.StringToHGlobalAnsi(this.comboBox16.Text);
				IntPtr value = intPtr;
				sbyte* ptr2 = (sbyte*)((void*)value);
				if (!(*(sbyte*)ptr2 < 65 | *(sbyte*)ptr2 > 122))
				{
					Struct109 struct2;
					<Module>.sprintf((sbyte*)(&struct2), (sbyte*)(&<Module>.struct22_5), *(sbyte*)ptr2);
					void* ptr3 = <Module>.CreateFileA((sbyte*)(&struct2), -1073741824, 3, null, 3, 128, null);
					if (ptr3 != -1)
					{
						if (string.Compare(this.button24.Text, "Play") == 0)
						{
							<Module>.memset((void*)(&@struct), 0, 62U);
							*(ref @struct + 28) = 165;
							*(ref @struct + 36) = 1;
							*(ref @struct + 37) = 43;
							@struct = 44;
							*(ref @struct + 6) = 12;
							*(ref @struct + 7) = 18;
							*(ref @struct + 8) = 2;
							*(ref @struct + 16) = 3;
							*(ref @struct + 24) = 44;
							uint num;
							if (<Module>.DeviceIoControl(ptr3, 315412, (void*)(&@struct), 62, (void*)(&@struct), 62, (uint*)(&num), null) != null && (ptr[2] & 15) == 0)
							{
								this.textBox6.AppendText("Played 79Unlock Audio CD" + "\r\n");
								this.button24.Text = "Pause";
								<Module>.CloseHandle(ptr3);
								<Module>.Sleep(200);
							}
							else
							{
								this.textBox6.AppendText("Failed to Play 79Unlock Audio CD" + "\r\n");
								<Module>.CloseHandle(ptr3);
							}
						}
						else if (string.Compare(this.button24.Text, "Pause") == 0)
						{
							<Module>.memset((void*)(&@struct), 0, 62U);
							*(ref @struct + 28) = 75;
							@struct = 44;
							*(ref @struct + 6) = 12;
							*(ref @struct + 7) = 18;
							*(ref @struct + 8) = 2;
							*(ref @struct + 16) = 3;
							*(ref @struct + 24) = 44;
							uint num;
							if (<Module>.DeviceIoControl(ptr3, 315412, (void*)(&@struct), 62, (void*)(&@struct), 62, (uint*)(&num), null) != null && (ptr[2] & 15) == 0)
							{
								this.button24.Text = "Play";
								this.textBox6.AppendText("Paused 79Unlock Audio CD" + "\r\n");
								string text = "" + "Now! You Need to Physically eject the 79Unlock CD, then, click the" + "/n";
								text = text + "'Unlock' button to execute the unlock code in Ram." + "/n/n";
								text = text + "Select the IO Port the 79 is on, click 'Open' button in Port Properties" + "/n";
								<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
								MessageBox.Show(text, "79 Unlock", MessageBoxButtons.OK, MessageBoxIcon.Asterisk);
								<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
								<Module>.CloseHandle(ptr3);
							}
							else
							{
								this.textBox6.AppendText("Failed to Pause 79Unlock Audio CD" + "\r\n");
								<Module>.CloseHandle(ptr3);
							}
						}
					}
				}
			}
		}

		// Token: 0x060003C9 RID: 969 RVA: 0x0014FBAC File Offset: 0x0014FBAC
		private unsafe void method_386()
		{
			if (this.comboBox1.Items.Count != 0)
			{
				uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
				ushort ushort_ = *(ref <Module>.struct38_0 + selectedIndex * 72U);
				uint num;
				if (*(ref <Module>.struct38_0 + selectedIndex * 72U + 4) == 160)
				{
					num = 0U;
				}
				else
				{
					num = 16U;
				}
				GStruct3 gstruct;
				<Module>.smethod_21(&gstruct, ushort_, 0, 1, 10000U);
				if (string.Compare(this.button24.Text, "Play") == 0)
				{
					Struct52 @struct;
					<Module>.memset((void*)(&@struct), 0, 12U);
					@struct = 165;
					*(ref @struct + 8) = 1;
					*(ref @struct + 9) = 43;
					if (<Module>.smethod_15((byte*)(&@struct), 12U, (byte)num, 1, &gstruct) != null)
					{
						this.textBox6.AppendText("Failed to Play 79Unlock Audio CD" + "\r\n");
					}
					else
					{
						this.textBox6.AppendText("Played 79Unlock Audio CD" + "\r\n");
						this.button24.Text = "Pause";
						<Module>.Sleep(200);
					}
				}
				else if (string.Compare(this.button24.Text, "Pause") == 0)
				{
					Struct52 @struct;
					<Module>.memset((void*)(&@struct), 0, 12U);
					@struct = 75;
					if (<Module>.smethod_15((byte*)(&@struct), 12U, (byte)num, 1, &gstruct) != null)
					{
						this.textBox6.AppendText("Failed to Pause 79Unlock Audio CD" + "\r\n");
					}
					else
					{
						this.button24.Text = "Play";
						this.textBox6.AppendText("Paused 79Unlock Audio CD" + "\r\n");
						<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
						MessageBox.Show("Now! You Need to Physically eject the 79Unlock CD, then, click the" + "\n" + "'Unlock' button to execute the unlock code in Ram." + "\n\n" + "Select the IO Port the 79 is on, click 'Open' button in Port Properties.", "79 Unlock", MessageBoxButtons.OK, MessageBoxIcon.Asterisk);
						<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
					}
				}
			}
		}

		// Token: 0x060003CA RID: 970 RVA: 0x0014FD94 File Offset: 0x0014FD94
		private unsafe void method_387()
		{
			if (this.comboBox16.Items.Count == 0)
			{
				<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
				MessageBox.Show("No drive Selected", "Warning", MessageBoxButtons.OK, MessageBoxIcon.Hand);
				<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
			}
			else
			{
				Struct108 @struct;
				byte* ptr = ref @struct + 44;
				IntPtr intPtr = Marshal.StringToHGlobalAnsi(this.comboBox16.Text);
				IntPtr value = intPtr;
				sbyte* ptr2 = (sbyte*)((void*)value);
				if (!(*(sbyte*)ptr2 < 65 | *(sbyte*)ptr2 > 122))
				{
					Struct109 struct2;
					<Module>.sprintf((sbyte*)(&struct2), (sbyte*)(&<Module>.struct22_5), *(sbyte*)ptr2);
					void* ptr3 = <Module>.CreateFileA((sbyte*)(&struct2), -1073741824, 3, null, 3, 128, null);
					if (ptr3 != -1)
					{
						this.textBox6.AppendText("\r\n" + "Sending 79 Unlock Command!" + "\r\n");
						<Module>.memset((void*)(&@struct), 0, 62U);
						*(ref @struct + 28) = 85;
						*(ref @struct + 29) = 16;
						*(ref @struct + 36) = 8;
						Struct103 struct3;
						<Module>.memset((void*)(&struct3), 0, 8U);
						*(ref struct3 + 1) = 6;
						@struct = 44;
						*(ref @struct + 6) = 12;
						*(ref @struct + 7) = 18;
						*(ref @struct + 8) = 0;
						*(ref @struct + 12) = 8;
						*(ref @struct + 16) = 15;
						*(ref @struct + 20) = ref struct3;
						*(ref @struct + 24) = 44;
						uint num;
						if (<Module>.DeviceIoControl(ptr3, 315412, (void*)(&@struct), 62, (void*)(&@struct), 62, (uint*)(&num), null) == null)
						{
							this.textBox6.AppendText("Setting bit 3 of 0x5B6 failed" + "\r\n");
							<Module>.CloseHandle(ptr3);
						}
						else
						{
							<Module>.memset((void*)(&@struct), 0, 62U);
							*(ref @struct + 28) = 231;
							*(ref @struct + 29) = 72;
							*(ref @struct + 30) = 73;
							*(ref @struct + 31) = 84;
							*(ref @struct + 32) = 59;
							*(ref @struct + 33) = 7;
							*(ref @struct + 39) = 1;
							@struct = 44;
							*(ref @struct + 6) = 12;
							*(ref @struct + 7) = 18;
							*(ref @struct + 8) = 2;
							*(ref @struct + 16) = 3;
							*(ref @struct + 24) = 44;
							if (<Module>.DeviceIoControl(ptr3, 315412, (void*)(&@struct), 62, (void*)(&@struct), 62, (uint*)(&num), null) != null && (ptr[2] & 15) == 0)
							{
								this.textBox6.AppendText("Done!" + "\r\n");
								this.Cursor = Cursors.Arrow;
								<Module>.CloseHandle(ptr3);
							}
							else
							{
								this.textBox6.AppendText("Ram Execucte command failed" + "\r\n");
								<Module>.CloseHandle(ptr3);
							}
						}
					}
				}
			}
		}

		// Token: 0x060003CB RID: 971 RVA: 0x0014FFE8 File Offset: 0x0014FFE8
		private unsafe void method_388()
		{
			if (this.comboBox1.Items.Count != 0)
			{
				uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
				ushort ushort_ = *(ref <Module>.struct38_0 + selectedIndex * 72U);
				uint num;
				if (*(ref <Module>.struct38_0 + selectedIndex * 72U + 4) == 160)
				{
					num = 0U;
				}
				else
				{
					num = 16U;
				}
				GStruct3 gstruct;
				<Module>.smethod_21(&gstruct, ushort_, 0, 1, 10000U);
				Struct52 @struct;
				<Module>.memset((void*)(&@struct), 0, 12U);
				Struct103 struct2;
				<Module>.memset((void*)(&struct2), 0, 8U);
				@struct = 85;
				*(ref @struct + 1) = 16;
				*(ref @struct + 8) = 8;
				*(ref struct2 + 1) = 6;
				uint num2;
				if (<Module>.smethod_17((byte*)(&@struct), 12U, (byte)num, 512, (void*)(&struct2), &num2, 8U, 1, &gstruct) != null)
				{
					this.textBox6.AppendText("UnLock Failed" + "\r\n");
					this.Cursor = Cursors.Arrow;
				}
				else
				{
					<Module>.memset((void*)(&@struct), 0, 12U);
					@struct = 231;
					*(ref @struct + 1) = 72;
					*(ref @struct + 2) = 73;
					*(ref @struct + 3) = 84;
					*(ref @struct + 4) = 59;
					*(ref @struct + 5) = 7;
					*(ref @struct + 11) = 1;
					if (<Module>.smethod_15((byte*)(&@struct), 12U, (byte)num, 1, &gstruct) != null)
					{
						this.textBox6.AppendText("UnLock Failed.." + "\r\n");
					}
					else
					{
						this.textBox6.AppendText("UnLocked!" + "\r\n");
						this.Cursor = Cursors.Arrow;
					}
				}
			}
		}

		// Token: 0x060003CC RID: 972 RVA: 0x003CCAFC File Offset: 0x00314AFC
		private unsafe void method_389()
		{
			string value = null;
			if (this.comboBox16.Items.Count == 0)
			{
				<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
				MessageBox.Show("No drive Selected", "Warning", MessageBoxButtons.OK, MessageBoxIcon.Hand);
				<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
			}
			else
			{
				Struct108 @struct;
				byte* ptr = ref @struct + 44;
				IntPtr intPtr = Marshal.StringToHGlobalAnsi(this.comboBox16.Text);
				IntPtr value2 = intPtr;
				sbyte* ptr2 = (sbyte*)((void*)value2);
				if (!(*(sbyte*)ptr2 < 65 | *(sbyte*)ptr2 > 122))
				{
					Struct109 struct2;
					<Module>.sprintf((sbyte*)(&struct2), (sbyte*)(&<Module>.struct22_5), *(sbyte*)ptr2);
					RegistryKey registryKey = Registry.CurrentUser.CreateSubKey("JungleFlasher");
					if (registryKey.GetValue("Delay79") != null)
					{
						value = registryKey.GetValue("Delay79").ToString();
					}
					else if (registryKey.GetValue("Delay79") == null)
					{
						registryKey.SetValue("Delay79", "500");
						value = "500";
					}
					registryKey.Close();
					int num = Convert.ToInt32(value);
					void* ptr3 = <Module>.CreateFileA((sbyte*)(&struct2), -1073741824, 3, null, 3, 128, null);
					if (ptr3 != -1)
					{
						this.textBox6.AppendText("Playing 79Unlock Audio CD" + "\r\n");
						<Module>.memset((void*)(&@struct), 0, 62U);
						*(ref @struct + 28) = 165;
						*(ref @struct + 36) = 1;
						*(ref @struct + 37) = 43;
						@struct = 44;
						*(ref @struct + 6) = 12;
						*(ref @struct + 7) = 18;
						*(ref @struct + 8) = 2;
						*(ref @struct + 16) = 15;
						*(ref @struct + 24) = 44;
						uint num2;
						if (<Module>.DeviceIoControl(ptr3, 315412, (void*)(&@struct), 62, (void*)(&@struct), 62, (uint*)(&num2), null) != null && (ptr[2] & 15) == 0)
						{
							<Module>.Sleep(num);
							this.textBox6.AppendText("Pausing 79Unlock Audio CD, after " + Convert.ToString(num) + "mS" + "\r\n");
							<Module>.memset((void*)(&@struct), 0, 62U);
							*(ref @struct + 28) = 75;
							@struct = 44;
							*(ref @struct + 6) = 12;
							*(ref @struct + 7) = 18;
							*(ref @struct + 8) = 2;
							*(ref @struct + 16) = 15;
							*(ref @struct + 24) = 44;
							if (<Module>.DeviceIoControl(ptr3, 315412, (void*)(&@struct), 62, (void*)(&@struct), 62, (uint*)(&num2), null) != null && (ptr[2] & 15) == 0)
							{
								this.textBox6.AppendText("Ejecting 79Unlock Audio CD" + "\r\n");
								<Module>.memset((void*)(&@struct), 0, 62U);
								*(ref @struct + 28) = 27;
								*(ref @struct + 32) = 2;
								@struct = 44;
								*(ref @struct + 6) = 12;
								*(ref @struct + 7) = 18;
								*(ref @struct + 8) = 2;
								*(ref @struct + 16) = 15;
								*(ref @struct + 24) = 44;
								if (<Module>.DeviceIoControl(ptr3, 315412, (void*)(&@struct), 62, (void*)(&@struct), 62, (uint*)(&num2), null) != null && (ptr[2] & 15) == 0)
								{
									<Module>.Sleep(2000);
									this.textBox6.AppendText("Setting bit 3 @ 0x5BD" + "\r\n");
									<Module>.memset((void*)(&@struct), 0, 62U);
									*(ref @struct + 28) = 85;
									*(ref @struct + 29) = 16;
									*(ref @struct + 36) = 8;
									Struct103 struct3;
									<Module>.memset((void*)(&struct3), 0, 8U);
									*(ref struct3 + 1) = 6;
									@struct = 44;
									*(ref @struct + 6) = 12;
									*(ref @struct + 7) = 18;
									*(ref @struct + 8) = 0;
									*(ref @struct + 12) = 8;
									*(ref @struct + 16) = 15;
									*(ref @struct + 20) = ref struct3;
									*(ref @struct + 24) = 44;
									if (<Module>.DeviceIoControl(ptr3, 315412, (void*)(&@struct), 62, (void*)(&@struct), 62, (uint*)(&num2), null) == null)
									{
										this.textBox6.AppendText("Failed to set bit 3 @ 0x5B6 failed" + "\r\n");
										<Module>.CloseHandle(ptr3);
									}
									else
									{
										this.textBox6.AppendText("Executing code in Ram" + "\r\n");
										<Module>.memset((void*)(&@struct), 0, 62U);
										*(ref @struct + 28) = 231;
										*(ref @struct + 29) = 72;
										*(ref @struct + 30) = 73;
										*(ref @struct + 31) = 84;
										*(ref @struct + 32) = 59;
										*(ref @struct + 33) = 7;
										*(ref @struct + 39) = 1;
										@struct = 44;
										*(ref @struct + 6) = 12;
										*(ref @struct + 7) = 18;
										*(ref @struct + 8) = 2;
										*(ref @struct + 16) = 15;
										*(ref @struct + 24) = 44;
										if (<Module>.DeviceIoControl(ptr3, 315412, (void*)(&@struct), 62, (void*)(&@struct), 62, (uint*)(&num2), null) != null && (ptr[2] & 15) == 0)
										{
											this.textBox6.AppendText("Done!" + "\r\n");
											this.Cursor = Cursors.Arrow;
											<Module>.CloseHandle(ptr3);
										}
										else
										{
											this.textBox6.AppendText("Ram Execute command failed" + "\r\n");
											<Module>.CloseHandle(ptr3);
										}
									}
								}
								else
								{
									this.textBox6.AppendText("Failed to Eject 79Unlock Audio CD" + "\r\n");
									<Module>.CloseHandle(ptr3);
								}
							}
							else
							{
								this.textBox6.AppendText("Failed to Pause 79Unlock Audio CD" + "\r\n");
								<Module>.CloseHandle(ptr3);
							}
						}
						else
						{
							this.textBox6.AppendText("Failed to Play 79Unlock Audio CD" + "\r\n");
							<Module>.CloseHandle(ptr3);
						}
					}
				}
			}
		}

		// Token: 0x060003CD RID: 973 RVA: 0x00150610 File Offset: 0x00150610
		private unsafe void method_390()
		{
			string value = null;
			if (this.comboBox1.Items.Count != 0)
			{
				uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
				ushort ushort_ = *(ref <Module>.struct38_0 + selectedIndex * 72U);
				uint num;
				if (*(ref <Module>.struct38_0 + selectedIndex * 72U + 4) == 160)
				{
					num = 0U;
				}
				else
				{
					num = 16U;
				}
				RegistryKey registryKey = Registry.CurrentUser.CreateSubKey("JungleFlasher");
				if (registryKey.GetValue("Delay79") != null)
				{
					value = registryKey.GetValue("Delay79").ToString();
				}
				else if (registryKey.GetValue("Delay79") == null)
				{
					registryKey.SetValue("Delay79", "500");
					value = "500";
				}
				registryKey.Close();
				int num2 = Convert.ToInt32(value);
				GStruct3 gstruct;
				<Module>.smethod_21(&gstruct, ushort_, 0, 1, 10000U);
				this.textBox6.AppendText("Playing 79Unlock Audio CD" + "\r\n");
				uint num3 = 0U;
				Struct52 @struct;
				for (;;)
				{
					<Module>.memset((void*)(&@struct), 0, 12U);
					@struct = 165;
					*(ref @struct + 8) = 1;
					*(ref @struct + 9) = 43;
					if (<Module>.smethod_15((byte*)(&@struct), 12U, (byte)num, 1, &gstruct) == null)
					{
						goto IL_139;
					}
					if (num3 >= 5U)
					{
						break;
					}
					num3 += 1U;
				}
				this.textBox6.AppendText("Failed to Play 79Unlock Audio CD" + "\r\n");
				return;
				IL_139:
				<Module>.Sleep(num2);
				this.textBox6.AppendText("Pausing 79Unlock Audio CD, after " + Convert.ToString(num2) + "mS" + "\r\n");
				<Module>.memset((void*)(&@struct), 0, 12U);
				@struct = 75;
				if (<Module>.smethod_15((byte*)(&@struct), 12U, (byte)num, 1, &gstruct) != null)
				{
					this.textBox6.AppendText("Failed to Pause 79Unlock Audio CD" + "\r\n");
				}
				else
				{
					this.textBox6.AppendText("Ejecting 79Unlock Audio CD" + "\r\n");
					<Module>.memset((void*)(&@struct), 0, 12U);
					@struct = 27;
					*(ref @struct + 4) = 2;
					if (<Module>.smethod_15((byte*)(&@struct), 12U, (byte)num, 1, &gstruct) != null)
					{
						this.textBox6.AppendText("Failed to Eject 79Unlock Audio CD" + "\r\n");
					}
					else
					{
						<Module>.Sleep(2000);
						<Module>.memset((void*)(&@struct), 0, 12U);
						Struct103 struct2;
						<Module>.memset((void*)(&struct2), 0, 8U);
						@struct = 85;
						*(ref @struct + 1) = 16;
						*(ref @struct + 8) = 8;
						*(ref struct2 + 1) = 6;
						uint num4;
						if (<Module>.smethod_17((byte*)(&@struct), 12U, (byte)num, 512, (void*)(&struct2), &num4, 8U, 1, &gstruct) != null)
						{
							this.textBox6.AppendText("Failed to set bit 3 @ 0x5B6 failed" + "\r\n");
							this.Cursor = Cursors.Arrow;
						}
						else
						{
							<Module>.memset((void*)(&@struct), 0, 12U);
							@struct = 231;
							*(ref @struct + 1) = 72;
							*(ref @struct + 2) = 73;
							*(ref @struct + 3) = 84;
							*(ref @struct + 4) = 59;
							*(ref @struct + 5) = 7;
							*(ref @struct + 11) = 1;
							if (<Module>.smethod_15((byte*)(&@struct), 12U, (byte)num, 1, &gstruct) != null)
							{
								this.textBox6.AppendText("Ram Execute command failed" + "\r\n");
							}
							else
							{
								this.textBox6.AppendText("Done!" + "\r\n");
								this.Cursor = Cursors.Arrow;
							}
						}
					}
				}
			}
		}

		// Token: 0x060003CE RID: 974 RVA: 0x00150968 File Offset: 0x00150968
		private unsafe void method_391(byte* pByte_0, byte* pByte_1, int int_16)
		{
			Struct115 @struct = 22;
			*(ref @struct + 4) = 27;
			*(ref @struct + 8) = 3;
			*(ref @struct + 12) = 10;
			*(ref @struct + 16) = 14;
			*(ref @struct + 20) = 16;
			*(ref @struct + 24) = 1;
			*(ref @struct + 28) = 28;
			*(ref @struct + 32) = 26;
			*(ref @struct + 36) = 7;
			*(ref @struct + 40) = 15;
			*(ref @struct + 44) = 21;
			*(ref @struct + 48) = 5;
			*(ref @struct + 52) = 19;
			*(ref @struct + 56) = 29;
			*(ref @struct + 60) = 12;
			*(ref @struct + 64) = 2;
			*(ref @struct + 68) = 11;
			*(ref @struct + 72) = 24;
			*(ref @struct + 76) = 20;
			*(ref @struct + 80) = 13;
			*(ref @struct + 84) = 18;
			*(ref @struct + 88) = 4;
			*(ref @struct + 92) = 30;
			*(ref @struct + 96) = 9;
			*(ref @struct + 100) = 17;
			*(ref @struct + 104) = 23;
			*(ref @struct + 108) = 0;
			*(ref @struct + 112) = 6;
			*(ref @struct + 116) = 31;
			*(ref @struct + 120) = 8;
			*(ref @struct + 124) = 25;
			for (int i = 0; i < int_16; i += 4)
			{
				uint num = (uint)((int)pByte_0[i] << 24 | (int)pByte_0[i + 1] << 16 | (int)pByte_0[i + 2] << 8 | (int)pByte_0[i + 3]);
				num ^= 2341178251U;
				num = this.method_32(num, (int*)(&@struct));
				pByte_1[i] = (byte)(num >> 24);
				pByte_1[i + 1] = (byte)(num >> 16);
				pByte_1[i + 2] = (byte)(num >> 8);
				pByte_1[i + 3] = (byte)num;
			}
		}

		// Token: 0x060003CF RID: 975 RVA: 0x00150ACC File Offset: 0x00150ACC
		private unsafe void method_392(byte* pByte_0, byte* pByte_1, int int_16)
		{
			Struct115 @struct = 2;
			*(ref @struct + 4) = 8;
			*(ref @struct + 8) = 17;
			*(ref @struct + 12) = 24;
			*(ref @struct + 16) = 30;
			*(ref @struct + 20) = 23;
			*(ref @struct + 24) = 0;
			*(ref @struct + 28) = 13;
			*(ref @struct + 32) = 5;
			*(ref @struct + 36) = 31;
			*(ref @struct + 40) = 20;
			*(ref @struct + 44) = 12;
			*(ref @struct + 48) = 18;
			*(ref @struct + 52) = 10;
			*(ref @struct + 56) = 6;
			*(ref @struct + 60) = 26;
			*(ref @struct + 64) = 21;
			*(ref @struct + 68) = 27;
			*(ref @struct + 72) = 11;
			*(ref @struct + 76) = 16;
			*(ref @struct + 80) = 14;
			*(ref @struct + 84) = 28;
			*(ref @struct + 88) = 7;
			*(ref @struct + 92) = 1;
			*(ref @struct + 96) = 22;
			*(ref @struct + 100) = 3;
			*(ref @struct + 104) = 19;
			*(ref @struct + 108) = 9;
			*(ref @struct + 112) = 29;
			*(ref @struct + 116) = 15;
			*(ref @struct + 120) = 25;
			*(ref @struct + 124) = 4;
			for (int i = 0; i < int_16; i += 4)
			{
				uint num = (uint)((int)pByte_0[i] << 24 | (int)pByte_0[i + 1] << 16 | (int)pByte_0[i + 2] << 8 | (int)pByte_0[i + 3]);
				num = this.method_32(num, (int*)(&@struct));
				num ^= 2341178251U;
				pByte_1[i] = (byte)(num >> 24);
				pByte_1[i + 1] = (byte)(num >> 16);
				pByte_1[i + 2] = (byte)(num >> 8);
				pByte_1[i + 3] = (byte)num;
			}
		}

		// Token: 0x060003D0 RID: 976 RVA: 0x00150C30 File Offset: 0x00150C30
		private int method_393(uint uint_0, uint uint_1, uint uint_2, uint uint_3)
		{
			if (this.int_13 == 1 && this.int_15 == 0)
			{
				if (this.method_396(uint_0, uint_1, uint_2, uint_3) != 0)
				{
					return 1;
				}
			}
			else if (this.int_13 == 2 && this.int_15 == 0)
			{
				if (this.method_401(uint_0, uint_1, uint_2, uint_3) != 0)
				{
					return 1;
				}
			}
			else if (this.int_13 == 3 && this.int_15 == 0)
			{
				if (this.method_399(uint_0, uint_1, uint_2, uint_3) != 0)
				{
					return 1;
				}
			}
			else if (this.int_13 == 1 && this.int_15 == 1)
			{
				if (this.method_398(uint_0, uint_1, uint_2, uint_3) != 0)
				{
					return 1;
				}
			}
			else if (this.int_13 == 2 && this.int_15 == 1)
			{
				if (this.method_402(uint_0, uint_1, uint_2, uint_3) != 0)
				{
					return 1;
				}
			}
			else
			{
				if (this.int_13 != 3 || this.int_15 != 1)
				{
					return 1;
				}
				if (this.method_400(uint_0, uint_1, uint_2, uint_3) != 0)
				{
					return 1;
				}
			}
			return 0;
		}

		// Token: 0x060003D1 RID: 977 RVA: 0x003CCFC8 File Offset: 0x00314FC8
		private unsafe int method_394(uint uint_0, uint uint_1, uint uint_2, uint uint_3)
		{
			int result;
			if (this.comboBox16.Items.Count == 0)
			{
				<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
				MessageBox.Show("No drive Selected", "Warning", MessageBoxButtons.OK, MessageBoxIcon.Hand);
				<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
				result = 1;
			}
			else
			{
				uint num = 0U;
				IntPtr intPtr = Marshal.StringToHGlobalAnsi(this.comboBox16.Text);
				IntPtr value = intPtr;
				sbyte* ptr = (sbyte*)((void*)value);
				if (*(sbyte*)ptr < 65 | *(sbyte*)ptr > 122)
				{
					result = 1;
				}
				else
				{
					Struct109 @struct;
					<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct22_5), *(sbyte*)ptr);
					void* ptr2 = <Module>.CreateFileA((sbyte*)(&@struct), -1073741824, 3, null, 3, 128, null);
					if (ptr2 == -1)
					{
						result = 1;
					}
					else
					{
						this.Cursor = Cursors.WaitCursor;
						Struct32 struct4;
						for (uint num2 = uint_0; num2 < uint_0 + uint_1; num2 += 1U)
						{
							Struct116 struct2;
							<Module>.memset((void*)(&struct2), 48, 32768U);
							Struct108 struct3;
							<Module>.memset((void*)(&struct3), 0, 62U);
							*(ref struct3 + 28) = 231;
							*(ref struct3 + 29) = 72;
							*(ref struct3 + 30) = 73;
							*(ref struct3 + 31) = 84;
							*(ref struct3 + 32) = 1;
							*(ref struct3 + 34) = (byte)((num2 * uint_2 & 4278190080U) >> 24);
							*(ref struct3 + 35) = (byte)((num2 * uint_2 & 16711680U) >> 16);
							*(ref struct3 + 36) = (byte)((num2 * uint_2 & 65280U) >> 8);
							*(ref struct3 + 37) = (byte)(num2 * uint_2 & 255U);
							*(ref struct3 + 38) = (byte)((uint_2 & 65280U) >> 8);
							*(ref struct3 + 39) = (byte)(uint_2 & 255U);
							struct3 = 44;
							*(ref struct3 + 6) = 12;
							*(ref struct3 + 7) = 18;
							*(ref struct3 + 8) = 1;
							*(ref struct3 + 12) = (int)uint_2;
							*(ref struct3 + 16) = 15;
							*(ref struct3 + 20) = ref struct2;
							*(ref struct3 + 24) = 44;
							uint num3;
							if (<Module>.DeviceIoControl(ptr2, 315412, (void*)(&struct3), 62, (void*)(&struct3), 62, (uint*)(&num3), null) == null)
							{
								this.textBox6.AppendText("Classic Dump Failed" + "\r\n");
								this.Cursor = Cursors.Arrow;
								<Module>.CloseHandle(ptr2);
								return 1;
							}
							byte* ptr3 = ref struct4 + num * uint_2;
							<Module>.memcpy((void*)ptr3, (void*)(&struct2), uint_2);
							num += 1U;
							if (num2 % uint_3 == 0U)
							{
								this.textBox6.AppendText(".");
								Application.DoEvents();
							}
						}
						this.Cursor = Cursors.Arrow;
						<Module>.memcpy(*(ref <Module>.struct121_0 + 7172), (void*)(&struct4), 262144U);
						<Module>.CloseHandle(ptr2);
						result = 0;
					}
				}
			}
			return result;
		}

		// Token: 0x060003D2 RID: 978 RVA: 0x00150F94 File Offset: 0x00150F94
		private unsafe int method_395(uint uint_0, uint uint_1, uint uint_2, uint uint_3)
		{
			int result;
			if (this.comboBox1.Items.Count == 0)
			{
				result = 0;
			}
			else
			{
				uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
				ushort ushort_ = *(ref <Module>.struct38_0 + selectedIndex * 72U);
				uint num;
				if (*(ref <Module>.struct38_0 + selectedIndex * 72U + 4) == 160)
				{
					num = 0U;
				}
				else
				{
					num = 16U;
				}
				uint num2 = 0U;
				this.Cursor = Cursors.WaitCursor;
				GStruct3 gstruct;
				<Module>.smethod_21(&gstruct, ushort_, 0, 1, 10000U);
				Struct32 struct3;
				for (uint num3 = uint_0; num3 < uint_0 + uint_1; num3 += 1U)
				{
					Struct116 @struct;
					<Module>.memset((void*)(&@struct), 0, 32768U);
					Struct52 struct2;
					<Module>.memset((void*)(&struct2), 0, 12U);
					struct2 = 231;
					*(ref struct2 + 1) = 72;
					*(ref struct2 + 2) = 73;
					*(ref struct2 + 3) = 84;
					*(ref struct2 + 4) = 1;
					*(ref struct2 + 6) = (byte)((num3 * uint_2 & 4278190080U) >> 24);
					*(ref struct2 + 7) = (byte)((num3 * uint_2 & 16711680U) >> 16);
					*(ref struct2 + 8) = (byte)((num3 * uint_2 & 65280U) >> 8);
					*(ref struct2 + 9) = (byte)(num3 * uint_2 & 255U);
					*(ref struct2 + 10) = (byte)((uint_2 & 65280U) >> 8);
					*(ref struct2 + 11) = (byte)(uint_2 & 255U);
					uint num4;
					if (<Module>.smethod_16((byte*)(&struct2), 12U, (byte)num, 512, (void*)(&@struct), &num4, uint_2, 1, &gstruct) != null)
					{
						this.textBox6.AppendText("Classic Dump Failed" + "\r\n");
						this.Cursor = Cursors.Arrow;
						return 1;
					}
					byte* ptr = ref struct3 + num2 * uint_2;
					<Module>.memcpy((void*)ptr, (void*)(&@struct), uint_2);
					num2 += 1U;
					if (num3 % uint_3 == 0U)
					{
						this.textBox6.AppendText(".");
						Application.DoEvents();
					}
				}
				this.Cursor = Cursors.Arrow;
				<Module>.memcpy(*(ref <Module>.struct121_0 + 7172), (void*)(&struct3), 262144U);
				result = 0;
			}
			return result;
		}

		// Token: 0x060003D3 RID: 979 RVA: 0x003CD234 File Offset: 0x00315234
		private unsafe int method_396(uint uint_0, uint uint_1, uint uint_2, uint uint_3)
		{
			int result;
			if (this.comboBox16.Items.Count == 0)
			{
				<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
				MessageBox.Show("No drive Selected", "Warning", MessageBoxButtons.OK, MessageBoxIcon.Hand);
				<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
				result = 1;
			}
			else
			{
				Struct45 @struct;
				if (this.int_12 == 79)
				{
					<Module>.memcpy((void*)(&@struct), (void*)(&<Module>.struct45_0), 384U);
				}
				else if (this.int_12 == 59)
				{
					<Module>.memcpy((void*)(&@struct), (void*)(&<Module>.struct45_2), 384U);
				}
				else if (this.int_12 == 47)
				{
					<Module>.memcpy((void*)(&@struct), (void*)(&<Module>.struct45_4), 384U);
				}
				else if (this.int_12 == 36)
				{
					<Module>.memcpy((void*)(&@struct), (void*)(&<Module>.struct45_1), 384U);
				}
				else if (this.int_12 == 32)
				{
					<Module>.memcpy((void*)(&@struct), (void*)(&<Module>.struct45_3), 384U);
				}
				uint num = 0U;
				string str = this.comboBox16.Text.Substring(0, 1);
				IntPtr intPtr = Marshal.StringToHGlobalAnsi(this.comboBox16.Text);
				IntPtr value = intPtr;
				sbyte* ptr = (sbyte*)((void*)value);
				if (*(sbyte*)ptr < 65 | *(sbyte*)ptr > 122)
				{
					result = 1;
				}
				else
				{
					Struct109 struct2;
					<Module>.sprintf((sbyte*)(&struct2), (sbyte*)(&<Module>.struct22_5), *(sbyte*)ptr);
					void* ptr2 = <Module>.CreateFileA((sbyte*)(&struct2), -1073741824, 3, null, 3, 128, null);
					if (ptr2 == -1)
					{
						this.textBox6.AppendText("Failed to open drive " + str + "\r\n");
						result = 1;
					}
					else
					{
						this.Cursor = Cursors.WaitCursor;
						uint num2 = 384U;
						Struct32 struct5;
						for (uint num3 = uint_0; num3 < uint_0 + uint_1; num3 += 1U)
						{
							*(ref @struct + 2) = (int)uint_2;
							*(ref @struct + 11) = (int)(num3 * uint_2);
							uint num4 = 0U;
							for (uint num5 = 0U; num5 < num2 - 2U; num5 += 1U)
							{
								num4 += (uint)(*(ref @struct + num5));
							}
							num4 = 65536U - (num4 & 65535U);
							*(ref @struct + (num2 - 2U)) = (byte)(num4 & 255U);
							*(ref @struct + (num2 - 1U)) = (byte)((num4 & 65280U) >> 8);
							Struct108 struct3;
							<Module>.memset((void*)(&struct3), 0, 62U);
							*(ref struct3 + 28) = 231;
							*(ref struct3 + 29) = 72;
							*(ref struct3 + 30) = 73;
							*(ref struct3 + 31) = 84;
							*(ref struct3 + 32) = 59;
							*(ref struct3 + 33) = 6;
							*(ref struct3 + 38) = (byte)((num2 & 65280U) >> 8);
							*(ref struct3 + 39) = (byte)(num2 & 255U);
							struct3 = 44;
							*(ref struct3 + 6) = 12;
							*(ref struct3 + 7) = 18;
							*(ref struct3 + 8) = 0;
							*(ref struct3 + 12) = (int)num2;
							*(ref struct3 + 16) = 15;
							*(ref struct3 + 20) = ref @struct;
							*(ref struct3 + 24) = 44;
							uint num6;
							if (<Module>.DeviceIoControl(ptr2, 315412, (void*)(&struct3), 62, (void*)(&struct3), 62, (uint*)(&num6), null) == null)
							{
								this.textBox6.AppendText("Ram Upload - Upload Failed" + "\r\n");
								<Module>.CloseHandle(ptr2);
								return 1;
							}
							Struct116 struct4;
							<Module>.memset((void*)(&struct4), 48, 32768U);
							<Module>.memset((void*)(&struct3), 0, 62U);
							*(ref struct3 + 28) = 231;
							*(ref struct3 + 29) = 72;
							*(ref struct3 + 30) = 73;
							*(ref struct3 + 31) = 84;
							*(ref struct3 + 32) = 59;
							*(ref struct3 + 33) = 7;
							*(ref struct3 + 39) = 1;
							struct3 = 44;
							*(ref struct3 + 6) = 12;
							*(ref struct3 + 7) = 18;
							*(ref struct3 + 8) = 1;
							*(ref struct3 + 12) = (int)uint_2;
							*(ref struct3 + 16) = 15;
							*(ref struct3 + 20) = ref struct4;
							*(ref struct3 + 24) = 44;
							if (<Module>.DeviceIoControl(ptr2, 315412, (void*)(&struct3), 62, (void*)(&struct3), 62, (uint*)(&num6), null) == null)
							{
								this.textBox6.AppendText("Ram Upload - Execute Failed" + "\r\n");
								<Module>.CloseHandle(ptr2);
								return 1;
							}
							num2 = 20U;
							byte* ptr3 = ref struct5 + num * uint_2;
							<Module>.memcpy((void*)ptr3, (void*)(&struct4), uint_2);
							num += 1U;
							if (num3 % uint_3 == 0U)
							{
								this.textBox6.AppendText(".");
								Application.DoEvents();
							}
						}
						this.Cursor = Cursors.Arrow;
						<Module>.memcpy(*(ref <Module>.struct121_0 + 7172), (void*)(&struct5), 262144U);
						<Module>.CloseHandle(ptr2);
						result = 0;
					}
				}
			}
			return result;
		}

		// Token: 0x060003D4 RID: 980 RVA: 0x003CD668 File Offset: 0x00315668
		private unsafe int method_397(uint uint_0, uint uint_1, uint uint_2, uint uint_3)
		{
			int result;
			if (this.comboBox16.Items.Count == 0)
			{
				<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
				MessageBox.Show("No drive Selected", "Warning", MessageBoxButtons.OK, MessageBoxIcon.Hand);
				<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
				result = 1;
			}
			else
			{
				Struct45 @struct;
				if (this.int_12 == 79)
				{
					<Module>.memcpy((void*)(&@struct), (void*)(&<Module>.struct45_0), 384U);
				}
				else if (this.int_12 == 59)
				{
					<Module>.memcpy((void*)(&@struct), (void*)(&<Module>.struct45_2), 384U);
				}
				else if (this.int_12 == 47)
				{
					<Module>.memcpy((void*)(&@struct), (void*)(&<Module>.struct45_4), 384U);
				}
				else if (this.int_12 == 36)
				{
					<Module>.memcpy((void*)(&@struct), (void*)(&<Module>.struct45_1), 384U);
				}
				else if (this.int_12 == 32)
				{
					<Module>.memcpy((void*)(&@struct), (void*)(&<Module>.struct45_3), 384U);
				}
				uint num = 0U;
				string str = this.comboBox16.Text.Substring(0, 1);
				IntPtr intPtr = Marshal.StringToHGlobalAnsi(this.comboBox16.Text);
				IntPtr value = intPtr;
				sbyte* ptr = (sbyte*)((void*)value);
				if (*(sbyte*)ptr < 65 | *(sbyte*)ptr > 122)
				{
					result = 1;
				}
				else
				{
					Struct109 struct2;
					<Module>.sprintf((sbyte*)(&struct2), (sbyte*)(&<Module>.struct22_5), *(sbyte*)ptr);
					void* ptr2 = <Module>.CreateFileA((sbyte*)(&struct2), -1073741824, 3, null, 3, 128, null);
					if (ptr2 == -1)
					{
						this.textBox6.AppendText("Failed to open drive " + str + "\r\n");
						result = 1;
					}
					else
					{
						this.Cursor = Cursors.WaitCursor;
						uint num2 = 384U;
						Struct32 struct5;
						for (uint num3 = uint_0; num3 < uint_0 + uint_1; num3 += 1U)
						{
							*(ref @struct + 2) = (int)uint_2;
							*(ref @struct + 11) = (int)(uint_0 * uint_2);
							uint num4 = 0U;
							for (uint num5 = 0U; num5 < num2 - 2U; num5 += 1U)
							{
								num4 += (uint)(*(ref @struct + num5));
							}
							num4 = 65536U - (num4 & 65535U);
							*(ref @struct + (num2 - 2U)) = (byte)(num4 & 255U);
							*(ref @struct + (num2 - 1U)) = (byte)((num4 & 65280U) >> 8);
							Struct108 struct3;
							<Module>.memset((void*)(&struct3), 0, 62U);
							*(ref struct3 + 28) = 231;
							*(ref struct3 + 29) = 72;
							*(ref struct3 + 30) = 73;
							*(ref struct3 + 31) = 84;
							*(ref struct3 + 32) = 59;
							*(ref struct3 + 33) = 6;
							*(ref struct3 + 38) = (byte)((num2 & 65280U) >> 8);
							*(ref struct3 + 39) = (byte)(num2 & 255U);
							struct3 = 44;
							*(ref struct3 + 6) = 12;
							*(ref struct3 + 7) = 18;
							*(ref struct3 + 8) = 0;
							*(ref struct3 + 12) = (int)num2;
							*(ref struct3 + 16) = 15;
							*(ref struct3 + 20) = ref @struct;
							*(ref struct3 + 24) = 44;
							uint num6;
							if (<Module>.DeviceIoControl(ptr2, 315412, (void*)(&struct3), 62, (void*)(&struct3), 62, (uint*)(&num6), null) == null)
							{
								this.textBox6.AppendText("Ram Upload - Upload Failed" + "\r\n");
								<Module>.CloseHandle(ptr2);
								return 1;
							}
							Struct116 struct4;
							<Module>.memset((void*)(&struct4), 48, 32768U);
							<Module>.memset((void*)(&struct3), 0, 62U);
							*(ref struct3 + 28) = 231;
							*(ref struct3 + 29) = 72;
							*(ref struct3 + 30) = 73;
							*(ref struct3 + 31) = 84;
							*(ref struct3 + 32) = 59;
							*(ref struct3 + 33) = 7;
							*(ref struct3 + 39) = 1;
							struct3 = 44;
							*(ref struct3 + 6) = 12;
							*(ref struct3 + 7) = 18;
							*(ref struct3 + 8) = 1;
							*(ref struct3 + 12) = (int)uint_2;
							*(ref struct3 + 16) = 15;
							*(ref struct3 + 20) = ref struct4;
							*(ref struct3 + 24) = 44;
							if (<Module>.DeviceIoControl(ptr2, 315412, (void*)(&struct3), 62, (void*)(&struct3), 62, (uint*)(&num6), null) == null)
							{
								this.textBox6.AppendText("Ram Upload - Execute Failed" + "\r\n");
								<Module>.CloseHandle(ptr2);
								return 1;
							}
							num2 = 20U;
							byte* ptr3 = ref struct5 + num * uint_2;
							<Module>.memcpy((void*)ptr3, (void*)(&struct4), uint_2);
							num += 1U;
							if (num3 % uint_3 == 0U)
							{
								this.textBox6.AppendText(".");
								Application.DoEvents();
							}
						}
						this.Cursor = Cursors.Arrow;
						GStruct5* pGstruct5_ = <Module>.fopen((sbyte*)(&<Module>.struct74_5), (sbyte*)(&<Module>.struct18_5));
						<Module>.fwrite((void*)(&struct5), uint_2 * uint_1, 1U, pGstruct5_);
						<Module>.fclose(pGstruct5_);
						<Module>.CloseHandle(ptr2);
						result = 0;
					}
				}
			}
			return result;
		}

		// Token: 0x060003D5 RID: 981 RVA: 0x003CDAA8 File Offset: 0x00315AA8
		private unsafe int method_398(uint uint_0, uint uint_1, uint uint_2, uint uint_3)
		{
			int result;
			if (this.comboBox1.Items.Count == 0)
			{
				result = 0;
			}
			else
			{
				uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
				ushort ushort_ = *(ref <Module>.struct38_0 + selectedIndex * 72U);
				uint num;
				if (*(ref <Module>.struct38_0 + selectedIndex * 72U + 4) == 160)
				{
					num = 0U;
				}
				else
				{
					num = 16U;
				}
				Struct45 @struct;
				if (this.int_12 == 79)
				{
					<Module>.memcpy((void*)(&@struct), (void*)(&<Module>.struct45_0), 384U);
				}
				else if (this.int_12 == 59)
				{
					<Module>.memcpy((void*)(&@struct), (void*)(&<Module>.struct45_2), 384U);
				}
				else if (this.int_12 == 47)
				{
					<Module>.memcpy((void*)(&@struct), (void*)(&<Module>.struct45_4), 384U);
				}
				else if (this.int_12 == 36)
				{
					<Module>.memcpy((void*)(&@struct), (void*)(&<Module>.struct45_1), 384U);
				}
				else if (this.int_12 == 32)
				{
					<Module>.memcpy((void*)(&@struct), (void*)(&<Module>.struct45_3), 384U);
				}
				uint num2 = 0U;
				this.Cursor = Cursors.WaitCursor;
				uint num3 = 384U;
				GStruct3 gstruct;
				<Module>.smethod_21(&gstruct, ushort_, 0, 1, 10000U);
				Struct32 struct4;
				for (uint num4 = uint_0; num4 < uint_0 + uint_1; num4 += 1U)
				{
					*(ref @struct + 2) = (int)uint_2;
					*(ref @struct + 11) = (int)(num4 * uint_2);
					uint num5 = 0U;
					for (uint num6 = 0U; num6 < num3 - 2U; num6 += 1U)
					{
						num5 += (uint)(*(ref @struct + num6));
					}
					num5 = 65536U - (num5 & 65535U);
					*(ref @struct + (num3 - 2U)) = (byte)(num5 & 255U);
					*(ref @struct + (num3 - 1U)) = (byte)((num5 & 65280U) >> 8);
					Struct52 struct2;
					<Module>.memset((void*)(&struct2), 0, 12U);
					struct2 = 231;
					*(ref struct2 + 1) = 72;
					*(ref struct2 + 2) = 73;
					*(ref struct2 + 3) = 84;
					*(ref struct2 + 4) = 59;
					*(ref struct2 + 5) = 6;
					*(ref struct2 + 10) = (byte)((num3 & 65280U) >> 8);
					*(ref struct2 + 11) = (byte)(num3 & 255U);
					uint num7;
					if (<Module>.smethod_17((byte*)(&struct2), 12U, (byte)num, 512, (void*)(&@struct), &num7, num3, 1, &gstruct) != null)
					{
						this.textBox6.AppendText("Ram Upload - Upload Failed" + "\r\n");
						this.Cursor = Cursors.Arrow;
						return 1;
					}
					<Module>.memset((void*)(&struct2), 0, 12U);
					Struct116 struct3;
					<Module>.memset((void*)(&struct3), 0, 32768U);
					struct2 = 231;
					*(ref struct2 + 1) = 72;
					*(ref struct2 + 2) = 73;
					*(ref struct2 + 3) = 84;
					*(ref struct2 + 4) = 59;
					*(ref struct2 + 5) = 7;
					*(ref struct2 + 11) = 1;
					if (<Module>.smethod_16((byte*)(&struct2), 12U, (byte)num, 512, (void*)(&struct3), &num7, uint_2, 1, &gstruct) != null)
					{
						this.textBox6.AppendText("Ram Upload - Execute Failed" + "\r\n");
						this.Cursor = Cursors.Arrow;
						return 1;
					}
					num3 = 20U;
					byte* ptr = ref struct4 + num2 * uint_2;
					<Module>.memcpy((void*)ptr, (void*)(&struct3), uint_2);
					num2 += 1U;
					if (num4 % uint_3 == 0U)
					{
						this.textBox6.AppendText(".");
						Application.DoEvents();
					}
				}
				this.Cursor = Cursors.Arrow;
				<Module>.memcpy(*(ref <Module>.struct121_0 + 7172), (void*)(&struct4), 262144U);
				result = 0;
			}
			return result;
		}

		// Token: 0x060003D6 RID: 982 RVA: 0x003CDDC4 File Offset: 0x00315DC4
		private unsafe int method_399(uint uint_0, uint uint_1, uint uint_2, uint uint_3)
		{
			int result;
			if (this.comboBox16.Items.Count == 0)
			{
				<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
				MessageBox.Show("No drive Selected", "Warning", MessageBoxButtons.OK, MessageBoxIcon.Hand);
				<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
				result = 1;
			}
			else
			{
				Struct45 @struct;
				if (this.int_12 == 79)
				{
					<Module>.memcpy((void*)(&@struct), (void*)(&<Module>.struct45_0), 384U);
				}
				else if (this.int_12 == 59)
				{
					<Module>.memcpy((void*)(&@struct), (void*)(&<Module>.struct45_2), 384U);
				}
				else if (this.int_12 == 47)
				{
					<Module>.memcpy((void*)(&@struct), (void*)(&<Module>.struct45_4), 384U);
				}
				else if (this.int_12 == 36)
				{
					<Module>.memcpy((void*)(&@struct), (void*)(&<Module>.struct45_1), 384U);
				}
				else if (this.int_12 == 32)
				{
					<Module>.memcpy((void*)(&@struct), (void*)(&<Module>.struct45_3), 384U);
				}
				uint num = 0U;
				IntPtr intPtr = Marshal.StringToHGlobalAnsi(this.comboBox16.Text);
				IntPtr value = intPtr;
				sbyte* ptr = (sbyte*)((void*)value);
				if (*(sbyte*)ptr < 65 | *(sbyte*)ptr > 122)
				{
					result = 1;
				}
				else
				{
					Struct109 struct2;
					<Module>.sprintf((sbyte*)(&struct2), (sbyte*)(&<Module>.struct22_5), *(sbyte*)ptr);
					void* ptr2 = <Module>.CreateFileA((sbyte*)(&struct2), -1073741824, 3, null, 3, 128, null);
					if (ptr2 == -1)
					{
						result = 1;
					}
					else
					{
						this.Cursor = Cursors.WaitCursor;
						uint num2 = 384U;
						Struct32 struct6;
						for (uint num3 = uint_0; num3 < uint_0 + uint_1; num3 += 1U)
						{
							*(ref @struct + 2) = (int)uint_2;
							*(ref @struct + 11) = (int)(num3 * uint_2);
							uint num4 = 0U;
							for (uint num5 = 0U; num5 < 382U; num5 += 1U)
							{
								num4 += (uint)(*(ref @struct + num5));
							}
							num4 = 65536U - (num4 & 65535U);
							*(ref @struct + 382) = (byte)(num4 & 255U);
							*(ref @struct + 383) = (byte)((num4 & 65280U) >> 8);
							Struct108 struct3;
							uint num7;
							for (uint num6 = 0U; num6 < num2; num6 += 1U)
							{
								<Module>.memset((void*)(&struct3), 0, 62U);
								*(ref struct3 + 28) = 231;
								*(ref struct3 + 29) = 72;
								*(ref struct3 + 30) = 73;
								*(ref struct3 + 31) = 84;
								*(ref struct3 + 32) = 204;
								*(ref struct3 + 33) = *(ref @struct + num6);
								*(ref struct3 + 36) = (byte)((num6 + 2147483648U & 4278190080U) >> 24);
								*(ref struct3 + 37) = (byte)((num6 + 2147483648U & 16711680U) >> 16);
								*(ref struct3 + 38) = (byte)((num6 + 2147483648U & 65280U) >> 8);
								*(ref struct3 + 39) = (byte)(num6 + 2147483648U & 255U);
								struct3 = 44;
								*(ref struct3 + 6) = 12;
								*(ref struct3 + 7) = 18;
								*(ref struct3 + 8) = 2;
								*(ref struct3 + 16) = 15;
								*(ref struct3 + 24) = 44;
								if (<Module>.DeviceIoControl(ptr2, 315412, (void*)(&struct3), 62, (void*)(&struct3), 62, (uint*)(&num7), null) == null)
								{
									this.textBox6.AppendText("Ram Poke Failed" + "\r\n");
									<Module>.CloseHandle(ptr2);
									return 1;
								}
							}
							<Module>.memset((void*)(&struct3), 0, 62U);
							*(ref struct3 + 28) = 85;
							*(ref struct3 + 29) = 16;
							*(ref struct3 + 36) = 8;
							Struct103 struct4;
							<Module>.memset((void*)(&struct4), 0, 8U);
							*(ref struct4 + 1) = 6;
							struct3 = 44;
							*(ref struct3 + 6) = 12;
							*(ref struct3 + 7) = 18;
							*(ref struct3 + 8) = 0;
							*(ref struct3 + 12) = 8;
							*(ref struct3 + 16) = 15;
							*(ref struct3 + 20) = ref struct4;
							*(ref struct3 + 24) = 44;
							if (<Module>.DeviceIoControl(ptr2, 315412, (void*)(&struct3), 62, (void*)(&struct3), 62, (uint*)(&num7), null) == null && <Module>.DeviceIoControl(ptr2, 315412, (void*)(&struct3), 62, (void*)(&struct3), 62, (uint*)(&num7), null) == null && <Module>.DeviceIoControl(ptr2, 315412, (void*)(&struct3), 62, (void*)(&struct3), 62, (uint*)(&num7), null) == null)
							{
								this.textBox6.AppendText("Set (59E) bit 3 via Mode Select(10) failed" + "\r\n");
								<Module>.CloseHandle(ptr2);
								return 1;
							}
							Struct116 struct5;
							<Module>.memset((void*)(&struct5), 48, uint_2);
							<Module>.memset((void*)(&struct3), 0, 62U);
							*(ref struct3 + 28) = 85;
							*(ref struct3 + 29) = 16;
							*(ref struct3 + 31) = 72;
							*(ref struct3 + 32) = 76;
							*(ref struct3 + 34) = 1;
							*(ref struct3 + 39) = 1;
							struct3 = 44;
							*(ref struct3 + 6) = 12;
							*(ref struct3 + 7) = 18;
							*(ref struct3 + 8) = 1;
							*(ref struct3 + 12) = (int)uint_2;
							*(ref struct3 + 16) = 15;
							*(ref struct3 + 20) = ref struct5;
							*(ref struct3 + 24) = 44;
							if (<Module>.DeviceIoControl(ptr2, 315412, (void*)(&struct3), 62, (void*)(&struct3), 62, (uint*)(&num7), null) == null)
							{
								this.textBox6.AppendText("Ram Poke Dump Failed" + "\r\n");
								<Module>.CloseHandle(ptr2);
								return 1;
							}
							byte* ptr3 = ref struct6 + num * uint_2;
							<Module>.memcpy((void*)ptr3, (void*)(&struct5), uint_2);
							num += 1U;
							if (num3 % uint_3 == 0U)
							{
								this.textBox6.AppendText(".");
								Application.DoEvents();
							}
							<Module>.memset((void*)(&struct3), 0, 62U);
							*(ref struct3 + 28) = 85;
							struct3 = 44;
							*(ref struct3 + 6) = 12;
							*(ref struct3 + 7) = 18;
							*(ref struct3 + 8) = 2;
							*(ref struct3 + 16) = 15;
							*(ref struct3 + 24) = 44;
							if (<Module>.DeviceIoControl(ptr2, 315412, (void*)(&struct3), 62, (void*)(&struct3), 62, (uint*)(&num7), null) == null && <Module>.DeviceIoControl(ptr2, 315412, (void*)(&struct3), 62, (void*)(&struct3), 62, (uint*)(&num7), null) == null)
							{
								this.textBox6.AppendText("Disable Execute Failed" + "\r\n");
								this.Cursor = Cursors.Arrow;
								<Module>.CloseHandle(ptr2);
								return 1;
							}
							num2 = 16U;
						}
						this.Cursor = Cursors.Arrow;
						<Module>.memcpy(*(ref <Module>.struct121_0 + 7172), (void*)(&struct6), 262144U);
						<Module>.CloseHandle(ptr2);
						result = 0;
					}
				}
			}
			return result;
		}

		// Token: 0x060003D7 RID: 983 RVA: 0x00152208 File Offset: 0x00152208
		private unsafe int method_400(uint uint_0, uint uint_1, uint uint_2, uint uint_3)
		{
			int result;
			if (this.comboBox1.Items.Count == 0)
			{
				result = 0;
			}
			else
			{
				uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
				ushort ushort_ = *(ref <Module>.struct38_0 + selectedIndex * 72U);
				uint num;
				if (*(ref <Module>.struct38_0 + selectedIndex * 72U + 4) == 160)
				{
					num = 0U;
				}
				else
				{
					num = 16U;
				}
				Struct45 @struct;
				if (this.int_12 == 79)
				{
					<Module>.memcpy((void*)(&@struct), (void*)(&<Module>.struct45_0), 384U);
				}
				else if (this.int_12 == 59)
				{
					<Module>.memcpy((void*)(&@struct), (void*)(&<Module>.struct45_2), 384U);
				}
				else if (this.int_12 == 47)
				{
					<Module>.memcpy((void*)(&@struct), (void*)(&<Module>.struct45_4), 384U);
				}
				else if (this.int_12 == 36)
				{
					<Module>.memcpy((void*)(&@struct), (void*)(&<Module>.struct45_1), 384U);
				}
				else if (this.int_12 == 32)
				{
					<Module>.memcpy((void*)(&@struct), (void*)(&<Module>.struct45_3), 384U);
				}
				uint num2 = 0U;
				GStruct3 gstruct;
				<Module>.smethod_21(&gstruct, ushort_, 0, 1, 10000U);
				this.Cursor = Cursors.WaitCursor;
				uint num3 = 384U;
				Struct52 struct2;
				<Module>.memset((void*)(&struct2), 0, 12U);
				struct2 = 85;
				if (<Module>.smethod_15((byte*)(&struct2), 12U, (byte)num, 1, &gstruct) != null && <Module>.smethod_15((byte*)(&struct2), 12U, (byte)num, 1, &gstruct) != null)
				{
					this.textBox6.AppendText("Disable Execute Failed" + "\r\n");
					this.Cursor = Cursors.Arrow;
					result = 1;
				}
				else
				{
					Struct32 struct5;
					for (uint num4 = uint_0; num4 < uint_0 + uint_1; num4 += 1U)
					{
						*(ref @struct + 2) = (int)uint_2;
						*(ref @struct + 11) = (int)(num4 * uint_2);
						uint num5 = 0U;
						for (uint num6 = 0U; num6 < 382U; num6 += 1U)
						{
							num5 += (uint)(*(ref @struct + num6));
						}
						num5 = 65536U - (num5 & 65535U);
						*(ref @struct + 382) = (byte)(num5 & 255U);
						*(ref @struct + 383) = (byte)((num5 & 65280U) >> 8);
						for (uint num7 = 0U; num7 < num3; num7 += 1U)
						{
							<Module>.memset((void*)(&struct2), 0, 12U);
							struct2 = 231;
							*(ref struct2 + 1) = 72;
							*(ref struct2 + 2) = 73;
							*(ref struct2 + 3) = 84;
							*(ref struct2 + 4) = 204;
							*(ref struct2 + 5) = *(ref @struct + num7);
							*(ref struct2 + 8) = (byte)((num7 + 2147483648U & 4278190080U) >> 24);
							*(ref struct2 + 9) = (byte)((num7 + 2147483648U & 16711680U) >> 16);
							*(ref struct2 + 10) = (byte)((num7 + 2147483648U & 65280U) >> 8);
							*(ref struct2 + 11) = (byte)(num7 + 2147483648U & 255U);
							if (<Module>.smethod_15((byte*)(&struct2), 12U, (byte)num, 1, &gstruct) != null)
							{
								this.textBox6.AppendText("Ram Poke Failed" + "\r\n");
								this.Cursor = Cursors.Arrow;
								return 1;
							}
						}
						<Module>.memset((void*)(&struct2), 0, 12U);
						Struct103 struct3;
						<Module>.memset((void*)(&struct3), 0, 8U);
						struct2 = 85;
						*(ref struct2 + 1) = 16;
						*(ref struct2 + 8) = 8;
						*(ref struct3 + 1) = 6;
						uint num8;
						if (<Module>.smethod_17((byte*)(&struct2), 12U, (byte)num, 512, (void*)(&struct3), &num8, 8U, 1, &gstruct) != null)
						{
							this.textBox6.AppendText("Execute Enable Failed" + "\r\n");
							this.Cursor = Cursors.Arrow;
							return 1;
						}
						<Module>.memset((void*)(&struct2), 0, 12U);
						struct2 = 85;
						*(ref struct2 + 1) = 16;
						*(ref struct2 + 3) = 72;
						*(ref struct2 + 4) = 76;
						*(ref struct2 + 6) = 1;
						*(ref struct2 + 11) = 1;
						Struct116 struct4;
						if (<Module>.smethod_16((byte*)(&struct2), 12U, (byte)num, 512, (void*)(&struct4), &num8, uint_2, 1, &gstruct) != null)
						{
							this.textBox6.AppendText("Execute Failed" + "\r\n");
							this.Cursor = Cursors.Arrow;
							return 1;
						}
						byte* ptr = ref struct5 + num2 * uint_2;
						<Module>.memcpy((void*)ptr, (void*)(&struct4), uint_2);
						num2 += 1U;
						if (num4 % uint_3 == 0U)
						{
							this.textBox6.AppendText(".");
							Application.DoEvents();
						}
						<Module>.memset((void*)(&struct2), 0, 12U);
						<Module>.memset((void*)(&struct3), 0, 8U);
						struct2 = 85;
						*(ref struct2 + 1) = 16;
						*(ref struct2 + 8) = 8;
						*(ref struct3 + 1) = 6;
						if (<Module>.smethod_17((byte*)(&struct2), 12U, (byte)num, 512, (void*)(&struct3), &num8, 8U, 1, &gstruct) != null)
						{
							this.textBox6.AppendText("Execute Disable Failed" + "\r\n");
							this.Cursor = Cursors.Arrow;
							return 1;
						}
						num3 = 16U;
					}
					this.Cursor = Cursors.Arrow;
					<Module>.memcpy(*(ref <Module>.struct121_0 + 7172), (void*)(&struct5), 262144U);
					result = 0;
				}
			}
			return result;
		}

		// Token: 0x060003D8 RID: 984 RVA: 0x003CE34C File Offset: 0x0031634C
		private unsafe int method_401(uint uint_0, uint uint_1, uint uint_2, uint uint_3)
		{
			int result;
			if (this.comboBox16.Items.Count == 0)
			{
				<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
				MessageBox.Show("No drive Selected", "Warning", MessageBoxButtons.OK, MessageBoxIcon.Hand);
				<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
				result = 1;
			}
			else
			{
				Struct45 @struct;
				if (this.int_12 == 79)
				{
					<Module>.memcpy((void*)(&@struct), (void*)(&<Module>.struct45_0), 384U);
				}
				else if (this.int_12 == 59)
				{
					<Module>.memcpy((void*)(&@struct), (void*)(&<Module>.struct45_2), 384U);
				}
				else if (this.int_12 == 47)
				{
					<Module>.memcpy((void*)(&@struct), (void*)(&<Module>.struct45_4), 384U);
				}
				else if (this.int_12 == 36)
				{
					<Module>.memcpy((void*)(&@struct), (void*)(&<Module>.struct45_1), 384U);
				}
				else if (this.int_12 == 32)
				{
					<Module>.memcpy((void*)(&@struct), (void*)(&<Module>.struct45_3), 384U);
				}
				uint num = 0U;
				Struct108 struct2;
				byte* ptr = ref struct2 + 44;
				IntPtr intPtr = Marshal.StringToHGlobalAnsi(this.comboBox16.Text);
				IntPtr value = intPtr;
				sbyte* ptr2 = (sbyte*)((void*)value);
				if (*(sbyte*)ptr2 < 65 | *(sbyte*)ptr2 > 122)
				{
					result = 1;
				}
				else
				{
					Struct109 struct3;
					<Module>.sprintf((sbyte*)(&struct3), (sbyte*)(&<Module>.struct22_5), *(sbyte*)ptr2);
					void* ptr3 = <Module>.CreateFileA((sbyte*)(&struct3), -1073741824, 3, null, 3, 128, null);
					if (ptr3 == -1)
					{
						result = 1;
					}
					else
					{
						this.Cursor = Cursors.WaitCursor;
						Struct32 struct6;
						for (uint num2 = uint_0; num2 < uint_0 + uint_1; num2 += 1U)
						{
							*(ref @struct + 2) = (int)uint_2;
							*(ref @struct + 11) = (int)(num2 * uint_2);
							uint num3 = 0U;
							for (uint num4 = 0U; num4 < 382U; num4 += 1U)
							{
								num3 += (uint)(*(ref @struct + num4));
							}
							num3 = 65536U - (num3 & 65535U);
							*(ref @struct + 382) = (byte)(num3 & 255U);
							*(ref @struct + 383) = (byte)((num3 & 65280U) >> 8);
							<Module>.memset((void*)(&struct2), 0, 62U);
							*(ref struct2 + 28) = 85;
							struct2 = 44;
							*(ref struct2 + 6) = 12;
							*(ref struct2 + 7) = 18;
							*(ref struct2 + 8) = 2;
							*(ref struct2 + 16) = 15;
							*(ref struct2 + 24) = 44;
							uint num5;
							if (<Module>.DeviceIoControl(ptr3, 315412, (void*)(&struct2), 62, (void*)(&struct2), 62, (uint*)(&num5), null) == null && <Module>.DeviceIoControl(ptr3, 315412, (void*)(&struct2), 62, (void*)(&struct2), 62, (uint*)(&num5), null) == null)
							{
								this.textBox6.AppendText("Disable Execute Failed" + "\r\n");
								this.Cursor = Cursors.Arrow;
								<Module>.CloseHandle(ptr3);
								return 1;
							}
							<Module>.memset((void*)(&struct2), 0, 62U);
							*(ref struct2 + 28) = 85;
							*(ref struct2 + 29) = 16;
							*(ref struct2 + 36) = 16;
							*(ref struct2 + 39) = 1;
							Struct28 struct4;
							<Module>.memset((void*)(&struct4), 0, 16U);
							*(ref struct4 + 9) = 6;
							*(ref struct4 + 10) = 72;
							*(ref struct4 + 11) = 76;
							*(ref struct4 + 12) = 0;
							*(ref struct4 + 13) = 0;
							*(ref struct4 + 14) = 1;
							*(ref struct4 + 15) = 128;
							struct2 = 44;
							*(ref struct2 + 6) = 12;
							*(ref struct2 + 7) = 18;
							*(ref struct2 + 8) = 0;
							*(ref struct2 + 12) = 16;
							*(ref struct2 + 16) = 15;
							*(ref struct2 + 20) = ref struct4;
							*(ref struct2 + 24) = 44;
							if (<Module>.DeviceIoControl(ptr3, 315412, (void*)(&struct2), 62, (void*)(&struct2), 62, (uint*)(&num5), null) == null || (ptr[2] & 15) != 0)
							{
								this.textBox6.AppendText("Configure Upload Failed" + "\r\n");
								this.Cursor = Cursors.Arrow;
								<Module>.CloseHandle(ptr3);
								return 1;
							}
							<Module>.memset((void*)(&struct2), 0, 62U);
							<Module>.memset((void*)(&<Module>.struct119_1), 0, 392U);
							*(ref struct2 + 28) = 85;
							*(ref struct2 + 29) = 16;
							*(ref struct2 + 35) = 1;
							*(ref struct2 + 36) = 136;
							*(ref struct2 + 39) = 1;
							<Module>.memset((void*)(&<Module>.struct119_1), 0, 392U);
							*(ref <Module>.struct119_1 + 4) = 72;
							*(ref <Module>.struct119_1 + 5) = 76;
							<Module>.memcpy(ref <Module>.struct119_1 + 8, (void*)(&@struct), 384U);
							struct2 = 44;
							*(ref struct2 + 6) = 12;
							*(ref struct2 + 7) = 18;
							*(ref struct2 + 8) = 0;
							*(ref struct2 + 12) = 392;
							*(ref struct2 + 16) = 15;
							*(ref struct2 + 20) = ref <Module>.struct119_1;
							*(ref struct2 + 24) = 44;
							if (<Module>.DeviceIoControl(ptr3, 315412, (void*)(&struct2), 62, (void*)(&struct2), 62, (uint*)(&num5), null) == null || (ptr[2] & 15) != 0)
							{
								this.textBox6.AppendText("Upload buffer failed" + "\r\n");
								<Module>.CloseHandle(ptr3);
								this.Cursor = Cursors.Arrow;
								return 1;
							}
							Struct116 struct5;
							<Module>.memset((void*)(&struct5), 0, 32768U);
							<Module>.memset((void*)(&struct2), 0, 62U);
							*(ref struct2 + 28) = 85;
							*(ref struct2 + 29) = 16;
							*(ref struct2 + 31) = 72;
							*(ref struct2 + 32) = 76;
							*(ref struct2 + 34) = 1;
							*(ref struct2 + 39) = 1;
							struct2 = 44;
							*(ref struct2 + 6) = 12;
							*(ref struct2 + 7) = 18;
							*(ref struct2 + 8) = 1;
							*(ref struct2 + 12) = (int)uint_2;
							*(ref struct2 + 16) = 15;
							*(ref struct2 + 20) = ref struct5;
							*(ref struct2 + 24) = 44;
							if (<Module>.DeviceIoControl(ptr3, 315412, (void*)(&struct2), 62, (void*)(&struct2), 62, (uint*)(&num5), null) == null)
							{
								this.textBox6.AppendText("Ram Execute Failed" + "\r\n");
								this.Cursor = Cursors.Arrow;
								<Module>.CloseHandle(ptr3);
								return 1;
							}
							byte* ptr4 = ref struct6 + num * uint_2;
							<Module>.memcpy((void*)ptr4, (void*)(&struct5), uint_2);
							num += 1U;
							if (num2 % uint_3 == 0U)
							{
								this.textBox6.AppendText(".");
								Application.DoEvents();
							}
						}
						this.Cursor = Cursors.Arrow;
						<Module>.memcpy(*(ref <Module>.struct121_0 + 7172), (void*)(&struct6), 262144U);
						<Module>.CloseHandle(ptr3);
						result = 0;
					}
				}
			}
			return result;
		}

		// Token: 0x060003D9 RID: 985 RVA: 0x003CE8E4 File Offset: 0x003168E4
		private unsafe int method_402(uint uint_0, uint uint_1, uint uint_2, uint uint_3)
		{
			uint uint_4 = uint_2 * uint_1;
			int result;
			if (this.comboBox1.Items.Count == 0)
			{
				result = 0;
			}
			else
			{
				uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
				ushort ushort_ = *(ref <Module>.struct38_0 + selectedIndex * 72U);
				uint num;
				if (*(ref <Module>.struct38_0 + selectedIndex * 72U + 4) == 160)
				{
					num = 0U;
				}
				else
				{
					num = 16U;
				}
				Struct45 @struct;
				if (this.int_12 == 79)
				{
					<Module>.memcpy((void*)(&@struct), (void*)(&<Module>.struct45_0), 384U);
				}
				else if (this.int_12 == 59)
				{
					<Module>.memcpy((void*)(&@struct), (void*)(&<Module>.struct45_2), 384U);
				}
				else if (this.int_12 == 47)
				{
					<Module>.memcpy((void*)(&@struct), (void*)(&<Module>.struct45_4), 384U);
				}
				else if (this.int_12 == 36)
				{
					<Module>.memcpy((void*)(&@struct), (void*)(&<Module>.struct45_1), 384U);
				}
				else if (this.int_12 == 32)
				{
					<Module>.memcpy((void*)(&@struct), (void*)(&<Module>.struct45_3), 384U);
				}
				uint num2 = 0U;
				GStruct3 gstruct;
				<Module>.smethod_21(&gstruct, ushort_, 0, 1, 10000U);
				this.Cursor = Cursors.WaitCursor;
				Struct32 struct5;
				for (uint num3 = uint_0; num3 < uint_0 + uint_1; num3 += 1U)
				{
					*(ref @struct + 2) = (int)uint_2;
					*(ref @struct + 11) = (int)(num3 * uint_2);
					uint num4 = 0U;
					for (uint num5 = 0U; num5 < 382U; num5 += 1U)
					{
						num4 += (uint)(*(ref @struct + num5));
					}
					num4 = 65536U - (num4 & 65535U);
					*(ref @struct + 382) = (byte)(num4 & 255U);
					*(ref @struct + 383) = (byte)((num4 & 65280U) >> 8);
					Struct52 struct2;
					<Module>.memset((void*)(&struct2), 0, 12U);
					struct2 = 85;
					if (<Module>.smethod_15((byte*)(&struct2), 12U, (byte)num, 1, &gstruct) != null && <Module>.smethod_15((byte*)(&struct2), 12U, (byte)num, 1, &gstruct) != null)
					{
						this.textBox6.AppendText("Disable Execute Failed" + "\r\n");
						this.Cursor = Cursors.Arrow;
						return 1;
					}
					<Module>.memset((void*)(&struct2), 0, 12U);
					struct2 = 85;
					*(ref struct2 + 1) = 16;
					*(ref struct2 + 8) = 16;
					*(ref struct2 + 11) = 1;
					Struct117 struct3;
					<Module>.memset((void*)(&struct3), 0, 22U);
					*(ref struct3 + 9) = 6;
					*(ref struct3 + 10) = 72;
					*(ref struct3 + 11) = 76;
					*(ref struct3 + 12) = 0;
					*(ref struct3 + 13) = 0;
					*(ref struct3 + 14) = 1;
					*(ref struct3 + 15) = 128;
					uint num6;
					if (<Module>.smethod_17((byte*)(&struct2), 12U, (byte)num, 512, (void*)(&struct3), &num6, 16U, 1, &gstruct) != null)
					{
						this.textBox6.AppendText("Configure Upload Failed" + "\r\n");
						this.Cursor = Cursors.Arrow;
						return 1;
					}
					<Module>.memset((void*)(&struct2), 0, 12U);
					struct2 = 85;
					*(ref struct2 + 1) = 16;
					*(ref struct2 + 7) = 1;
					*(ref struct2 + 8) = 136;
					*(ref struct2 + 11) = 1;
					<Module>.memset((void*)(&<Module>.struct119_0), 0, 392U);
					*(ref <Module>.struct119_0 + 4) = 72;
					*(ref <Module>.struct119_0 + 5) = 76;
					<Module>.memcpy(ref <Module>.struct119_0 + 8, (void*)(&@struct), 384U);
					if (<Module>.smethod_17((byte*)(&struct2), 12U, (byte)num, 512, (void*)(&<Module>.struct119_0), &num6, 392U, 1, &gstruct) != null)
					{
						this.textBox6.AppendText("Upload buffer failed" + "\r\n");
						this.Cursor = Cursors.Arrow;
						return 1;
					}
					<Module>.memset((void*)(&struct2), 0, 12U);
					struct2 = 85;
					*(ref struct2 + 1) = 16;
					*(ref struct2 + 3) = 72;
					*(ref struct2 + 4) = 76;
					*(ref struct2 + 6) = 1;
					*(ref struct2 + 11) = 1;
					Struct116 struct4;
					if (<Module>.smethod_16((byte*)(&struct2), 12U, (byte)num, 512, (void*)(&struct4), &num6, uint_2, 1, &gstruct) != null)
					{
						this.textBox6.AppendText("Execute Failed" + "\r\n");
						this.Cursor = Cursors.Arrow;
						return 1;
					}
					byte* ptr = ref struct5 + num2 * uint_2;
					<Module>.memcpy((void*)ptr, (void*)(&struct4), uint_2);
					num2 += 1U;
					if (num3 % uint_3 == 0U)
					{
						this.textBox6.AppendText(".");
						Application.DoEvents();
					}
				}
				this.Cursor = Cursors.Arrow;
				<Module>.memcpy(*(ref <Module>.struct121_0 + 7172), (void*)(&struct5), uint_4);
				result = 0;
			}
			return result;
		}

		// Token: 0x060003DA RID: 986 RVA: 0x00153040 File Offset: 0x00153040
		private unsafe int method_403(byte* pByte_0, uint uint_0, uint uint_1)
		{
			if (this.int_13 == 1 && this.int_15 == 0)
			{
				if (this.method_404(pByte_0, uint_0, uint_1) != 0)
				{
					return 1;
				}
			}
			else if (this.int_13 == 2 && this.int_15 == 0)
			{
				if (this.method_406(pByte_0, uint_0, uint_1) != 0)
				{
					return 1;
				}
			}
			else if (this.int_13 == 3 && this.int_15 == 0)
			{
				if (this.method_408(pByte_0, uint_0, uint_1) != 0)
				{
					return 1;
				}
			}
			else if (this.int_13 == 1 && this.int_15 == 1)
			{
				if (this.method_405(pByte_0, uint_0, uint_1) != 0)
				{
					return 1;
				}
			}
			else if (this.int_13 == 2 && this.int_15 == 1)
			{
				if (this.method_407(pByte_0, uint_0, uint_1) != 0)
				{
					return 1;
				}
			}
			else
			{
				if (this.int_13 != 3 || this.int_15 != 1)
				{
					return 1;
				}
				if (this.method_409(pByte_0, uint_0, uint_1) != 0)
				{
					return 1;
				}
			}
			return 0;
		}

		// Token: 0x060003DB RID: 987 RVA: 0x00153128 File Offset: 0x00153128
		private unsafe int method_404(byte* pByte_0, uint uint_0, uint uint_1)
		{
			ushort num = 255;
			int result;
			if (this.comboBox16.Items.Count == 0)
			{
				MessageBox.Show("No drive Selected", "Warning", MessageBoxButtons.OK, MessageBoxIcon.Hand);
				<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
				result = 1;
			}
			else
			{
				Struct108 @struct;
				byte* ptr = ref @struct + 44;
				string str = this.comboBox16.Text.Substring(0, 1);
				IntPtr intPtr = Marshal.StringToHGlobalAnsi(this.comboBox16.Text);
				IntPtr value = intPtr;
				sbyte* ptr2 = (sbyte*)((void*)value);
				if (*(sbyte*)ptr2 < 65 | *(sbyte*)ptr2 > 122)
				{
					result = 1;
				}
				else
				{
					Struct109 struct2;
					<Module>.sprintf((sbyte*)(&struct2), (sbyte*)(&<Module>.struct22_5), *(sbyte*)ptr2);
					void* ptr3 = <Module>.CreateFileA((sbyte*)(&struct2), -1073741824, 3, null, 3, 128, null);
					if (ptr3 == -1)
					{
						this.textBox6.AppendText("Failed to open drive " + str + "\r\n");
						result = 1;
					}
					else
					{
						Struct63 struct3;
						*(ref struct3 + 3) = (byte)(uint_0 & 255U);
						*(ref struct3 + 2) = (byte)((uint_0 & 65280U) >> 8);
						*(ref struct3 + 1) = (byte)((uint_0 & 16711680U) >> 16);
						struct3 = (uint_0 & 4278190080U) >> 24;
						this.method_6((byte*)(&struct3), 4U, 0U);
						this.textBox6.AppendText("Flashing Sector" + " " + this.string_0 + "\r\n");
						uint num2 = uint_1 + 2184U;
						if ((num2 & 3U) != 0U)
						{
							num2 += 4U - (num2 & 3U);
						}
						byte* ptr4 = <Module>.malloc(num2);
						if (ptr4 == null)
						{
							<Module>.CloseHandle(ptr3);
							result = 1;
						}
						else
						{
							<Module>.memset((void*)ptr4, 0, num2);
							uint num3;
							if (num == 0)
							{
								num3 = uint_0;
								uint_0 = (uint)(*(ref num3 + 3));
								*(ref uint_0 + 1) = *(ref num3 + 2);
								*(ref uint_0 + 2) = *(ref num3 + 1);
								*(ref uint_0 + 3) = (byte)num3;
								num3 = (uint)(*(ref uint_1 + 3));
								*(ref num3 + 1) = *(ref uint_1 + 2);
								*(ref num3 + 2) = *(ref uint_1 + 1);
								*(ref num3 + 3) = (byte)uint_1;
							}
							else
							{
								num3 = uint_1;
							}
							*(ref <Module>.struct54_0 + 8) = (int)uint_0;
							*(ref <Module>.struct54_0 + 30) = (int)uint_0;
							*(ref <Module>.struct54_0 + 48) = (int)num3;
							if (this.int_12 == 79)
							{
								*(ref <Module>.struct54_0 + 64) = 241;
							}
							else if (this.int_12 == 59)
							{
								*(ref <Module>.struct54_0 + 64) = 221;
							}
							else if (this.int_12 == 47)
							{
								*(ref <Module>.struct54_0 + 64) = 217;
							}
							else if (this.int_12 == 36)
							{
								*(ref <Module>.struct54_0 + 64) = 209;
							}
							else if (this.int_12 == 32)
							{
								*(ref <Module>.struct54_0 + 64) = 213;
							}
							<Module>.memcpy((void*)ptr4, (void*)(&<Module>.struct54_0), 74U);
							byte* ptr5 = ptr4 + 74;
							<Module>.memcpy((void*)ptr5, (void*)(&<Module>.struct44_0), 1136U);
							ptr5 = ptr4 + 1210;
							<Module>.memcpy((void*)ptr5, (void*)(&<Module>.struct57_0), 972U);
							ptr5 = ptr4 + 2182;
							byte* ptr6 = pByte_0 + (uint_0 - 2415919104U);
							<Module>.memcpy((void*)ptr5, (void*)ptr6, uint_1);
							uint num4 = 0U;
							for (num3 = 0U; num3 < num2 - 2U; num3 += 1U)
							{
								num4 += (uint)ptr4[num3];
							}
							num4 = 65536U - (num4 & 65535U);
							ptr4[num2 - 2U] = (byte)(num4 & 255U);
							ptr4[num2 - 1U] = (byte)((num4 & 65280U) >> 8);
							<Module>.memset((void*)(&@struct), 0, 62U);
							*(ref @struct + 28) = 231;
							*(ref @struct + 29) = 72;
							*(ref @struct + 30) = 73;
							*(ref @struct + 31) = 84;
							*(ref @struct + 32) = 59;
							*(ref @struct + 33) = 6;
							*(ref @struct + 38) = (byte)((num2 & 65280U) >> 8);
							*(ref @struct + 39) = (byte)(num2 & 255U);
							@struct = 44;
							*(ref @struct + 6) = 12;
							*(ref @struct + 7) = 18;
							*(ref @struct + 8) = 0;
							*(ref @struct + 12) = (int)num2;
							*(ref @struct + 16) = 15;
							*(ref @struct + 20) = ptr4;
							*(ref @struct + 24) = 44;
							uint num5;
							if (<Module>.DeviceIoControl(ptr3, 315412, (void*)(&@struct), 62, (void*)(&@struct), 62, (uint*)(&num5), null) == null)
							{
								this.textBox6.AppendText("\r\n" + "Sector Upload Failed" + "\r\n");
								<Module>.CloseHandle(ptr3);
								result = 1;
							}
							else
							{
								<Module>.memset((void*)(&@struct), 0, 62U);
								*(ref @struct + 28) = 231;
								*(ref @struct + 29) = 72;
								*(ref @struct + 30) = 73;
								*(ref @struct + 31) = 84;
								*(ref @struct + 32) = 59;
								*(ref @struct + 33) = 7;
								*(ref @struct + 39) = 1;
								@struct = 44;
								*(ref @struct + 6) = 12;
								*(ref @struct + 7) = 18;
								*(ref @struct + 8) = 2;
								*(ref @struct + 16) = 15;
								*(ref @struct + 24) = 44;
								if (<Module>.DeviceIoControl(ptr3, 315396, (void*)(&@struct), 62, (void*)(&@struct), 62, (uint*)(&num5), null) != null && (ptr[2] & 15) == 0)
								{
									<Module>.CloseHandle(ptr3);
									<Module>.free((void*)ptr4);
									result = 0;
								}
								else
								{
									this.textBox6.AppendText("Flash Code Execute Failed!" + "\r\n");
									<Module>.CloseHandle(ptr3);
									result = 1;
								}
							}
						}
					}
				}
			}
			return result;
		}

		// Token: 0x060003DC RID: 988 RVA: 0x001535C8 File Offset: 0x001535C8
		private unsafe int method_405(byte* pByte_0, uint uint_0, uint uint_1)
		{
			ushort num = 255;
			int result;
			if (this.comboBox1.Items.Count == 0)
			{
				result = 0;
			}
			else
			{
				uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
				ushort ushort_ = *(ref <Module>.struct38_0 + selectedIndex * 72U);
				uint num2;
				if (*(ref <Module>.struct38_0 + selectedIndex * 72U + 4) == 160)
				{
					num2 = 0U;
				}
				else
				{
					num2 = 16U;
				}
				Struct63 @struct;
				*(ref @struct + 3) = (byte)(uint_0 & 255U);
				*(ref @struct + 2) = (byte)((uint_0 & 65280U) >> 8);
				*(ref @struct + 1) = (byte)((uint_0 & 16711680U) >> 16);
				@struct = (uint_0 & 4278190080U) >> 24;
				this.method_6((byte*)(&@struct), 4U, 0U);
				this.textBox6.AppendText("Flashing Sector" + " " + this.string_0 + "\r\n");
				uint num3 = uint_1 + 2184U;
				if ((num3 & 3U) != 0U)
				{
					num3 += 4U - (num3 & 3U);
				}
				byte* ptr = <Module>.malloc(num3);
				if (ptr == null)
				{
					result = 1;
				}
				else
				{
					<Module>.memset((void*)ptr, 0, num3);
					uint num4;
					if (num == 0)
					{
						num4 = uint_0;
						uint_0 = (uint)(*(ref num4 + 3));
						*(ref uint_0 + 1) = *(ref num4 + 2);
						*(ref uint_0 + 2) = *(ref num4 + 1);
						*(ref uint_0 + 3) = (byte)num4;
						num4 = (uint)(*(ref uint_1 + 3));
						*(ref num4 + 1) = *(ref uint_1 + 2);
						*(ref num4 + 2) = *(ref uint_1 + 1);
						*(ref num4 + 3) = (byte)uint_1;
					}
					else
					{
						num4 = uint_1;
					}
					*(ref <Module>.struct54_0 + 8) = (int)uint_0;
					*(ref <Module>.struct54_0 + 30) = (int)uint_0;
					*(ref <Module>.struct54_0 + 48) = (int)num4;
					if (this.int_12 == 79)
					{
						*(ref <Module>.struct54_0 + 64) = 241;
					}
					else if (this.int_12 == 59)
					{
						*(ref <Module>.struct54_0 + 64) = 221;
					}
					else if (this.int_12 == 47)
					{
						*(ref <Module>.struct54_0 + 64) = 217;
					}
					else if (this.int_12 == 36)
					{
						*(ref <Module>.struct54_0 + 64) = 209;
					}
					else if (this.int_12 == 32)
					{
						*(ref <Module>.struct54_0 + 64) = 213;
					}
					<Module>.memcpy((void*)ptr, (void*)(&<Module>.struct54_0), 74U);
					byte* ptr2 = ptr + 74;
					<Module>.memcpy((void*)ptr2, (void*)(&<Module>.struct44_0), 1136U);
					ptr2 = ptr + 1210;
					<Module>.memcpy((void*)ptr2, (void*)(&<Module>.struct57_0), 972U);
					ptr2 = ptr + 2182;
					byte* ptr3 = pByte_0 + (uint_0 - 2415919104U);
					<Module>.memcpy((void*)ptr2, (void*)ptr3, uint_1);
					uint num5 = 0U;
					for (num4 = 0U; num4 < num3 - 2U; num4 += 1U)
					{
						num5 += (uint)ptr[num4];
					}
					num5 = 65536U - (num5 & 65535U);
					ptr[num3 - 2U] = (byte)(num5 & 255U);
					ptr[num3 - 1U] = (byte)((num5 & 65280U) >> 8);
					this.Cursor = Cursors.WaitCursor;
					GStruct3 gstruct;
					<Module>.smethod_21(&gstruct, ushort_, 0, 1, 10000U);
					Struct52 struct2;
					<Module>.memset((void*)(&struct2), 0, 12U);
					struct2 = 231;
					*(ref struct2 + 1) = 72;
					*(ref struct2 + 2) = 73;
					*(ref struct2 + 3) = 84;
					*(ref struct2 + 4) = 59;
					*(ref struct2 + 5) = 6;
					*(ref struct2 + 10) = (byte)((num3 & 65280U) >> 8);
					*(ref struct2 + 11) = (byte)(num3 & 255U);
					uint num6;
					if (<Module>.smethod_17((byte*)(&struct2), 12U, (byte)num2, 512, (void*)ptr, &num6, num3, 1, &gstruct) != null)
					{
						this.textBox6.AppendText("Ram Upload Dump Failed" + "\r\n");
						this.Cursor = Cursors.Arrow;
						result = 1;
					}
					else
					{
						<Module>.memset((void*)(&struct2), 0, 12U);
						struct2 = 231;
						*(ref struct2 + 1) = 72;
						*(ref struct2 + 2) = 73;
						*(ref struct2 + 3) = 84;
						*(ref struct2 + 4) = 59;
						*(ref struct2 + 5) = 7;
						*(ref struct2 + 11) = 1;
						if (<Module>.smethod_15((byte*)(&struct2), 12U, (byte)num2, 1, &gstruct) != null)
						{
							this.textBox6.AppendText("Flash Code Execute Failed!" + "\r\n");
							this.Cursor = Cursors.Arrow;
							<Module>.free((void*)ptr);
							result = 1;
						}
						else
						{
							this.Cursor = Cursors.Arrow;
							<Module>.free((void*)ptr);
							result = 0;
						}
					}
				}
			}
			return result;
		}

		// Token: 0x060003DD RID: 989 RVA: 0x003CED00 File Offset: 0x00316D00
		private unsafe int method_406(byte* pByte_0, uint uint_0, uint uint_1)
		{
			ushort num = 255;
			int result;
			if (this.comboBox16.Items.Count == 0)
			{
				<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
				MessageBox.Show("No drive Selected", "Warning", MessageBoxButtons.OK, MessageBoxIcon.Hand);
				<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
				result = 1;
			}
			else
			{
				string str = this.comboBox16.Text.Substring(0, 1);
				IntPtr intPtr = Marshal.StringToHGlobalAnsi(this.comboBox16.Text);
				IntPtr value = intPtr;
				sbyte* ptr = (sbyte*)((void*)value);
				if (*(sbyte*)ptr < 65 | *(sbyte*)ptr > 122)
				{
					result = 1;
				}
				else
				{
					Struct109 @struct;
					<Module>.sprintf((sbyte*)(&@struct), (sbyte*)(&<Module>.struct22_5), *(sbyte*)ptr);
					void* ptr2 = <Module>.CreateFileA((sbyte*)(&@struct), -1073741824, 3, null, 3, 128, null);
					if (ptr2 == -1)
					{
						this.textBox6.AppendText("Failed to open drive " + str + "\r\n");
						result = 1;
					}
					else
					{
						this.Cursor = Cursors.WaitCursor;
						Struct63 struct2;
						*(ref struct2 + 3) = (byte)(uint_0 & 255U);
						*(ref struct2 + 2) = (byte)((uint_0 & 65280U) >> 8);
						*(ref struct2 + 1) = (byte)((uint_0 & 16711680U) >> 16);
						struct2 = (uint_0 & 4278190080U) >> 24;
						this.method_6((byte*)(&struct2), 4U, 0U);
						this.textBox6.AppendText("Flashing Sector" + " " + this.string_0 + "\r\n");
						uint num2 = uint_1 + 2184U;
						if ((num2 & 3U) != 0U)
						{
							num2 += 4U - (num2 & 3U);
						}
						byte* ptr3 = <Module>.malloc(num2);
						if (ptr3 == null)
						{
							this.textBox6.AppendText("Malloc failed!" + "\r\n");
							<Module>.CloseHandle(ptr2);
							this.Cursor = Cursors.Arrow;
							result = 1;
						}
						else
						{
							<Module>.memset((void*)ptr3, 0, num2);
							uint num3;
							if (num == 0)
							{
								num3 = uint_0;
								uint_0 = (uint)(*(ref num3 + 3));
								*(ref uint_0 + 1) = *(ref num3 + 2);
								*(ref uint_0 + 2) = *(ref num3 + 1);
								*(ref uint_0 + 3) = (byte)num3;
								num3 = (uint)(*(ref uint_1 + 3));
								*(ref num3 + 1) = *(ref uint_1 + 2);
								*(ref num3 + 2) = *(ref uint_1 + 1);
								*(ref num3 + 3) = (byte)uint_1;
							}
							else
							{
								num3 = uint_1;
							}
							*(ref <Module>.struct54_0 + 8) = (int)uint_0;
							*(ref <Module>.struct54_0 + 30) = (int)uint_0;
							*(ref <Module>.struct54_0 + 48) = (int)num3;
							if (this.int_12 == 79)
							{
								*(ref <Module>.struct54_0 + 64) = 241;
							}
							else if (this.int_12 == 59)
							{
								*(ref <Module>.struct54_0 + 64) = 221;
							}
							else if (this.int_12 == 47)
							{
								*(ref <Module>.struct54_0 + 64) = 217;
							}
							else if (this.int_12 == 36)
							{
								*(ref <Module>.struct54_0 + 64) = 209;
							}
							else if (this.int_12 == 32)
							{
								*(ref <Module>.struct54_0 + 64) = 213;
							}
							<Module>.memcpy((void*)ptr3, (void*)(&<Module>.struct54_0), 74U);
							byte* ptr4 = ptr3 + 74;
							<Module>.memcpy((void*)ptr4, (void*)(&<Module>.struct44_0), 1136U);
							ptr4 = ptr3 + 1210;
							<Module>.memcpy((void*)ptr4, (void*)(&<Module>.struct57_0), 972U);
							ptr4 = ptr3 + 2182;
							byte* ptr5 = pByte_0 + (uint_0 - 2415919104U);
							<Module>.memcpy((void*)ptr4, (void*)ptr5, uint_1);
							uint num4 = 0U;
							for (num3 = 0U; num3 < num2 - 2U; num3 += 1U)
							{
								num4 += (uint)ptr3[num3];
							}
							num4 = 65536U - (num4 & 65535U);
							ptr3[num2 - 2U] = (byte)(num4 & 255U);
							ptr3[num2 - 1U] = (byte)((num4 & 65280U) >> 8);
							Struct108 struct3;
							uint num6;
							for (uint num5 = 0U; num5 < num2; num5 += 1U)
							{
								<Module>.memset((void*)(&struct3), 0, 62U);
								*(ref struct3 + 28) = 231;
								*(ref struct3 + 29) = 72;
								*(ref struct3 + 30) = 73;
								*(ref struct3 + 31) = 84;
								*(ref struct3 + 32) = 204;
								*(ref struct3 + 33) = ptr3[num5];
								*(ref struct3 + 36) = (byte)((num5 + 2147483648U & 4278190080U) >> 24);
								*(ref struct3 + 37) = (byte)((num5 + 2147483648U & 16711680U) >> 16);
								*(ref struct3 + 38) = (byte)((num5 + 2147483648U & 65280U) >> 8);
								*(ref struct3 + 39) = (byte)(num5 + 2147483648U & 255U);
								struct3 = 44;
								*(ref struct3 + 6) = 12;
								*(ref struct3 + 7) = 18;
								*(ref struct3 + 8) = 2;
								*(ref struct3 + 16) = 15;
								*(ref struct3 + 24) = 44;
								if (<Module>.DeviceIoControl(ptr2, 315412, (void*)(&struct3), 62, (void*)(&struct3), 62, (uint*)(&num6), null) == null)
								{
									this.textBox6.AppendText("Ram Poke Upload Failed" + "\r\n");
									<Module>.CloseHandle(ptr2);
									this.Cursor = Cursors.Arrow;
									<Module>.free((void*)ptr3);
									return 1;
								}
								if (num5 % 256U == 0U)
								{
									this.textBox6.AppendText(".");
									Application.DoEvents();
								}
							}
							<Module>.memset((void*)(&struct3), 0, 62U);
							*(ref struct3 + 28) = 85;
							*(ref struct3 + 29) = 16;
							*(ref struct3 + 36) = 8;
							Struct103 struct4;
							<Module>.memset((void*)(&struct4), 0, 8U);
							*(ref struct4 + 1) = 6;
							struct3 = 44;
							*(ref struct3 + 6) = 12;
							*(ref struct3 + 7) = 18;
							*(ref struct3 + 8) = 0;
							*(ref struct3 + 12) = 8;
							*(ref struct3 + 16) = 15;
							*(ref struct3 + 20) = ref struct4;
							*(ref struct3 + 24) = 44;
							if (<Module>.DeviceIoControl(ptr2, 315412, (void*)(&struct3), 62, (void*)(&struct3), 62, (uint*)(&num6), null) == null)
							{
								this.textBox6.AppendText("Set (59E) bit 3 via Mode Select(10) failed" + "\r\n");
								<Module>.CloseHandle(ptr2);
								this.Cursor = Cursors.Arrow;
								<Module>.free((void*)ptr3);
								result = 1;
							}
							else
							{
								<Module>.memset((void*)(&struct3), 0, 62U);
								*(ref struct3 + 28) = 85;
								*(ref struct3 + 29) = 16;
								*(ref struct3 + 31) = 72;
								*(ref struct3 + 32) = 76;
								*(ref struct3 + 34) = 1;
								*(ref struct3 + 39) = 1;
								struct3 = 44;
								*(ref struct3 + 6) = 12;
								*(ref struct3 + 7) = 18;
								*(ref struct3 + 8) = 2;
								*(ref struct3 + 16) = 15;
								*(ref struct3 + 24) = 44;
								if (<Module>.DeviceIoControl(ptr2, 315412, (void*)(&struct3), 62, (void*)(&struct3), 62, (uint*)(&num6), null) == null)
								{
									this.textBox6.AppendText("Flash Code Execute Failed!" + "\r\n");
									<Module>.CloseHandle(ptr2);
									this.Cursor = Cursors.Arrow;
									<Module>.free((void*)ptr3);
									result = 1;
								}
								else
								{
									<Module>.CloseHandle(ptr2);
									this.Cursor = Cursors.Arrow;
									<Module>.free((void*)ptr3);
									result = 0;
								}
							}
						}
					}
				}
			}
			return result;
		}

		// Token: 0x060003DE RID: 990 RVA: 0x00153FBC File Offset: 0x00153FBC
		private unsafe int method_407(byte* pByte_0, uint uint_0, uint uint_1)
		{
			ushort num = 255;
			int result;
			if (this.comboBox1.Items.Count == 0)
			{
				result = 0;
			}
			else
			{
				uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
				ushort ushort_ = *(ref <Module>.struct38_0 + selectedIndex * 72U);
				uint num2;
				if (*(ref <Module>.struct38_0 + selectedIndex * 72U + 4) == 160)
				{
					num2 = 0U;
				}
				else
				{
					num2 = 16U;
				}
				Struct63 @struct;
				*(ref @struct + 3) = (byte)(uint_0 & 255U);
				*(ref @struct + 2) = (byte)((uint_0 & 65280U) >> 8);
				*(ref @struct + 1) = (byte)((uint_0 & 16711680U) >> 16);
				@struct = (uint_0 & 4278190080U) >> 24;
				this.method_6((byte*)(&@struct), 4U, 0U);
				this.textBox6.AppendText("Flashing Sector" + " " + this.string_0 + "\r\n");
				uint num3 = uint_1 + 2184U;
				if ((num3 & 3U) != 0U)
				{
					num3 += 4U - (num3 & 3U);
				}
				byte* ptr = <Module>.malloc(num3);
				if (ptr == null)
				{
					result = 1;
				}
				else
				{
					<Module>.memset((void*)ptr, 0, num3);
					uint num4;
					if (num == 0)
					{
						num4 = uint_0;
						uint_0 = (uint)(*(ref num4 + 3));
						*(ref uint_0 + 1) = *(ref num4 + 2);
						*(ref uint_0 + 2) = *(ref num4 + 1);
						*(ref uint_0 + 3) = (byte)num4;
						num4 = (uint)(*(ref uint_1 + 3));
						*(ref num4 + 1) = *(ref uint_1 + 2);
						*(ref num4 + 2) = *(ref uint_1 + 1);
						*(ref num4 + 3) = (byte)uint_1;
					}
					else
					{
						num4 = uint_1;
					}
					*(ref <Module>.struct54_0 + 8) = (int)uint_0;
					*(ref <Module>.struct54_0 + 30) = (int)uint_0;
					*(ref <Module>.struct54_0 + 48) = (int)num4;
					if (this.int_12 == 79)
					{
						*(ref <Module>.struct54_0 + 64) = 241;
					}
					else if (this.int_12 == 59)
					{
						*(ref <Module>.struct54_0 + 64) = 221;
					}
					else if (this.int_12 == 47)
					{
						*(ref <Module>.struct54_0 + 64) = 217;
					}
					else if (this.int_12 == 36)
					{
						*(ref <Module>.struct54_0 + 64) = 209;
					}
					else if (this.int_12 == 32)
					{
						*(ref <Module>.struct54_0 + 64) = 213;
					}
					<Module>.memcpy((void*)ptr, (void*)(&<Module>.struct54_0), 74U);
					byte* ptr2 = ptr + 74;
					<Module>.memcpy((void*)ptr2, (void*)(&<Module>.struct44_0), 1136U);
					ptr2 = ptr + 1210;
					<Module>.memcpy((void*)ptr2, (void*)(&<Module>.struct57_0), 972U);
					ptr2 = ptr + 2182;
					byte* ptr3 = pByte_0 + (uint_0 - 2415919104U);
					<Module>.memcpy((void*)ptr2, (void*)ptr3, uint_1);
					uint num5 = 0U;
					for (num4 = 0U; num4 < num3 - 2U; num4 += 1U)
					{
						num5 += (uint)ptr[num4];
					}
					num5 = 65536U - (num5 & 65535U);
					ptr[num3 - 2U] = (byte)(num5 & 255U);
					ptr[num3 - 1U] = (byte)((num5 & 65280U) >> 8);
					this.Cursor = Cursors.WaitCursor;
					GStruct3 gstruct;
					<Module>.smethod_21(&gstruct, ushort_, 0, 1, 10000U);
					Struct52 struct2;
					<Module>.memset((void*)(&struct2), 0, 12U);
					struct2 = 85;
					if (<Module>.smethod_15((byte*)(&struct2), 12U, (byte)num2, 1, &gstruct) != null && <Module>.smethod_15((byte*)(&struct2), 12U, (byte)num2, 1, &gstruct) != null)
					{
						this.textBox6.AppendText("Disable Execute Failed" + "\r\n");
						this.Cursor = Cursors.Arrow;
						result = 1;
					}
					else
					{
						for (uint num6 = 0U; num6 < num3; num6 += 1U)
						{
							<Module>.memset((void*)(&struct2), 0, 12U);
							struct2 = 231;
							*(ref struct2 + 1) = 72;
							*(ref struct2 + 2) = 73;
							*(ref struct2 + 3) = 84;
							*(ref struct2 + 4) = 204;
							*(ref struct2 + 5) = ptr[num6];
							*(ref struct2 + 8) = (byte)((num6 + 2147483648U & 4278190080U) >> 24);
							*(ref struct2 + 9) = (byte)((num6 + 2147483648U & 16711680U) >> 16);
							*(ref struct2 + 10) = (byte)((num6 + 2147483648U & 65280U) >> 8);
							*(ref struct2 + 11) = (byte)(num6 + 2147483648U & 255U);
							if (<Module>.smethod_15((byte*)(&struct2), 12U, (byte)num2, 1, &gstruct) != null)
							{
								this.textBox6.AppendText("Ram Poke Failed" + "\r\n");
								this.Cursor = Cursors.Arrow;
								return 1;
							}
							if (num6 % 256U == 0U)
							{
								this.textBox6.AppendText(".");
								Application.DoEvents();
							}
						}
						<Module>.memset((void*)(&struct2), 0, 12U);
						Struct103 struct3;
						<Module>.memset((void*)(&struct3), 0, 8U);
						struct2 = 85;
						*(ref struct2 + 1) = 16;
						*(ref struct2 + 8) = 8;
						*(ref struct3 + 1) = 6;
						uint num7;
						if (<Module>.smethod_17((byte*)(&struct2), 12U, (byte)num2, 512, (void*)(&struct3), &num7, 8U, 1, &gstruct) != null)
						{
							this.textBox6.AppendText("Execute Enable Failed" + "\r\n");
							this.Cursor = Cursors.Arrow;
							result = 1;
						}
						else
						{
							<Module>.memset((void*)(&struct2), 0, 12U);
							struct2 = 85;
							*(ref struct2 + 1) = 16;
							*(ref struct2 + 3) = 72;
							*(ref struct2 + 4) = 76;
							*(ref struct2 + 6) = 1;
							*(ref struct2 + 11) = 1;
							if (<Module>.smethod_15((byte*)(&struct2), 12U, (byte)num2, 1, &gstruct) != null)
							{
								this.textBox6.AppendText("Execute Failed.." + "\r\n");
								this.Cursor = Cursors.Arrow;
								result = 1;
							}
							else
							{
								<Module>.free((void*)ptr);
								this.Cursor = Cursors.Arrow;
								result = 0;
							}
						}
					}
				}
			}
			return result;
		}

		// Token: 0x060003DF RID: 991 RVA: 0x001544BC File Offset: 0x001544BC
		private unsafe int method_408(byte* pByte_0, uint uint_0, uint uint_1)
		{
			ushort num = 255;
			int result;
			if (this.comboBox16.Items.Count == 0)
			{
				<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
				MessageBox.Show("No drive Selected", "Warning", MessageBoxButtons.OK, MessageBoxIcon.Hand);
				<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
				result = 1;
			}
			else
			{
				Struct108 @struct;
				byte* ptr = ref @struct + 44;
				string str = this.comboBox16.Text.Substring(0, 1);
				IntPtr intPtr = Marshal.StringToHGlobalAnsi(this.comboBox16.Text);
				IntPtr value = intPtr;
				sbyte* ptr2 = (sbyte*)((void*)value);
				if (*(sbyte*)ptr2 < 65 | *(sbyte*)ptr2 > 122)
				{
					result = 1;
				}
				else
				{
					Struct109 struct2;
					<Module>.sprintf((sbyte*)(&struct2), (sbyte*)(&<Module>.struct22_5), *(sbyte*)ptr2);
					void* ptr3 = <Module>.CreateFileA((sbyte*)(&struct2), -1073741824, 3, null, 3, 128, null);
					if (ptr3 == -1)
					{
						this.textBox6.AppendText("Failed to open drive " + str + "\r\n");
						result = 1;
					}
					else
					{
						this.Cursor = Cursors.WaitCursor;
						Struct63 struct3;
						*(ref struct3 + 3) = (byte)(uint_0 & 255U);
						*(ref struct3 + 2) = (byte)((uint_0 & 65280U) >> 8);
						*(ref struct3 + 1) = (byte)((uint_0 & 16711680U) >> 16);
						struct3 = (uint_0 & 4278190080U) >> 24;
						this.method_6((byte*)(&struct3), 4U, 0U);
						this.textBox6.AppendText("Flashing Sector" + " " + this.string_0 + "\r\n");
						uint num2 = uint_1 + 2184U;
						if ((num2 & 3U) != 0U)
						{
							num2 += 4U - (num2 & 3U);
						}
						byte* ptr4 = <Module>.malloc(num2);
						if (ptr4 == null)
						{
							<Module>.CloseHandle(ptr3);
							result = 1;
						}
						else
						{
							<Module>.memset((void*)ptr4, 0, num2);
							uint num3;
							if (num == 0)
							{
								num3 = uint_0;
								uint_0 = (uint)(*(ref num3 + 3));
								*(ref uint_0 + 1) = *(ref num3 + 2);
								*(ref uint_0 + 2) = *(ref num3 + 1);
								*(ref uint_0 + 3) = (byte)num3;
								num3 = (uint)(*(ref uint_1 + 3));
								*(ref num3 + 1) = *(ref uint_1 + 2);
								*(ref num3 + 2) = *(ref uint_1 + 1);
								*(ref num3 + 3) = (byte)uint_1;
							}
							else
							{
								num3 = uint_1;
							}
							*(ref <Module>.struct54_0 + 8) = (int)uint_0;
							*(ref <Module>.struct54_0 + 30) = (int)uint_0;
							*(ref <Module>.struct54_0 + 48) = (int)num3;
							if (this.int_12 == 79)
							{
								*(ref <Module>.struct54_0 + 64) = 241;
							}
							else if (this.int_12 == 59)
							{
								*(ref <Module>.struct54_0 + 64) = 221;
							}
							else if (this.int_12 == 47)
							{
								*(ref <Module>.struct54_0 + 64) = 217;
							}
							else if (this.int_12 == 36)
							{
								*(ref <Module>.struct54_0 + 64) = 209;
							}
							else if (this.int_12 == 32)
							{
								*(ref <Module>.struct54_0 + 64) = 213;
							}
							<Module>.memcpy((void*)ptr4, (void*)(&<Module>.struct54_0), 74U);
							byte* ptr5 = ptr4 + 74;
							<Module>.memcpy((void*)ptr5, (void*)(&<Module>.struct44_0), 1136U);
							ptr5 = ptr4 + 1210;
							<Module>.memcpy((void*)ptr5, (void*)(&<Module>.struct57_0), 972U);
							ptr5 = ptr4 + 2182;
							byte* ptr6 = pByte_0 + (uint_0 - 2415919104U);
							<Module>.memcpy((void*)ptr5, (void*)ptr6, uint_1);
							uint num4 = 0U;
							for (num3 = 0U; num3 < num2 - 2U; num3 += 1U)
							{
								num4 += (uint)ptr4[num3];
							}
							num4 = 65536U - (num4 & 65535U);
							ptr4[num2 - 2U] = (byte)(num4 & 255U);
							ptr4[num2 - 1U] = (byte)((num4 & 65280U) >> 8);
							<Module>.memset((void*)(&@struct), 0, 62U);
							*(ref @struct + 28) = 85;
							@struct = 44;
							*(ref @struct + 6) = 12;
							*(ref @struct + 7) = 18;
							*(ref @struct + 8) = 2;
							*(ref @struct + 16) = 15;
							*(ref @struct + 24) = 44;
							uint num5;
							if (<Module>.DeviceIoControl(ptr3, 315412, (void*)(&@struct), 62, (void*)(&@struct), 62, (uint*)(&num5), null) == null && <Module>.DeviceIoControl(ptr3, 315412, (void*)(&@struct), 62, (void*)(&@struct), 62, (uint*)(&num5), null) == null)
							{
								this.textBox6.AppendText("Disable Execute Failed" + "\r\n");
								this.Cursor = Cursors.Arrow;
								<Module>.CloseHandle(ptr3);
								<Module>.free((void*)ptr4);
								result = 1;
							}
							else
							{
								<Module>.memset((void*)(&@struct), 0, 62U);
								*(ref @struct + 28) = 85;
								*(ref @struct + 29) = 16;
								*(ref @struct + 36) = 16;
								*(ref @struct + 39) = 1;
								Struct28 struct4;
								<Module>.memset((void*)(&struct4), 0, 16U);
								*(ref struct4 + 9) = 6;
								*(ref struct4 + 10) = 72;
								*(ref struct4 + 11) = 76;
								*(ref struct4 + 12) = (byte)((num2 & 4278190080U) >> 24);
								*(ref struct4 + 13) = (byte)((num2 & 16711680U) >> 16);
								*(ref struct4 + 14) = (byte)((num2 & 65280U) >> 8);
								*(ref struct4 + 15) = (byte)(num2 & 255U);
								@struct = 44;
								*(ref @struct + 6) = 12;
								*(ref @struct + 7) = 18;
								*(ref @struct + 8) = 0;
								*(ref @struct + 12) = 16;
								*(ref @struct + 16) = 15;
								*(ref @struct + 20) = ref struct4;
								*(ref @struct + 24) = 44;
								if (<Module>.DeviceIoControl(ptr3, 315412, (void*)(&@struct), 62, (void*)(&@struct), 62, (uint*)(&num5), null) != null && (ptr[2] & 15) == 0)
								{
									uint num6 = num2 / 2040U;
									if (num2 % 2040U != 0U)
									{
										num6 += 1U;
									}
									for (num3 = 0U; num3 < num6; num3 += 1U)
									{
										uint num7;
										if (num3 != num6 - 1U)
										{
											num7 = 2048U;
										}
										else
										{
											num7 = num2 % 2040U + 8U;
										}
										<Module>.memset((void*)(&@struct), 0, 62U);
										*(ref @struct + 28) = 85;
										*(ref @struct + 29) = 16;
										*(ref @struct + 35) = (byte)((num7 & 65280U) >> 8);
										*(ref @struct + 36) = (byte)(num7 & 255U);
										*(ref @struct + 39) = 1;
										<Module>.memset((void*)(&<Module>.struct120_0), 0, 2048U);
										*(ref <Module>.struct120_0 + 4) = 72;
										*(ref <Module>.struct120_0 + 5) = 76;
										<Module>.memcpy(ref <Module>.struct120_0 + 8, (void*)(ptr4 + num3 * 2040U), num7 - 8U);
										@struct = 44;
										*(ref @struct + 6) = 12;
										*(ref @struct + 7) = 18;
										*(ref @struct + 8) = 0;
										*(ref @struct + 12) = (int)num7;
										*(ref @struct + 16) = 15;
										*(ref @struct + 20) = ref <Module>.struct120_0;
										*(ref @struct + 24) = 44;
										if (<Module>.DeviceIoControl(ptr3, 315412, (void*)(&@struct), 62, (void*)(&@struct), 62, (uint*)(&num5), null) == null || (ptr[2] & 15) != 0)
										{
											this.textBox6.AppendText("Upload buffer failed" + "\r\n");
											<Module>.CloseHandle(ptr3);
											this.Cursor = Cursors.Arrow;
											<Module>.free((void*)ptr4);
											return 1;
										}
									}
									<Module>.memset((void*)(&@struct), 0, 62U);
									*(ref @struct + 28) = 85;
									*(ref @struct + 29) = 16;
									*(ref @struct + 31) = 72;
									*(ref @struct + 32) = 76;
									*(ref @struct + 34) = 1;
									*(ref @struct + 39) = 1;
									@struct = 44;
									*(ref @struct + 6) = 12;
									*(ref @struct + 7) = 18;
									*(ref @struct + 8) = 2;
									*(ref @struct + 16) = 15;
									*(ref @struct + 24) = 44;
									if (<Module>.DeviceIoControl(ptr3, 315412, (void*)(&@struct), 62, (void*)(&@struct), 62, (uint*)(&num5), null) == null)
									{
										this.textBox6.AppendText("Ram Execute Failed" + "\r\n");
										this.Cursor = Cursors.Arrow;
										<Module>.CloseHandle(ptr3);
										<Module>.free((void*)ptr4);
										result = 1;
									}
									else
									{
										this.Cursor = Cursors.Arrow;
										<Module>.CloseHandle(ptr3);
										<Module>.free((void*)ptr4);
										result = 0;
									}
								}
								else
								{
									this.textBox6.AppendText("Configure Upload Failed" + "\r\n");
									this.Cursor = Cursors.Arrow;
									<Module>.CloseHandle(ptr3);
									<Module>.free((void*)ptr4);
									result = 1;
								}
							}
						}
					}
				}
			}
			return result;
		}

		// Token: 0x060003E0 RID: 992 RVA: 0x00154BCC File Offset: 0x00154BCC
		private unsafe int method_409(byte* pByte_0, uint uint_0, uint uint_1)
		{
			ushort num = 255;
			int result;
			if (this.comboBox1.Items.Count == 0)
			{
				result = 0;
			}
			else
			{
				uint selectedIndex = (uint)this.comboBox1.SelectedIndex;
				ushort ushort_ = *(ref <Module>.struct38_0 + selectedIndex * 72U);
				uint num2;
				if (*(ref <Module>.struct38_0 + selectedIndex * 72U + 4) == 160)
				{
					num2 = 0U;
				}
				else
				{
					num2 = 16U;
				}
				Struct63 @struct;
				*(ref @struct + 3) = (byte)(uint_0 & 255U);
				*(ref @struct + 2) = (byte)((uint_0 & 65280U) >> 8);
				*(ref @struct + 1) = (byte)((uint_0 & 16711680U) >> 16);
				@struct = (uint_0 & 4278190080U) >> 24;
				this.method_6((byte*)(&@struct), 4U, 0U);
				this.textBox6.AppendText("Flashing Sector" + " " + this.string_0 + "\r\n");
				uint num3 = uint_1 + 2184U;
				if ((num3 & 3U) != 0U)
				{
					num3 += 4U - (num3 & 3U);
				}
				byte* ptr = <Module>.malloc(num3);
				if (ptr == null)
				{
					result = 1;
				}
				else
				{
					<Module>.memset((void*)ptr, 0, num3);
					uint num4;
					if (num == 0)
					{
						num4 = uint_0;
						uint_0 = (uint)(*(ref num4 + 3));
						*(ref uint_0 + 1) = *(ref num4 + 2);
						*(ref uint_0 + 2) = *(ref num4 + 1);
						*(ref uint_0 + 3) = (byte)num4;
						num4 = (uint)(*(ref uint_1 + 3));
						*(ref num4 + 1) = *(ref uint_1 + 2);
						*(ref num4 + 2) = *(ref uint_1 + 1);
						*(ref num4 + 3) = (byte)uint_1;
					}
					else
					{
						num4 = uint_1;
					}
					*(ref <Module>.struct54_0 + 8) = (int)uint_0;
					*(ref <Module>.struct54_0 + 30) = (int)uint_0;
					*(ref <Module>.struct54_0 + 48) = (int)num4;
					if (this.int_12 == 79)
					{
						*(ref <Module>.struct54_0 + 64) = 241;
					}
					else if (this.int_12 == 59)
					{
						*(ref <Module>.struct54_0 + 64) = 221;
					}
					else if (this.int_12 == 47)
					{
						*(ref <Module>.struct54_0 + 64) = 217;
					}
					else if (this.int_12 == 36)
					{
						*(ref <Module>.struct54_0 + 64) = 209;
					}
					else if (this.int_12 == 32)
					{
						*(ref <Module>.struct54_0 + 64) = 213;
					}
					<Module>.memcpy((void*)ptr, (void*)(&<Module>.struct54_0), 74U);
					byte* ptr2 = ptr + 74;
					<Module>.memcpy((void*)ptr2, (void*)(&<Module>.struct44_0), 1136U);
					ptr2 = ptr + 1210;
					<Module>.memcpy((void*)ptr2, (void*)(&<Module>.struct57_0), 972U);
					ptr2 = ptr + 2182;
					byte* ptr3 = pByte_0 + (uint_0 - 2415919104U);
					<Module>.memcpy((void*)ptr2, (void*)ptr3, uint_1);
					uint num5 = 0U;
					for (num4 = 0U; num4 < num3 - 2U; num4 += 1U)
					{
						num5 += (uint)ptr[num4];
					}
					num5 = 65536U - (num5 & 65535U);
					ptr[num3 - 2U] = (byte)(num5 & 255U);
					ptr[num3 - 1U] = (byte)((num5 & 65280U) >> 8);
					this.Cursor = Cursors.WaitCursor;
					GStruct3 gstruct;
					<Module>.smethod_21(&gstruct, ushort_, 0, 1, 10000U);
					Struct52 struct2;
					<Module>.memset((void*)(&struct2), 0, 12U);
					struct2 = 85;
					if (<Module>.smethod_15((byte*)(&struct2), 12U, (byte)num2, 1, &gstruct) != null && <Module>.smethod_15((byte*)(&struct2), 12U, (byte)num2, 1, &gstruct) != null)
					{
						this.textBox6.AppendText("Disable Execute Failed" + "\r\n");
						this.Cursor = Cursors.Arrow;
						result = 1;
					}
					else
					{
						<Module>.memset((void*)(&struct2), 0, 12U);
						struct2 = 85;
						*(ref struct2 + 1) = 16;
						*(ref struct2 + 8) = 16;
						*(ref struct2 + 11) = 1;
						Struct28 struct3;
						<Module>.memset((void*)(&struct3), 0, 16U);
						*(ref struct3 + 9) = 6;
						*(ref struct3 + 10) = 72;
						*(ref struct3 + 11) = 76;
						*(ref struct3 + 12) = (byte)((num3 & 4278190080U) >> 24);
						*(ref struct3 + 13) = (byte)((num3 & 16711680U) >> 16);
						*(ref struct3 + 14) = (byte)((num3 & 65280U) >> 8);
						*(ref struct3 + 15) = (byte)(num3 & 255U);
						uint num6;
						if (<Module>.smethod_17((byte*)(&struct2), 12U, (byte)num2, 512, (void*)(&struct3), &num6, 16U, 1, &gstruct) != null)
						{
							this.textBox6.AppendText("Configure Upload Failed" + "\r\n");
							this.Cursor = Cursors.Arrow;
							<Module>.free((void*)ptr);
							result = 1;
						}
						else
						{
							uint num7 = num3 / 2040U;
							if (num3 % 2040U != 0U)
							{
								num7 += 1U;
							}
							for (num4 = 0U; num4 < num7; num4 += 1U)
							{
								uint num8;
								if (num4 != num7 - 1U)
								{
									num8 = 2048U;
								}
								else
								{
									num8 = num3 % 2040U + 8U;
								}
								<Module>.memset((void*)(&struct2), 0, 12U);
								struct2 = 85;
								*(ref struct2 + 1) = 16;
								*(ref struct2 + 7) = (byte)((num8 & 65280U) >> 8);
								*(ref struct2 + 8) = (byte)(num8 & 255U);
								*(ref struct2 + 11) = 1;
								<Module>.memset((void*)(&<Module>.struct120_1), 0, 2048U);
								*(ref <Module>.struct120_1 + 4) = 72;
								*(ref <Module>.struct120_1 + 5) = 76;
								<Module>.memcpy(ref <Module>.struct120_1 + 8, (void*)(ptr + num4 * 2040U), num8 - 8U);
								if (<Module>.smethod_17((byte*)(&struct2), 12U, (byte)num2, 512, (void*)(&<Module>.struct120_1), &num6, num8, 1, &gstruct) != null)
								{
									this.textBox6.AppendText("Upload buffer failed" + "\r\n");
									this.Cursor = Cursors.Arrow;
									<Module>.free((void*)ptr);
									return 1;
								}
							}
							<Module>.memset((void*)(&struct2), 0, 12U);
							<Module>.memset((void*)(&struct3), 0, 16U);
							struct2 = 85;
							*(ref struct2 + 1) = 16;
							*(ref struct2 + 3) = 72;
							*(ref struct2 + 4) = 76;
							*(ref struct2 + 6) = 1;
							*(ref struct2 + 11) = 1;
							if (<Module>.smethod_15((byte*)(&struct2), 12U, (byte)num2, 1, &gstruct) != null)
							{
								this.textBox6.AppendText("Mode Select Execute Failed!" + "\r\n");
								this.Cursor = Cursors.Arrow;
								<Module>.free((void*)ptr);
								result = 1;
							}
							else
							{
								this.Cursor = Cursors.Arrow;
								<Module>.free((void*)ptr);
								result = 0;
							}
						}
					}
				}
			}
			return result;
		}

		// Token: 0x060003E1 RID: 993 RVA: 0x00155148 File Offset: 0x00155148
		private unsafe int method_410()
		{
			<Module>.usb_init();
			<Module>.usb_find_busses();
			<Module>.usb_find_devices();
			GStruct8* ptr = <Module>.usb_get_busses();
			<Module>.usb_set_debug(4);
			for (GStruct8* ptr2 = ptr; ptr2 != null; ptr2 = *(int*)ptr2)
			{
				for (GStruct9* ptr3 = *(int*)(ptr2 + 520 / sizeof(GStruct8)); ptr3 != null; ptr3 = *(int*)ptr3)
				{
					if (*(ushort*)(ptr3 + 532 / sizeof(GStruct9)) == 4564 && *(ushort*)(ptr3 + 534 / sizeof(GStruct9)) == 33587)
					{
						this.bool_5 = true;
						*(ref <Module>.gstruct10_0 + 12) = 1;
						this.pictureBox8.Visible = true;
						this.pictureBox9.Visible = true;
						this.pictureBox10.Visible = false;
						this.pictureBox11.Visible = false;
						return 1;
					}
				}
			}
			this.bool_5 = false;
			*(ref <Module>.gstruct10_0 + 12) = 0;
			*(ref <Module>.gstruct10_0 + 4) = 0;
			this.pictureBox8.Visible = false;
			this.pictureBox9.Visible = false;
			this.pictureBox10.Visible = true;
			this.pictureBox11.Visible = true;
			return 0;
		}

		// Token: 0x060003E2 RID: 994 RVA: 0x00155258 File Offset: 0x00155258
		private unsafe int method_411()
		{
			<Module>.usb_init();
			<Module>.usb_find_busses();
			<Module>.usb_find_devices();
			GStruct8* ptr = <Module>.usb_get_busses();
			<Module>.usb_set_debug(4);
			for (GStruct8* ptr2 = ptr; ptr2 != null; ptr2 = *(int*)ptr2)
			{
				for (GStruct9* ptr3 = *(int*)(ptr2 + 520 / sizeof(GStruct8)); ptr3 != null; ptr3 = *(int*)ptr3)
				{
					if (*(ushort*)(ptr3 + 532 / sizeof(GStruct9)) == 4564 && *(ushort*)(ptr3 + 534 / sizeof(GStruct9)) == 33591)
					{
						this.bool_7 = true;
						*(ref <Module>.gstruct10_0 + 13) = 1;
						if (*(ref <Module>.gstruct10_0 + 12) == 0)
						{
							this.pictureBox8.Visible = true;
							this.pictureBox9.Visible = true;
							this.pictureBox10.Visible = false;
							this.pictureBox11.Visible = false;
						}
						return 1;
					}
				}
			}
			this.bool_7 = false;
			*(ref <Module>.gstruct10_0 + 13) = 0;
			*(ref <Module>.gstruct10_0 + 8) = 0;
			if (*(ref <Module>.gstruct10_0 + 12) == 0)
			{
				this.pictureBox8.Visible = false;
				this.pictureBox9.Visible = false;
				this.pictureBox10.Visible = true;
				this.pictureBox11.Visible = true;
			}
			return 0;
		}

		// Token: 0x060003E3 RID: 995 RVA: 0x00155384 File Offset: 0x00155384
		private unsafe void method_412()
		{
			Struct3 @struct = 0;
			initblk(ref @struct + 1, 0, 63);
			Struct3 struct2 = 0;
			initblk(ref struct2 + 1, 0, 63);
			@struct = 0;
			if (this.method_416((sbyte*)(&@struct), 1, (sbyte*)(&struct2), 4) == 1)
			{
				this.textBox6.AppendText("Version " + Convert.ToString((int)(*(ref struct2 + 2))) + ".");
				this.textBox6.AppendText(Convert.ToString((int)(*(ref struct2 + 3))) + "\r\n");
				this.string_23 = Convert.ToString((int)(*(ref struct2 + 2))) + "." + Convert.ToString((int)(*(ref struct2 + 3)));
			}
		}

		// Token: 0x060003E4 RID: 996 RVA: 0x0015542C File Offset: 0x0015542C
		private unsafe void method_413()
		{
			Struct3 @struct = 0;
			initblk(ref @struct + 1, 0, 63);
			Struct3 struct2 = 0;
			initblk(ref struct2 + 1, 0, 63);
			@struct = 0;
			if (this.method_417((sbyte*)(&@struct), 1, (sbyte*)(&struct2), 4) == 1)
			{
				this.textBox6.AppendText("Version " + Convert.ToString((int)(*(ref struct2 + 2))) + ".");
				this.textBox6.AppendText(Convert.ToString((int)(*(ref struct2 + 3))) + "\r\n");
				this.string_24 = Convert.ToString((int)(*(ref struct2 + 2))) + "." + Convert.ToString((int)(*(ref struct2 + 3)));
			}
		}

		// Token: 0x060003E5 RID: 997 RVA: 0x001554D4 File Offset: 0x001554D4
		private unsafe void method_414()
		{
			Struct3 @struct = 0;
			initblk(ref @struct + 1, 0, 63);
			Struct3 struct2 = 0;
			initblk(ref struct2 + 1, 0, 63);
			@struct = 0;
			if (this.method_416((sbyte*)(&@struct), 1, (sbyte*)(&struct2), 4) == 1)
			{
				this.string_23 = Convert.ToString((int)(*(ref struct2 + 2))) + "." + Convert.ToString((int)(*(ref struct2 + 3)));
			}
		}

		// Token: 0x060003E6 RID: 998 RVA: 0x00155538 File Offset: 0x00155538
		private unsafe void method_415()
		{
			Struct3 @struct = 0;
			initblk(ref @struct + 1, 0, 63);
			Struct3 struct2 = 0;
			initblk(ref struct2 + 1, 0, 63);
			@struct = 0;
			if (this.method_417((sbyte*)(&@struct), 1, (sbyte*)(&struct2), 4) == 1)
			{
				this.string_24 = Convert.ToString((int)(*(ref struct2 + 2))) + "." + Convert.ToString((int)(*(ref struct2 + 3)));
			}
		}

		// Token: 0x060003E7 RID: 999 RVA: 0x0015559C File Offset: 0x0015559C
		private unsafe int method_416(sbyte* pSbyte_0, int int_16, sbyte* pSbyte_1, int int_17)
		{
			if (*(ref <Module>.gstruct10_0 + 14) == 0)
			{
				if (*(ref <Module>.gstruct10_0 + 4) == 0)
				{
					this.method_420();
					<Module>.gstruct10_0 = *(ref <Module>.gstruct10_0 + 4);
				}
			}
			else if (<Module>.gstruct10_0 == null)
			{
				this.method_421();
				<Module>.gstruct10_0 = *(ref <Module>.gstruct10_0 + 8);
			}
			return (<Module>.usb_bulk_write(<Module>.gstruct10_0, 1, pSbyte_0, int_16, 10000) != int_16) ? 0 : ((int_17 == 0) ? 1 : ((<Module>.usb_bulk_read(<Module>.gstruct10_0, 129, pSbyte_1, int_17, 5000) != int_17) ? 0 : 1));
		}

		// Token: 0x060003E8 RID: 1000 RVA: 0x00155634 File Offset: 0x00155634
		private unsafe int method_417(sbyte* pSbyte_0, int int_16, sbyte* pSbyte_1, int int_17)
		{
			if (*(ref <Module>.gstruct10_0 + 8) == 0)
			{
				this.method_421();
			}
			return (<Module>.usb_bulk_write(*(ref <Module>.gstruct10_0 + 8), 1, pSbyte_0, int_16, 10000) != int_16) ? 0 : ((int_17 == 0) ? 1 : ((<Module>.usb_bulk_read(*(ref <Module>.gstruct10_0 + 8), 129, pSbyte_1, int_17, 5000) != int_17) ? 0 : 1));
		}

		// Token: 0x060003E9 RID: 1001 RVA: 0x00155698 File Offset: 0x00155698
		private unsafe int method_418(sbyte sbyte_0, ushort ushort_0)
		{
			Struct3 @struct = 0;
			initblk(ref @struct + 1, 0, 63);
			Struct3 struct2 = 0;
			initblk(ref struct2 + 1, 0, 63);
			int num = 1;
			@struct = sbyte_0 + 16;
			*(ref @struct + 2) = (byte)((ushort_0 & 65280) >> 8);
			*(ref @struct + 1) = (byte)(ushort_0 & 255);
			int result;
			if (this.method_416((sbyte*)(&@struct), 3, (sbyte*)(&struct2), 1) == 1)
			{
				if (num == 1 && struct2 == sbyte_0 + 16)
				{
					result = 1;
				}
				else
				{
					<Module>.printf((sbyte*)(&<Module>.struct98_1));
					result = 0;
				}
			}
			else
			{
				<Module>.printf((sbyte*)(&<Module>.struct65_10));
				result = 0;
			}
			return result;
		}

		// Token: 0x060003EA RID: 1002 RVA: 0x00155720 File Offset: 0x00155720
		private unsafe void method_419(sbyte sbyte_0, byte* pByte_0)
		{
			Struct3 @struct = 0;
			initblk(ref @struct + 1, 0, 63);
			Struct3 struct2 = 0;
			initblk(ref struct2 + 1, 0, 63);
			int num = 3;
			@struct = sbyte_0 + 32;
			if (this.method_416((sbyte*)(&@struct), 1, (sbyte*)(&struct2), 3) == 1)
			{
				if (num == 3 && struct2 == sbyte_0 + 32)
				{
					*pByte_0 = (byte)(*(ref struct2 + 1));
					pByte_0[1] = (byte)(*(ref struct2 + 2));
				}
				else
				{
					<Module>.printf((sbyte*)(&<Module>.struct65_11));
				}
			}
			else
			{
				<Module>.printf((sbyte*)(&<Module>.struct67_3));
			}
		}

		// Token: 0x060003EB RID: 1003 RVA: 0x0015579C File Offset: 0x0015579C
		private unsafe int method_420()
		{
			int result;
			if (*(ref <Module>.gstruct10_0 + 12) == 0)
			{
				result = 0;
			}
			else
			{
				<Module>.usb_init();
				<Module>.usb_find_busses();
				<Module>.usb_find_devices();
				GStruct8* ptr = <Module>.usb_get_busses();
				<Module>.usb_set_debug(4);
				for (GStruct8* ptr2 = ptr; ptr2 != null; ptr2 = *(int*)ptr2)
				{
					for (GStruct9* ptr3 = *(int*)(ptr2 + 520 / sizeof(GStruct8)); ptr3 != null; ptr3 = *(int*)ptr3)
					{
						if (*(ushort*)(ptr3 + 532 / sizeof(GStruct9)) == 4564 && *(ushort*)(ptr3 + 534 / sizeof(GStruct9)) == 33587)
						{
							*(ref <Module>.gstruct10_0 + 4) = <Module>.usb_open(ptr3);
							<Module>.gstruct10_0 = *(ref <Module>.gstruct10_0 + 4);
						}
					}
				}
				if (*(ref <Module>.gstruct10_0 + 4) == 0)
				{
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					MessageBox.Show("error: device not found!", "LibUSB", MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
					result = 0;
				}
				else if (<Module>.usb_set_configuration(*(ref <Module>.gstruct10_0 + 4), 1) < 0)
				{
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					MessageBox.Show("error: setting config failed", "LibUSB", MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
					<Module>.usb_close(<Module>.gstruct10_0);
					*(ref <Module>.gstruct10_0 + 4) = 0;
					result = 0;
				}
				else if (<Module>.usb_claim_interface(*(ref <Module>.gstruct10_0 + 4), 0) < 0)
				{
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					MessageBox.Show("error: claiming interface failed", "LibUSB", MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
					<Module>.usb_close(*(ref <Module>.gstruct10_0 + 4));
					*(ref <Module>.gstruct10_0 + 4) = 0;
					result = 0;
				}
				else
				{
					this.method_414();
					this.method_424(2);
					this.bool_9 = false;
					result = 1;
				}
			}
			return result;
		}

		// Token: 0x060003EC RID: 1004 RVA: 0x00155980 File Offset: 0x00155980
		private unsafe int method_421()
		{
			int result;
			if (*(ref <Module>.gstruct10_0 + 13) == 0)
			{
				result = 0;
			}
			else
			{
				<Module>.usb_init();
				<Module>.usb_find_busses();
				<Module>.usb_find_devices();
				GStruct8* ptr = <Module>.usb_get_busses();
				<Module>.usb_set_debug(4);
				for (GStruct8* ptr2 = ptr; ptr2 != null; ptr2 = *(int*)ptr2)
				{
					for (GStruct9* ptr3 = *(int*)(ptr2 + 520 / sizeof(GStruct8)); ptr3 != null; ptr3 = *(int*)ptr3)
					{
						if (*(ushort*)(ptr3 + 532 / sizeof(GStruct9)) == 4564 && *(ushort*)(ptr3 + 534 / sizeof(GStruct9)) == 33591)
						{
							*(ref <Module>.gstruct10_0 + 8) = <Module>.usb_open(ptr3);
							<Module>.gstruct10_0 = *(ref <Module>.gstruct10_0 + 8);
						}
					}
				}
				if (*(ref <Module>.gstruct10_0 + 8) == 0)
				{
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					MessageBox.Show("error: device not found!", "LibUSB", MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
					result = 0;
				}
				else if (<Module>.usb_set_configuration(*(ref <Module>.gstruct10_0 + 8), 1) < 0)
				{
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					MessageBox.Show("error: setting config failed", "LibUSB", MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
					<Module>.usb_close(*(ref <Module>.gstruct10_0 + 8));
					*(ref <Module>.gstruct10_0 + 8) = 0;
					result = 0;
				}
				else if (<Module>.usb_claim_interface(*(ref <Module>.gstruct10_0 + 8), 0) < 0)
				{
					<Module>.pGstruct14_10 = <Module>.SetWindowsHookExA(5, <Module>.ppInt_12, <Module>.GetWindowLongA(this.pGstruct11_0, -6), <Module>.GetCurrentThreadId());
					MessageBox.Show("error: claiming interface failed", "LibUSB", MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
					<Module>.UnhookWindowsHookEx(<Module>.pGstruct14_10);
					<Module>.usb_close(*(ref <Module>.gstruct10_0 + 8));
					*(ref <Module>.gstruct10_0 + 8) = 0;
					result = 0;
				}
				else
				{
					this.method_415();
					result = 1;
				}
			}
			return result;
		}

		// Token: 0x060003ED RID: 1005 RVA: 0x00155B58 File Offset: 0x00155B58
		private unsafe int method_422()
		{
			int result;
			if (*(ref <Module>.gstruct10_0 + 12) == 0)
			{
				result = 1;
			}
			else if (*(ref <Module>.gstruct10_0 + 4) == 0)
			{
				<Module>.gstruct10_0 = 0;
				result = 1;
			}
			else if (*(ref <Module>.gstruct10_0 + 4) == 0)
			{
				<Module>.gstruct10_0 = 0;
				result = 1;
			}
			else if (<Module>.usb_release_interface(*(ref <Module>.gstruct10_0 + 4), 0) < 0)
			{
				result = 0;
			}
			else if (<Module>.usb_close(*(ref <Module>.gstruct10_0 + 4)) < 0)
			{
				result = 0;
			}
			else
			{
				*(ref <Module>.gstruct10_0 + 4) = 0;
				<Module>.gstruct10_0 = 0;
				result = 1;
			}
			return result;
		}

		// Token: 0x060003EE RID: 1006 RVA: 0x00155BD8 File Offset: 0x00155BD8
		private unsafe int method_423()
		{
			int result;
			if (*(ref <Module>.gstruct10_0 + 13) == 0)
			{
				result = 1;
			}
			else if (*(ref <Module>.gstruct10_0 + 8) == 0)
			{
				<Module>.gstruct10_0 = 0;
				result = 1;
			}
			else if (*(ref <Module>.gstruct10_0 + 8) == 0)
			{
				<Module>.gstruct10_0 = 0;
				result = 1;
			}
			else if (<Module>.usb_release_interface(*(ref <Module>.gstruct10_0 + 8), 0) < 0)
			{
				result = 0;
			}
			else if (<Module>.usb_close(*(ref <Module>.gstruct10_0 + 8)) < 0)
			{
				result = 0;
			}
			else
			{
				*(ref <Module>.gstruct10_0 + 8) = 0;
				<Module>.gstruct10_0 = 0;
				result = 1;
			}
			return result;
		}

		// Token: 0x060003EF RID: 1007 RVA: 0x00155C58 File Offset: 0x00155C58
		private unsafe int method_424(byte byte_0)
		{
			Struct3 @struct = 0;
			initblk(ref @struct + 1, 0, 63);
			Struct3 struct2 = 0;
			initblk(ref struct2 + 1, 0, 63);
			int int_ = 1;
			int num = 1;
			if (byte_0 == 1)
			{
				@struct = 1;
			}
			else if (byte_0 == 2)
			{
				@struct = 2;
			}
			else if (byte_0 == 5)
			{
				@struct = 5;
			}
			else if (byte_0 == 6)
			{
				@struct = 6;
			}
			else if (byte_0 == 7)
			{
				@struct = 7;
			}
			else if (byte_0 == 8)
			{
				@struct = 8;
			}
			else if (byte_0 == 88)
			{
				@struct = 9;
			}
			else if (byte_0 == 9)
			{
				@struct = -88;
			}
			else if (byte_0 == 10)
			{
				@struct = -3;
			}
			else
			{
				if (byte_0 != 11)
				{
					return 0;
				}
				@struct = -2;
			}
			return (this.method_416((sbyte*)(&@struct), int_, (sbyte*)(&struct2), num) != 1) ? 0 : ((num != 1 || struct2 != @struct) ? 0 : 1);
		}

		// Token: 0x040004C0 RID: 1216
		public string string_0;

		// Token: 0x040004C1 RID: 1217
		public bool bool_0;

		// Token: 0x040004C2 RID: 1218
		public bool bool_1;

		// Token: 0x040004C3 RID: 1219
		public bool bool_2;

		// Token: 0x040004C4 RID: 1220
		public bool bool_3;

		// Token: 0x040004C5 RID: 1221
		public bool bool_4;

		// Token: 0x040004C6 RID: 1222
		public int int_0;

		// Token: 0x040004C7 RID: 1223
		public int int_1;

		// Token: 0x040004C8 RID: 1224
		public int int_2;

		// Token: 0x040004C9 RID: 1225
		public int int_3;

		// Token: 0x040004CA RID: 1226
		public int int_4;

		// Token: 0x040004CB RID: 1227
		public int int_5;

		// Token: 0x040004CC RID: 1228
		public int int_6;

		// Token: 0x040004CD RID: 1229
		public int int_7;

		// Token: 0x040004CE RID: 1230
		public int int_8;

		// Token: 0x040004CF RID: 1231
		public Thread thread_0;

		// Token: 0x040004D0 RID: 1232
		public Thread thread_1;

		// Token: 0x040004D1 RID: 1233
		public string string_1;

		// Token: 0x040004D2 RID: 1234
		public string string_2;

		// Token: 0x040004D3 RID: 1235
		public string string_3;

		// Token: 0x040004D4 RID: 1236
		public string string_4;

		// Token: 0x040004D5 RID: 1237
		public string string_5;

		// Token: 0x040004D6 RID: 1238
		public string string_6;

		// Token: 0x040004D7 RID: 1239
		public string string_7;

		// Token: 0x040004D8 RID: 1240
		public string string_8;

		// Token: 0x040004D9 RID: 1241
		public string string_9;

		// Token: 0x040004DA RID: 1242
		public string string_10;

		// Token: 0x040004DB RID: 1243
		public string string_11;

		// Token: 0x040004DC RID: 1244
		public string string_12;

		// Token: 0x040004DD RID: 1245
		public string string_13;

		// Token: 0x040004DE RID: 1246
		public string string_14;

		// Token: 0x040004DF RID: 1247
		public string string_15;

		// Token: 0x040004E0 RID: 1248
		public string string_16;

		// Token: 0x040004E1 RID: 1249
		public string string_17;

		// Token: 0x040004E2 RID: 1250
		public string string_18;

		// Token: 0x040004E3 RID: 1251
		public bool bool_5;

		// Token: 0x040004E4 RID: 1252
		public bool bool_6;

		// Token: 0x040004E5 RID: 1253
		public bool bool_7;

		// Token: 0x040004E6 RID: 1254
		public bool bool_8;

		// Token: 0x040004E7 RID: 1255
		public bool bool_9;

		// Token: 0x040004E8 RID: 1256
		public int int_9;

		// Token: 0x040004E9 RID: 1257
		public int int_10;

		// Token: 0x040004EA RID: 1258
		public int int_11;

		// Token: 0x040004EB RID: 1259
		public unsafe GStruct11* pGstruct11_0;

		// Token: 0x040004EC RID: 1260
		private bool bool_10;

		// Token: 0x040004ED RID: 1261
		private bool bool_11;

		// Token: 0x040004EE RID: 1262
		private unsafe void* pVoid_0;

		// Token: 0x040004EF RID: 1263
		private unsafe void* pVoid_1;

		// Token: 0x040004F0 RID: 1264
		private unsafe void* pVoid_2;

		// Token: 0x040004F1 RID: 1265
		private int int_12;

		// Token: 0x040004F2 RID: 1266
		public string string_19;

		// Token: 0x040004F3 RID: 1267
		public int int_13;

		// Token: 0x040004F4 RID: 1268
		public string string_20;

		// Token: 0x040004F5 RID: 1269
		public int int_14;

		// Token: 0x040004F6 RID: 1270
		public string string_21;

		// Token: 0x040004F7 RID: 1271
		public int int_15;

		// Token: 0x040004F8 RID: 1272
		public string string_22;

		// Token: 0x040004F9 RID: 1273
		private unsafe void** ppVoid_0;

		// Token: 0x040004FA RID: 1274
		public string string_23;

		// Token: 0x040004FB RID: 1275
		public string string_24;
	}
}
